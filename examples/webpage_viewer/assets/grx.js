var wF = Object.defineProperty;
var bF = (e, t, r) => t in e ? wF(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: r
}) : e[t] = r;
var oe = (e, t, r) => (bF(e, typeof t != "symbol" ? t + "" : t, r), r);

function xF(e, t) {
    for (var r = 0; r < t.length; r++) {
        const n = t[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for (const i in n)
                if (i !== "default" && !(i in e)) {
                    const s = Object.getOwnPropertyDescriptor(n, i);
                    s && Object.defineProperty(e, i, s.get ? s : {
                        enumerable: !0,
                        get: () => n[i]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function r(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function n(i) {
        if (i.ep) return;
        i.ep = !0;
        const s = r(i);
        fetch(i.href, s)
    }
})();
var cd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function NO(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var V = {},
    EF = {
        get exports() {
            return V
        },
        set exports(e) {
            V = e
        }
    },
    pm = {},
    b = {},
    SF = {
        get exports() {
            return b
        },
        set exports(e) {
            b = e
        }
    },
    je = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vu = Symbol.for("react.element"),
    PF = Symbol.for("react.portal"),
    CF = Symbol.for("react.fragment"),
    TF = Symbol.for("react.strict_mode"),
    OF = Symbol.for("react.profiler"),
    AF = Symbol.for("react.provider"),
    IF = Symbol.for("react.context"),
    $F = Symbol.for("react.forward_ref"),
    RF = Symbol.for("react.suspense"),
    kF = Symbol.for("react.memo"),
    MF = Symbol.for("react.lazy"),
    px = Symbol.iterator;

function DF(e) {
    return e === null || typeof e != "object" ? null : (e = px && e[px] || e["@@iterator"], typeof e == "function" ? e : null)
}
var LO = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    },
    FO = Object.assign,
    BO = {};

function ul(e, t, r) {
    this.props = e, this.context = t, this.refs = BO, this.updater = r || LO
}
ul.prototype.isReactComponent = {};
ul.prototype.setState = function(e, t) {
    if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, e, t, "setState")
};
ul.prototype.forceUpdate = function(e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
};

function zO() {}
zO.prototype = ul.prototype;

function J_(e, t, r) {
    this.props = e, this.context = t, this.refs = BO, this.updater = r || LO
}
var e1 = J_.prototype = new zO;
e1.constructor = J_;
FO(e1, ul.prototype);
e1.isPureReactComponent = !0;
var mx = Array.isArray,
    jO = Object.prototype.hasOwnProperty,
    t1 = {
        current: null
    },
    UO = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function HO(e, t, r) {
    var n, i = {},
        s = null,
        o = null;
    if (t != null)
        for (n in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (s = "" + t.key), t) jO.call(t, n) && !UO.hasOwnProperty(n) && (i[n] = t[n]);
    var a = arguments.length - 2;
    if (a === 1) i.children = r;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
        i.children = l
    }
    if (e && e.defaultProps)
        for (n in a = e.defaultProps, a) i[n] === void 0 && (i[n] = a[n]);
    return {
        $$typeof: vu,
        type: e,
        key: s,
        ref: o,
        props: i,
        _owner: t1.current
    }
}

function NF(e, t) {
    return {
        $$typeof: vu,
        type: e.type,
        key: t,
        ref: e.ref,
        props: e.props,
        _owner: e._owner
    }
}

function r1(e) {
    return typeof e == "object" && e !== null && e.$$typeof === vu
}

function LF(e) {
    var t = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + e.replace(/[=:]/g, function(r) {
        return t[r]
    })
}
var gx = /\/+/g;

function tv(e, t) {
    return typeof e == "object" && e !== null && e.key != null ? LF("" + e.key) : t.toString(36)
}

function ud(e, t, r, n, i) {
    var s = typeof e;
    (s === "undefined" || s === "boolean") && (e = null);
    var o = !1;
    if (e === null) o = !0;
    else switch (s) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (e.$$typeof) {
                case vu:
                case PF:
                    o = !0
            }
    }
    if (o) return o = e, i = i(o), e = n === "" ? "." + tv(o, 0) : n, mx(i) ? (r = "", e != null && (r = e.replace(gx, "$&/") + "/"), ud(i, t, r, "", function(c) {
        return c
    })) : i != null && (r1(i) && (i = NF(i, r + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(gx, "$&/") + "/") + e)), t.push(i)), 1;
    if (o = 0, n = n === "" ? "." : n + ":", mx(e))
        for (var a = 0; a < e.length; a++) {
            s = e[a];
            var l = n + tv(s, a);
            o += ud(s, t, r, l, i)
        } else if (l = DF(e), typeof l == "function")
            for (e = l.call(e), a = 0; !(s = e.next()).done;) s = s.value, l = n + tv(s, a++), o += ud(s, t, r, l, i);
        else if (s === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
    return o
}

function Qu(e, t, r) {
    if (e == null) return e;
    var n = [],
        i = 0;
    return ud(e, n, "", "", function(s) {
        return t.call(r, s, i++)
    }), n
}

function FF(e) {
    if (e._status === -1) {
        var t = e._result;
        t = t(), t.then(function(r) {
            (e._status === 0 || e._status === -1) && (e._status = 1, e._result = r)
        }, function(r) {
            (e._status === 0 || e._status === -1) && (e._status = 2, e._result = r)
        }), e._status === -1 && (e._status = 0, e._result = t)
    }
    if (e._status === 1) return e._result.default;
    throw e._result
}
var gr = {
        current: null
    },
    hd = {
        transition: null
    },
    BF = {
        ReactCurrentDispatcher: gr,
        ReactCurrentBatchConfig: hd,
        ReactCurrentOwner: t1
    };
je.Children = {
    map: Qu,
    forEach: function(e, t, r) {
        Qu(e, function() {
            t.apply(this, arguments)
        }, r)
    },
    count: function(e) {
        var t = 0;
        return Qu(e, function() {
            t++
        }), t
    },
    toArray: function(e) {
        return Qu(e, function(t) {
            return t
        }) || []
    },
    only: function(e) {
        if (!r1(e)) throw Error("React.Children.only expected to receive a single React element child.");
        return e
    }
};
je.Component = ul;
je.Fragment = CF;
je.Profiler = OF;
je.PureComponent = J_;
je.StrictMode = TF;
je.Suspense = RF;
je.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = BF;
je.cloneElement = function(e, t, r) {
    if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
    var n = FO({}, e.props),
        i = e.key,
        s = e.ref,
        o = e._owner;
    if (t != null) {
        if (t.ref !== void 0 && (s = t.ref, o = t1.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps;
        for (l in t) jO.call(t, l) && !UO.hasOwnProperty(l) && (n[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l])
    }
    var l = arguments.length - 2;
    if (l === 1) n.children = r;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
        n.children = a
    }
    return {
        $$typeof: vu,
        type: e.type,
        key: i,
        ref: s,
        props: n,
        _owner: o
    }
};
je.createContext = function(e) {
    return e = {
        $$typeof: IF,
        _currentValue: e,
        _currentValue2: e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    }, e.Provider = {
        $$typeof: AF,
        _context: e
    }, e.Consumer = e
};
je.createElement = HO;
je.createFactory = function(e) {
    var t = HO.bind(null, e);
    return t.type = e, t
};
je.createRef = function() {
    return {
        current: null
    }
};
je.forwardRef = function(e) {
    return {
        $$typeof: $F,
        render: e
    }
};
je.isValidElement = r1;
je.lazy = function(e) {
    return {
        $$typeof: MF,
        _payload: {
            _status: -1,
            _result: e
        },
        _init: FF
    }
};
je.memo = function(e, t) {
    return {
        $$typeof: kF,
        type: e,
        compare: t === void 0 ? null : t
    }
};
je.startTransition = function(e) {
    var t = hd.transition;
    hd.transition = {};
    try {
        e()
    } finally {
        hd.transition = t
    }
};
je.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
};
je.useCallback = function(e, t) {
    return gr.current.useCallback(e, t)
};
je.useContext = function(e) {
    return gr.current.useContext(e)
};
je.useDebugValue = function() {};
je.useDeferredValue = function(e) {
    return gr.current.useDeferredValue(e)
};
je.useEffect = function(e, t) {
    return gr.current.useEffect(e, t)
};
je.useId = function() {
    return gr.current.useId()
};
je.useImperativeHandle = function(e, t, r) {
    return gr.current.useImperativeHandle(e, t, r)
};
je.useInsertionEffect = function(e, t) {
    return gr.current.useInsertionEffect(e, t)
};
je.useLayoutEffect = function(e, t) {
    return gr.current.useLayoutEffect(e, t)
};
je.useMemo = function(e, t) {
    return gr.current.useMemo(e, t)
};
je.useReducer = function(e, t, r) {
    return gr.current.useReducer(e, t, r)
};
je.useRef = function(e) {
    return gr.current.useRef(e)
};
je.useState = function(e) {
    return gr.current.useState(e)
};
je.useSyncExternalStore = function(e, t, r) {
    return gr.current.useSyncExternalStore(e, t, r)
};
je.useTransition = function() {
    return gr.current.useTransition()
};
je.version = "18.2.0";
(function(e) {
    e.exports = je
})(SF);
const I = NO(b),
    Hd = xF({
        __proto__: null,
        default: I
    }, [b]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zF = b,
    jF = Symbol.for("react.element"),
    UF = Symbol.for("react.fragment"),
    HF = Object.prototype.hasOwnProperty,
    GF = zF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    VF = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function GO(e, t, r) {
    var n, i = {},
        s = null,
        o = null;
    r !== void 0 && (s = "" + r), t.key !== void 0 && (s = "" + t.key), t.ref !== void 0 && (o = t.ref);
    for (n in t) HF.call(t, n) && !VF.hasOwnProperty(n) && (i[n] = t[n]);
    if (e && e.defaultProps)
        for (n in t = e.defaultProps, t) i[n] === void 0 && (i[n] = t[n]);
    return {
        $$typeof: jF,
        type: e,
        key: s,
        ref: o,
        props: i,
        _owner: GF.current
    }
}
pm.Fragment = UF;
pm.jsx = GO;
pm.jsxs = GO;
(function(e) {
    e.exports = pm
})(EF);
var D0 = {},
    Ci = {},
    WF = {
        get exports() {
            return Ci
        },
        set exports(e) {
            Ci = e
        }
    },
    Ur = {},
    N0 = {},
    XF = {
        get exports() {
            return N0
        },
        set exports(e) {
            N0 = e
        }
    },
    VO = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
    function t(G, X) {
        var z = G.length;
        G.push(X);
        e: for (; 0 < z;) {
            var Q = z - 1 >>> 1,
                ie = G[Q];
            if (0 < i(ie, X)) G[Q] = X, G[z] = ie, z = Q;
            else break e
        }
    }

    function r(G) {
        return G.length === 0 ? null : G[0]
    }

    function n(G) {
        if (G.length === 0) return null;
        var X = G[0],
            z = G.pop();
        if (z !== X) {
            G[0] = z;
            e: for (var Q = 0, ie = G.length, _e = ie >>> 1; Q < _e;) {
                var we = 2 * (Q + 1) - 1,
                    De = G[we],
                    Te = we + 1,
                    Ne = G[Te];
                if (0 > i(De, z)) Te < ie && 0 > i(Ne, De) ? (G[Q] = Ne, G[Te] = z, Q = Te) : (G[Q] = De, G[we] = z, Q = we);
                else if (Te < ie && 0 > i(Ne, z)) G[Q] = Ne, G[Te] = z, Q = Te;
                else break e
            }
        }
        return X
    }

    function i(G, X) {
        var z = G.sortIndex - X.sortIndex;
        return z !== 0 ? z : G.id - X.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        e.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        e.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = [],
        c = [],
        u = 1,
        h = null,
        d = 3,
        f = !1,
        p = !1,
        m = !1,
        w = typeof setTimeout == "function" ? setTimeout : null,
        y = typeof clearTimeout == "function" ? clearTimeout : null,
        v = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function _(G) {
        for (var X = r(c); X !== null;) {
            if (X.callback === null) n(c);
            else if (X.startTime <= G) n(c), X.sortIndex = X.expirationTime, t(l, X);
            else break;
            X = r(c)
        }
    }

    function E(G) {
        if (m = !1, _(G), !p)
            if (r(l) !== null) p = !0, Z(P);
            else {
                var X = r(c);
                X !== null && q(E, X.startTime - G)
            }
    }

    function P(G, X) {
        p = !1, m && (m = !1, y(O), O = -1), f = !0;
        var z = d;
        try {
            for (_(X), h = r(l); h !== null && (!(h.expirationTime > X) || G && !B());) {
                var Q = h.callback;
                if (typeof Q == "function") {
                    h.callback = null, d = h.priorityLevel;
                    var ie = Q(h.expirationTime <= X);
                    X = e.unstable_now(), typeof ie == "function" ? h.callback = ie : h === r(l) && n(l), _(X)
                } else n(l);
                h = r(l)
            }
            if (h !== null) var _e = !0;
            else {
                var we = r(c);
                we !== null && q(E, we.startTime - X), _e = !1
            }
            return _e
        } finally {
            h = null, d = z, f = !1
        }
    }
    var C = !1,
        T = null,
        O = -1,
        k = 5,
        D = -1;

    function B() {
        return !(e.unstable_now() - D < k)
    }

    function j() {
        if (T !== null) {
            var G = e.unstable_now();
            D = G;
            var X = !0;
            try {
                X = T(!0, G)
            } finally {
                X ? L() : (C = !1, T = null)
            }
        } else C = !1
    }
    var L;
    if (typeof v == "function") L = function() {
        v(j)
    };
    else if (typeof MessageChannel < "u") {
        var M = new MessageChannel,
            W = M.port2;
        M.port1.onmessage = j, L = function() {
            W.postMessage(null)
        }
    } else L = function() {
        w(j, 0)
    };

    function Z(G) {
        T = G, C || (C = !0, L())
    }

    function q(G, X) {
        O = w(function() {
            G(e.unstable_now())
        }, X)
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(G) {
        G.callback = null
    }, e.unstable_continueExecution = function() {
        p || f || (p = !0, Z(P))
    }, e.unstable_forceFrameRate = function(G) {
        0 > G || 125 < G ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : k = 0 < G ? Math.floor(1e3 / G) : 5
    }, e.unstable_getCurrentPriorityLevel = function() {
        return d
    }, e.unstable_getFirstCallbackNode = function() {
        return r(l)
    }, e.unstable_next = function(G) {
        switch (d) {
            case 1:
            case 2:
            case 3:
                var X = 3;
                break;
            default:
                X = d
        }
        var z = d;
        d = X;
        try {
            return G()
        } finally {
            d = z
        }
    }, e.unstable_pauseExecution = function() {}, e.unstable_requestPaint = function() {}, e.unstable_runWithPriority = function(G, X) {
        switch (G) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                G = 3
        }
        var z = d;
        d = G;
        try {
            return X()
        } finally {
            d = z
        }
    }, e.unstable_scheduleCallback = function(G, X, z) {
        var Q = e.unstable_now();
        switch (typeof z == "object" && z !== null ? (z = z.delay, z = typeof z == "number" && 0 < z ? Q + z : Q) : z = Q, G) {
            case 1:
                var ie = -1;
                break;
            case 2:
                ie = 250;
                break;
            case 5:
                ie = 1073741823;
                break;
            case 4:
                ie = 1e4;
                break;
            default:
                ie = 5e3
        }
        return ie = z + ie, G = {
            id: u++,
            callback: X,
            priorityLevel: G,
            startTime: z,
            expirationTime: ie,
            sortIndex: -1
        }, z > Q ? (G.sortIndex = z, t(c, G), r(l) === null && G === r(c) && (m ? (y(O), O = -1) : m = !0, q(E, z - Q))) : (G.sortIndex = ie, t(l, G), p || f || (p = !0, Z(P))), G
    }, e.unstable_shouldYield = B, e.unstable_wrapCallback = function(G) {
        var X = d;
        return function() {
            var z = d;
            d = X;
            try {
                return G.apply(this, arguments)
            } finally {
                d = z
            }
        }
    }
})(VO);
(function(e) {
    e.exports = VO
})(XF);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WO = b,
    zr = N0;

function re(e) {
    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 1; r < arguments.length; r++) t += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var XO = new Set,
    kc = {};

function Eo(e, t) {
    Wa(e, t), Wa(e + "Capture", t)
}

function Wa(e, t) {
    for (kc[e] = t, e = 0; e < t.length; e++) XO.add(t[e])
}
var Ti = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
    L0 = Object.prototype.hasOwnProperty,
    YF = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    vx = {},
    yx = {};

function KF(e) {
    return L0.call(yx, e) ? !0 : L0.call(vx, e) ? !1 : YF.test(e) ? yx[e] = !0 : (vx[e] = !0, !1)
}

function qF(e, t, r, n) {
    if (r !== null && r.type === 0) return !1;
    switch (typeof t) {
        case "function":
        case "symbol":
            return !0;
        case "boolean":
            return n ? !1 : r !== null ? !r.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-");
        default:
            return !1
    }
}

function QF(e, t, r, n) {
    if (t === null || typeof t > "u" || qF(e, t, r, n)) return !0;
    if (n) return !1;
    if (r !== null) switch (r.type) {
        case 3:
            return !t;
        case 4:
            return t === !1;
        case 5:
            return isNaN(t);
        case 6:
            return isNaN(t) || 1 > t
    }
    return !1
}

function vr(e, t, r, n, i, s, o) {
    this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = n, this.attributeNamespace = i, this.mustUseProperty = r, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = o
}
var sr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
    sr[e] = new vr(e, 0, !1, e, null, !1, !1)
});
[
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
].forEach(function(e) {
    var t = e[0];
    sr[t] = new vr(t, 1, !1, e[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
    sr[e] = new vr(e, 2, !1, e.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
    sr[e] = new vr(e, 2, !1, e, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
    sr[e] = new vr(e, 3, !1, e.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(e) {
    sr[e] = new vr(e, 3, !0, e, null, !1, !1)
});
["capture", "download"].forEach(function(e) {
    sr[e] = new vr(e, 4, !1, e, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(e) {
    sr[e] = new vr(e, 6, !1, e, null, !1, !1)
});
["rowSpan", "start"].forEach(function(e) {
    sr[e] = new vr(e, 5, !1, e.toLowerCase(), null, !1, !1)
});
var n1 = /[\-:]([a-z])/g;

function i1(e) {
    return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
    var t = e.replace(n1, i1);
    sr[t] = new vr(t, 1, !1, e, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
    var t = e.replace(n1, i1);
    sr[t] = new vr(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
    var t = e.replace(n1, i1);
    sr[t] = new vr(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(e) {
    sr[e] = new vr(e, 1, !1, e.toLowerCase(), null, !1, !1)
});
sr.xlinkHref = new vr("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(e) {
    sr[e] = new vr(e, 1, !1, e.toLowerCase(), null, !0, !0)
});

function s1(e, t, r, n) {
    var i = sr.hasOwnProperty(t) ? sr[t] : null;
    (i !== null ? i.type !== 0 : n || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (QF(t, r, i, n) && (r = null), n || i === null ? KF(t) && (r === null ? e.removeAttribute(t) : e.setAttribute(t, "" + r)) : i.mustUseProperty ? e[i.propertyName] = r === null ? i.type === 3 ? !1 : "" : r : (t = i.attributeName, n = i.attributeNamespace, r === null ? e.removeAttribute(t) : (i = i.type, r = i === 3 || i === 4 && r === !0 ? "" : "" + r, n ? e.setAttributeNS(n, t, r) : e.setAttribute(t, r))))
}
var Ri = WO.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    Zu = Symbol.for("react.element"),
    ma = Symbol.for("react.portal"),
    ga = Symbol.for("react.fragment"),
    o1 = Symbol.for("react.strict_mode"),
    F0 = Symbol.for("react.profiler"),
    YO = Symbol.for("react.provider"),
    KO = Symbol.for("react.context"),
    a1 = Symbol.for("react.forward_ref"),
    B0 = Symbol.for("react.suspense"),
    z0 = Symbol.for("react.suspense_list"),
    l1 = Symbol.for("react.memo"),
    qi = Symbol.for("react.lazy"),
    qO = Symbol.for("react.offscreen"),
    _x = Symbol.iterator;

function Rl(e) {
    return e === null || typeof e != "object" ? null : (e = _x && e[_x] || e["@@iterator"], typeof e == "function" ? e : null)
}
var Et = Object.assign,
    rv;

function ic(e) {
    if (rv === void 0) try {
        throw Error()
    } catch (r) {
        var t = r.stack.trim().match(/\n( *(at )?)/);
        rv = t && t[1] || ""
    }
    return `
` + rv + e
}
var nv = !1;

function iv(e, t) {
    if (!e || nv) return "";
    nv = !0;
    var r = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (t)
            if (t = function() {
                    throw Error()
                }, Object.defineProperty(t.prototype, "props", {
                    set: function() {
                        throw Error()
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(t, [])
                } catch (c) {
                    var n = c
                }
                Reflect.construct(e, [], t)
            } else {
                try {
                    t.call()
                } catch (c) {
                    n = c
                }
                e.call(t.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                n = c
            }
            e()
        }
    } catch (c) {
        if (c && n && typeof c.stack == "string") {
            for (var i = c.stack.split(`
`), s = n.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];) a--;
            for (; 1 <= o && 0 <= a; o--, a--)
                if (i[o] !== s[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--, a--, 0 > a || i[o] !== s[a]) {
                                var l = `
` + i[o].replace(" at new ", " at ");
                                return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                            }
                    while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        nv = !1, Error.prepareStackTrace = r
    }
    return (e = e ? e.displayName || e.name : "") ? ic(e) : ""
}

function ZF(e) {
    switch (e.tag) {
        case 5:
            return ic(e.type);
        case 16:
            return ic("Lazy");
        case 13:
            return ic("Suspense");
        case 19:
            return ic("SuspenseList");
        case 0:
        case 2:
        case 15:
            return e = iv(e.type, !1), e;
        case 11:
            return e = iv(e.type.render, !1), e;
        case 1:
            return e = iv(e.type, !0), e;
        default:
            return ""
    }
}

function j0(e) {
    if (e == null) return null;
    if (typeof e == "function") return e.displayName || e.name || null;
    if (typeof e == "string") return e;
    switch (e) {
        case ga:
            return "Fragment";
        case ma:
            return "Portal";
        case F0:
            return "Profiler";
        case o1:
            return "StrictMode";
        case B0:
            return "Suspense";
        case z0:
            return "SuspenseList"
    }
    if (typeof e == "object") switch (e.$$typeof) {
        case KO:
            return (e.displayName || "Context") + ".Consumer";
        case YO:
            return (e._context.displayName || "Context") + ".Provider";
        case a1:
            var t = e.render;
            return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
        case l1:
            return t = e.displayName || null, t !== null ? t : j0(e.type) || "Memo";
        case qi:
            t = e._payload, e = e._init;
            try {
                return j0(e(t))
            } catch {}
    }
    return null
}

function JF(e) {
    var t = e.type;
    switch (e.tag) {
        case 24:
            return "Cache";
        case 9:
            return (t.displayName || "Context") + ".Consumer";
        case 10:
            return (t._context.displayName || "Context") + ".Provider";
        case 18:
            return "DehydratedFragment";
        case 11:
            return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef");
        case 7:
            return "Fragment";
        case 5:
            return t;
        case 4:
            return "Portal";
        case 3:
            return "Root";
        case 6:
            return "Text";
        case 16:
            return j0(t);
        case 8:
            return t === o1 ? "StrictMode" : "Mode";
        case 22:
            return "Offscreen";
        case 12:
            return "Profiler";
        case 21:
            return "Scope";
        case 13:
            return "Suspense";
        case 19:
            return "SuspenseList";
        case 25:
            return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
            if (typeof t == "function") return t.displayName || t.name || null;
            if (typeof t == "string") return t
    }
    return null
}

function xs(e) {
    switch (typeof e) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return e;
        case "object":
            return e;
        default:
            return ""
    }
}

function QO(e) {
    var t = e.type;
    return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio")
}

function eB(e) {
    var t = QO(e) ? "checked" : "value",
        r = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
        n = "" + e[t];
    if (!e.hasOwnProperty(t) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
        var i = r.get,
            s = r.set;
        return Object.defineProperty(e, t, {
            configurable: !0,
            get: function() {
                return i.call(this)
            },
            set: function(o) {
                n = "" + o, s.call(this, o)
            }
        }), Object.defineProperty(e, t, {
            enumerable: r.enumerable
        }), {
            getValue: function() {
                return n
            },
            setValue: function(o) {
                n = "" + o
            },
            stopTracking: function() {
                e._valueTracker = null, delete e[t]
            }
        }
    }
}

function Ju(e) {
    e._valueTracker || (e._valueTracker = eB(e))
}

function ZO(e) {
    if (!e) return !1;
    var t = e._valueTracker;
    if (!t) return !0;
    var r = t.getValue(),
        n = "";
    return e && (n = QO(e) ? e.checked ? "true" : "false" : e.value), e = n, e !== r ? (t.setValue(e), !0) : !1
}

function Gd(e) {
    if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
    try {
        return e.activeElement || e.body
    } catch {
        return e.body
    }
}

function U0(e, t) {
    var r = t.checked;
    return Et({}, t, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: r??e._wrapperState.initialChecked
    }
    )
}

function wx(e, t) {
    var r = t.defaultValue == null ? "" : t.defaultValue,
        n = t.checked != null ? t.checked : t.defaultChecked;
    r = xs(t.value != null ? t.value : r), e._wrapperState = {
        initialChecked: n,
        initialValue: r,
        controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null
    }
}

function JO(e, t) {
    t = t.checked, t != null && s1(e, "checked", t, !1)
}

function H0(e, t) {
    JO(e, t);
    var r = xs(t.value),
        n = t.type;
    if (r != null) n === "number" ? (r === 0 && e.value === "" || e.value != r) && (e.value = "" + r) : e.value !== "" + r && (e.value = "" + r);
    else if (n === "submit" || n === "reset") {
        e.removeAttribute("value");
        return
    }
    t.hasOwnProperty("value") ? G0(e, t.type, r) : t.hasOwnProperty("defaultValue") && G0(e, t.type, xs(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked)
}

function bx(e, t, r) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
        var n = t.type;
        if (!(n !== "submit" && n !== "reset" || t.value !== void 0 && t.value !== null)) return;
        t = "" + e._wrapperState.initialValue, r || t === e.value || (e.value = t), e.defaultValue = t
    }
    r = e.name, r !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, r !== "" && (e.name = r)
}

function G0(e, t, r) {
    (t !== "number" || Gd(e.ownerDocument) !== e) && (r == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + r && (e.defaultValue = "" + r))
}
var sc = Array.isArray;

function Aa(e, t, r, n) {
    if (e = e.options, t) {
        t = {};
        for (var i = 0; i < r.length; i++) t["$" + r[i]] = !0;
        for (r = 0; r < e.length; r++) i = t.hasOwnProperty("$" + e[r].value), e[r].selected !== i && (e[r].selected = i), i && n && (e[r].defaultSelected = !0)
    } else {
        for (r = "" + xs(r), t = null, i = 0; i < e.length; i++) {
            if (e[i].value === r) {
                e[i].selected = !0, n && (e[i].defaultSelected = !0);
                return
            }
            t !== null || e[i].disabled || (t = e[i])
        }
        t !== null && (t.selected = !0)
    }
}

function V0(e, t) {
    if (t.dangerouslySetInnerHTML != null) throw Error(re(91));
    return Et({}, t, {
        value: void 0,
        defaultValue: void 0,
        children: "" + e._wrapperState.initialValue
    })
}

function xx(e, t) {
    var r = t.value;
    if (r == null) {
        if (r = t.children, t = t.defaultValue, r != null) {
            if (t != null) throw Error(re(92));
            if (sc(r)) {
                if (1 < r.length) throw Error(re(93));
                r = r[0]
            }
            t = r
        }
        t == null && (t = ""), r = t
    }
    e._wrapperState = {
        initialValue: xs(r)
    }
}

function eA(e, t) {
    var r = xs(t.value),
        n = xs(t.defaultValue);
    r != null && (r = "" + r, r !== e.value && (e.value = r), t.defaultValue == null && e.defaultValue !== r && (e.defaultValue = r)), n != null && (e.defaultValue = "" + n)
}

function Ex(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}

function tA(e) {
    switch (e) {
        case "svg":
            return "http://www.w3.org/2000/svg";
        case "math":
            return "http://www.w3.org/1998/Math/MathML";
        default:
            return "http://www.w3.org/1999/xhtml"
    }
}

function W0(e, t) {
    return e == null || e === "http://www.w3.org/1999/xhtml" ? tA(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e
}
var eh, rA = function(e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(t, r, n, i) {
        MSApp.execUnsafeLocalFunction(function() {
            return e(t, r, n, i)
        })
    } : e
}(function(e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t;
    else {
        for (eh = eh || document.createElement("div"), eh.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = eh.firstChild; e.firstChild;) e.removeChild(e.firstChild);
        for (; t.firstChild;) e.appendChild(t.firstChild)
    }
});

function Mc(e, t) {
    if (t) {
        var r = e.firstChild;
        if (r && r === e.lastChild && r.nodeType === 3) {
            r.nodeValue = t;
            return
        }
    }
    e.textContent = t
}
var mc = {
        animationIterationCount: !0,
        aspectRatio: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridArea: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    tB = ["Webkit", "ms", "Moz", "O"];
Object.keys(mc).forEach(function(e) {
    tB.forEach(function(t) {
        t = t + e.charAt(0).toUpperCase() + e.substring(1), mc[t] = mc[e]
    })
});

function nA(e, t, r) {
    return t == null || typeof t == "boolean" || t === "" ? "" : r || typeof t != "number" || t === 0 || mc.hasOwnProperty(e) && mc[e] ? ("" + t).trim() : t + "px"
}

function iA(e, t) {
    e = e.style;
    for (var r in t)
        if (t.hasOwnProperty(r)) {
            var n = r.indexOf("--") === 0,
                i = nA(r, t[r], n);
            r === "float" && (r = "cssFloat"), n ? e.setProperty(r, i) : e[r] = i
        }
}
var rB = Et({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});

function X0(e, t) {
    if (t) {
        if (rB[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(re(137, e));
        if (t.dangerouslySetInnerHTML != null) {
            if (t.children != null) throw Error(re(60));
            if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(re(61))
        }
        if (t.style != null && typeof t.style != "object") throw Error(re(62))
    }
}

function Y0(e, t) {
    if (e.indexOf("-") === -1) return typeof t.is == "string";
    switch (e) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
    }
}
var K0 = null;

function c1(e) {
    return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e
}
var q0 = null,
    Ia = null,
    $a = null;

function Sx(e) {
    if (e = wu(e)) {
        if (typeof q0 != "function") throw Error(re(280));
        var t = e.stateNode;
        t && (t = _m(t), q0(e.stateNode, e.type, t))
    }
}

function sA(e) {
    Ia ? $a ? $a.push(e) : $a = [e] : Ia = e
}

function oA() {
    if (Ia) {
        var e = Ia,
            t = $a;
        if ($a = Ia = null, Sx(e), t)
            for (e = 0; e < t.length; e++) Sx(t[e])
    }
}

function aA(e, t) {
    return e(t)
}

function lA() {}
var sv = !1;

function cA(e, t, r) {
    if (sv) return e(t, r);
    sv = !0;
    try {
        return aA(e, t, r)
    } finally {
        sv = !1, (Ia !== null || $a !== null) && (lA(), oA())
    }
}

function Dc(e, t) {
    var r = e.stateNode;
    if (r === null) return null;
    var n = _m(r);
    if (n === null) return null;
    r = n[t];
    e: switch (t) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (n = !n.disabled) || (e = e.type, n = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !n;
            break e;
        default:
            e = !1
    }
    if (e) return null;
    if (r && typeof r != "function") throw Error(re(231, t, typeof r));
    return r
}
var Q0 = !1;
if (Ti) try {
    var kl = {};
    Object.defineProperty(kl, "passive", {
        get: function() {
            Q0 = !0
        }
    }), window.addEventListener("test", kl, kl), window.removeEventListener("test", kl, kl)
} catch {
    Q0 = !1
}

function nB(e, t, r, n, i, s, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        t.apply(r, c)
    } catch (u) {
        this.onError(u)
    }
}
var gc = !1,
    Vd = null,
    Wd = !1,
    Z0 = null,
    iB = {
        onError: function(e) {
            gc = !0, Vd = e
        }
    };

function sB(e, t, r, n, i, s, o, a, l) {
    gc = !1, Vd = null, nB.apply(iB, arguments)
}

function oB(e, t, r, n, i, s, o, a, l) {
    if (sB.apply(this, arguments), gc) {
        if (gc) {
            var c = Vd;
            gc = !1, Vd = null
        } else throw Error(re(198));
        Wd || (Wd = !0, Z0 = c)
    }
}

function So(e) {
    var t = e,
        r = e;
    if (e.alternate)
        for (; t.return;) t = t.return;
    else {
        e = t;
        do t = e, t.flags & 4098 && (r = t.return), e = t.return; while (e)
    }
    return t.tag === 3 ? r : null
}

function uA(e) {
    if (e.tag === 13) {
        var t = e.memoizedState;
        if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated
    }
    return null
}

function Px(e) {
    if (So(e) !== e) throw Error(re(188))
}

function aB(e) {
    var t = e.alternate;
    if (!t) {
        if (t = So(e), t === null) throw Error(re(188));
        return t !== e ? null : e
    }
    for (var r = e, n = t;;) {
        var i = r.return;
        if (i === null) break;
        var s = i.alternate;
        if (s === null) {
            if (n = i.return, n !== null) {
                r = n;
                continue
            }
            break
        }
        if (i.child === s.child) {
            for (s = i.child; s;) {
                if (s === r) return Px(i), e;
                if (s === n) return Px(i), t;
                s = s.sibling
            }
            throw Error(re(188))
        }
        if (r.return !== n.return) r = i, n = s;
        else {
            for (var o = !1, a = i.child; a;) {
                if (a === r) {
                    o = !0, r = i, n = s;
                    break
                }
                if (a === n) {
                    o = !0, n = i, r = s;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = s.child; a;) {
                    if (a === r) {
                        o = !0, r = s, n = i;
                        break
                    }
                    if (a === n) {
                        o = !0, n = s, r = i;
                        break
                    }
                    a = a.sibling
                }
                if (!o) throw Error(re(189))
            }
        }
        if (r.alternate !== n) throw Error(re(190))
    }
    if (r.tag !== 3) throw Error(re(188));
    return r.stateNode.current === r ? e : t
}

function hA(e) {
    return e = aB(e), e !== null ? dA(e) : null
}

function dA(e) {
    if (e.tag === 5 || e.tag === 6) return e;
    for (e = e.child; e !== null;) {
        var t = dA(e);
        if (t !== null) return t;
        e = e.sibling
    }
    return null
}
var fA = zr.unstable_scheduleCallback,
    Cx = zr.unstable_cancelCallback,
    lB = zr.unstable_shouldYield,
    cB = zr.unstable_requestPaint,
    Tt = zr.unstable_now,
    uB = zr.unstable_getCurrentPriorityLevel,
    u1 = zr.unstable_ImmediatePriority,
    pA = zr.unstable_UserBlockingPriority,
    Xd = zr.unstable_NormalPriority,
    hB = zr.unstable_LowPriority,
    mA = zr.unstable_IdlePriority,
    mm = null,
    ei = null;

function dB(e) {
    if (ei && typeof ei.onCommitFiberRoot == "function") try {
        ei.onCommitFiberRoot(mm, e, void 0, (e.current.flags & 128) === 128)
    } catch {}
}
var Cn = Math.clz32 ? Math.clz32 : mB,
    fB = Math.log,
    pB = Math.LN2;

function mB(e) {
    return e >>>= 0, e === 0 ? 32 : 31 - (fB(e) / pB | 0) | 0
}
var th = 64,
    rh = 4194304;

function oc(e) {
    switch (e & -e) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return e & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return e & 130023424;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 1073741824;
        default:
            return e
    }
}

function Yd(e, t) {
    var r = e.pendingLanes;
    if (r === 0) return 0;
    var n = 0,
        i = e.suspendedLanes,
        s = e.pingedLanes,
        o = r & 268435455;
    if (o !== 0) {
        var a = o & ~i;
        a !== 0 ? n = oc(a) : (s &= o, s !== 0 && (n = oc(s)))
    } else o = r & ~i, o !== 0 ? n = oc(o) : s !== 0 && (n = oc(s));
    if (n === 0) return 0;
    if (t !== 0 && t !== n && !(t & i) && (i = n & -n, s = t & -t, i >= s || i === 16 && (s & 4194240) !== 0)) return t;
    if (n & 4 && (n |= r & 16), t = e.entangledLanes, t !== 0)
        for (e = e.entanglements, t &= n; 0 < t;) r = 31 - Cn(t), i = 1 << r, n |= e[r], t &= ~i;
    return n
}

function gB(e, t) {
    switch (e) {
        case 1:
        case 2:
        case 4:
            return t + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return t + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
            return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
    }
}

function vB(e, t) {
    for (var r = e.suspendedLanes, n = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s;) {
        var o = 31 - Cn(s),
            a = 1 << o,
            l = i[o];
        l === -1 ? (!(a & r) || a & n) && (i[o] = gB(a, t)) : l <= t && (e.expiredLanes |= a), s &= ~a
    }
}

function J0(e) {
    return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
}

function gA() {
    var e = th;
    return th <<= 1, !(th & 4194240) && (th = 64), e
}

function ov(e) {
    for (var t = [], r = 0; 31 > r; r++) t.push(e);
    return t
}

function yu(e, t, r) {
    e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Cn(t), e[t] = r
}

function yB(e, t) {
    var r = e.pendingLanes & ~t;
    e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
    var n = e.eventTimes;
    for (e = e.expirationTimes; 0 < r;) {
        var i = 31 - Cn(r),
            s = 1 << i;
        t[i] = 0, n[i] = -1, e[i] = -1, r &= ~s
    }
}

function h1(e, t) {
    var r = e.entangledLanes |= t;
    for (e = e.entanglements; r;) {
        var n = 31 - Cn(r),
            i = 1 << n;
        i & t | e[n] & t && (e[n] |= t), r &= ~i
    }
}
var it = 0;

function vA(e) {
    return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1
}
var yA, d1, _A, wA, bA, ey = !1,
    nh = [],
    cs = null,
    us = null,
    hs = null,
    Nc = new Map,
    Lc = new Map,
    Zi = [],
    _B = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function Tx(e, t) {
    switch (e) {
        case "focusin":
        case "focusout":
            cs = null;
            break;
        case "dragenter":
        case "dragleave":
            us = null;
            break;
        case "mouseover":
        case "mouseout":
            hs = null;
            break;
        case "pointerover":
        case "pointerout":
            Nc.delete(t.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            Lc.delete(t.pointerId)
    }
}

function Ml(e, t, r, n, i, s) {
    return e === null || e.nativeEvent !== s ? (e = {
        blockedOn: t,
        domEventName: r,
        eventSystemFlags: n,
        nativeEvent: s,
        targetContainers: [i]
    }, t !== null && (t = wu(t), t !== null && d1(t)), e) : (e.eventSystemFlags |= n, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e)
}

function wB(e, t, r, n, i) {
    switch (t) {
        case "focusin":
            return cs = Ml(cs, e, t, r, n, i), !0;
        case "dragenter":
            return us = Ml(us, e, t, r, n, i), !0;
        case "mouseover":
            return hs = Ml(hs, e, t, r, n, i), !0;
        case "pointerover":
            var s = i.pointerId;
            return Nc.set(s, Ml(Nc.get(s) || null, e, t, r, n, i)), !0;
        case "gotpointercapture":
            return s = i.pointerId, Lc.set(s, Ml(Lc.get(s) || null, e, t, r, n, i)), !0
    }
    return !1
}

function xA(e) {
    var t = Js(e.target);
    if (t !== null) {
        var r = So(t);
        if (r !== null) {
            if (t = r.tag, t === 13) {
                if (t = uA(r), t !== null) {
                    e.blockedOn = t, bA(e.priority, function() {
                        _A(r)
                    });
                    return
                }
            } else if (t === 3 && r.stateNode.current.memoizedState.isDehydrated) {
                e.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
                return
            }
        }
    }
    e.blockedOn = null
}

function dd(e) {
    if (e.blockedOn !== null) return !1;
    for (var t = e.targetContainers; 0 < t.length;) {
        var r = ty(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
        if (r === null) {
            r = e.nativeEvent;
            var n = new r.constructor(r.type, r);
            K0 = n, r.target.dispatchEvent(n), K0 = null
        } else return t = wu(r), t !== null && d1(t), e.blockedOn = r, !1;
        t.shift()
    }
    return !0
}

function Ox(e, t, r) {
    dd(e) && r.delete(t)
}

function bB() {
    ey = !1, cs !== null && dd(cs) && (cs = null), us !== null && dd(us) && (us = null), hs !== null && dd(hs) && (hs = null), Nc.forEach(Ox), Lc.forEach(Ox)
}

function Dl(e, t) {
    e.blockedOn === t && (e.blockedOn = null, ey || (ey = !0, zr.unstable_scheduleCallback(zr.unstable_NormalPriority, bB)))
}

function Fc(e) {
    function t(i) {
        return Dl(i, e)
    }
    if (0 < nh.length) {
        Dl(nh[0], e);
        for (var r = 1; r < nh.length; r++) {
            var n = nh[r];
            n.blockedOn === e && (n.blockedOn = null)
        }
    }
    for (cs !== null && Dl(cs, e), us !== null && Dl(us, e), hs !== null && Dl(hs, e), Nc.forEach(t), Lc.forEach(t), r = 0; r < Zi.length; r++) n = Zi[r], n.blockedOn === e && (n.blockedOn = null);
    for (; 0 < Zi.length && (r = Zi[0], r.blockedOn === null);) xA(r), r.blockedOn === null && Zi.shift()
}
var Ra = Ri.ReactCurrentBatchConfig,
    Kd = !0;

function xB(e, t, r, n) {
    var i = it,
        s = Ra.transition;
    Ra.transition = null;
    try {
        it = 1, f1(e, t, r, n)
    } finally {
        it = i, Ra.transition = s
    }
}

function EB(e, t, r, n) {
    var i = it,
        s = Ra.transition;
    Ra.transition = null;
    try {
        it = 4, f1(e, t, r, n)
    } finally {
        it = i, Ra.transition = s
    }
}

function f1(e, t, r, n) {
    if (Kd) {
        var i = ty(e, t, r, n);
        if (i === null) gv(e, t, n, qd, r), Tx(e, n);
        else if (wB(i, e, t, r, n)) n.stopPropagation();
        else if (Tx(e, n), t & 4 && -1 < _B.indexOf(e)) {
            for (; i !== null;) {
                var s = wu(i);
                if (s !== null && yA(s), s = ty(e, t, r, n), s === null && gv(e, t, n, qd, r), s === i) break;
                i = s
            }
            i !== null && n.stopPropagation()
        } else gv(e, t, n, null, r)
    }
}
var qd = null;

function ty(e, t, r, n) {
    if (qd = null, e = c1(n), e = Js(e), e !== null)
        if (t = So(e), t === null) e = null;
        else if (r = t.tag, r === 13) {
        if (e = uA(t), e !== null) return e;
        e = null
    } else if (r === 3) {
        if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
        e = null
    } else t !== e && (e = null);
    return qd = e, null
}

function EA(e) {
    switch (e) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 4;
        case "message":
            switch (uB()) {
                case u1:
                    return 1;
                case pA:
                    return 4;
                case Xd:
                case hB:
                    return 16;
                case mA:
                    return 536870912;
                default:
                    return 16
            }
        default:
            return 16
    }
}
var rs = null,
    p1 = null,
    fd = null;

function SA() {
    if (fd) return fd;
    var e, t = p1,
        r = t.length,
        n, i = "value" in rs ? rs.value : rs.textContent,
        s = i.length;
    for (e = 0; e < r && t[e] === i[e]; e++);
    var o = r - e;
    for (n = 1; n <= o && t[r - n] === i[s - n]; n++);
    return fd = i.slice(e, 1 < n ? 1 - n : void 0)
}

function pd(e) {
    var t = e.keyCode;
    return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0
}

function ih() {
    return !0
}

function Ax() {
    return !1
}

function Hr(e) {
    function t(r, n, i, s, o) {
        this._reactName = r, this._targetInst = i, this.type = n, this.nativeEvent = s, this.target = o, this.currentTarget = null;
        for (var a in e) e.hasOwnProperty(a) && (r = e[a], this[a] = r ? r(s) : s[a]);
        return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ih : Ax, this.isPropagationStopped = Ax, this
    }
    return Et(t.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var r = this.nativeEvent;
            r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1), this.isDefaultPrevented = ih)
        },
        stopPropagation: function() {
            var r = this.nativeEvent;
            r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0), this.isPropagationStopped = ih)
        },
        persist: function() {},
        isPersistent: ih
    }), t
}
var hl = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(e) {
            return e.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    },
    m1 = Hr(hl),
    _u = Et({}, hl, {
        view: 0,
        detail: 0
    }),
    SB = Hr(_u),
    av, lv, Nl, gm = Et({}, _u, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: g1,
        button: 0,
        buttons: 0,
        relatedTarget: function(e) {
            return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
        },
        movementX: function(e) {
            return "movementX" in e ? e.movementX : (e !== Nl && (Nl && e.type === "mousemove" ? (av = e.screenX - Nl.screenX, lv = e.screenY - Nl.screenY) : lv = av = 0, Nl = e), av)
        },
        movementY: function(e) {
            return "movementY" in e ? e.movementY : lv
        }
    }),
    Ix = Hr(gm),
    PB = Et({}, gm, {
        dataTransfer: 0
    }),
    CB = Hr(PB),
    TB = Et({}, _u, {
        relatedTarget: 0
    }),
    cv = Hr(TB),
    OB = Et({}, hl, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    AB = Hr(OB),
    IB = Et({}, hl, {
        clipboardData: function(e) {
            return "clipboardData" in e ? e.clipboardData : window.clipboardData
        }
    }),
    $B = Hr(IB),
    RB = Et({}, hl, {
        data: 0
    }),
    $x = Hr(RB),
    kB = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    },
    MB = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    },
    DB = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };

function NB(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : (e = DB[e]) ? !!t[e] : !1
}

function g1() {
    return NB
}
var LB = Et({}, _u, {
        key: function(e) {
            if (e.key) {
                var t = kB[e.key] || e.key;
                if (t !== "Unidentified") return t
            }
            return e.type === "keypress" ? (e = pd(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? MB[e.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: g1,
        charCode: function(e) {
            return e.type === "keypress" ? pd(e) : 0
        },
        keyCode: function(e) {
            return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
        },
        which: function(e) {
            return e.type === "keypress" ? pd(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
        }
    }),
    FB = Hr(LB),
    BB = Et({}, gm, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    }),
    Rx = Hr(BB),
    zB = Et({}, _u, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: g1
    }),
    jB = Hr(zB),
    UB = Et({}, hl, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }),
    HB = Hr(UB),
    GB = Et({}, gm, {
        deltaX: function(e) {
            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
        },
        deltaY: function(e) {
            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    }),
    VB = Hr(GB),
    WB = [9, 13, 27, 32],
    v1 = Ti && "CompositionEvent" in window,
    vc = null;
Ti && "documentMode" in document && (vc = document.documentMode);
var XB = Ti && "TextEvent" in window && !vc,
    PA = Ti && (!v1 || vc && 8 < vc && 11 >= vc),
    kx = String.fromCharCode(32),
    Mx = !1;

function CA(e, t) {
    switch (e) {
        case "keyup":
            return WB.indexOf(t.keyCode) !== -1;
        case "keydown":
            return t.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
    }
}

function TA(e) {
    return e = e.detail, typeof e == "object" && "data" in e ? e.data : null
}
var va = !1;

function YB(e, t) {
    switch (e) {
        case "compositionend":
            return TA(t);
        case "keypress":
            return t.which !== 32 ? null : (Mx = !0, kx);
        case "textInput":
            return e = t.data, e === kx && Mx ? null : e;
        default:
            return null
    }
}

function KB(e, t) {
    if (va) return e === "compositionend" || !v1 && CA(e, t) ? (e = SA(), fd = p1 = rs = null, va = !1, e) : null;
    switch (e) {
        case "paste":
            return null;
        case "keypress":
            if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                if (t.char && 1 < t.char.length) return t.char;
                if (t.which) return String.fromCharCode(t.which)
            }
            return null;
        case "compositionend":
            return PA && t.locale !== "ko" ? null : t.data;
        default:
            return null
    }
}
var qB = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};

function Dx(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t === "input" ? !!qB[e.type] : t === "textarea"
}

function OA(e, t, r, n) {
    sA(n), t = Qd(t, "onChange"), 0 < t.length && (r = new m1("onChange", "change", null, r, n), e.push({
        event: r,
        listeners: t
    }))
}
var yc = null,
    Bc = null;

function QB(e) {
    BA(e, 0)
}

function vm(e) {
    var t = wa(e);
    if (ZO(t)) return e
}

function ZB(e, t) {
    if (e === "change") return t
}
var AA = !1;
if (Ti) {
    var uv;
    if (Ti) {
        var hv = "oninput" in document;
        if (!hv) {
            var Nx = document.createElement("div");
            Nx.setAttribute("oninput", "return;"), hv = typeof Nx.oninput == "function"
        }
        uv = hv
    } else uv = !1;
    AA = uv && (!document.documentMode || 9 < document.documentMode)
}

function Lx() {
    yc && (yc.detachEvent("onpropertychange", IA), Bc = yc = null)
}

function IA(e) {
    if (e.propertyName === "value" && vm(Bc)) {
        var t = [];
        OA(t, Bc, e, c1(e)), cA(QB, t)
    }
}

function JB(e, t, r) {
    e === "focusin" ? (Lx(), yc = t, Bc = r, yc.attachEvent("onpropertychange", IA)) : e === "focusout" && Lx()
}

function e8(e) {
    if (e === "selectionchange" || e === "keyup" || e === "keydown") return vm(Bc)
}

function t8(e, t) {
    if (e === "click") return vm(t)
}

function r8(e, t) {
    if (e === "input" || e === "change") return vm(t)
}

function n8(e, t) {
    return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t
}
var kn = typeof Object.is == "function" ? Object.is : n8;

function zc(e, t) {
    if (kn(e, t)) return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1;
    var r = Object.keys(e),
        n = Object.keys(t);
    if (r.length !== n.length) return !1;
    for (n = 0; n < r.length; n++) {
        var i = r[n];
        if (!L0.call(t, i) || !kn(e[i], t[i])) return !1
    }
    return !0
}

function Fx(e) {
    for (; e && e.firstChild;) e = e.firstChild;
    return e
}

function Bx(e, t) {
    var r = Fx(e);
    e = 0;
    for (var n; r;) {
        if (r.nodeType === 3) {
            if (n = e + r.textContent.length, e <= t && n >= t) return {
                node: r,
                offset: t - e
            };
            e = n
        }
        e: {
            for (; r;) {
                if (r.nextSibling) {
                    r = r.nextSibling;
                    break e
                }
                r = r.parentNode
            }
            r = void 0
        }
        r = Fx(r)
    }
}

function $A(e, t) {
    return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? $A(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1
}

function RA() {
    for (var e = window, t = Gd(); t instanceof e.HTMLIFrameElement;) {
        try {
            var r = typeof t.contentWindow.location.href == "string"
        } catch {
            r = !1
        }
        if (r) e = t.contentWindow;
        else break;
        t = Gd(e.document)
    }
    return t
}

function y1(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true")
}

function i8(e) {
    var t = RA(),
        r = e.focusedElem,
        n = e.selectionRange;
    if (t !== r && r && r.ownerDocument && $A(r.ownerDocument.documentElement, r)) {
        if (n !== null && y1(r)) {
            if (t = n.start, e = n.end, e === void 0 && (e = t), "selectionStart" in r) r.selectionStart = t, r.selectionEnd = Math.min(e, r.value.length);
            else if (e = (t = r.ownerDocument || document) && t.defaultView || window, e.getSelection) {
                e = e.getSelection();
                var i = r.textContent.length,
                    s = Math.min(n.start, i);
                n = n.end === void 0 ? s : Math.min(n.end, i), !e.extend && s > n && (i = n, n = s, s = i), i = Bx(r, s);
                var o = Bx(r, n);
                i && o && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), s > n ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t)))
            }
        }
        for (t = [], e = r; e = e.parentNode;) e.nodeType === 1 && t.push({
            element: e,
            left: e.scrollLeft,
            top: e.scrollTop
        });
        for (typeof r.focus == "function" && r.focus(), r = 0; r < t.length; r++) e = t[r], e.element.scrollLeft = e.left, e.element.scrollTop = e.top
    }
}
var s8 = Ti && "documentMode" in document && 11 >= document.documentMode,
    ya = null,
    ry = null,
    _c = null,
    ny = !1;

function zx(e, t, r) {
    var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
    ny || ya == null || ya !== Gd(n) || (n = ya, "selectionStart" in n && y1(n) ? n = {
        start: n.selectionStart,
        end: n.selectionEnd
    } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(), n = {
        anchorNode: n.anchorNode,
        anchorOffset: n.anchorOffset,
        focusNode: n.focusNode,
        focusOffset: n.focusOffset
    }), _c && zc(_c, n) || (_c = n, n = Qd(ry, "onSelect"), 0 < n.length && (t = new m1("onSelect", "select", null, t, r), e.push({
        event: t,
        listeners: n
    }), t.target = ya)))
}

function sh(e, t) {
    var r = {};
    return r[e.toLowerCase()] = t.toLowerCase(), r["Webkit" + e] = "webkit" + t, r["Moz" + e] = "moz" + t, r
}
var _a = {
        animationend: sh("Animation", "AnimationEnd"),
        animationiteration: sh("Animation", "AnimationIteration"),
        animationstart: sh("Animation", "AnimationStart"),
        transitionend: sh("Transition", "TransitionEnd")
    },
    dv = {},
    kA = {};
Ti && (kA = document.createElement("div").style, "AnimationEvent" in window || (delete _a.animationend.animation, delete _a.animationiteration.animation, delete _a.animationstart.animation), "TransitionEvent" in window || delete _a.transitionend.transition);

function ym(e) {
    if (dv[e]) return dv[e];
    if (!_a[e]) return e;
    var t = _a[e],
        r;
    for (r in t)
        if (t.hasOwnProperty(r) && r in kA) return dv[e] = t[r];
    return e
}
var MA = ym("animationend"),
    DA = ym("animationiteration"),
    NA = ym("animationstart"),
    LA = ym("transitionend"),
    FA = new Map,
    jx = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function Os(e, t) {
    FA.set(e, t), Eo(t, [e])
}
for (var fv = 0; fv < jx.length; fv++) {
    var pv = jx[fv],
        o8 = pv.toLowerCase(),
        a8 = pv[0].toUpperCase() + pv.slice(1);
    Os(o8, "on" + a8)
}
Os(MA, "onAnimationEnd");
Os(DA, "onAnimationIteration");
Os(NA, "onAnimationStart");
Os("dblclick", "onDoubleClick");
Os("focusin", "onFocus");
Os("focusout", "onBlur");
Os(LA, "onTransitionEnd");
Wa("onMouseEnter", ["mouseout", "mouseover"]);
Wa("onMouseLeave", ["mouseout", "mouseover"]);
Wa("onPointerEnter", ["pointerout", "pointerover"]);
Wa("onPointerLeave", ["pointerout", "pointerover"]);
Eo("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Eo("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Eo("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Eo("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Eo("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Eo("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var ac = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    l8 = new Set("cancel close invalid load scroll toggle".split(" ").concat(ac));

function Ux(e, t, r) {
    var n = e.type || "unknown-event";
    e.currentTarget = r, oB(n, t, void 0, e), e.currentTarget = null
}

function BA(e, t) {
    t = (t & 4) !== 0;
    for (var r = 0; r < e.length; r++) {
        var n = e[r],
            i = n.event;
        n = n.listeners;
        e: {
            var s = void 0;
            if (t)
                for (var o = n.length - 1; 0 <= o; o--) {
                    var a = n[o],
                        l = a.instance,
                        c = a.currentTarget;
                    if (a = a.listener, l !== s && i.isPropagationStopped()) break e;
                    Ux(i, a, c), s = l
                } else
                    for (o = 0; o < n.length; o++) {
                        if (a = n[o], l = a.instance, c = a.currentTarget, a = a.listener, l !== s && i.isPropagationStopped()) break e;
                        Ux(i, a, c), s = l
                    }
        }
    }
    if (Wd) throw e = Z0, Wd = !1, Z0 = null, e
}

function ut(e, t) {
    var r = t[ly];
    r === void 0 && (r = t[ly] = new Set);
    var n = e + "__bubble";
    r.has(n) || (zA(t, e, 2, !1), r.add(n))
}

function mv(e, t, r) {
    var n = 0;
    t && (n |= 4), zA(r, e, n, t)
}
var oh = "_reactListening" + Math.random().toString(36).slice(2);

function jc(e) {
    if (!e[oh]) {
        e[oh] = !0, XO.forEach(function(r) {
            r !== "selectionchange" && (l8.has(r) || mv(r, !1, e), mv(r, !0, e))
        });
        var t = e.nodeType === 9 ? e : e.ownerDocument;
        t === null || t[oh] || (t[oh] = !0, mv("selectionchange", !1, t))
    }
}

function zA(e, t, r, n) {
    switch (EA(t)) {
        case 1:
            var i = xB;
            break;
        case 4:
            i = EB;
            break;
        default:
            i = f1
    }
    r = i.bind(null, t, r, e), i = void 0, !Q0 || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), n ? i !== void 0 ? e.addEventListener(t, r, {
        capture: !0,
        passive: i
    }) : e.addEventListener(t, r, !0) : i !== void 0 ? e.addEventListener(t, r, {
        passive: i
    }) : e.addEventListener(t, r, !1)
}

function gv(e, t, r, n, i) {
    var s = n;
    if (!(t & 1) && !(t & 2) && n !== null) e: for (;;) {
        if (n === null) return;
        var o = n.tag;
        if (o === 3 || o === 4) {
            var a = n.stateNode.containerInfo;
            if (a === i || a.nodeType === 8 && a.parentNode === i) break;
            if (o === 4)
                for (o = n.return; o !== null;) {
                    var l = o.tag;
                    if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return;
                    o = o.return
                }
            for (; a !== null;) {
                if (o = Js(a), o === null) return;
                if (l = o.tag, l === 5 || l === 6) {
                    n = s = o;
                    continue e
                }
                a = a.parentNode
            }
        }
        n = n.return
    }
    cA(function() {
        var c = s,
            u = c1(r),
            h = [];
        e: {
            var d = FA.get(e);
            if (d !== void 0) {
                var f = m1,
                    p = e;
                switch (e) {
                    case "keypress":
                        if (pd(r) === 0) break e;
                    case "keydown":
                    case "keyup":
                        f = FB;
                        break;
                    case "focusin":
                        p = "focus", f = cv;
                        break;
                    case "focusout":
                        p = "blur", f = cv;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        f = cv;
                        break;
                    case "click":
                        if (r.button === 2) break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        f = Ix;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        f = CB;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        f = jB;
                        break;
                    case MA:
                    case DA:
                    case NA:
                        f = AB;
                        break;
                    case LA:
                        f = HB;
                        break;
                    case "scroll":
                        f = SB;
                        break;
                    case "wheel":
                        f = VB;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        f = $B;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        f = Rx
                }
                var m = (t & 4) !== 0,
                    w = !m && e === "scroll",
                    y = m ? d !== null ? d + "Capture" : null : d;
                m = [];
                for (var v = c, _; v !== null;) {
                    _ = v;
                    var E = _.stateNode;
                    if (_.tag === 5 && E !== null && (_ = E, y !== null && (E = Dc(v, y), E != null && m.push(Uc(v, E, _)))), w) break;
                    v = v.return
                }
                0 < m.length && (d = new f(d, p, null, r, u), h.push({
                    event: d,
                    listeners: m
                }))
            }
        }
        if (!(t & 7)) {
            e: {
                if (d = e === "mouseover" || e === "pointerover", f = e === "mouseout" || e === "pointerout", d && r !== K0 && (p = r.relatedTarget || r.fromElement) && (Js(p) || p[Oi])) break e;
                if ((f || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : window, f ? (p = r.relatedTarget || r.toElement, f = c, p = p ? Js(p) : null, p !== null && (w = So(p), p !== w || p.tag !== 5 && p.tag !== 6) && (p = null)) : (f = null, p = c), f !== p)) {
                    if (m = Ix, E = "onMouseLeave", y = "onMouseEnter", v = "mouse", (e === "pointerout" || e === "pointerover") && (m = Rx, E = "onPointerLeave", y = "onPointerEnter", v = "pointer"), w = f == null ? d : wa(f), _ = p == null ? d : wa(p), d = new m(E, v + "leave", f, r, u), d.target = w, d.relatedTarget = _, E = null, Js(u) === c && (m = new m(y, v + "enter", p, r, u), m.target = _, m.relatedTarget = w, E = m), w = E, f && p) t: {
                        for (m = f, y = p, v = 0, _ = m; _; _ = Xo(_)) v++;
                        for (_ = 0, E = y; E; E = Xo(E)) _++;
                        for (; 0 < v - _;) m = Xo(m),
                        v--;
                        for (; 0 < _ - v;) y = Xo(y),
                        _--;
                        for (; v--;) {
                            if (m === y || y !== null && m === y.alternate) break t;
                            m = Xo(m), y = Xo(y)
                        }
                        m = null
                    }
                    else m = null;
                    f !== null && Hx(h, d, f, m, !1), p !== null && w !== null && Hx(h, w, p, m, !0)
                }
            }
            e: {
                if (d = c ? wa(c) : window, f = d.nodeName && d.nodeName.toLowerCase(), f === "select" || f === "input" && d.type === "file") var P = ZB;
                else if (Dx(d))
                    if (AA) P = r8;
                    else {
                        P = e8;
                        var C = JB
                    }
                else(f = d.nodeName) && f.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (P = t8);
                if (P && (P = P(e, c))) {
                    OA(h, P, r, u);
                    break e
                }
                C && C(e, d, c),
                e === "focusout" && (C = d._wrapperState) && C.controlled && d.type === "number" && G0(d, "number", d.value)
            }
            switch (C = c ? wa(c) : window, e) {
                case "focusin":
                    (Dx(C) || C.contentEditable === "true") && (ya = C, ry = c, _c = null);
                    break;
                case "focusout":
                    _c = ry = ya = null;
                    break;
                case "mousedown":
                    ny = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    ny = !1, zx(h, r, u);
                    break;
                case "selectionchange":
                    if (s8) break;
                case "keydown":
                case "keyup":
                    zx(h, r, u)
            }
            var T;
            if (v1) e: {
                switch (e) {
                    case "compositionstart":
                        var O = "onCompositionStart";
                        break e;
                    case "compositionend":
                        O = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        O = "onCompositionUpdate";
                        break e
                }
                O = void 0
            }
            else va ? CA(e, r) && (O = "onCompositionEnd") : e === "keydown" && r.keyCode === 229 && (O = "onCompositionStart");O && (PA && r.locale !== "ko" && (va || O !== "onCompositionStart" ? O === "onCompositionEnd" && va && (T = SA()) : (rs = u, p1 = "value" in rs ? rs.value : rs.textContent, va = !0)), C = Qd(c, O), 0 < C.length && (O = new $x(O, e, null, r, u), h.push({
                event: O,
                listeners: C
            }), T ? O.data = T : (T = TA(r), T !== null && (O.data = T)))),
            (T = XB ? YB(e, r) : KB(e, r)) && (c = Qd(c, "onBeforeInput"), 0 < c.length && (u = new $x("onBeforeInput", "beforeinput", null, r, u), h.push({
                event: u,
                listeners: c
            }), u.data = T))
        }
        BA(h, t)
    })
}

function Uc(e, t, r) {
    return {
        instance: e,
        listener: t,
        currentTarget: r
    }
}

function Qd(e, t) {
    for (var r = t + "Capture", n = []; e !== null;) {
        var i = e,
            s = i.stateNode;
        i.tag === 5 && s !== null && (i = s, s = Dc(e, r), s != null && n.unshift(Uc(e, s, i)), s = Dc(e, t), s != null && n.push(Uc(e, s, i))), e = e.return
    }
    return n
}

function Xo(e) {
    if (e === null) return null;
    do e = e.return; while (e && e.tag !== 5);
    return e || null
}

function Hx(e, t, r, n, i) {
    for (var s = t._reactName, o = []; r !== null && r !== n;) {
        var a = r,
            l = a.alternate,
            c = a.stateNode;
        if (l !== null && l === n) break;
        a.tag === 5 && c !== null && (a = c, i ? (l = Dc(r, s), l != null && o.unshift(Uc(r, l, a))) : i || (l = Dc(r, s), l != null && o.push(Uc(r, l, a)))), r = r.return
    }
    o.length !== 0 && e.push({
        event: t,
        listeners: o
    })
}
var c8 = /\r\n?/g,
    u8 = /\u0000|\uFFFD/g;

function Gx(e) {
    return (typeof e == "string" ? e : "" + e).replace(c8, `
`).replace(u8, "")
}

function ah(e, t, r) {
    if (t = Gx(t), Gx(e) !== t && r) throw Error(re(425))
}

function Zd() {}
var iy = null,
    sy = null;

function oy(e, t) {
    return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null
}
var ay = typeof setTimeout == "function" ? setTimeout : void 0,
    h8 = typeof clearTimeout == "function" ? clearTimeout : void 0,
    Vx = typeof Promise == "function" ? Promise : void 0,
    d8 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Vx < "u" ? function(e) {
        return Vx.resolve(null).then(e).catch(f8)
    } : ay;

function f8(e) {
    setTimeout(function() {
        throw e
    })
}

function vv(e, t) {
    var r = t,
        n = 0;
    do {
        var i = r.nextSibling;
        if (e.removeChild(r), i && i.nodeType === 8)
            if (r = i.data, r === "/$") {
                if (n === 0) {
                    e.removeChild(i), Fc(t);
                    return
                }
                n--
            } else r !== "$" && r !== "$?" && r !== "$!" || n++;
        r = i
    } while (r);
    Fc(t)
}

function ds(e) {
    for (; e != null; e = e.nextSibling) {
        var t = e.nodeType;
        if (t === 1 || t === 3) break;
        if (t === 8) {
            if (t = e.data, t === "$" || t === "$!" || t === "$?") break;
            if (t === "/$") return null
        }
    }
    return e
}

function Wx(e) {
    e = e.previousSibling;
    for (var t = 0; e;) {
        if (e.nodeType === 8) {
            var r = e.data;
            if (r === "$" || r === "$!" || r === "$?") {
                if (t === 0) return e;
                t--
            } else r === "/$" && t++
        }
        e = e.previousSibling
    }
    return null
}
var dl = Math.random().toString(36).slice(2),
    qn = "__reactFiber$" + dl,
    Hc = "__reactProps$" + dl,
    Oi = "__reactContainer$" + dl,
    ly = "__reactEvents$" + dl,
    p8 = "__reactListeners$" + dl,
    m8 = "__reactHandles$" + dl;

function Js(e) {
    var t = e[qn];
    if (t) return t;
    for (var r = e.parentNode; r;) {
        if (t = r[Oi] || r[qn]) {
            if (r = t.alternate, t.child !== null || r !== null && r.child !== null)
                for (e = Wx(e); e !== null;) {
                    if (r = e[qn]) return r;
                    e = Wx(e)
                }
            return t
        }
        e = r, r = e.parentNode
    }
    return null
}

function wu(e) {
    return e = e[qn] || e[Oi], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e
}

function wa(e) {
    if (e.tag === 5 || e.tag === 6) return e.stateNode;
    throw Error(re(33))
}

function _m(e) {
    return e[Hc] || null
}
var cy = [],
    ba = -1;

function As(e) {
    return {
        current: e
    }
}

function ht(e) {
    0 > ba || (e.current = cy[ba], cy[ba] = null, ba--)
}

function ct(e, t) {
    ba++, cy[ba] = e.current, e.current = t
}
var Es = {},
    dr = As(Es),
    Pr = As(!1),
    uo = Es;

function Xa(e, t) {
    var r = e.type.contextTypes;
    if (!r) return Es;
    var n = e.stateNode;
    if (n && n.__reactInternalMemoizedUnmaskedChildContext === t) return n.__reactInternalMemoizedMaskedChildContext;
    var i = {},
        s;
    for (s in r) i[s] = t[s];
    return n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i
}

function Cr(e) {
    return e = e.childContextTypes, e != null
}

function Jd() {
    ht(Pr), ht(dr)
}

function Xx(e, t, r) {
    if (dr.current !== Es) throw Error(re(168));
    ct(dr, t), ct(Pr, r)
}

function jA(e, t, r) {
    var n = e.stateNode;
    if (t = t.childContextTypes, typeof n.getChildContext != "function") return r;
    n = n.getChildContext();
    for (var i in n)
        if (!(i in t)) throw Error(re(108, JF(e) || "Unknown", i));
    return Et({}, r, n)
}

function ef(e) {
    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Es, uo = dr.current, ct(dr, e), ct(Pr, Pr.current), !0
}

function Yx(e, t, r) {
    var n = e.stateNode;
    if (!n) throw Error(re(169));
    r ? (e = jA(e, t, uo), n.__reactInternalMemoizedMergedChildContext = e, ht(Pr), ht(dr), ct(dr, e)) : ht(Pr), ct(Pr, r)
}
var vi = null,
    wm = !1,
    yv = !1;

function UA(e) {
    vi === null ? vi = [e] : vi.push(e)
}

function g8(e) {
    wm = !0, UA(e)
}

function Is() {
    if (!yv && vi !== null) {
        yv = !0;
        var e = 0,
            t = it;
        try {
            var r = vi;
            for (it = 1; e < r.length; e++) {
                var n = r[e];
                do n = n(!0); while (n !== null)
            }
            vi = null, wm = !1
        } catch (i) {
            throw vi !== null && (vi = vi.slice(e + 1)), fA(u1, Is), i
        } finally {
            it = t, yv = !1
        }
    }
    return null
}
var xa = [],
    Ea = 0,
    tf = null,
    rf = 0,
    Xr = [],
    Yr = 0,
    ho = null,
    _i = 1,
    wi = "";

function js(e, t) {
    xa[Ea++] = rf, xa[Ea++] = tf, tf = e, rf = t
}

function HA(e, t, r) {
    Xr[Yr++] = _i, Xr[Yr++] = wi, Xr[Yr++] = ho, ho = e;
    var n = _i;
    e = wi;
    var i = 32 - Cn(n) - 1;
    n &= ~(1 << i), r += 1;
    var s = 32 - Cn(t) + i;
    if (30 < s) {
        var o = i - i % 5;
        s = (n & (1 << o) - 1).toString(32), n >>= o, i -= o, _i = 1 << 32 - Cn(t) + i | r << i | n, wi = s + e
    } else _i = 1 << s | r << i | n, wi = e
}

function _1(e) {
    e.return !== null && (js(e, 1), HA(e, 1, 0))
}

function w1(e) {
    for (; e === tf;) tf = xa[--Ea], xa[Ea] = null, rf = xa[--Ea], xa[Ea] = null;
    for (; e === ho;) ho = Xr[--Yr], Xr[Yr] = null, wi = Xr[--Yr], Xr[Yr] = null, _i = Xr[--Yr], Xr[Yr] = null
}
var Fr = null,
    Mr = null,
    pt = !1,
    _n = null;

function GA(e, t) {
    var r = Zr(5, null, null, 0);
    r.elementType = "DELETED", r.stateNode = t, r.return = e, t = e.deletions, t === null ? (e.deletions = [r], e.flags |= 16) : t.push(r)
}

function Kx(e, t) {
    switch (e.tag) {
        case 5:
            var r = e.type;
            return t = t.nodeType !== 1 || r.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Fr = e, Mr = ds(t.firstChild), !0) : !1;
        case 6:
            return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Fr = e, Mr = null, !0) : !1;
        case 13:
            return t = t.nodeType !== 8 ? null : t, t !== null ? (r = ho !== null ? {
                id: _i,
                overflow: wi
            } : null, e.memoizedState = {
                dehydrated: t,
                treeContext: r,
                retryLane: 1073741824
            }, r = Zr(18, null, null, 0), r.stateNode = t, r.return = e, e.child = r, Fr = e, Mr = null, !0) : !1;
        default:
            return !1
    }
}

function uy(e) {
    return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}

function hy(e) {
    if (pt) {
        var t = Mr;
        if (t) {
            var r = t;
            if (!Kx(e, t)) {
                if (uy(e)) throw Error(re(418));
                t = ds(r.nextSibling);
                var n = Fr;
                t && Kx(e, t) ? GA(n, r) : (e.flags = e.flags & -4097 | 2, pt = !1, Fr = e)
            }
        } else {
            if (uy(e)) throw Error(re(418));
            e.flags = e.flags & -4097 | 2, pt = !1, Fr = e
        }
    }
}

function qx(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;) e = e.return;
    Fr = e
}

function lh(e) {
    if (e !== Fr) return !1;
    if (!pt) return qx(e), pt = !0, !1;
    var t;
    if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !oy(e.type, e.memoizedProps)), t && (t = Mr)) {
        if (uy(e)) throw VA(), Error(re(418));
        for (; t;) GA(e, t), t = ds(t.nextSibling)
    }
    if (qx(e), e.tag === 13) {
        if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(re(317));
        e: {
            for (e = e.nextSibling, t = 0; e;) {
                if (e.nodeType === 8) {
                    var r = e.data;
                    if (r === "/$") {
                        if (t === 0) {
                            Mr = ds(e.nextSibling);
                            break e
                        }
                        t--
                    } else r !== "$" && r !== "$!" && r !== "$?" || t++
                }
                e = e.nextSibling
            }
            Mr = null
        }
    } else Mr = Fr ? ds(e.stateNode.nextSibling) : null;
    return !0
}

function VA() {
    for (var e = Mr; e;) e = ds(e.nextSibling)
}

function Ya() {
    Mr = Fr = null, pt = !1
}

function b1(e) {
    _n === null ? _n = [e] : _n.push(e)
}
var v8 = Ri.ReactCurrentBatchConfig;

function gn(e, t) {
    if (e && e.defaultProps) {
        t = Et({}, t), e = e.defaultProps;
        for (var r in e) t[r] === void 0 && (t[r] = e[r]);
        return t
    }
    return t
}
var nf = As(null),
    sf = null,
    Sa = null,
    x1 = null;

function E1() {
    x1 = Sa = sf = null
}

function S1(e) {
    var t = nf.current;
    ht(nf), e._currentValue = t
}

function dy(e, t, r) {
    for (; e !== null;) {
        var n = e.alternate;
        if ((e.childLanes & t) !== t ? (e.childLanes |= t, n !== null && (n.childLanes |= t)) : n !== null && (n.childLanes & t) !== t && (n.childLanes |= t), e === r) break;
        e = e.return
    }
}

function ka(e, t) {
    sf = e, x1 = Sa = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Sr = !0), e.firstContext = null)
}

function rn(e) {
    var t = e._currentValue;
    if (x1 !== e)
        if (e = {
                context: e,
                memoizedValue: t,
                next: null
            }, Sa === null) {
            if (sf === null) throw Error(re(308));
            Sa = e, sf.dependencies = {
                lanes: 0,
                firstContext: e
            }
        } else Sa = Sa.next = e;
    return t
}
var eo = null;

function P1(e) {
    eo === null ? eo = [e] : eo.push(e)
}

function WA(e, t, r, n) {
    var i = t.interleaved;
    return i === null ? (r.next = r, P1(t)) : (r.next = i.next, i.next = r), t.interleaved = r, Ai(e, n)
}

function Ai(e, t) {
    e.lanes |= t;
    var r = e.alternate;
    for (r !== null && (r.lanes |= t), r = e, e = e.return; e !== null;) e.childLanes |= t, r = e.alternate, r !== null && (r.childLanes |= t), r = e, e = e.return;
    return r.tag === 3 ? r.stateNode : null
}
var Qi = !1;

function C1(e) {
    e.updateQueue = {
        baseState: e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}

function XA(e, t) {
    e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects
    })
}

function Ei(e, t) {
    return {
        eventTime: e,
        lane: t,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}

function fs(e, t, r) {
    var n = e.updateQueue;
    if (n === null) return null;
    if (n = n.shared, Ye & 2) {
        var i = n.pending;
        return i === null ? t.next = t : (t.next = i.next, i.next = t), n.pending = t, Ai(e, r)
    }
    return i = n.interleaved, i === null ? (t.next = t, P1(n)) : (t.next = i.next, i.next = t), n.interleaved = t, Ai(e, r)
}

function md(e, t, r) {
    if (t = t.updateQueue, t !== null && (t = t.shared, (r & 4194240) !== 0)) {
        var n = t.lanes;
        n &= e.pendingLanes, r |= n, t.lanes = r, h1(e, r)
    }
}

function Qx(e, t) {
    var r = e.updateQueue,
        n = e.alternate;
    if (n !== null && (n = n.updateQueue, r === n)) {
        var i = null,
            s = null;
        if (r = r.firstBaseUpdate, r !== null) {
            do {
                var o = {
                    eventTime: r.eventTime,
                    lane: r.lane,
                    tag: r.tag,
                    payload: r.payload,
                    callback: r.callback,
                    next: null
                };
                s === null ? i = s = o : s = s.next = o, r = r.next
            } while (r !== null);
            s === null ? i = s = t : s = s.next = t
        } else i = s = t;
        r = {
            baseState: n.baseState,
            firstBaseUpdate: i,
            lastBaseUpdate: s,
            shared: n.shared,
            effects: n.effects
        }, e.updateQueue = r;
        return
    }
    e = r.lastBaseUpdate, e === null ? r.firstBaseUpdate = t : e.next = t, r.lastBaseUpdate = t
}

function of (e, t, r, n) {
    var i = e.updateQueue;
    Qi = !1;
    var s = i.firstBaseUpdate,
        o = i.lastBaseUpdate,
        a = i.shared.pending;
    if (a !== null) {
        i.shared.pending = null;
        var l = a,
            c = l.next;
        l.next = null, o === null ? s = c : o.next = c, o = l;
        var u = e.alternate;
        u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== o && (a === null ? u.firstBaseUpdate = c : a.next = c, u.lastBaseUpdate = l))
    }
    if (s !== null) {
        var h = i.baseState;
        o = 0, u = c = l = null, a = s;
        do {
            var d = a.lane,
                f = a.eventTime;
            if ((n & d) === d) {
                u !== null && (u = u.next = {
                    eventTime: f,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var p = e,
                        m = a;
                    switch (d = t, f = r, m.tag) {
                        case 1:
                            if (p = m.payload, typeof p == "function") {
                                h = p.call(f, h, d);
                                break e
                            }
                            h = p;
                            break e;
                        case 3:
                            p.flags = p.flags & -65537 | 128;
                        case 0:
                            if (p = m.payload, d = typeof p == "function" ? p.call(f, h, d) : p, d == null) break e;
                            h = Et({}, h, d);
                            break e;
                        case 2:
                            Qi = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (e.flags |= 64, d = i.effects, d === null ? i.effects = [a] : d.push(a))
            } else f = {
                eventTime: f,
                lane: d,
                tag: a.tag,
                payload: a.payload,
                callback: a.callback,
                next: null
            }, u === null ? (c = u = f, l = h) : u = u.next = f, o |= d;
            if (a = a.next, a === null) {
                if (a = i.shared.pending, a === null) break;
                d = a, a = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null
            }
        } while (1);
        if (u === null && (l = h), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, t = i.shared.interleaved, t !== null) {
            i = t;
            do o |= i.lane, i = i.next; while (i !== t)
        } else s === null && (i.shared.lanes = 0);
        po |= o, e.lanes = o, e.memoizedState = h
    }
}

function Zx(e, t, r) {
    if (e = t.effects, t.effects = null, e !== null)
        for (t = 0; t < e.length; t++) {
            var n = e[t],
                i = n.callback;
            if (i !== null) {
                if (n.callback = null, n = r, typeof i != "function") throw Error(re(191, i));
                i.call(n)
            }
        }
}
var YA = new WO.Component().refs;

function fy(e, t, r, n) {
    t = e.memoizedState, r = r(n, t), r = r == null ? t : Et({}, t, r), e.memoizedState = r, e.lanes === 0 && (e.updateQueue.baseState = r)
}
var bm = {
    isMounted: function(e) {
        return (e = e._reactInternals) ? So(e) === e : !1
    },
    enqueueSetState: function(e, t, r) {
        e = e._reactInternals;
        var n = mr(),
            i = ms(e),
            s = Ei(n, i);
        s.payload = t, r != null && (s.callback = r), t = fs(e, s, i), t !== null && (Tn(t, e, i, n), md(t, e, i))
    },
    enqueueReplaceState: function(e, t, r) {
        e = e._reactInternals;
        var n = mr(),
            i = ms(e),
            s = Ei(n, i);
        s.tag = 1, s.payload = t, r != null && (s.callback = r), t = fs(e, s, i), t !== null && (Tn(t, e, i, n), md(t, e, i))
    },
    enqueueForceUpdate: function(e, t) {
        e = e._reactInternals;
        var r = mr(),
            n = ms(e),
            i = Ei(r, n);
        i.tag = 2, t != null && (i.callback = t), t = fs(e, i, n), t !== null && (Tn(t, e, n, r), md(t, e, n))
    }
};

function Jx(e, t, r, n, i, s, o) {
    return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(n, s, o) : t.prototype && t.prototype.isPureReactComponent ? !zc(r, n) || !zc(i, s) : !0
}

function KA(e, t, r) {
    var n = !1,
        i = Es,
        s = t.contextType;
    return typeof s == "object" && s !== null ? s = rn(s) : (i = Cr(t) ? uo : dr.current, n = t.contextTypes, s = (n = n != null) ? Xa(e, i) : Es), t = new t(r, s), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = bm, e.stateNode = t, t._reactInternals = e, n && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t
}

function eE(e, t, r, n) {
    e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(r, n), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(r, n), t.state !== e && bm.enqueueReplaceState(t, t.state, null)
}

function py(e, t, r, n) {
    var i = e.stateNode;
    i.props = r, i.state = e.memoizedState, i.refs = YA, C1(e);
    var s = t.contextType;
    typeof s == "object" && s !== null ? i.context = rn(s) : (s = Cr(t) ? uo : dr.current, i.context = Xa(e, s)), i.state = e.memoizedState, s = t.getDerivedStateFromProps, typeof s == "function" && (fy(e, t, s, r), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && bm.enqueueReplaceState(i, i.state, null), of (e, r, i, n), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308)
}

function Ll(e, t, r) {
    if (e = r.ref, e !== null && typeof e != "function" && typeof e != "object") {
        if (r._owner) {
            if (r = r._owner, r) {
                if (r.tag !== 1) throw Error(re(309));
                var n = r.stateNode
            }
            if (!n) throw Error(re(147, e));
            var i = n,
                s = "" + e;
            return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function(o) {
                var a = i.refs;
                a === YA && (a = i.refs = {}), o === null ? delete a[s] : a[s] = o
            }, t._stringRef = s, t)
        }
        if (typeof e != "string") throw Error(re(284));
        if (!r._owner) throw Error(re(290, e))
    }
    return e
}

function ch(e, t) {
    throw e = Object.prototype.toString.call(t), Error(re(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
}

function tE(e) {
    var t = e._init;
    return t(e._payload)
}

function qA(e) {
    function t(y, v) {
        if (e) {
            var _ = y.deletions;
            _ === null ? (y.deletions = [v], y.flags |= 16) : _.push(v)
        }
    }

    function r(y, v) {
        if (!e) return null;
        for (; v !== null;) t(y, v), v = v.sibling;
        return null
    }

    function n(y, v) {
        for (y = new Map; v !== null;) v.key !== null ? y.set(v.key, v) : y.set(v.index, v), v = v.sibling;
        return y
    }

    function i(y, v) {
        return y = gs(y, v), y.index = 0, y.sibling = null, y
    }

    function s(y, v, _) {
        return y.index = _, e ? (_ = y.alternate, _ !== null ? (_ = _.index, _ < v ? (y.flags |= 2, v) : _) : (y.flags |= 2, v)) : (y.flags |= 1048576, v)
    }

    function o(y) {
        return e && y.alternate === null && (y.flags |= 2), y
    }

    function a(y, v, _, E) {
        return v === null || v.tag !== 6 ? (v = Pv(_, y.mode, E), v.return = y, v) : (v = i(v, _), v.return = y, v)
    }

    function l(y, v, _, E) {
        var P = _.type;
        return P === ga ? u(y, v, _.props.children, E, _.key) : v !== null && (v.elementType === P || typeof P == "object" && P !== null && P.$$typeof === qi && tE(P) === v.type) ? (E = i(v, _.props), E.ref = Ll(y, v, _), E.return = y, E) : (E = bd(_.type, _.key, _.props, null, y.mode, E), E.ref = Ll(y, v, _), E.return = y, E)
    }

    function c(y, v, _, E) {
        return v === null || v.tag !== 4 || v.stateNode.containerInfo !== _.containerInfo || v.stateNode.implementation !== _.implementation ? (v = Cv(_, y.mode, E), v.return = y, v) : (v = i(v, _.children || []), v.return = y, v)
    }

    function u(y, v, _, E, P) {
        return v === null || v.tag !== 7 ? (v = so(_, y.mode, E, P), v.return = y, v) : (v = i(v, _), v.return = y, v)
    }

    function h(y, v, _) {
        if (typeof v == "string" && v !== "" || typeof v == "number") return v = Pv("" + v, y.mode, _), v.return = y, v;
        if (typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
                case Zu:
                    return _ = bd(v.type, v.key, v.props, null, y.mode, _), _.ref = Ll(y, null, v), _.return = y, _;
                case ma:
                    return v = Cv(v, y.mode, _), v.return = y, v;
                case qi:
                    var E = v._init;
                    return h(y, E(v._payload), _)
            }
            if (sc(v) || Rl(v)) return v = so(v, y.mode, _, null), v.return = y, v;
            ch(y, v)
        }
        return null
    }

    function d(y, v, _, E) {
        var P = v !== null ? v.key : null;
        if (typeof _ == "string" && _ !== "" || typeof _ == "number") return P !== null ? null : a(y, v, "" + _, E);
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
                case Zu:
                    return _.key === P ? l(y, v, _, E) : null;
                case ma:
                    return _.key === P ? c(y, v, _, E) : null;
                case qi:
                    return P = _._init, d(y, v, P(_._payload), E)
            }
            if (sc(_) || Rl(_)) return P !== null ? null : u(y, v, _, E, null);
            ch(y, _)
        }
        return null
    }

    function f(y, v, _, E, P) {
        if (typeof E == "string" && E !== "" || typeof E == "number") return y = y.get(_) || null, a(v, y, "" + E, P);
        if (typeof E == "object" && E !== null) {
            switch (E.$$typeof) {
                case Zu:
                    return y = y.get(E.key === null ? _ : E.key) || null, l(v, y, E, P);
                case ma:
                    return y = y.get(E.key === null ? _ : E.key) || null, c(v, y, E, P);
                case qi:
                    var C = E._init;
                    return f(y, v, _, C(E._payload), P)
            }
            if (sc(E) || Rl(E)) return y = y.get(_) || null, u(v, y, E, P, null);
            ch(v, E)
        }
        return null
    }

    function p(y, v, _, E) {
        for (var P = null, C = null, T = v, O = v = 0, k = null; T !== null && O < _.length; O++) {
            T.index > O ? (k = T, T = null) : k = T.sibling;
            var D = d(y, T, _[O], E);
            if (D === null) {
                T === null && (T = k);
                break
            }
            e && T && D.alternate === null && t(y, T), v = s(D, v, O), C === null ? P = D : C.sibling = D, C = D, T = k
        }
        if (O === _.length) return r(y, T), pt && js(y, O), P;
        if (T === null) {
            for (; O < _.length; O++) T = h(y, _[O], E), T !== null && (v = s(T, v, O), C === null ? P = T : C.sibling = T, C = T);
            return pt && js(y, O), P
        }
        for (T = n(y, T); O < _.length; O++) k = f(T, y, O, _[O], E), k !== null && (e && k.alternate !== null && T.delete(k.key === null ? O : k.key), v = s(k, v, O), C === null ? P = k : C.sibling = k, C = k);
        return e && T.forEach(function(B) {
            return t(y, B)
        }), pt && js(y, O), P
    }

    function m(y, v, _, E) {
        var P = Rl(_);
        if (typeof P != "function") throw Error(re(150));
        if (_ = P.call(_), _ == null) throw Error(re(151));
        for (var C = P = null, T = v, O = v = 0, k = null, D = _.next(); T !== null && !D.done; O++, D = _.next()) {
            T.index > O ? (k = T, T = null) : k = T.sibling;
            var B = d(y, T, D.value, E);
            if (B === null) {
                T === null && (T = k);
                break
            }
            e && T && B.alternate === null && t(y, T), v = s(B, v, O), C === null ? P = B : C.sibling = B, C = B, T = k
        }
        if (D.done) return r(y, T), pt && js(y, O), P;
        if (T === null) {
            for (; !D.done; O++, D = _.next()) D = h(y, D.value, E), D !== null && (v = s(D, v, O), C === null ? P = D : C.sibling = D, C = D);
            return pt && js(y, O), P
        }
        for (T = n(y, T); !D.done; O++, D = _.next()) D = f(T, y, O, D.value, E), D !== null && (e && D.alternate !== null && T.delete(D.key === null ? O : D.key), v = s(D, v, O), C === null ? P = D : C.sibling = D, C = D);
        return e && T.forEach(function(j) {
            return t(y, j)
        }), pt && js(y, O), P
    }

    function w(y, v, _, E) {
        if (typeof _ == "object" && _ !== null && _.type === ga && _.key === null && (_ = _.props.children), typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
                case Zu:
                    e: {
                        for (var P = _.key, C = v; C !== null;) {
                            if (C.key === P) {
                                if (P = _.type, P === ga) {
                                    if (C.tag === 7) {
                                        r(y, C.sibling), v = i(C, _.props.children), v.return = y, y = v;
                                        break e
                                    }
                                } else if (C.elementType === P || typeof P == "object" && P !== null && P.$$typeof === qi && tE(P) === C.type) {
                                    r(y, C.sibling), v = i(C, _.props), v.ref = Ll(y, C, _), v.return = y, y = v;
                                    break e
                                }
                                r(y, C);
                                break
                            } else t(y, C);
                            C = C.sibling
                        }
                        _.type === ga ? (v = so(_.props.children, y.mode, E, _.key), v.return = y, y = v) : (E = bd(_.type, _.key, _.props, null, y.mode, E), E.ref = Ll(y, v, _), E.return = y, y = E)
                    }
                    return o(y);
                case ma:
                    e: {
                        for (C = _.key; v !== null;) {
                            if (v.key === C)
                                if (v.tag === 4 && v.stateNode.containerInfo === _.containerInfo && v.stateNode.implementation === _.implementation) {
                                    r(y, v.sibling), v = i(v, _.children || []), v.return = y, y = v;
                                    break e
                                } else {
                                    r(y, v);
                                    break
                                }
                            else t(y, v);
                            v = v.sibling
                        }
                        v = Cv(_, y.mode, E),
                        v.return = y,
                        y = v
                    }
                    return o(y);
                case qi:
                    return C = _._init, w(y, v, C(_._payload), E)
            }
            if (sc(_)) return p(y, v, _, E);
            if (Rl(_)) return m(y, v, _, E);
            ch(y, _)
        }
        return typeof _ == "string" && _ !== "" || typeof _ == "number" ? (_ = "" + _, v !== null && v.tag === 6 ? (r(y, v.sibling), v = i(v, _), v.return = y, y = v) : (r(y, v), v = Pv(_, y.mode, E), v.return = y, y = v), o(y)) : r(y, v)
    }
    return w
}
var Ka = qA(!0),
    QA = qA(!1),
    bu = {},
    ti = As(bu),
    Gc = As(bu),
    Vc = As(bu);

function to(e) {
    if (e === bu) throw Error(re(174));
    return e
}

function T1(e, t) {
    switch (ct(Vc, t), ct(Gc, e), ct(ti, bu), e = t.nodeType, e) {
        case 9:
        case 11:
            t = (t = t.documentElement) ? t.namespaceURI : W0(null, "");
            break;
        default:
            e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = W0(t, e)
    }
    ht(ti), ct(ti, t)
}

function qa() {
    ht(ti), ht(Gc), ht(Vc)
}

function ZA(e) {
    to(Vc.current);
    var t = to(ti.current),
        r = W0(t, e.type);
    t !== r && (ct(Gc, e), ct(ti, r))
}

function O1(e) {
    Gc.current === e && (ht(ti), ht(Gc))
}
var _t = As(0);

function af(e) {
    for (var t = e; t !== null;) {
        if (t.tag === 13) {
            var r = t.memoizedState;
            if (r !== null && (r = r.dehydrated, r === null || r.data === "$?" || r.data === "$!")) return t
        } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
            if (t.flags & 128) return t
        } else if (t.child !== null) {
            t.child.return = t, t = t.child;
            continue
        }
        if (t === e) break;
        for (; t.sibling === null;) {
            if (t.return === null || t.return === e) return null;
            t = t.return
        }
        t.sibling.return = t.return, t = t.sibling
    }
    return null
}
var _v = [];

function A1() {
    for (var e = 0; e < _v.length; e++) _v[e]._workInProgressVersionPrimary = null;
    _v.length = 0
}
var gd = Ri.ReactCurrentDispatcher,
    wv = Ri.ReactCurrentBatchConfig,
    fo = 0,
    xt = null,
    Ft = null,
    Ht = null,
    lf = !1,
    wc = !1,
    Wc = 0,
    y8 = 0;

function ar() {
    throw Error(re(321))
}

function I1(e, t) {
    if (t === null) return !1;
    for (var r = 0; r < t.length && r < e.length; r++)
        if (!kn(e[r], t[r])) return !1;
    return !0
}

function $1(e, t, r, n, i, s) {
    if (fo = s, xt = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, gd.current = e === null || e.memoizedState === null ? x8 : E8, e = r(n, i), wc) {
        s = 0;
        do {
            if (wc = !1, Wc = 0, 25 <= s) throw Error(re(301));
            s += 1, Ht = Ft = null, t.updateQueue = null, gd.current = S8, e = r(n, i)
        } while (wc)
    }
    if (gd.current = cf, t = Ft !== null && Ft.next !== null, fo = 0, Ht = Ft = xt = null, lf = !1, t) throw Error(re(300));
    return e
}

function R1() {
    var e = Wc !== 0;
    return Wc = 0, e
}

function Hn() {
    var e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Ht === null ? xt.memoizedState = Ht = e : Ht = Ht.next = e, Ht
}

function nn() {
    if (Ft === null) {
        var e = xt.alternate;
        e = e !== null ? e.memoizedState : null
    } else e = Ft.next;
    var t = Ht === null ? xt.memoizedState : Ht.next;
    if (t !== null) Ht = t, Ft = e;
    else {
        if (e === null) throw Error(re(310));
        Ft = e, e = {
            memoizedState: Ft.memoizedState,
            baseState: Ft.baseState,
            baseQueue: Ft.baseQueue,
            queue: Ft.queue,
            next: null
        }, Ht === null ? xt.memoizedState = Ht = e : Ht = Ht.next = e
    }
    return Ht
}

function Xc(e, t) {
    return typeof t == "function" ? t(e) : t
}

function bv(e) {
    var t = nn(),
        r = t.queue;
    if (r === null) throw Error(re(311));
    r.lastRenderedReducer = e;
    var n = Ft,
        i = n.baseQueue,
        s = r.pending;
    if (s !== null) {
        if (i !== null) {
            var o = i.next;
            i.next = s.next, s.next = o
        }
        n.baseQueue = i = s, r.pending = null
    }
    if (i !== null) {
        s = i.next, n = n.baseState;
        var a = o = null,
            l = null,
            c = s;
        do {
            var u = c.lane;
            if ((fo & u) === u) l !== null && (l = l.next = {
                lane: 0,
                action: c.action,
                hasEagerState: c.hasEagerState,
                eagerState: c.eagerState,
                next: null
            }), n = c.hasEagerState ? c.eagerState : e(n, c.action);
            else {
                var h = {
                    lane: u,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = h, o = n) : l = l.next = h, xt.lanes |= u, po |= u
            }
            c = c.next
        } while (c !== null && c !== s);
        l === null ? o = n : l.next = a, kn(n, t.memoizedState) || (Sr = !0), t.memoizedState = n, t.baseState = o, t.baseQueue = l, r.lastRenderedState = n
    }
    if (e = r.interleaved, e !== null) {
        i = e;
        do s = i.lane, xt.lanes |= s, po |= s, i = i.next; while (i !== e)
    } else i === null && (r.lanes = 0);
    return [t.memoizedState, r.dispatch]
}

function xv(e) {
    var t = nn(),
        r = t.queue;
    if (r === null) throw Error(re(311));
    r.lastRenderedReducer = e;
    var n = r.dispatch,
        i = r.pending,
        s = t.memoizedState;
    if (i !== null) {
        r.pending = null;
        var o = i = i.next;
        do s = e(s, o.action), o = o.next; while (o !== i);
        kn(s, t.memoizedState) || (Sr = !0), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), r.lastRenderedState = s
    }
    return [s, n]
}

function JA() {}

function eI(e, t) {
    var r = xt,
        n = nn(),
        i = t(),
        s = !kn(n.memoizedState, i);
    if (s && (n.memoizedState = i, Sr = !0), n = n.queue, k1(nI.bind(null, r, n, e), [e]), n.getSnapshot !== t || s || Ht !== null && Ht.memoizedState.tag & 1) {
        if (r.flags |= 2048, Yc(9, rI.bind(null, r, n, i, t), void 0, null), Vt === null) throw Error(re(349));
        fo & 30 || tI(r, t, i)
    }
    return i
}

function tI(e, t, r) {
    e.flags |= 16384, e = {
        getSnapshot: t,
        value: r
    }, t = xt.updateQueue, t === null ? (t = {
        lastEffect: null,
        stores: null
    }, xt.updateQueue = t, t.stores = [e]) : (r = t.stores, r === null ? t.stores = [e] : r.push(e))
}

function rI(e, t, r, n) {
    t.value = r, t.getSnapshot = n, iI(t) && sI(e)
}

function nI(e, t, r) {
    return r(function() {
        iI(t) && sI(e)
    })
}

function iI(e) {
    var t = e.getSnapshot;
    e = e.value;
    try {
        var r = t();
        return !kn(e, r)
    } catch {
        return !0
    }
}

function sI(e) {
    var t = Ai(e, 1);
    t !== null && Tn(t, e, 1, -1)
}

function rE(e) {
    var t = Hn();
    return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Xc,
        lastRenderedState: e
    }, t.queue = e, e = e.dispatch = b8.bind(null, xt, e), [t.memoizedState, e]
}

function Yc(e, t, r, n) {
    return e = {
        tag: e,
        create: t,
        destroy: r,
        deps: n,
        next: null
    }, t = xt.updateQueue, t === null ? (t = {
        lastEffect: null,
        stores: null
    }, xt.updateQueue = t, t.lastEffect = e.next = e) : (r = t.lastEffect, r === null ? t.lastEffect = e.next = e : (n = r.next, r.next = e, e.next = n, t.lastEffect = e)), e
}

function oI() {
    return nn().memoizedState
}

function vd(e, t, r, n) {
    var i = Hn();
    xt.flags |= e, i.memoizedState = Yc(1 | t, r, void 0, n === void 0 ? null : n)
}

function xm(e, t, r, n) {
    var i = nn();
    n = n === void 0 ? null : n;
    var s = void 0;
    if (Ft !== null) {
        var o = Ft.memoizedState;
        if (s = o.destroy, n !== null && I1(n, o.deps)) {
            i.memoizedState = Yc(t, r, s, n);
            return
        }
    }
    xt.flags |= e, i.memoizedState = Yc(1 | t, r, s, n)
}

function nE(e, t) {
    return vd(8390656, 8, e, t)
}

function k1(e, t) {
    return xm(2048, 8, e, t)
}

function aI(e, t) {
    return xm(4, 2, e, t)
}

function lI(e, t) {
    return xm(4, 4, e, t)
}

function cI(e, t) {
    if (typeof t == "function") return e = e(), t(e),
        function() {
            t(null)
        };
    if (t != null) return e = e(), t.current = e,
        function() {
            t.current = null
        }
}

function uI(e, t, r) {
    return r = r != null ? r.concat([e]) : null, xm(4, 4, cI.bind(null, t, e), r)
}

function M1() {}

function hI(e, t) {
    var r = nn();
    t = t === void 0 ? null : t;
    var n = r.memoizedState;
    return n !== null && t !== null && I1(t, n[1]) ? n[0] : (r.memoizedState = [e, t], e)
}

function dI(e, t) {
    var r = nn();
    t = t === void 0 ? null : t;
    var n = r.memoizedState;
    return n !== null && t !== null && I1(t, n[1]) ? n[0] : (e = e(), r.memoizedState = [e, t], e)
}

function fI(e, t, r) {
    return fo & 21 ? (kn(r, t) || (r = gA(), xt.lanes |= r, po |= r, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Sr = !0), e.memoizedState = r)
}

function _8(e, t) {
    var r = it;
    it = r !== 0 && 4 > r ? r : 4, e(!0);
    var n = wv.transition;
    wv.transition = {};
    try {
        e(!1), t()
    } finally {
        it = r, wv.transition = n
    }
}

function pI() {
    return nn().memoizedState
}

function w8(e, t, r) {
    var n = ms(e);
    if (r = {
            lane: n,
            action: r,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, mI(e)) gI(t, r);
    else if (r = WA(e, t, r, n), r !== null) {
        var i = mr();
        Tn(r, e, n, i), vI(r, t, n)
    }
}

function b8(e, t, r) {
    var n = ms(e),
        i = {
            lane: n,
            action: r,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
    if (mI(e)) gI(t, i);
    else {
        var s = e.alternate;
        if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer, s !== null)) try {
            var o = t.lastRenderedState,
                a = s(o, r);
            if (i.hasEagerState = !0, i.eagerState = a, kn(a, o)) {
                var l = t.interleaved;
                l === null ? (i.next = i, P1(t)) : (i.next = l.next, l.next = i), t.interleaved = i;
                return
            }
        } catch {} finally {}
        r = WA(e, t, i, n), r !== null && (i = mr(), Tn(r, e, n, i), vI(r, t, n))
    }
}

function mI(e) {
    var t = e.alternate;
    return e === xt || t !== null && t === xt
}

function gI(e, t) {
    wc = lf = !0;
    var r = e.pending;
    r === null ? t.next = t : (t.next = r.next, r.next = t), e.pending = t
}

function vI(e, t, r) {
    if (r & 4194240) {
        var n = t.lanes;
        n &= e.pendingLanes, r |= n, t.lanes = r, h1(e, r)
    }
}
var cf = {
        readContext: rn,
        useCallback: ar,
        useContext: ar,
        useEffect: ar,
        useImperativeHandle: ar,
        useInsertionEffect: ar,
        useLayoutEffect: ar,
        useMemo: ar,
        useReducer: ar,
        useRef: ar,
        useState: ar,
        useDebugValue: ar,
        useDeferredValue: ar,
        useTransition: ar,
        useMutableSource: ar,
        useSyncExternalStore: ar,
        useId: ar,
        unstable_isNewReconciler: !1
    },
    x8 = {
        readContext: rn,
        useCallback: function(e, t) {
            return Hn().memoizedState = [e, t === void 0 ? null : t], e
        },
        useContext: rn,
        useEffect: nE,
        useImperativeHandle: function(e, t, r) {
            return r = r != null ? r.concat([e]) : null, vd(4194308, 4, cI.bind(null, t, e), r)
        },
        useLayoutEffect: function(e, t) {
            return vd(4194308, 4, e, t)
        },
        useInsertionEffect: function(e, t) {
            return vd(4, 2, e, t)
        },
        useMemo: function(e, t) {
            var r = Hn();
            return t = t === void 0 ? null : t, e = e(), r.memoizedState = [e, t], e
        },
        useReducer: function(e, t, r) {
            var n = Hn();
            return t = r !== void 0 ? r(t) : t, n.memoizedState = n.baseState = t, e = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: e,
                lastRenderedState: t
            }, n.queue = e, e = e.dispatch = w8.bind(null, xt, e), [n.memoizedState, e]
        },
        useRef: function(e) {
            var t = Hn();
            return e = {
                current: e
            }, t.memoizedState = e
        },
        useState: rE,
        useDebugValue: M1,
        useDeferredValue: function(e) {
            return Hn().memoizedState = e
        },
        useTransition: function() {
            var e = rE(!1),
                t = e[0];
            return e = _8.bind(null, e[1]), Hn().memoizedState = e, [t, e]
        },
        useMutableSource: function() {},
        useSyncExternalStore: function(e, t, r) {
            var n = xt,
                i = Hn();
            if (pt) {
                if (r === void 0) throw Error(re(407));
                r = r()
            } else {
                if (r = t(), Vt === null) throw Error(re(349));
                fo & 30 || tI(n, t, r)
            }
            i.memoizedState = r;
            var s = {
                value: r,
                getSnapshot: t
            };
            return i.queue = s, nE(nI.bind(null, n, s, e), [e]), n.flags |= 2048, Yc(9, rI.bind(null, n, s, r, t), void 0, null), r
        },
        useId: function() {
            var e = Hn(),
                t = Vt.identifierPrefix;
            if (pt) {
                var r = wi,
                    n = _i;
                r = (n & ~(1 << 32 - Cn(n) - 1)).toString(32) + r, t = ":" + t + "R" + r, r = Wc++, 0 < r && (t += "H" + r.toString(32)), t += ":"
            } else r = y8++, t = ":" + t + "r" + r.toString(32) + ":";
            return e.memoizedState = t
        },
        unstable_isNewReconciler: !1
    },
    E8 = {
        readContext: rn,
        useCallback: hI,
        useContext: rn,
        useEffect: k1,
        useImperativeHandle: uI,
        useInsertionEffect: aI,
        useLayoutEffect: lI,
        useMemo: dI,
        useReducer: bv,
        useRef: oI,
        useState: function() {
            return bv(Xc)
        },
        useDebugValue: M1,
        useDeferredValue: function(e) {
            var t = nn();
            return fI(t, Ft.memoizedState, e)
        },
        useTransition: function() {
            var e = bv(Xc)[0],
                t = nn().memoizedState;
            return [e, t]
        },
        useMutableSource: JA,
        useSyncExternalStore: eI,
        useId: pI,
        unstable_isNewReconciler: !1
    },
    S8 = {
        readContext: rn,
        useCallback: hI,
        useContext: rn,
        useEffect: k1,
        useImperativeHandle: uI,
        useInsertionEffect: aI,
        useLayoutEffect: lI,
        useMemo: dI,
        useReducer: xv,
        useRef: oI,
        useState: function() {
            return xv(Xc)
        },
        useDebugValue: M1,
        useDeferredValue: function(e) {
            var t = nn();
            return Ft === null ? t.memoizedState = e : fI(t, Ft.memoizedState, e)
        },
        useTransition: function() {
            var e = xv(Xc)[0],
                t = nn().memoizedState;
            return [e, t]
        },
        useMutableSource: JA,
        useSyncExternalStore: eI,
        useId: pI,
        unstable_isNewReconciler: !1
    };

function Qa(e, t) {
    try {
        var r = "",
            n = t;
        do r += ZF(n), n = n.return; while (n);
        var i = r
    } catch (s) {
        i = `
Error generating stack: ` + s.message + `
` + s.stack
    }
    return {
        value: e,
        source: t,
        stack: i,
        digest: null
    }
}

function Ev(e, t, r) {
    return {
        value: e,
        source: null,
        stack: r??null,
        digest: t??null
    }
}

function my(e, t) {
    try {
        console.error(t.value)
    } catch (r) {
        setTimeout(function() {
            throw r
        })
    }
}
var P8 = typeof WeakMap == "function" ? WeakMap : Map;

function yI(e, t, r) {
    r = Ei(-1, r), r.tag = 3, r.payload = {
        element: null
    };
    var n = t.value;
    return r.callback = function() {
        hf || (hf = !0, Py = n), my(e, t)
    }, r
}

function _I(e, t, r) {
    r = Ei(-1, r), r.tag = 3;
    var n = e.type.getDerivedStateFromError;
    if (typeof n == "function") {
        var i = t.value;
        r.payload = function() {
            return n(i)
        }, r.callback = function() {
            my(e, t)
        }
    }
    var s = e.stateNode;
    return s !== null && typeof s.componentDidCatch == "function" && (r.callback = function() {
        my(e, t), typeof n != "function" && (ps === null ? ps = new Set([this]) : ps.add(this));
        var o = t.stack;
        this.componentDidCatch(t.value, {
            componentStack: o !== null ? o : ""
        })
    }), r
}

function iE(e, t, r) {
    var n = e.pingCache;
    if (n === null) {
        n = e.pingCache = new P8;
        var i = new Set;
        n.set(t, i)
    } else i = n.get(t), i === void 0 && (i = new Set, n.set(t, i));
    i.has(r) || (i.add(r), e = B8.bind(null, e, t, r), t.then(e, e))
}

function sE(e) {
    do {
        var t;
        if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e;
        e = e.return
    } while (e !== null);
    return null
}

function oE(e, t, r, n, i) {
    return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, r.flags |= 131072, r.flags &= -52805, r.tag === 1 && (r.alternate === null ? r.tag = 17 : (t = Ei(-1, 1), t.tag = 2, fs(r, t, 1))), r.lanes |= 1), e)
}
var C8 = Ri.ReactCurrentOwner,
    Sr = !1;

function pr(e, t, r, n) {
    t.child = e === null ? QA(t, null, r, n) : Ka(t, e.child, r, n)
}

function aE(e, t, r, n, i) {
    r = r.render;
    var s = t.ref;
    return ka(t, i), n = $1(e, t, r, n, s, i), r = R1(), e !== null && !Sr ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ii(e, t, i)) : (pt && r && _1(t), t.flags |= 1, pr(e, t, n, i), t.child)
}

function lE(e, t, r, n, i) {
    if (e === null) {
        var s = r.type;
        return typeof s == "function" && !U1(s) && s.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (t.tag = 15, t.type = s, wI(e, t, s, n, i)) : (e = bd(r.type, null, n, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e)
    }
    if (s = e.child, !(e.lanes & i)) {
        var o = s.memoizedProps;
        if (r = r.compare, r = r !== null ? r : zc, r(o, n) && e.ref === t.ref) return Ii(e, t, i)
    }
    return t.flags |= 1, e = gs(s, n), e.ref = t.ref, e.return = t, t.child = e
}

function wI(e, t, r, n, i) {
    if (e !== null) {
        var s = e.memoizedProps;
        if (zc(s, n) && e.ref === t.ref)
            if (Sr = !1, t.pendingProps = n = s, (e.lanes & i) !== 0) e.flags & 131072 && (Sr = !0);
            else return t.lanes = e.lanes, Ii(e, t, i)
    }
    return gy(e, t, r, n, i)
}

function bI(e, t, r) {
    var n = t.pendingProps,
        i = n.children,
        s = e !== null ? e.memoizedState : null;
    if (n.mode === "hidden")
        if (!(t.mode & 1)) t.memoizedState = {
            baseLanes: 0,
            cachePool: null,
            transitions: null
        }, ct(Ca, kr), kr |= r;
        else {
            if (!(r & 1073741824)) return e = s !== null ? s.baseLanes | r : r, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
                baseLanes: e,
                cachePool: null,
                transitions: null
            }, t.updateQueue = null, ct(Ca, kr), kr |= e, null;
            t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, n = s !== null ? s.baseLanes : r, ct(Ca, kr), kr |= n
        }
    else s !== null ? (n = s.baseLanes | r, t.memoizedState = null) : n = r, ct(Ca, kr), kr |= n;
    return pr(e, t, i, r), t.child
}

function xI(e, t) {
    var r = t.ref;
    (e === null && r !== null || e !== null && e.ref !== r) && (t.flags |= 512, t.flags |= 2097152)
}

function gy(e, t, r, n, i) {
    var s = Cr(r) ? uo : dr.current;
    return s = Xa(t, s), ka(t, i), r = $1(e, t, r, n, s, i), n = R1(), e !== null && !Sr ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ii(e, t, i)) : (pt && n && _1(t), t.flags |= 1, pr(e, t, r, i), t.child)
}

function cE(e, t, r, n, i) {
    if (Cr(r)) {
        var s = !0;
        ef(t)
    } else s = !1;
    if (ka(t, i), t.stateNode === null) yd(e, t), KA(t, r, n), py(t, r, n, i), n = !0;
    else if (e === null) {
        var o = t.stateNode,
            a = t.memoizedProps;
        o.props = a;
        var l = o.context,
            c = r.contextType;
        typeof c == "object" && c !== null ? c = rn(c) : (c = Cr(r) ? uo : dr.current, c = Xa(t, c));
        var u = r.getDerivedStateFromProps,
            h = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== n || l !== c) && eE(t, o, n, c), Qi = !1;
        var d = t.memoizedState;
        o.state = d, of (t, n, o, i), l = t.memoizedState, a !== n || d !== l || Pr.current || Qi ? (typeof u == "function" && (fy(t, r, u, n), l = t.memoizedState), (a = Qi || Jx(t, r, a, n, d, l, c)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = n, t.memoizedState = l), o.props = n, o.state = l, o.context = c, n = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), n = !1)
    } else {
        o = t.stateNode, XA(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : gn(t.type, a), o.props = c, h = t.pendingProps, d = o.context, l = r.contextType, typeof l == "object" && l !== null ? l = rn(l) : (l = Cr(r) ? uo : dr.current, l = Xa(t, l));
        var f = r.getDerivedStateFromProps;
        (u = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || d !== l) && eE(t, o, n, l), Qi = !1, d = t.memoizedState, o.state = d, of (t, n, o, i);
        var p = t.memoizedState;
        a !== h || d !== p || Pr.current || Qi ? (typeof f == "function" && (fy(t, r, f, n), p = t.memoizedState), (c = Qi || Jx(t, r, c, n, d, p, l) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(n, p, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(n, p, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = n, t.memoizedState = p), o.props = n, o.state = p, o.context = l, n = c) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), n = !1)
    }
    return vy(e, t, r, n, s, i)
}

function vy(e, t, r, n, i, s) {
    xI(e, t);
    var o = (t.flags & 128) !== 0;
    if (!n && !o) return i && Yx(t, r, !1), Ii(e, t, s);
    n = t.stateNode, C8.current = t;
    var a = o && typeof r.getDerivedStateFromError != "function" ? null : n.render();
    return t.flags |= 1, e !== null && o ? (t.child = Ka(t, e.child, null, s), t.child = Ka(t, null, a, s)) : pr(e, t, a, s), t.memoizedState = n.state, i && Yx(t, r, !0), t.child
}

function EI(e) {
    var t = e.stateNode;
    t.pendingContext ? Xx(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Xx(e, t.context, !1), T1(e, t.containerInfo)
}

function uE(e, t, r, n, i) {
    return Ya(), b1(i), t.flags |= 256, pr(e, t, r, n), t.child
}
var yy = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};

function _y(e) {
    return {
        baseLanes: e,
        cachePool: null,
        transitions: null
    }
}

function SI(e, t, r) {
    var n = t.pendingProps,
        i = _t.current,
        s = !1,
        o = (t.flags & 128) !== 0,
        a;
    if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), ct(_t, i & 1), e === null) return hy(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = n.children, e = n.fallback, s ? (n = t.mode, s = t.child, o = {
        mode: "hidden",
        children: o
    }, !(n & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = Pm(o, n, 0, null), e = so(e, n, r, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = _y(r), t.memoizedState = yy, e) : D1(t, o));
    if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return T8(e, t, o, n, a, i, r);
    if (s) {
        s = n.fallback, o = t.mode, i = e.child, a = i.sibling;
        var l = {
            mode: "hidden",
            children: n.children
        };
        return !(o & 1) && t.child !== i ? (n = t.child, n.childLanes = 0, n.pendingProps = l, t.deletions = null) : (n = gs(i, l), n.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = gs(a, s) : (s = so(s, o, r, null), s.flags |= 2), s.return = t, n.return = t, n.sibling = s, t.child = n, n = s, s = t.child, o = e.child.memoizedState, o = o === null ? _y(r) : {
            baseLanes: o.baseLanes | r,
            cachePool: null,
            transitions: o.transitions
        }, s.memoizedState = o, s.childLanes = e.childLanes & ~r, t.memoizedState = yy, n
    }
    return s = e.child, e = s.sibling, n = gs(s, {
        mode: "visible",
        children: n.children
    }), !(t.mode & 1) && (n.lanes = r), n.return = t, n.sibling = null, e !== null && (r = t.deletions, r === null ? (t.deletions = [e], t.flags |= 16) : r.push(e)), t.child = n, t.memoizedState = null, n
}

function D1(e, t) {
    return t = Pm({
        mode: "visible",
        children: t
    }, e.mode, 0, null), t.return = e, e.child = t
}

function uh(e, t, r, n) {
    return n !== null && b1(n), Ka(t, e.child, null, r), e = D1(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e
}

function T8(e, t, r, n, i, s, o) {
    if (r) return t.flags & 256 ? (t.flags &= -257, n = Ev(Error(re(422))), uh(e, t, o, n)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (s = n.fallback, i = t.mode, n = Pm({
        mode: "visible",
        children: n.children
    }, i, 0, null), s = so(s, i, o, null), s.flags |= 2, n.return = t, s.return = t, n.sibling = s, t.child = n, t.mode & 1 && Ka(t, e.child, null, o), t.child.memoizedState = _y(o), t.memoizedState = yy, s);
    if (!(t.mode & 1)) return uh(e, t, o, null);
    if (i.data === "$!") {
        if (n = i.nextSibling && i.nextSibling.dataset, n) var a = n.dgst;
        return n = a, s = Error(re(419)), n = Ev(s, n, void 0), uh(e, t, o, n)
    }
    if (a = (o & e.childLanes) !== 0, Sr || a) {
        if (n = Vt, n !== null) {
            switch (o & -o) {
                case 4:
                    i = 2;
                    break;
                case 16:
                    i = 8;
                    break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    i = 32;
                    break;
                case 536870912:
                    i = 268435456;
                    break;
                default:
                    i = 0
            }
            i = i & (n.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, Ai(e, i), Tn(n, e, i, -1))
        }
        return j1(), n = Ev(Error(re(421))), uh(e, t, o, n)
    }
    return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = z8.bind(null, e), i._reactRetry = t, null) : (e = s.treeContext, Mr = ds(i.nextSibling), Fr = t, pt = !0, _n = null, e !== null && (Xr[Yr++] = _i, Xr[Yr++] = wi, Xr[Yr++] = ho, _i = e.id, wi = e.overflow, ho = t), t = D1(t, n.children), t.flags |= 4096, t)
}

function hE(e, t, r) {
    e.lanes |= t;
    var n = e.alternate;
    n !== null && (n.lanes |= t), dy(e.return, t, r)
}

function Sv(e, t, r, n, i) {
    var s = e.memoizedState;
    s === null ? e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: n,
        tail: r,
        tailMode: i
    } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = n, s.tail = r, s.tailMode = i)
}

function PI(e, t, r) {
    var n = t.pendingProps,
        i = n.revealOrder,
        s = n.tail;
    if (pr(e, t, n.children, r), n = _t.current, n & 2) n = n & 1 | 2, t.flags |= 128;
    else {
        if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) {
            if (e.tag === 13) e.memoizedState !== null && hE(e, r, t);
            else if (e.tag === 19) hE(e, r, t);
            else if (e.child !== null) {
                e.child.return = e, e = e.child;
                continue
            }
            if (e === t) break e;
            for (; e.sibling === null;) {
                if (e.return === null || e.return === t) break e;
                e = e.return
            }
            e.sibling.return = e.return, e = e.sibling
        }
        n &= 1
    }
    if (ct(_t, n), !(t.mode & 1)) t.memoizedState = null;
    else switch (i) {
        case "forwards":
            for (r = t.child, i = null; r !== null;) e = r.alternate, e !== null && af(e) === null && (i = r), r = r.sibling;
            r = i, r === null ? (i = t.child, t.child = null) : (i = r.sibling, r.sibling = null), Sv(t, !1, i, r, s);
            break;
        case "backwards":
            for (r = null, i = t.child, t.child = null; i !== null;) {
                if (e = i.alternate, e !== null && af(e) === null) {
                    t.child = i;
                    break
                }
                e = i.sibling, i.sibling = r, r = i, i = e
            }
            Sv(t, !0, r, null, s);
            break;
        case "together":
            Sv(t, !1, null, null, void 0);
            break;
        default:
            t.memoizedState = null
    }
    return t.child
}

function yd(e, t) {
    !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2)
}

function Ii(e, t, r) {
    if (e !== null && (t.dependencies = e.dependencies), po |= t.lanes, !(r & t.childLanes)) return null;
    if (e !== null && t.child !== e.child) throw Error(re(153));
    if (t.child !== null) {
        for (e = t.child, r = gs(e, e.pendingProps), t.child = r, r.return = t; e.sibling !== null;) e = e.sibling, r = r.sibling = gs(e, e.pendingProps), r.return = t;
        r.sibling = null
    }
    return t.child
}

function O8(e, t, r) {
    switch (t.tag) {
        case 3:
            EI(t), Ya();
            break;
        case 5:
            ZA(t);
            break;
        case 1:
            Cr(t.type) && ef(t);
            break;
        case 4:
            T1(t, t.stateNode.containerInfo);
            break;
        case 10:
            var n = t.type._context,
                i = t.memoizedProps.value;
            ct(nf, n._currentValue), n._currentValue = i;
            break;
        case 13:
            if (n = t.memoizedState, n !== null) return n.dehydrated !== null ? (ct(_t, _t.current & 1), t.flags |= 128, null) : r & t.child.childLanes ? SI(e, t, r) : (ct(_t, _t.current & 1), e = Ii(e, t, r), e !== null ? e.sibling : null);
            ct(_t, _t.current & 1);
            break;
        case 19:
            if (n = (r & t.childLanes) !== 0, e.flags & 128) {
                if (n) return PI(e, t, r);
                t.flags |= 128
            }
            if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), ct(_t, _t.current), n) break;
            return null;
        case 22:
        case 23:
            return t.lanes = 0, bI(e, t, r)
    }
    return Ii(e, t, r)
}
var CI, wy, TI, OI;
CI = function(e, t) {
    for (var r = t.child; r !== null;) {
        if (r.tag === 5 || r.tag === 6) e.appendChild(r.stateNode);
        else if (r.tag !== 4 && r.child !== null) {
            r.child.return = r, r = r.child;
            continue
        }
        if (r === t) break;
        for (; r.sibling === null;) {
            if (r.return === null || r.return === t) return;
            r = r.return
        }
        r.sibling.return = r.return, r = r.sibling
    }
};
wy = function() {};
TI = function(e, t, r, n) {
    var i = e.memoizedProps;
    if (i !== n) {
        e = t.stateNode, to(ti.current);
        var s = null;
        switch (r) {
            case "input":
                i = U0(e, i), n = U0(e, n), s = [];
                break;
            case "select":
                i = Et({}, i, {
                    value: void 0
                }), n = Et({}, n, {
                    value: void 0
                }), s = [];
                break;
            case "textarea":
                i = V0(e, i), n = V0(e, n), s = [];
                break;
            default:
                typeof i.onClick != "function" && typeof n.onClick == "function" && (e.onclick = Zd)
        }
        X0(r, n);
        var o;
        r = null;
        for (c in i)
            if (!n.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
                if (c === "style") {
                    var a = i[c];
                    for (o in a) a.hasOwnProperty(o) && (r || (r = {}), r[o] = "")
                } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (kc.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null));
        for (c in n) {
            var l = n[c];
            if (a = i != null ? i[c] : void 0, n.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (r || (r = {}), r[o] = "");
                        for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (r || (r = {}), r[o] = l[o])
                    } else r || (s || (s = []), s.push(c, r)), r = l;
            else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (kc.hasOwnProperty(c) ? (l != null && c === "onScroll" && ut("scroll", e), s || a === l || (s = [])) : (s = s || []).push(c, l))
        }
        r && (s = s || []).push("style", r);
        var c = s;
        (t.updateQueue = c) && (t.flags |= 4)
    }
};
OI = function(e, t, r, n) {
    r !== n && (t.flags |= 4)
};

function Fl(e, t) {
    if (!pt) switch (e.tailMode) {
        case "hidden":
            t = e.tail;
            for (var r = null; t !== null;) t.alternate !== null && (r = t), t = t.sibling;
            r === null ? e.tail = null : r.sibling = null;
            break;
        case "collapsed":
            r = e.tail;
            for (var n = null; r !== null;) r.alternate !== null && (n = r), r = r.sibling;
            n === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : n.sibling = null
    }
}

function lr(e) {
    var t = e.alternate !== null && e.alternate.child === e.child,
        r = 0,
        n = 0;
    if (t)
        for (var i = e.child; i !== null;) r |= i.lanes | i.childLanes, n |= i.subtreeFlags & 14680064, n |= i.flags & 14680064, i.return = e, i = i.sibling;
    else
        for (i = e.child; i !== null;) r |= i.lanes | i.childLanes, n |= i.subtreeFlags, n |= i.flags, i.return = e, i = i.sibling;
    return e.subtreeFlags |= n, e.childLanes = r, t
}

function A8(e, t, r) {
    var n = t.pendingProps;
    switch (w1(t), t.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return lr(t), null;
        case 1:
            return Cr(t.type) && Jd(), lr(t), null;
        case 3:
            return n = t.stateNode, qa(), ht(Pr), ht(dr), A1(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (e === null || e.child === null) && (lh(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, _n !== null && (Oy(_n), _n = null))), wy(e, t), lr(t), null;
        case 5:
            O1(t);
            var i = to(Vc.current);
            if (r = t.type, e !== null && t.stateNode != null) TI(e, t, r, n, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
            else {
                if (!n) {
                    if (t.stateNode === null) throw Error(re(166));
                    return lr(t), null
                }
                if (e = to(ti.current), lh(t)) {
                    n = t.stateNode, r = t.type;
                    var s = t.memoizedProps;
                    switch (n[qn] = t, n[Hc] = s, e = (t.mode & 1) !== 0, r) {
                        case "dialog":
                            ut("cancel", n), ut("close", n);
                            break;
                        case "iframe":
                        case "object":
                        case "embed":
                            ut("load", n);
                            break;
                        case "video":
                        case "audio":
                            for (i = 0; i < ac.length; i++) ut(ac[i], n);
                            break;
                        case "source":
                            ut("error", n);
                            break;
                        case "img":
                        case "image":
                        case "link":
                            ut("error", n), ut("load", n);
                            break;
                        case "details":
                            ut("toggle", n);
                            break;
                        case "input":
                            wx(n, s), ut("invalid", n);
                            break;
                        case "select":
                            n._wrapperState = {
                                wasMultiple: !!s.multiple
                            }, ut("invalid", n);
                            break;
                        case "textarea":
                            xx(n, s), ut("invalid", n)
                    }
                    X0(r, s), i = null;
                    for (var o in s)
                        if (s.hasOwnProperty(o)) {
                            var a = s[o];
                            o === "children" ? typeof a == "string" ? n.textContent !== a && (s.suppressHydrationWarning !== !0 && ah(n.textContent, a, e), i = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && ah(n.textContent, a, e), i = ["children", "" + a]) : kc.hasOwnProperty(o) && a != null && o === "onScroll" && ut("scroll", n)
                        }
                    switch (r) {
                        case "input":
                            Ju(n), bx(n, s, !0);
                            break;
                        case "textarea":
                            Ju(n), Ex(n);
                            break;
                        case "select":
                        case "option":
                            break;
                        default:
                            typeof s.onClick == "function" && (n.onclick = Zd)
                    }
                    n = i, t.updateQueue = n, n !== null && (t.flags |= 4)
                } else {
                    o = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = tA(r)), e === "http://www.w3.org/1999/xhtml" ? r === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof n.is == "string" ? e = o.createElement(r, {
                        is: n.is
                    }) : (e = o.createElement(r), r === "select" && (o = e, n.multiple ? o.multiple = !0 : n.size && (o.size = n.size))) : e = o.createElementNS(e, r), e[qn] = t, e[Hc] = n, CI(e, t, !1, !1), t.stateNode = e;
                    e: {
                        switch (o = Y0(r, n), r) {
                            case "dialog":
                                ut("cancel", e), ut("close", e), i = n;
                                break;
                            case "iframe":
                            case "object":
                            case "embed":
                                ut("load", e), i = n;
                                break;
                            case "video":
                            case "audio":
                                for (i = 0; i < ac.length; i++) ut(ac[i], e);
                                i = n;
                                break;
                            case "source":
                                ut("error", e), i = n;
                                break;
                            case "img":
                            case "image":
                            case "link":
                                ut("error", e), ut("load", e), i = n;
                                break;
                            case "details":
                                ut("toggle", e), i = n;
                                break;
                            case "input":
                                wx(e, n), i = U0(e, n), ut("invalid", e);
                                break;
                            case "option":
                                i = n;
                                break;
                            case "select":
                                e._wrapperState = {
                                    wasMultiple: !!n.multiple
                                }, i = Et({}, n, {
                                    value: void 0
                                }), ut("invalid", e);
                                break;
                            case "textarea":
                                xx(e, n), i = V0(e, n), ut("invalid", e);
                                break;
                            default:
                                i = n
                        }
                        X0(r, i),
                        a = i;
                        for (s in a)
                            if (a.hasOwnProperty(s)) {
                                var l = a[s];
                                s === "style" ? iA(e, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && rA(e, l)) : s === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && Mc(e, l) : typeof l == "number" && Mc(e, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (kc.hasOwnProperty(s) ? l != null && s === "onScroll" && ut("scroll", e) : l != null && s1(e, s, l, o))
                            }
                        switch (r) {
                            case "input":
                                Ju(e), bx(e, n, !1);
                                break;
                            case "textarea":
                                Ju(e), Ex(e);
                                break;
                            case "option":
                                n.value != null && e.setAttribute("value", "" + xs(n.value));
                                break;
                            case "select":
                                e.multiple = !!n.multiple, s = n.value, s != null ? Aa(e, !!n.multiple, s, !1) : n.defaultValue != null && Aa(e, !!n.multiple, n.defaultValue, !0);
                                break;
                            default:
                                typeof i.onClick == "function" && (e.onclick = Zd)
                        }
                        switch (r) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                n = !!n.autoFocus;
                                break e;
                            case "img":
                                n = !0;
                                break e;
                            default:
                                n = !1
                        }
                    }
                    n && (t.flags |= 4)
                }
                t.ref !== null && (t.flags |= 512, t.flags |= 2097152)
            }
            return lr(t), null;
        case 6:
            if (e && t.stateNode != null) OI(e, t, e.memoizedProps, n);
            else {
                if (typeof n != "string" && t.stateNode === null) throw Error(re(166));
                if (r = to(Vc.current), to(ti.current), lh(t)) {
                    if (n = t.stateNode, r = t.memoizedProps, n[qn] = t, (s = n.nodeValue !== r) && (e = Fr, e !== null)) switch (e.tag) {
                        case 3:
                            ah(n.nodeValue, r, (e.mode & 1) !== 0);
                            break;
                        case 5:
                            e.memoizedProps.suppressHydrationWarning !== !0 && ah(n.nodeValue, r, (e.mode & 1) !== 0)
                    }
                    s && (t.flags |= 4)
                } else n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n), n[qn] = t, t.stateNode = n
            }
            return lr(t), null;
        case 13:
            if (ht(_t), n = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
                if (pt && Mr !== null && t.mode & 1 && !(t.flags & 128)) VA(), Ya(), t.flags |= 98560, s = !1;
                else if (s = lh(t), n !== null && n.dehydrated !== null) {
                    if (e === null) {
                        if (!s) throw Error(re(318));
                        if (s = t.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(re(317));
                        s[qn] = t
                    } else Ya(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
                    lr(t), s = !1
                } else _n !== null && (Oy(_n), _n = null), s = !0;
                if (!s) return t.flags & 65536 ? t : null
            }
            return t.flags & 128 ? (t.lanes = r, t) : (n = n !== null, n !== (e !== null && e.memoizedState !== null) && n && (t.child.flags |= 8192, t.mode & 1 && (e === null || _t.current & 1 ? Bt === 0 && (Bt = 3) : j1())), t.updateQueue !== null && (t.flags |= 4), lr(t), null);
        case 4:
            return qa(), wy(e, t), e === null && jc(t.stateNode.containerInfo), lr(t), null;
        case 10:
            return S1(t.type._context), lr(t), null;
        case 17:
            return Cr(t.type) && Jd(), lr(t), null;
        case 19:
            if (ht(_t), s = t.memoizedState, s === null) return lr(t), null;
            if (n = (t.flags & 128) !== 0, o = s.rendering, o === null)
                if (n) Fl(s, !1);
                else {
                    if (Bt !== 0 || e !== null && e.flags & 128)
                        for (e = t.child; e !== null;) {
                            if (o = af(e), o !== null) {
                                for (t.flags |= 128, Fl(s, !1), n = o.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), t.subtreeFlags = 0, n = r, r = t.child; r !== null;) s = r, e = n, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, e = o.dependencies, s.dependencies = e === null ? null : {
                                    lanes: e.lanes,
                                    firstContext: e.firstContext
                                }), r = r.sibling;
                                return ct(_t, _t.current & 1 | 2), t.child
                            }
                            e = e.sibling
                        }
                    s.tail !== null && Tt() > Za && (t.flags |= 128, n = !0, Fl(s, !1), t.lanes = 4194304)
                }
            else {
                if (!n)
                    if (e = af(o), e !== null) {
                        if (t.flags |= 128, n = !0, r = e.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), Fl(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !pt) return lr(t), null
                    } else 2 * Tt() - s.renderingStartTime > Za && r !== 1073741824 && (t.flags |= 128, n = !0, Fl(s, !1), t.lanes = 4194304);
                s.isBackwards ? (o.sibling = t.child, t.child = o) : (r = s.last, r !== null ? r.sibling = o : t.child = o, s.last = o)
            }
            return s.tail !== null ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = Tt(), t.sibling = null, r = _t.current, ct(_t, n ? r & 1 | 2 : r & 1), t) : (lr(t), null);
        case 22:
        case 23:
            return z1(), n = t.memoizedState !== null, e !== null && e.memoizedState !== null !== n && (t.flags |= 8192), n && t.mode & 1 ? kr & 1073741824 && (lr(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : lr(t), null;
        case 24:
            return null;
        case 25:
            return null
    }
    throw Error(re(156, t.tag))
}

function I8(e, t) {
    switch (w1(t), t.tag) {
        case 1:
            return Cr(t.type) && Jd(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
        case 3:
            return qa(), ht(Pr), ht(dr), A1(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
        case 5:
            return O1(t), null;
        case 13:
            if (ht(_t), e = t.memoizedState, e !== null && e.dehydrated !== null) {
                if (t.alternate === null) throw Error(re(340));
                Ya()
            }
            return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
        case 19:
            return ht(_t), null;
        case 4:
            return qa(), null;
        case 10:
            return S1(t.type._context), null;
        case 22:
        case 23:
            return z1(), null;
        case 24:
            return null;
        default:
            return null
    }
}
var hh = !1,
    ur = !1,
    $8 = typeof WeakSet == "function" ? WeakSet : Set,
    fe = null;

function Pa(e, t) {
    var r = e.ref;
    if (r !== null)
        if (typeof r == "function") try {
            r(null)
        } catch (n) {
            Pt(e, t, n)
        } else r.current = null
}

function by(e, t, r) {
    try {
        r()
    } catch (n) {
        Pt(e, t, n)
    }
}
var dE = !1;

function R8(e, t) {
    if (iy = Kd, e = RA(), y1(e)) {
        if ("selectionStart" in e) var r = {
            start: e.selectionStart,
            end: e.selectionEnd
        };
        else e: {
            r = (r = e.ownerDocument) && r.defaultView || window;
            var n = r.getSelection && r.getSelection();
            if (n && n.rangeCount !== 0) {
                r = n.anchorNode;
                var i = n.anchorOffset,
                    s = n.focusNode;
                n = n.focusOffset;
                try {
                    r.nodeType, s.nodeType
                } catch {
                    r = null;
                    break e
                }
                var o = 0,
                    a = -1,
                    l = -1,
                    c = 0,
                    u = 0,
                    h = e,
                    d = null;
                t: for (;;) {
                    for (var f; h !== r || i !== 0 && h.nodeType !== 3 || (a = o + i), h !== s || n !== 0 && h.nodeType !== 3 || (l = o + n), h.nodeType === 3 && (o += h.nodeValue.length), (f = h.firstChild) !== null;) d = h, h = f;
                    for (;;) {
                        if (h === e) break t;
                        if (d === r && ++c === i && (a = o), d === s && ++u === n && (l = o), (f = h.nextSibling) !== null) break;
                        h = d, d = h.parentNode
                    }
                    h = f
                }
                r = a === -1 || l === -1 ? null : {
                    start: a,
                    end: l
                }
            } else r = null
        }
        r = r || {
            start: 0,
            end: 0
        }
    } else r = null;
    for (sy = {
            focusedElem: e,
            selectionRange: r
        }, Kd = !1, fe = t; fe !== null;)
        if (t = fe, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, fe = e;
        else
            for (; fe !== null;) {
                t = fe;
                try {
                    var p = t.alternate;
                    if (t.flags & 1024) switch (t.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (p !== null) {
                                var m = p.memoizedProps,
                                    w = p.memoizedState,
                                    y = t.stateNode,
                                    v = y.getSnapshotBeforeUpdate(t.elementType === t.type ? m : gn(t.type, m), w);
                                y.__reactInternalSnapshotBeforeUpdate = v
                            }
                            break;
                        case 3:
                            var _ = t.stateNode.containerInfo;
                            _.nodeType === 1 ? _.textContent = "" : _.nodeType === 9 && _.documentElement && _.removeChild(_.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(re(163))
                    }
                } catch (E) {
                    Pt(t, t.return, E)
                }
                if (e = t.sibling, e !== null) {
                    e.return = t.return, fe = e;
                    break
                }
                fe = t.return
            }
    return p = dE, dE = !1, p
}

function bc(e, t, r) {
    var n = t.updateQueue;
    if (n = n !== null ? n.lastEffect : null, n !== null) {
        var i = n = n.next;
        do {
            if ((i.tag & e) === e) {
                var s = i.destroy;
                i.destroy = void 0, s !== void 0 && by(t, r, s)
            }
            i = i.next
        } while (i !== n)
    }
}

function Em(e, t) {
    if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) {
        var r = t = t.next;
        do {
            if ((r.tag & e) === e) {
                var n = r.create;
                r.destroy = n()
            }
            r = r.next
        } while (r !== t)
    }
}

function xy(e) {
    var t = e.ref;
    if (t !== null) {
        var r = e.stateNode;
        switch (e.tag) {
            case 5:
                e = r;
                break;
            default:
                e = r
        }
        typeof t == "function" ? t(e) : t.current = e
    }
}

function AI(e) {
    var t = e.alternate;
    t !== null && (e.alternate = null, AI(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[qn], delete t[Hc], delete t[ly], delete t[p8], delete t[m8])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
}

function II(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4
}

function fE(e) {
    e: for (;;) {
        for (; e.sibling === null;) {
            if (e.return === null || II(e.return)) return null;
            e = e.return
        }
        for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) {
            if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
            e.child.return = e, e = e.child
        }
        if (!(e.flags & 2)) return e.stateNode
    }
}

function Ey(e, t, r) {
    var n = e.tag;
    if (n === 5 || n === 6) e = e.stateNode, t ? r.nodeType === 8 ? r.parentNode.insertBefore(e, t) : r.insertBefore(e, t) : (r.nodeType === 8 ? (t = r.parentNode, t.insertBefore(e, r)) : (t = r, t.appendChild(e)), r = r._reactRootContainer, r != null || t.onclick !== null || (t.onclick = Zd));
    else if (n !== 4 && (e = e.child, e !== null))
        for (Ey(e, t, r), e = e.sibling; e !== null;) Ey(e, t, r), e = e.sibling
}

function Sy(e, t, r) {
    var n = e.tag;
    if (n === 5 || n === 6) e = e.stateNode, t ? r.insertBefore(e, t) : r.appendChild(e);
    else if (n !== 4 && (e = e.child, e !== null))
        for (Sy(e, t, r), e = e.sibling; e !== null;) Sy(e, t, r), e = e.sibling
}
var Qt = null,
    yn = !1;

function Ui(e, t, r) {
    for (r = r.child; r !== null;) $I(e, t, r), r = r.sibling
}

function $I(e, t, r) {
    if (ei && typeof ei.onCommitFiberUnmount == "function") try {
        ei.onCommitFiberUnmount(mm, r)
    } catch {}
    switch (r.tag) {
        case 5:
            ur || Pa(r, t);
        case 6:
            var n = Qt,
                i = yn;
            Qt = null, Ui(e, t, r), Qt = n, yn = i, Qt !== null && (yn ? (e = Qt, r = r.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(r) : e.removeChild(r)) : Qt.removeChild(r.stateNode));
            break;
        case 18:
            Qt !== null && (yn ? (e = Qt, r = r.stateNode, e.nodeType === 8 ? vv(e.parentNode, r) : e.nodeType === 1 && vv(e, r), Fc(e)) : vv(Qt, r.stateNode));
            break;
        case 4:
            n = Qt, i = yn, Qt = r.stateNode.containerInfo, yn = !0, Ui(e, t, r), Qt = n, yn = i;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            if (!ur && (n = r.updateQueue, n !== null && (n = n.lastEffect, n !== null))) {
                i = n = n.next;
                do {
                    var s = i,
                        o = s.destroy;
                    s = s.tag, o !== void 0 && (s & 2 || s & 4) && by(r, t, o), i = i.next
                } while (i !== n)
            }
            Ui(e, t, r);
            break;
        case 1:
            if (!ur && (Pa(r, t), n = r.stateNode, typeof n.componentWillUnmount == "function")) try {
                n.props = r.memoizedProps, n.state = r.memoizedState, n.componentWillUnmount()
            } catch (a) {
                Pt(r, t, a)
            }
            Ui(e, t, r);
            break;
        case 21:
            Ui(e, t, r);
            break;
        case 22:
            r.mode & 1 ? (ur = (n = ur) || r.memoizedState !== null, Ui(e, t, r), ur = n) : Ui(e, t, r);
            break;
        default:
            Ui(e, t, r)
    }
}

function pE(e) {
    var t = e.updateQueue;
    if (t !== null) {
        e.updateQueue = null;
        var r = e.stateNode;
        r === null && (r = e.stateNode = new $8), t.forEach(function(n) {
            var i = j8.bind(null, e, n);
            r.has(n) || (r.add(n), n.then(i, i))
        })
    }
}

function hn(e, t) {
    var r = t.deletions;
    if (r !== null)
        for (var n = 0; n < r.length; n++) {
            var i = r[n];
            try {
                var s = e,
                    o = t,
                    a = o;
                e: for (; a !== null;) {
                    switch (a.tag) {
                        case 5:
                            Qt = a.stateNode, yn = !1;
                            break e;
                        case 3:
                            Qt = a.stateNode.containerInfo, yn = !0;
                            break e;
                        case 4:
                            Qt = a.stateNode.containerInfo, yn = !0;
                            break e
                    }
                    a = a.return
                }
                if (Qt === null) throw Error(re(160));
                $I(s, o, i), Qt = null, yn = !1;
                var l = i.alternate;
                l !== null && (l.return = null), i.return = null
            } catch (c) {
                Pt(i, t, c)
            }
        }
    if (t.subtreeFlags & 12854)
        for (t = t.child; t !== null;) RI(t, e), t = t.sibling
}

function RI(e, t) {
    var r = e.alternate,
        n = e.flags;
    switch (e.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            if (hn(t, e), Fn(e), n & 4) {
                try {
                    bc(3, e, e.return), Em(3, e)
                } catch (m) {
                    Pt(e, e.return, m)
                }
                try {
                    bc(5, e, e.return)
                } catch (m) {
                    Pt(e, e.return, m)
                }
            }
            break;
        case 1:
            hn(t, e), Fn(e), n & 512 && r !== null && Pa(r, r.return);
            break;
        case 5:
            if (hn(t, e), Fn(e), n & 512 && r !== null && Pa(r, r.return), e.flags & 32) {
                var i = e.stateNode;
                try {
                    Mc(i, "")
                } catch (m) {
                    Pt(e, e.return, m)
                }
            }
            if (n & 4 && (i = e.stateNode, i != null)) {
                var s = e.memoizedProps,
                    o = r !== null ? r.memoizedProps : s,
                    a = e.type,
                    l = e.updateQueue;
                if (e.updateQueue = null, l !== null) try {
                    a === "input" && s.type === "radio" && s.name != null && JO(i, s), Y0(a, o);
                    var c = Y0(a, s);
                    for (o = 0; o < l.length; o += 2) {
                        var u = l[o],
                            h = l[o + 1];
                        u === "style" ? iA(i, h) : u === "dangerouslySetInnerHTML" ? rA(i, h) : u === "children" ? Mc(i, h) : s1(i, u, h, c)
                    }
                    switch (a) {
                        case "input":
                            H0(i, s);
                            break;
                        case "textarea":
                            eA(i, s);
                            break;
                        case "select":
                            var d = i._wrapperState.wasMultiple;
                            i._wrapperState.wasMultiple = !!s.multiple;
                            var f = s.value;
                            f != null ? Aa(i, !!s.multiple, f, !1) : d !== !!s.multiple && (s.defaultValue != null ? Aa(i, !!s.multiple, s.defaultValue, !0) : Aa(i, !!s.multiple, s.multiple ? [] : "", !1))
                    }
                    i[Hc] = s
                } catch (m) {
                    Pt(e, e.return, m)
                }
            }
            break;
        case 6:
            if (hn(t, e), Fn(e), n & 4) {
                if (e.stateNode === null) throw Error(re(162));
                i = e.stateNode, s = e.memoizedProps;
                try {
                    i.nodeValue = s
                } catch (m) {
                    Pt(e, e.return, m)
                }
            }
            break;
        case 3:
            if (hn(t, e), Fn(e), n & 4 && r !== null && r.memoizedState.isDehydrated) try {
                Fc(t.containerInfo)
            } catch (m) {
                Pt(e, e.return, m)
            }
            break;
        case 4:
            hn(t, e), Fn(e);
            break;
        case 13:
            hn(t, e), Fn(e), i = e.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (F1 = Tt())), n & 4 && pE(e);
            break;
        case 22:
            if (u = r !== null && r.memoizedState !== null, e.mode & 1 ? (ur = (c = ur) || u, hn(t, e), ur = c) : hn(t, e), Fn(e), n & 8192) {
                if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !u && e.mode & 1)
                    for (fe = e, u = e.child; u !== null;) {
                        for (h = fe = u; fe !== null;) {
                            switch (d = fe, f = d.child, d.tag) {
                                case 0:
                                case 11:
                                case 14:
                                case 15:
                                    bc(4, d, d.return);
                                    break;
                                case 1:
                                    Pa(d, d.return);
                                    var p = d.stateNode;
                                    if (typeof p.componentWillUnmount == "function") {
                                        n = d, r = d.return;
                                        try {
                                            t = n, p.props = t.memoizedProps, p.state = t.memoizedState, p.componentWillUnmount()
                                        } catch (m) {
                                            Pt(n, r, m)
                                        }
                                    }
                                    break;
                                case 5:
                                    Pa(d, d.return);
                                    break;
                                case 22:
                                    if (d.memoizedState !== null) {
                                        gE(h);
                                        continue
                                    }
                            }
                            f !== null ? (f.return = d, fe = f) : gE(h)
                        }
                        u = u.sibling
                    }
                e: for (u = null, h = e;;) {
                    if (h.tag === 5) {
                        if (u === null) {
                            u = h;
                            try {
                                i = h.stateNode, c ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = h.stateNode, l = h.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = nA("display", o))
                            } catch (m) {
                                Pt(e, e.return, m)
                            }
                        }
                    } else if (h.tag === 6) {
                        if (u === null) try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (m) {
                            Pt(e, e.return, m)
                        }
                    } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === e) && h.child !== null) {
                        h.child.return = h, h = h.child;
                        continue
                    }
                    if (h === e) break e;
                    for (; h.sibling === null;) {
                        if (h.return === null || h.return === e) break e;
                        u === h && (u = null), h = h.return
                    }
                    u === h && (u = null), h.sibling.return = h.return, h = h.sibling
                }
            }
            break;
        case 19:
            hn(t, e), Fn(e), n & 4 && pE(e);
            break;
        case 21:
            break;
        default:
            hn(t, e), Fn(e)
    }
}

function Fn(e) {
    var t = e.flags;
    if (t & 2) {
        try {
            e: {
                for (var r = e.return; r !== null;) {
                    if (II(r)) {
                        var n = r;
                        break e
                    }
                    r = r.return
                }
                throw Error(re(160))
            }
            switch (n.tag) {
                case 5:
                    var i = n.stateNode;
                    n.flags & 32 && (Mc(i, ""), n.flags &= -33);
                    var s = fE(e);
                    Sy(e, s, i);
                    break;
                case 3:
                case 4:
                    var o = n.stateNode.containerInfo,
                        a = fE(e);
                    Ey(e, a, o);
                    break;
                default:
                    throw Error(re(161))
            }
        }
        catch (l) {
            Pt(e, e.return, l)
        }
        e.flags &= -3
    }
    t & 4096 && (e.flags &= -4097)
}

function k8(e, t, r) {
    fe = e, kI(e)
}

function kI(e, t, r) {
    for (var n = (e.mode & 1) !== 0; fe !== null;) {
        var i = fe,
            s = i.child;
        if (i.tag === 22 && n) {
            var o = i.memoizedState !== null || hh;
            if (!o) {
                var a = i.alternate,
                    l = a !== null && a.memoizedState !== null || ur;
                a = hh;
                var c = ur;
                if (hh = o, (ur = l) && !c)
                    for (fe = i; fe !== null;) o = fe, l = o.child, o.tag === 22 && o.memoizedState !== null ? vE(i) : l !== null ? (l.return = o, fe = l) : vE(i);
                for (; s !== null;) fe = s, kI(s), s = s.sibling;
                fe = i, hh = a, ur = c
            }
            mE(e)
        } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, fe = s) : mE(e)
    }
}

function mE(e) {
    for (; fe !== null;) {
        var t = fe;
        if (t.flags & 8772) {
            var r = t.alternate;
            try {
                if (t.flags & 8772) switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                        ur || Em(5, t);
                        break;
                    case 1:
                        var n = t.stateNode;
                        if (t.flags & 4 && !ur)
                            if (r === null) n.componentDidMount();
                            else {
                                var i = t.elementType === t.type ? r.memoizedProps : gn(t.type, r.memoizedProps);
                                n.componentDidUpdate(i, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate)
                            }
                        var s = t.updateQueue;
                        s !== null && Zx(t, s, n);
                        break;
                    case 3:
                        var o = t.updateQueue;
                        if (o !== null) {
                            if (r = null, t.child !== null) switch (t.child.tag) {
                                case 5:
                                    r = t.child.stateNode;
                                    break;
                                case 1:
                                    r = t.child.stateNode
                            }
                            Zx(t, o, r)
                        }
                        break;
                    case 5:
                        var a = t.stateNode;
                        if (r === null && t.flags & 4) {
                            r = a;
                            var l = t.memoizedProps;
                            switch (t.type) {
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    l.autoFocus && r.focus();
                                    break;
                                case "img":
                                    l.src && (r.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (t.memoizedState === null) {
                            var c = t.alternate;
                            if (c !== null) {
                                var u = c.memoizedState;
                                if (u !== null) {
                                    var h = u.dehydrated;
                                    h !== null && Fc(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(re(163))
                }
                ur || t.flags & 512 && xy(t)
            } catch (d) {
                Pt(t, t.return, d)
            }
        }
        if (t === e) {
            fe = null;
            break
        }
        if (r = t.sibling, r !== null) {
            r.return = t.return, fe = r;
            break
        }
        fe = t.return
    }
}

function gE(e) {
    for (; fe !== null;) {
        var t = fe;
        if (t === e) {
            fe = null;
            break
        }
        var r = t.sibling;
        if (r !== null) {
            r.return = t.return, fe = r;
            break
        }
        fe = t.return
    }
}

function vE(e) {
    for (; fe !== null;) {
        var t = fe;
        try {
            switch (t.tag) {
                case 0:
                case 11:
                case 15:
                    var r = t.return;
                    try {
                        Em(4, t)
                    } catch (l) {
                        Pt(t, r, l)
                    }
                    break;
                case 1:
                    var n = t.stateNode;
                    if (typeof n.componentDidMount == "function") {
                        var i = t.return;
                        try {
                            n.componentDidMount()
                        } catch (l) {
                            Pt(t, i, l)
                        }
                    }
                    var s = t.return;
                    try {
                        xy(t)
                    } catch (l) {
                        Pt(t, s, l)
                    }
                    break;
                case 5:
                    var o = t.return;
                    try {
                        xy(t)
                    } catch (l) {
                        Pt(t, o, l)
                    }
            }
        } catch (l) {
            Pt(t, t.return, l)
        }
        if (t === e) {
            fe = null;
            break
        }
        var a = t.sibling;
        if (a !== null) {
            a.return = t.return, fe = a;
            break
        }
        fe = t.return
    }
}
var M8 = Math.ceil,
    uf = Ri.ReactCurrentDispatcher,
    N1 = Ri.ReactCurrentOwner,
    tn = Ri.ReactCurrentBatchConfig,
    Ye = 0,
    Vt = null,
    Mt = null,
    nr = 0,
    kr = 0,
    Ca = As(0),
    Bt = 0,
    Kc = null,
    po = 0,
    Sm = 0,
    L1 = 0,
    xc = null,
    Er = null,
    F1 = 0,
    Za = 1 / 0,
    pi = null,
    hf = !1,
    Py = null,
    ps = null,
    dh = !1,
    ns = null,
    df = 0,
    Ec = 0,
    Cy = null,
    _d = -1,
    wd = 0;

function mr() {
    return Ye & 6 ? Tt() : _d !== -1 ? _d : _d = Tt()
}

function ms(e) {
    return e.mode & 1 ? Ye & 2 && nr !== 0 ? nr & -nr : v8.transition !== null ? (wd === 0 && (wd = gA()), wd) : (e = it, e !== 0 || (e = window.event, e = e === void 0 ? 16 : EA(e.type)), e) : 1
}

function Tn(e, t, r, n) {
    if (50 < Ec) throw Ec = 0, Cy = null, Error(re(185));
    yu(e, r, n), (!(Ye & 2) || e !== Vt) && (e === Vt && (!(Ye & 2) && (Sm |= r), Bt === 4 && Ji(e, nr)), Tr(e, n), r === 1 && Ye === 0 && !(t.mode & 1) && (Za = Tt() + 500, wm && Is()))
}

function Tr(e, t) {
    var r = e.callbackNode;
    vB(e, t);
    var n = Yd(e, e === Vt ? nr : 0);
    if (n === 0) r !== null && Cx(r), e.callbackNode = null, e.callbackPriority = 0;
    else if (t = n & -n, e.callbackPriority !== t) {
        if (r != null && Cx(r), t === 1) e.tag === 0 ? g8(yE.bind(null, e)) : UA(yE.bind(null, e)), d8(function() {
            !(Ye & 6) && Is()
        }), r = null;
        else {
            switch (vA(n)) {
                case 1:
                    r = u1;
                    break;
                case 4:
                    r = pA;
                    break;
                case 16:
                    r = Xd;
                    break;
                case 536870912:
                    r = mA;
                    break;
                default:
                    r = Xd
            }
            r = jI(r, MI.bind(null, e))
        }
        e.callbackPriority = t, e.callbackNode = r
    }
}

function MI(e, t) {
    if (_d = -1, wd = 0, Ye & 6) throw Error(re(327));
    var r = e.callbackNode;
    if (Ma() && e.callbackNode !== r) return null;
    var n = Yd(e, e === Vt ? nr : 0);
    if (n === 0) return null;
    if (n & 30 || n & e.expiredLanes || t) t = ff(e, n);
    else {
        t = n;
        var i = Ye;
        Ye |= 2;
        var s = NI();
        (Vt !== e || nr !== t) && (pi = null, Za = Tt() + 500, io(e, t));
        do try {
            L8();
            break
        } catch (a) {
            DI(e, a)
        }
        while (1);
        E1(), uf.current = s, Ye = i, Mt !== null ? t = 0 : (Vt = null, nr = 0, t = Bt)
    }
    if (t !== 0) {
        if (t === 2 && (i = J0(e), i !== 0 && (n = i, t = Ty(e, i))), t === 1) throw r = Kc, io(e, 0), Ji(e, n), Tr(e, Tt()), r;
        if (t === 6) Ji(e, n);
        else {
            if (i = e.current.alternate, !(n & 30) && !D8(i) && (t = ff(e, n), t === 2 && (s = J0(e), s !== 0 && (n = s, t = Ty(e, s))), t === 1)) throw r = Kc, io(e, 0), Ji(e, n), Tr(e, Tt()), r;
            switch (e.finishedWork = i, e.finishedLanes = n, t) {
                case 0:
                case 1:
                    throw Error(re(345));
                case 2:
                    Us(e, Er, pi);
                    break;
                case 3:
                    if (Ji(e, n), (n & 130023424) === n && (t = F1 + 500 - Tt(), 10 < t)) {
                        if (Yd(e, 0) !== 0) break;
                        if (i = e.suspendedLanes, (i & n) !== n) {
                            mr(), e.pingedLanes |= e.suspendedLanes & i;
                            break
                        }
                        e.timeoutHandle = ay(Us.bind(null, e, Er, pi), t);
                        break
                    }
                    Us(e, Er, pi);
                    break;
                case 4:
                    if (Ji(e, n), (n & 4194240) === n) break;
                    for (t = e.eventTimes, i = -1; 0 < n;) {
                        var o = 31 - Cn(n);
                        s = 1 << o, o = t[o], o > i && (i = o), n &= ~s
                    }
                    if (n = i, n = Tt() - n, n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * M8(n / 1960)) - n, 10 < n) {
                        e.timeoutHandle = ay(Us.bind(null, e, Er, pi), n);
                        break
                    }
                    Us(e, Er, pi);
                    break;
                case 5:
                    Us(e, Er, pi);
                    break;
                default:
                    throw Error(re(329))
            }
        }
    }
    return Tr(e, Tt()), e.callbackNode === r ? MI.bind(null, e) : null
}

function Ty(e, t) {
    var r = xc;
    return e.current.memoizedState.isDehydrated && (io(e, t).flags |= 256), e = ff(e, t), e !== 2 && (t = Er, Er = r, t !== null && Oy(t)), e
}

function Oy(e) {
    Er === null ? Er = e : Er.push.apply(Er, e)
}

function D8(e) {
    for (var t = e;;) {
        if (t.flags & 16384) {
            var r = t.updateQueue;
            if (r !== null && (r = r.stores, r !== null))
                for (var n = 0; n < r.length; n++) {
                    var i = r[n],
                        s = i.getSnapshot;
                    i = i.value;
                    try {
                        if (!kn(s(), i)) return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (r = t.child, t.subtreeFlags & 16384 && r !== null) r.return = t, t = r;
        else {
            if (t === e) break;
            for (; t.sibling === null;) {
                if (t.return === null || t.return === e) return !0;
                t = t.return
            }
            t.sibling.return = t.return, t = t.sibling
        }
    }
    return !0
}

function Ji(e, t) {
    for (t &= ~L1, t &= ~Sm, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
        var r = 31 - Cn(t),
            n = 1 << r;
        e[r] = -1, t &= ~n
    }
}

function yE(e) {
    if (Ye & 6) throw Error(re(327));
    Ma();
    var t = Yd(e, 0);
    if (!(t & 1)) return Tr(e, Tt()), null;
    var r = ff(e, t);
    if (e.tag !== 0 && r === 2) {
        var n = J0(e);
        n !== 0 && (t = n, r = Ty(e, n))
    }
    if (r === 1) throw r = Kc, io(e, 0), Ji(e, t), Tr(e, Tt()), r;
    if (r === 6) throw Error(re(345));
    return e.finishedWork = e.current.alternate, e.finishedLanes = t, Us(e, Er, pi), Tr(e, Tt()), null
}

function B1(e, t) {
    var r = Ye;
    Ye |= 1;
    try {
        return e(t)
    } finally {
        Ye = r, Ye === 0 && (Za = Tt() + 500, wm && Is())
    }
}

function mo(e) {
    ns !== null && ns.tag === 0 && !(Ye & 6) && Ma();
    var t = Ye;
    Ye |= 1;
    var r = tn.transition,
        n = it;
    try {
        if (tn.transition = null, it = 1, e) return e()
    } finally {
        it = n, tn.transition = r, Ye = t, !(Ye & 6) && Is()
    }
}

function z1() {
    kr = Ca.current, ht(Ca)
}

function io(e, t) {
    e.finishedWork = null, e.finishedLanes = 0;
    var r = e.timeoutHandle;
    if (r !== -1 && (e.timeoutHandle = -1, h8(r)), Mt !== null)
        for (r = Mt.return; r !== null;) {
            var n = r;
            switch (w1(n), n.tag) {
                case 1:
                    n = n.type.childContextTypes, n != null && Jd();
                    break;
                case 3:
                    qa(), ht(Pr), ht(dr), A1();
                    break;
                case 5:
                    O1(n);
                    break;
                case 4:
                    qa();
                    break;
                case 13:
                    ht(_t);
                    break;
                case 19:
                    ht(_t);
                    break;
                case 10:
                    S1(n.type._context);
                    break;
                case 22:
                case 23:
                    z1()
            }
            r = r.return
        }
    if (Vt = e, Mt = e = gs(e.current, null), nr = kr = t, Bt = 0, Kc = null, L1 = Sm = po = 0, Er = xc = null, eo !== null) {
        for (t = 0; t < eo.length; t++)
            if (r = eo[t], n = r.interleaved, n !== null) {
                r.interleaved = null;
                var i = n.next,
                    s = r.pending;
                if (s !== null) {
                    var o = s.next;
                    s.next = i, n.next = o
                }
                r.pending = n
            }
        eo = null
    }
    return e
}

function DI(e, t) {
    do {
        var r = Mt;
        try {
            if (E1(), gd.current = cf, lf) {
                for (var n = xt.memoizedState; n !== null;) {
                    var i = n.queue;
                    i !== null && (i.pending = null), n = n.next
                }
                lf = !1
            }
            if (fo = 0, Ht = Ft = xt = null, wc = !1, Wc = 0, N1.current = null, r === null || r.return === null) {
                Bt = 1, Kc = t, Mt = null;
                break
            }
            e: {
                var s = e,
                    o = r.return,
                    a = r,
                    l = t;
                if (t = nr, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l,
                        u = a,
                        h = u.tag;
                    if (!(u.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var d = u.alternate;
                        d ? (u.updateQueue = d.updateQueue, u.memoizedState = d.memoizedState, u.lanes = d.lanes) : (u.updateQueue = null, u.memoizedState = null)
                    }
                    var f = sE(o);
                    if (f !== null) {
                        f.flags &= -257, oE(f, o, a, s, t), f.mode & 1 && iE(s, c, t), t = f, l = c;
                        var p = t.updateQueue;
                        if (p === null) {
                            var m = new Set;
                            m.add(l), t.updateQueue = m
                        } else p.add(l);
                        break e
                    } else {
                        if (!(t & 1)) {
                            iE(s, c, t), j1();
                            break e
                        }
                        l = Error(re(426))
                    }
                } else if (pt && a.mode & 1) {
                    var w = sE(o);
                    if (w !== null) {
                        !(w.flags & 65536) && (w.flags |= 256), oE(w, o, a, s, t), b1(Qa(l, a));
                        break e
                    }
                }
                s = l = Qa(l, a),
                Bt !== 4 && (Bt = 2),
                xc === null ? xc = [s] : xc.push(s),
                s = o;do {
                    switch (s.tag) {
                        case 3:
                            s.flags |= 65536, t &= -t, s.lanes |= t;
                            var y = yI(s, l, t);
                            Qx(s, y);
                            break e;
                        case 1:
                            a = l;
                            var v = s.type,
                                _ = s.stateNode;
                            if (!(s.flags & 128) && (typeof v.getDerivedStateFromError == "function" || _ !== null && typeof _.componentDidCatch == "function" && (ps === null || !ps.has(_)))) {
                                s.flags |= 65536, t &= -t, s.lanes |= t;
                                var E = _I(s, a, t);
                                Qx(s, E);
                                break e
                            }
                    }
                    s = s.return
                } while (s !== null)
            }
            FI(r)
        } catch (P) {
            t = P, Mt === r && r !== null && (Mt = r = r.return);
            continue
        }
        break
    } while (1)
}

function NI() {
    var e = uf.current;
    return uf.current = cf, e === null ? cf : e
}

function j1() {
    (Bt === 0 || Bt === 3 || Bt === 2) && (Bt = 4), Vt === null || !(po & 268435455) && !(Sm & 268435455) || Ji(Vt, nr)
}

function ff(e, t) {
    var r = Ye;
    Ye |= 2;
    var n = NI();
    (Vt !== e || nr !== t) && (pi = null, io(e, t));
    do try {
        N8();
        break
    } catch (i) {
        DI(e, i)
    }
    while (1);
    if (E1(), Ye = r, uf.current = n, Mt !== null) throw Error(re(261));
    return Vt = null, nr = 0, Bt
}

function N8() {
    for (; Mt !== null;) LI(Mt)
}

function L8() {
    for (; Mt !== null && !lB();) LI(Mt)
}

function LI(e) {
    var t = zI(e.alternate, e, kr);
    e.memoizedProps = e.pendingProps, t === null ? FI(e) : Mt = t, N1.current = null
}

function FI(e) {
    var t = e;
    do {
        var r = t.alternate;
        if (e = t.return, t.flags & 32768) {
            if (r = I8(r, t), r !== null) {
                r.flags &= 32767, Mt = r;
                return
            }
            if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null;
            else {
                Bt = 6, Mt = null;
                return
            }
        } else if (r = A8(r, t, kr), r !== null) {
            Mt = r;
            return
        }
        if (t = t.sibling, t !== null) {
            Mt = t;
            return
        }
        Mt = t = e
    } while (t !== null);
    Bt === 0 && (Bt = 5)
}

function Us(e, t, r) {
    var n = it,
        i = tn.transition;
    try {
        tn.transition = null, it = 1, F8(e, t, r, n)
    } finally {
        tn.transition = i, it = n
    }
    return null
}

function F8(e, t, r, n) {
    do Ma(); while (ns !== null);
    if (Ye & 6) throw Error(re(327));
    r = e.finishedWork;
    var i = e.finishedLanes;
    if (r === null) return null;
    if (e.finishedWork = null, e.finishedLanes = 0, r === e.current) throw Error(re(177));
    e.callbackNode = null, e.callbackPriority = 0;
    var s = r.lanes | r.childLanes;
    if (yB(e, s), e === Vt && (Mt = Vt = null, nr = 0), !(r.subtreeFlags & 2064) && !(r.flags & 2064) || dh || (dh = !0, jI(Xd, function() {
            return Ma(), null
        })), s = (r.flags & 15990) !== 0, r.subtreeFlags & 15990 || s) {
        s = tn.transition, tn.transition = null;
        var o = it;
        it = 1;
        var a = Ye;
        Ye |= 4, N1.current = null, R8(e, r), RI(r, e), i8(sy), Kd = !!iy, sy = iy = null, e.current = r, k8(r), cB(), Ye = a, it = o, tn.transition = s
    } else e.current = r;
    if (dh && (dh = !1, ns = e, df = i), s = e.pendingLanes, s === 0 && (ps = null), dB(r.stateNode), Tr(e, Tt()), t !== null)
        for (n = e.onRecoverableError, r = 0; r < t.length; r++) i = t[r], n(i.value, {
            componentStack: i.stack,
            digest: i.digest
        });
    if (hf) throw hf = !1, e = Py, Py = null, e;
    return df & 1 && e.tag !== 0 && Ma(), s = e.pendingLanes, s & 1 ? e === Cy ? Ec++ : (Ec = 0, Cy = e) : Ec = 0, Is(), null
}

function Ma() {
    if (ns !== null) {
        var e = vA(df),
            t = tn.transition,
            r = it;
        try {
            if (tn.transition = null, it = 16 > e ? 16 : e, ns === null) var n = !1;
            else {
                if (e = ns, ns = null, df = 0, Ye & 6) throw Error(re(331));
                var i = Ye;
                for (Ye |= 4, fe = e.current; fe !== null;) {
                    var s = fe,
                        o = s.child;
                    if (fe.flags & 16) {
                        var a = s.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (fe = c; fe !== null;) {
                                    var u = fe;
                                    switch (u.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            bc(8, u, s)
                                    }
                                    var h = u.child;
                                    if (h !== null) h.return = u, fe = h;
                                    else
                                        for (; fe !== null;) {
                                            u = fe;
                                            var d = u.sibling,
                                                f = u.return;
                                            if (AI(u), u === c) {
                                                fe = null;
                                                break
                                            }
                                            if (d !== null) {
                                                d.return = f, fe = d;
                                                break
                                            }
                                            fe = f
                                        }
                                }
                            }
                            var p = s.alternate;
                            if (p !== null) {
                                var m = p.child;
                                if (m !== null) {
                                    p.child = null;
                                    do {
                                        var w = m.sibling;
                                        m.sibling = null, m = w
                                    } while (m !== null)
                                }
                            }
                            fe = s
                        }
                    }
                    if (s.subtreeFlags & 2064 && o !== null) o.return = s, fe = o;
                    else e: for (; fe !== null;) {
                        if (s = fe, s.flags & 2048) switch (s.tag) {
                            case 0:
                            case 11:
                            case 15:
                                bc(9, s, s.return)
                        }
                        var y = s.sibling;
                        if (y !== null) {
                            y.return = s.return, fe = y;
                            break e
                        }
                        fe = s.return
                    }
                }
                var v = e.current;
                for (fe = v; fe !== null;) {
                    o = fe;
                    var _ = o.child;
                    if (o.subtreeFlags & 2064 && _ !== null) _.return = o, fe = _;
                    else e: for (o = v; fe !== null;) {
                        if (a = fe, a.flags & 2048) try {
                            switch (a.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Em(9, a)
                            }
                        } catch (P) {
                            Pt(a, a.return, P)
                        }
                        if (a === o) {
                            fe = null;
                            break e
                        }
                        var E = a.sibling;
                        if (E !== null) {
                            E.return = a.return, fe = E;
                            break e
                        }
                        fe = a.return
                    }
                }
                if (Ye = i, Is(), ei && typeof ei.onPostCommitFiberRoot == "function") try {
                    ei.onPostCommitFiberRoot(mm, e)
                } catch {}
                n = !0
            }
            return n
        } finally {
            it = r, tn.transition = t
        }
    }
    return !1
}

function _E(e, t, r) {
    t = Qa(r, t), t = yI(e, t, 1), e = fs(e, t, 1), t = mr(), e !== null && (yu(e, 1, t), Tr(e, t))
}

function Pt(e, t, r) {
    if (e.tag === 3) _E(e, e, r);
    else
        for (; t !== null;) {
            if (t.tag === 3) {
                _E(t, e, r);
                break
            } else if (t.tag === 1) {
                var n = t.stateNode;
                if (typeof t.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (ps === null || !ps.has(n))) {
                    e = Qa(r, e), e = _I(t, e, 1), t = fs(t, e, 1), e = mr(), t !== null && (yu(t, 1, e), Tr(t, e));
                    break
                }
            }
            t = t.return
        }
}

function B8(e, t, r) {
    var n = e.pingCache;
    n !== null && n.delete(t), t = mr(), e.pingedLanes |= e.suspendedLanes & r, Vt === e && (nr & r) === r && (Bt === 4 || Bt === 3 && (nr & 130023424) === nr && 500 > Tt() - F1 ? io(e, 0) : L1 |= r), Tr(e, t)
}

function BI(e, t) {
    t === 0 && (e.mode & 1 ? (t = rh, rh <<= 1, !(rh & 130023424) && (rh = 4194304)) : t = 1);
    var r = mr();
    e = Ai(e, t), e !== null && (yu(e, t, r), Tr(e, r))
}

function z8(e) {
    var t = e.memoizedState,
        r = 0;
    t !== null && (r = t.retryLane), BI(e, r)
}

function j8(e, t) {
    var r = 0;
    switch (e.tag) {
        case 13:
            var n = e.stateNode,
                i = e.memoizedState;
            i !== null && (r = i.retryLane);
            break;
        case 19:
            n = e.stateNode;
            break;
        default:
            throw Error(re(314))
    }
    n !== null && n.delete(t), BI(e, r)
}
var zI;
zI = function(e, t, r) {
    if (e !== null)
        if (e.memoizedProps !== t.pendingProps || Pr.current) Sr = !0;
        else {
            if (!(e.lanes & r) && !(t.flags & 128)) return Sr = !1, O8(e, t, r);
            Sr = !!(e.flags & 131072)
        }
    else Sr = !1, pt && t.flags & 1048576 && HA(t, rf, t.index);
    switch (t.lanes = 0, t.tag) {
        case 2:
            var n = t.type;
            yd(e, t), e = t.pendingProps;
            var i = Xa(t, dr.current);
            ka(t, r), i = $1(null, t, n, e, i, r);
            var s = R1();
            return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Cr(n) ? (s = !0, ef(t)) : s = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, C1(t), i.updater = bm, t.stateNode = i, i._reactInternals = t, py(t, n, e, r), t = vy(null, t, n, !0, s, r)) : (t.tag = 0, pt && s && _1(t), pr(null, t, i, r), t = t.child), t;
        case 16:
            n = t.elementType;
            e: {
                switch (yd(e, t), e = t.pendingProps, i = n._init, n = i(n._payload), t.type = n, i = t.tag = H8(n), e = gn(n, e), i) {
                    case 0:
                        t = gy(null, t, n, e, r);
                        break e;
                    case 1:
                        t = cE(null, t, n, e, r);
                        break e;
                    case 11:
                        t = aE(null, t, n, e, r);
                        break e;
                    case 14:
                        t = lE(null, t, n, gn(n.type, e), r);
                        break e
                }
                throw Error(re(306, n, ""))
            }
            return t;
        case 0:
            return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : gn(n, i), gy(e, t, n, i, r);
        case 1:
            return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : gn(n, i), cE(e, t, n, i, r);
        case 3:
            e: {
                if (EI(t), e === null) throw Error(re(387));n = t.pendingProps,
                s = t.memoizedState,
                i = s.element,
                XA(e, t),
                of (t, n, null, r);
                var o = t.memoizedState;
                if (n = o.element, s.isDehydrated)
                    if (s = {
                            element: n,
                            isDehydrated: !1,
                            cache: o.cache,
                            pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                            transitions: o.transitions
                        }, t.updateQueue.baseState = s, t.memoizedState = s, t.flags & 256) {
                        i = Qa(Error(re(423)), t), t = uE(e, t, n, r, i);
                        break e
                    } else if (n !== i) {
                    i = Qa(Error(re(424)), t), t = uE(e, t, n, r, i);
                    break e
                } else
                    for (Mr = ds(t.stateNode.containerInfo.firstChild), Fr = t, pt = !0, _n = null, r = QA(t, null, n, r), t.child = r; r;) r.flags = r.flags & -3 | 4096, r = r.sibling;
                else {
                    if (Ya(), n === i) {
                        t = Ii(e, t, r);
                        break e
                    }
                    pr(e, t, n, r)
                }
                t = t.child
            }
            return t;
        case 5:
            return ZA(t), e === null && hy(t), n = t.type, i = t.pendingProps, s = e !== null ? e.memoizedProps : null, o = i.children, oy(n, i) ? o = null : s !== null && oy(n, s) && (t.flags |= 32), xI(e, t), pr(e, t, o, r), t.child;
        case 6:
            return e === null && hy(t), null;
        case 13:
            return SI(e, t, r);
        case 4:
            return T1(t, t.stateNode.containerInfo), n = t.pendingProps, e === null ? t.child = Ka(t, null, n, r) : pr(e, t, n, r), t.child;
        case 11:
            return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : gn(n, i), aE(e, t, n, i, r);
        case 7:
            return pr(e, t, t.pendingProps, r), t.child;
        case 8:
            return pr(e, t, t.pendingProps.children, r), t.child;
        case 12:
            return pr(e, t, t.pendingProps.children, r), t.child;
        case 10:
            e: {
                if (n = t.type._context, i = t.pendingProps, s = t.memoizedProps, o = i.value, ct(nf, n._currentValue), n._currentValue = o, s !== null)
                    if (kn(s.value, o)) {
                        if (s.children === i.children && !Pr.current) {
                            t = Ii(e, t, r);
                            break e
                        }
                    } else
                        for (s = t.child, s !== null && (s.return = t); s !== null;) {
                            var a = s.dependencies;
                            if (a !== null) {
                                o = s.child;
                                for (var l = a.firstContext; l !== null;) {
                                    if (l.context === n) {
                                        if (s.tag === 1) {
                                            l = Ei(-1, r & -r), l.tag = 2;
                                            var c = s.updateQueue;
                                            if (c !== null) {
                                                c = c.shared;
                                                var u = c.pending;
                                                u === null ? l.next = l : (l.next = u.next, u.next = l), c.pending = l
                                            }
                                        }
                                        s.lanes |= r, l = s.alternate, l !== null && (l.lanes |= r), dy(s.return, r, t), a.lanes |= r;
                                        break
                                    }
                                    l = l.next
                                }
                            } else if (s.tag === 10) o = s.type === t.type ? null : s.child;
                            else if (s.tag === 18) {
                                if (o = s.return, o === null) throw Error(re(341));
                                o.lanes |= r, a = o.alternate, a !== null && (a.lanes |= r), dy(o, r, t), o = s.sibling
                            } else o = s.child;
                            if (o !== null) o.return = s;
                            else
                                for (o = s; o !== null;) {
                                    if (o === t) {
                                        o = null;
                                        break
                                    }
                                    if (s = o.sibling, s !== null) {
                                        s.return = o.return, o = s;
                                        break
                                    }
                                    o = o.return
                                }
                            s = o
                        }
                pr(e, t, i.children, r),
                t = t.child
            }
            return t;
        case 9:
            return i = t.type, n = t.pendingProps.children, ka(t, r), i = rn(i), n = n(i), t.flags |= 1, pr(e, t, n, r), t.child;
        case 14:
            return n = t.type, i = gn(n, t.pendingProps), i = gn(n.type, i), lE(e, t, n, i, r);
        case 15:
            return wI(e, t, t.type, t.pendingProps, r);
        case 17:
            return n = t.type, i = t.pendingProps, i = t.elementType === n ? i : gn(n, i), yd(e, t), t.tag = 1, Cr(n) ? (e = !0, ef(t)) : e = !1, ka(t, r), KA(t, n, i), py(t, n, i, r), vy(null, t, n, !0, e, r);
        case 19:
            return PI(e, t, r);
        case 22:
            return bI(e, t, r)
    }
    throw Error(re(156, t.tag))
};

function jI(e, t) {
    return fA(e, t)
}

function U8(e, t, r, n) {
    this.tag = e, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = n, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function Zr(e, t, r, n) {
    return new U8(e, t, r, n)
}

function U1(e) {
    return e = e.prototype, !(!e || !e.isReactComponent)
}

function H8(e) {
    if (typeof e == "function") return U1(e) ? 1 : 0;
    if (e != null) {
        if (e = e.$$typeof, e === a1) return 11;
        if (e === l1) return 14
    }
    return 2
}

function gs(e, t) {
    var r = e.alternate;
    return r === null ? (r = Zr(e.tag, t, e.key, e.mode), r.elementType = e.elementType, r.type = e.type, r.stateNode = e.stateNode, r.alternate = e, e.alternate = r) : (r.pendingProps = t, r.type = e.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null), r.flags = e.flags & 14680064, r.childLanes = e.childLanes, r.lanes = e.lanes, r.child = e.child, r.memoizedProps = e.memoizedProps, r.memoizedState = e.memoizedState, r.updateQueue = e.updateQueue, t = e.dependencies, r.dependencies = t === null ? null : {
        lanes: t.lanes,
        firstContext: t.firstContext
    }, r.sibling = e.sibling, r.index = e.index, r.ref = e.ref, r
}

function bd(e, t, r, n, i, s) {
    var o = 2;
    if (n = e, typeof e == "function") U1(e) && (o = 1);
    else if (typeof e == "string") o = 5;
    else e: switch (e) {
        case ga:
            return so(r.children, i, s, t);
        case o1:
            o = 8, i |= 8;
            break;
        case F0:
            return e = Zr(12, r, t, i | 2), e.elementType = F0, e.lanes = s, e;
        case B0:
            return e = Zr(13, r, t, i), e.elementType = B0, e.lanes = s, e;
        case z0:
            return e = Zr(19, r, t, i), e.elementType = z0, e.lanes = s, e;
        case qO:
            return Pm(r, i, s, t);
        default:
            if (typeof e == "object" && e !== null) switch (e.$$typeof) {
                case YO:
                    o = 10;
                    break e;
                case KO:
                    o = 9;
                    break e;
                case a1:
                    o = 11;
                    break e;
                case l1:
                    o = 14;
                    break e;
                case qi:
                    o = 16, n = null;
                    break e
            }
            throw Error(re(130, e == null ? e : typeof e, ""))
    }
    return t = Zr(o, r, t, i), t.elementType = e, t.type = n, t.lanes = s, t
}

function so(e, t, r, n) {
    return e = Zr(7, e, n, t), e.lanes = r, e
}

function Pm(e, t, r, n) {
    return e = Zr(22, e, n, t), e.elementType = qO, e.lanes = r, e.stateNode = {
        isHidden: !1
    }, e
}

function Pv(e, t, r) {
    return e = Zr(6, e, null, t), e.lanes = r, e
}

function Cv(e, t, r) {
    return t = Zr(4, e.children !== null ? e.children : [], e.key, t), t.lanes = r, t.stateNode = {
        containerInfo: e.containerInfo,
        pendingChildren: null,
        implementation: e.implementation
    }, t
}

function G8(e, t, r, n, i) {
    this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ov(0), this.expirationTimes = ov(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ov(0), this.identifierPrefix = n, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
}

function H1(e, t, r, n, i, s, o, a, l) {
    return e = new G8(e, t, r, a, l), t === 1 ? (t = 1, s === !0 && (t |= 8)) : t = 0, s = Zr(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = {
        element: n,
        isDehydrated: r,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    }, C1(s), e
}

function V8(e, t, r) {
    var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: ma,
        key: n == null ? null : "" + n,
        children: e,
        containerInfo: t,
        implementation: r
    }
}

function UI(e) {
    if (!e) return Es;
    e = e._reactInternals;
    e: {
        if (So(e) !== e || e.tag !== 1) throw Error(re(170));
        var t = e;do {
            switch (t.tag) {
                case 3:
                    t = t.stateNode.context;
                    break e;
                case 1:
                    if (Cr(t.type)) {
                        t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                        break e
                    }
            }
            t = t.return
        } while (t !== null);
        throw Error(re(171))
    }
    if (e.tag === 1) {
        var r = e.type;
        if (Cr(r)) return jA(e, r, t)
    }
    return t
}

function HI(e, t, r, n, i, s, o, a, l) {
    return e = H1(r, n, !0, e, i, s, o, a, l), e.context = UI(null), r = e.current, n = mr(), i = ms(r), s = Ei(n, i), s.callback = t??null, fs(r, s, i), e.current.lanes = i, yu(e, i, n), Tr(e, n), e
}

function Cm(e, t, r, n) {
    var i = t.current,
        s = mr(),
        o = ms(i);
    return r = UI(r), t.context === null ? t.context = r : t.pendingContext = r, t = Ei(s, o), t.payload = {
        element: e
    }, n = n === void 0 ? null : n, n !== null && (t.callback = n), e = fs(i, t, o), e !== null && (Tn(e, i, o, s), md(e, i, o)), o
}

function pf(e) {
    if (e = e.current, !e.child) return null;
    switch (e.child.tag) {
        case 5:
            return e.child.stateNode;
        default:
            return e.child.stateNode
    }
}

function wE(e, t) {
    if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
        var r = e.retryLane;
        e.retryLane = r !== 0 && r < t ? r : t
    }
}

function G1(e, t) {
    wE(e, t), (e = e.alternate) && wE(e, t)
}

function W8() {
    return null
}
var GI = typeof reportError == "function" ? reportError : function(e) {
    console.error(e)
};

function V1(e) {
    this._internalRoot = e
}
Tm.prototype.render = V1.prototype.render = function(e) {
    var t = this._internalRoot;
    if (t === null) throw Error(re(409));
    Cm(e, t, null, null)
};
Tm.prototype.unmount = V1.prototype.unmount = function() {
    var e = this._internalRoot;
    if (e !== null) {
        this._internalRoot = null;
        var t = e.containerInfo;
        mo(function() {
            Cm(null, e, null, null)
        }), t[Oi] = null
    }
};

function Tm(e) {
    this._internalRoot = e
}
Tm.prototype.unstable_scheduleHydration = function(e) {
    if (e) {
        var t = wA();
        e = {
            blockedOn: null,
            target: e,
            priority: t
        };
        for (var r = 0; r < Zi.length && t !== 0 && t < Zi[r].priority; r++);
        Zi.splice(r, 0, e), r === 0 && xA(e)
    }
};

function W1(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11)
}

function Om(e) {
    return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
}

function bE() {}

function X8(e, t, r, n, i) {
    if (i) {
        if (typeof n == "function") {
            var s = n;
            n = function() {
                var c = pf(o);
                s.call(c)
            }
        }
        var o = HI(t, n, e, 0, null, !1, !1, "", bE);
        return e._reactRootContainer = o, e[Oi] = o.current, jc(e.nodeType === 8 ? e.parentNode : e), mo(), o
    }
    for (; i = e.lastChild;) e.removeChild(i);
    if (typeof n == "function") {
        var a = n;
        n = function() {
            var c = pf(l);
            a.call(c)
        }
    }
    var l = H1(e, 0, !1, null, null, !1, !1, "", bE);
    return e._reactRootContainer = l, e[Oi] = l.current, jc(e.nodeType === 8 ? e.parentNode : e), mo(function() {
        Cm(t, l, r, n)
    }), l
}

function Am(e, t, r, n, i) {
    var s = r._reactRootContainer;
    if (s) {
        var o = s;
        if (typeof i == "function") {
            var a = i;
            i = function() {
                var l = pf(o);
                a.call(l)
            }
        }
        Cm(t, o, e, i)
    } else o = X8(r, t, e, i, n);
    return pf(o)
}
yA = function(e) {
    switch (e.tag) {
        case 3:
            var t = e.stateNode;
            if (t.current.memoizedState.isDehydrated) {
                var r = oc(t.pendingLanes);
                r !== 0 && (h1(t, r | 1), Tr(t, Tt()), !(Ye & 6) && (Za = Tt() + 500, Is()))
            }
            break;
        case 13:
            mo(function() {
                var n = Ai(e, 1);
                if (n !== null) {
                    var i = mr();
                    Tn(n, e, 1, i)
                }
            }), G1(e, 1)
    }
};
d1 = function(e) {
    if (e.tag === 13) {
        var t = Ai(e, 134217728);
        if (t !== null) {
            var r = mr();
            Tn(t, e, 134217728, r)
        }
        G1(e, 134217728)
    }
};
_A = function(e) {
    if (e.tag === 13) {
        var t = ms(e),
            r = Ai(e, t);
        if (r !== null) {
            var n = mr();
            Tn(r, e, t, n)
        }
        G1(e, t)
    }
};
wA = function() {
    return it
};
bA = function(e, t) {
    var r = it;
    try {
        return it = e, t()
    } finally {
        it = r
    }
};
q0 = function(e, t, r) {
    switch (t) {
        case "input":
            if (H0(e, r), t = r.name, r.type === "radio" && t != null) {
                for (r = e; r.parentNode;) r = r.parentNode;
                for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < r.length; t++) {
                    var n = r[t];
                    if (n !== e && n.form === e.form) {
                        var i = _m(n);
                        if (!i) throw Error(re(90));
                        ZO(n), H0(n, i)
                    }
                }
            }
            break;
        case "textarea":
            eA(e, r);
            break;
        case "select":
            t = r.value, t != null && Aa(e, !!r.multiple, t, !1)
    }
};
aA = B1;
lA = mo;
var Y8 = {
        usingClientEntryPoint: !1,
        Events: [wu, wa, _m, sA, oA, B1]
    },
    Bl = {
        findFiberByHostInstance: Js,
        bundleType: 0,
        version: "18.2.0",
        rendererPackageName: "react-dom"
    },
    K8 = {
        bundleType: Bl.bundleType,
        version: Bl.version,
        rendererPackageName: Bl.rendererPackageName,
        rendererConfig: Bl.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: Ri.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(e) {
            return e = hA(e), e === null ? null : e.stateNode
        },
        findFiberByHostInstance: Bl.findFiberByHostInstance || W8,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
    };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var fh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!fh.isDisabled && fh.supportsFiber) try {
        mm = fh.inject(K8), ei = fh
    } catch {}
}
Ur.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y8;
Ur.createPortal = function(e, t) {
    var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!W1(t)) throw Error(re(200));
    return V8(e, t, null, r)
};
Ur.createRoot = function(e, t) {
    if (!W1(e)) throw Error(re(299));
    var r = !1,
        n = "",
        i = GI;
    return t != null && (t.unstable_strictMode === !0 && (r = !0), t.identifierPrefix !== void 0 && (n = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = H1(e, 1, !1, null, null, r, !1, n, i), e[Oi] = t.current, jc(e.nodeType === 8 ? e.parentNode : e), new V1(t)
};
Ur.findDOMNode = function(e) {
    if (e == null) return null;
    if (e.nodeType === 1) return e;
    var t = e._reactInternals;
    if (t === void 0) throw typeof e.render == "function" ? Error(re(188)) : (e = Object.keys(e).join(","), Error(re(268, e)));
    return e = hA(t), e = e === null ? null : e.stateNode, e
};
Ur.flushSync = function(e) {
    return mo(e)
};
Ur.hydrate = function(e, t, r) {
    if (!Om(t)) throw Error(re(200));
    return Am(null, e, t, !0, r)
};
Ur.hydrateRoot = function(e, t, r) {
    if (!W1(e)) throw Error(re(405));
    var n = r != null && r.hydratedSources || null,
        i = !1,
        s = "",
        o = GI;
    if (r != null && (r.unstable_strictMode === !0 && (i = !0), r.identifierPrefix !== void 0 && (s = r.identifierPrefix), r.onRecoverableError !== void 0 && (o = r.onRecoverableError)), t = HI(t, null, e, 1, r??null, i, !1, s, o), e[Oi] = t.current, jc(e), n)
        for (e = 0; e < n.length; e++) r = n[e], i = r._getVersion, i = i(r._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [r, i] : t.mutableSourceEagerHydrationData.push(r, i);
    return new Tm(t)
};
Ur.render = function(e, t, r) {
    if (!Om(t)) throw Error(re(200));
    return Am(null, e, t, !1, r)
};
Ur.unmountComponentAtNode = function(e) {
    if (!Om(e)) throw Error(re(40));
    return e._reactRootContainer ? (mo(function() {
        Am(null, null, e, !1, function() {
            e._reactRootContainer = null, e[Oi] = null
        })
    }), !0) : !1
};
Ur.unstable_batchedUpdates = B1;
Ur.unstable_renderSubtreeIntoContainer = function(e, t, r, n) {
    if (!Om(r)) throw Error(re(200));
    if (e == null || e._reactInternals === void 0) throw Error(re(38));
    return Am(e, t, r, !1, n)
};
Ur.version = "18.2.0-next-9e3b772b8-20220608";
(function(e) {
    function t() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
        } catch (r) {
            console.error(r)
        }
    }
    t(), e.exports = Ur
})(WF);
const Tv = NO(Ci);
var xE = Ci;
D0.createRoot = xE.createRoot, D0.hydrateRoot = xE.hydrateRoot;
var Po = (e => (e[e.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", e[e.WEBGL = 1] = "WEBGL", e[e.WEBGL2 = 2] = "WEBGL2", e))(Po || {}),
    VI = (e => (e[e.UNKNOWN = 0] = "UNKNOWN", e[e.WEBGL = 1] = "WEBGL", e[e.CANVAS = 2] = "CANVAS", e))(VI || {}),
    Ay = (e => (e[e.COLOR = 16384] = "COLOR", e[e.DEPTH = 256] = "DEPTH", e[e.STENCIL = 1024] = "STENCIL", e))(Ay || {}),
    Ce = (e => (e[e.NORMAL = 0] = "NORMAL", e[e.ADD = 1] = "ADD", e[e.MULTIPLY = 2] = "MULTIPLY", e[e.SCREEN = 3] = "SCREEN", e[e.OVERLAY = 4] = "OVERLAY", e[e.DARKEN = 5] = "DARKEN", e[e.LIGHTEN = 6] = "LIGHTEN", e[e.COLOR_DODGE = 7] = "COLOR_DODGE", e[e.COLOR_BURN = 8] = "COLOR_BURN", e[e.HARD_LIGHT = 9] = "HARD_LIGHT", e[e.SOFT_LIGHT = 10] = "SOFT_LIGHT", e[e.DIFFERENCE = 11] = "DIFFERENCE", e[e.EXCLUSION = 12] = "EXCLUSION", e[e.HUE = 13] = "HUE", e[e.SATURATION = 14] = "SATURATION", e[e.COLOR = 15] = "COLOR", e[e.LUMINOSITY = 16] = "LUMINOSITY", e[e.NORMAL_NPM = 17] = "NORMAL_NPM", e[e.ADD_NPM = 18] = "ADD_NPM", e[e.SCREEN_NPM = 19] = "SCREEN_NPM", e[e.NONE = 20] = "NONE", e[e.SRC_OVER = 0] = "SRC_OVER", e[e.SRC_IN = 21] = "SRC_IN", e[e.SRC_OUT = 22] = "SRC_OUT", e[e.SRC_ATOP = 23] = "SRC_ATOP", e[e.DST_OVER = 24] = "DST_OVER", e[e.DST_IN = 25] = "DST_IN", e[e.DST_OUT = 26] = "DST_OUT", e[e.DST_ATOP = 27] = "DST_ATOP", e[e.ERASE = 26] = "ERASE", e[e.SUBTRACT = 28] = "SUBTRACT", e[e.XOR = 29] = "XOR", e))(Ce || {}),
    Zn = (e => (e[e.POINTS = 0] = "POINTS", e[e.LINES = 1] = "LINES", e[e.LINE_LOOP = 2] = "LINE_LOOP", e[e.LINE_STRIP = 3] = "LINE_STRIP", e[e.TRIANGLES = 4] = "TRIANGLES", e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", e))(Zn || {}),
    se = (e => (e[e.RGBA = 6408] = "RGBA", e[e.RGB = 6407] = "RGB", e[e.RG = 33319] = "RG", e[e.RED = 6403] = "RED", e[e.RGBA_INTEGER = 36249] = "RGBA_INTEGER", e[e.RGB_INTEGER = 36248] = "RGB_INTEGER", e[e.RG_INTEGER = 33320] = "RG_INTEGER", e[e.RED_INTEGER = 36244] = "RED_INTEGER", e[e.ALPHA = 6406] = "ALPHA", e[e.LUMINANCE = 6409] = "LUMINANCE", e[e.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", e[e.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", e[e.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", e))(se || {}),
    Da = (e => (e[e.TEXTURE_2D = 3553] = "TEXTURE_2D", e[e.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", e[e.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", e[e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", e[e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", e[e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", e[e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", e))(Da || {}),
    be = (e => (e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e[e.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", e[e.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", e[e.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT", e[e.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", e[e.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", e[e.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", e[e.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", e[e.BYTE = 5120] = "BYTE", e[e.SHORT = 5122] = "SHORT", e[e.INT = 5124] = "INT", e[e.FLOAT = 5126] = "FLOAT", e[e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", e[e.HALF_FLOAT = 36193] = "HALF_FLOAT", e))(be || {}),
    Iy = (e => (e[e.FLOAT = 0] = "FLOAT", e[e.INT = 1] = "INT", e[e.UINT = 2] = "UINT", e))(Iy || {}),
    bi = (e => (e[e.NEAREST = 0] = "NEAREST", e[e.LINEAR = 1] = "LINEAR", e))(bi || {}),
    vs = (e => (e[e.CLAMP = 33071] = "CLAMP", e[e.REPEAT = 10497] = "REPEAT", e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", e))(vs || {}),
    si = (e => (e[e.OFF = 0] = "OFF", e[e.POW2 = 1] = "POW2", e[e.ON = 2] = "ON", e[e.ON_MANUAL = 3] = "ON_MANUAL", e))(si || {}),
    Nn = (e => (e[e.NPM = 0] = "NPM", e[e.UNPACK = 1] = "UNPACK", e[e.PMA = 2] = "PMA", e[e.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", e[e.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", e[e.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", e))(Nn || {}),
    Vn = (e => (e[e.NO = 0] = "NO", e[e.YES = 1] = "YES", e[e.AUTO = 2] = "AUTO", e[e.BLEND = 0] = "BLEND", e[e.CLEAR = 1] = "CLEAR", e[e.BLIT = 2] = "BLIT", e))(Vn || {}),
    X1 = (e => (e[e.AUTO = 0] = "AUTO", e[e.MANUAL = 1] = "MANUAL", e))(X1 || {}),
    Jr = (e => (e.LOW = "lowp", e.MEDIUM = "mediump", e.HIGH = "highp", e))(Jr || {}),
    Lt = (e => (e[e.NONE = 0] = "NONE", e[e.SCISSOR = 1] = "SCISSOR", e[e.STENCIL = 2] = "STENCIL", e[e.SPRITE = 3] = "SPRITE", e[e.COLOR = 4] = "COLOR", e))(Lt || {}),
    Rt = (e => (e[e.NONE = 0] = "NONE", e[e.LOW = 2] = "LOW", e[e.MEDIUM = 4] = "MEDIUM", e[e.HIGH = 8] = "HIGH", e))(Rt || {}),
    ri = (e => (e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", e))(ri || {});
const q8 = {
        createCanvas: (e, t) => {
            const r = document.createElement("canvas");
            return r.width = e, r.height = t, r
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI??window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (e, t) => fetch(e, t),
        parseXML: e => new DOMParser().parseFromString(e, "text/xml")
    },
    ce = {
        ADAPTER: q8,
        RESOLUTION: 1,
        CREATE_IMAGE_BITMAP: !1,
        ROUND_PIXELS: !1
    };
var Ov = /iPhone/i,
    EE = /iPod/i,
    SE = /iPad/i,
    PE = /\biOS-universal(?:.+)Mac\b/i,
    Av = /\bAndroid(?:.+)Mobile\b/i,
    CE = /Android/i,
    Yo = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    ph = /Silk/i,
    hi = /Windows Phone/i,
    TE = /\bWindows(?:.+)ARM\b/i,
    OE = /BlackBerry/i,
    AE = /BB10/i,
    IE = /Opera Mini/i,
    $E = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    RE = /Mobile(?:.+)Firefox\b/i,
    kE = function(e) {
        return typeof e < "u" && e.platform === "MacIntel" && typeof e.maxTouchPoints == "number" && e.maxTouchPoints > 1 && typeof MSStream > "u"
    };

function Q8(e) {
    return function(t) {
        return t.test(e)
    }
}

function ME(e) {
    var t = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    !e && typeof navigator < "u" ? t = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof e == "string" ? t.userAgent = e : e && e.userAgent && (t = {
        userAgent: e.userAgent,
        platform: e.platform,
        maxTouchPoints: e.maxTouchPoints || 0
    });
    var r = t.userAgent,
        n = r.split("[FBAN");
    typeof n[1] < "u" && (r = n[0]), n = r.split("Twitter"), typeof n[1] < "u" && (r = n[0]);
    var i = Q8(r),
        s = {
            apple: {
                phone: i(Ov) && !i(hi),
                ipod: i(EE),
                tablet: !i(Ov) && (i(SE) || kE(t)) && !i(hi),
                universal: i(PE),
                device: (i(Ov) || i(EE) || i(SE) || i(PE) || kE(t)) && !i(hi)
            },
            amazon: {
                phone: i(Yo),
                tablet: !i(Yo) && i(ph),
                device: i(Yo) || i(ph)
            },
            android: {
                phone: !i(hi) && i(Yo) || !i(hi) && i(Av),
                tablet: !i(hi) && !i(Yo) && !i(Av) && (i(ph) || i(CE)),
                device: !i(hi) && (i(Yo) || i(ph) || i(Av) || i(CE)) || i(/\bokhttp\b/i)
            },
            windows: {
                phone: i(hi),
                tablet: i(TE),
                device: i(hi) || i(TE)
            },
            other: {
                blackberry: i(OE),
                blackberry10: i(AE),
                opera: i(IE),
                firefox: i(RE),
                chrome: i($E),
                device: i(OE) || i(AE) || i(IE) || i(RE) || i($E)
            },
            any: !1,
            phone: !1,
            tablet: !1
        };
    return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s
}
const Z8 = ME.default??ME,
    xi = Z8(globalThis.navigator);
ce.RETINA_PREFIX = /@([0-9\.]+)x/;
ce.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var go = {},
    J8 = {
        get exports() {
            return go
        },
        set exports(e) {
            go = e
        }
    };
(function(e) {
    var t = Object.prototype.hasOwnProperty,
        r = "~";

    function n() {}
    Object.create && (n.prototype = Object.create(null), new n().__proto__ || (r = !1));

    function i(l, c, u) {
        this.fn = l, this.context = c, this.once = u || !1
    }

    function s(l, c, u, h, d) {
        if (typeof u != "function") throw new TypeError("The listener must be a function");
        var f = new i(u, h || l, d),
            p = r ? r + c : c;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], f] : l._events[p].push(f) : (l._events[p] = f, l._eventsCount++), l
    }

    function o(l, c) {
        --l._eventsCount === 0 ? l._events = new n : delete l._events[c]
    }

    function a() {
        this._events = new n, this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [],
            u, h;
        if (this._eventsCount === 0) return c;
        for (h in u = this._events) t.call(u, h) && c.push(r ? h.slice(1) : h);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c
    }, a.prototype.listeners = function(c) {
        var u = r ? r + c : c,
            h = this._events[u];
        if (!h) return [];
        if (h.fn) return [h.fn];
        for (var d = 0, f = h.length, p = new Array(f); d < f; d++) p[d] = h[d].fn;
        return p
    }, a.prototype.listenerCount = function(c) {
        var u = r ? r + c : c,
            h = this._events[u];
        return h ? h.fn ? 1 : h.length : 0
    }, a.prototype.emit = function(c, u, h, d, f, p) {
        var m = r ? r + c : c;
        if (!this._events[m]) return !1;
        var w = this._events[m],
            y = arguments.length,
            v, _;
        if (w.fn) {
            switch (w.once && this.removeListener(c, w.fn, void 0, !0), y) {
                case 1:
                    return w.fn.call(w.context), !0;
                case 2:
                    return w.fn.call(w.context, u), !0;
                case 3:
                    return w.fn.call(w.context, u, h), !0;
                case 4:
                    return w.fn.call(w.context, u, h, d), !0;
                case 5:
                    return w.fn.call(w.context, u, h, d, f), !0;
                case 6:
                    return w.fn.call(w.context, u, h, d, f, p), !0
            }
            for (_ = 1, v = new Array(y - 1); _ < y; _++) v[_ - 1] = arguments[_];
            w.fn.apply(w.context, v)
        } else {
            var E = w.length,
                P;
            for (_ = 0; _ < E; _++) switch (w[_].once && this.removeListener(c, w[_].fn, void 0, !0), y) {
                case 1:
                    w[_].fn.call(w[_].context);
                    break;
                case 2:
                    w[_].fn.call(w[_].context, u);
                    break;
                case 3:
                    w[_].fn.call(w[_].context, u, h);
                    break;
                case 4:
                    w[_].fn.call(w[_].context, u, h, d);
                    break;
                default:
                    if (!v)
                        for (P = 1, v = new Array(y - 1); P < y; P++) v[P - 1] = arguments[P];
                    w[_].fn.apply(w[_].context, v)
            }
        }
        return !0
    }, a.prototype.on = function(c, u, h) {
        return s(this, c, u, h, !1)
    }, a.prototype.once = function(c, u, h) {
        return s(this, c, u, h, !0)
    }, a.prototype.removeListener = function(c, u, h, d) {
        var f = r ? r + c : c;
        if (!this._events[f]) return this;
        if (!u) return o(this, f), this;
        var p = this._events[f];
        if (p.fn) p.fn === u && (!d || p.once) && (!h || p.context === h) && o(this, f);
        else {
            for (var m = 0, w = [], y = p.length; m < y; m++)(p[m].fn !== u || d && !p[m].once || h && p[m].context !== h) && w.push(p[m]);
            w.length ? this._events[f] = w.length === 1 ? w[0] : w : o(this, f)
        }
        return this
    }, a.prototype.removeAllListeners = function(c) {
        var u;
        return c ? (u = r ? r + c : c, this._events[u] && o(this, u)) : (this._events = new n, this._eventsCount = 0), this
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, e.exports = a
})(J8);
var mf = {},
    e7 = {
        get exports() {
            return mf
        },
        set exports(e) {
            mf = e
        }
    };
e7.exports = Im;
mf.default = Im;

function Im(e, t, r) {
    r = r || 2;
    var n = t && t.length,
        i = n ? t[0] * r : e.length,
        s = WI(e, 0, i, r, !0),
        o = [];
    if (!s || s.next === s.prev) return o;
    var a, l, c, u, h, d, f;
    if (n && (s = s7(e, t, s, r)), e.length > 80 * r) {
        a = c = e[0], l = u = e[1];
        for (var p = r; p < i; p += r) h = e[p], d = e[p + 1], h < a && (a = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
        f = Math.max(c - a, u - l), f = f !== 0 ? 32767 / f : 0
    }
    return qc(s, o, r, a, l, f, 0), o
}

function WI(e, t, r, n, i) {
    var s, o;
    if (i === ky(e, t, r, n) > 0)
        for (s = t; s < r; s += n) o = DE(s, e[s], e[s + 1], o);
    else
        for (s = r - n; s >= t; s -= n) o = DE(s, e[s], e[s + 1], o);
    return o && $m(o, o.next) && (Zc(o), o = o.next), o
}

function vo(e, t) {
    if (!e) return e;
    t || (t = e);
    var r = e,
        n;
    do
        if (n = !1, !r.steiner && ($m(r, r.next) || wt(r.prev, r, r.next) === 0)) {
            if (Zc(r), r = t = r.prev, r === r.next) break;
            n = !0
        } else r = r.next; while (n || r !== t);
    return t
}

function qc(e, t, r, n, i, s, o) {
    if (e) {
        !o && s && u7(e, n, i, s);
        for (var a = e, l, c; e.prev !== e.next;) {
            if (l = e.prev, c = e.next, s ? r7(e, n, i, s) : t7(e)) {
                t.push(l.i / r | 0), t.push(e.i / r | 0), t.push(c.i / r | 0), Zc(e), e = c.next, a = c.next;
                continue
            }
            if (e = c, e === a) {
                o ? o === 1 ? (e = n7(vo(e), t, r), qc(e, t, r, n, i, s, 2)) : o === 2 && i7(e, t, r, n, i, s) : qc(vo(e), t, r, n, i, s, 1);
                break
            }
        }
    }
}

function t7(e) {
    var t = e.prev,
        r = e,
        n = e.next;
    if (wt(t, r, n) >= 0) return !1;
    for (var i = t.x, s = r.x, o = n.x, a = t.y, l = r.y, c = n.y, u = i < s ? i < o ? i : o : s < o ? s : o, h = a < l ? a < c ? a : c : l < c ? l : c, d = i > s ? i > o ? i : o : s > o ? s : o, f = a > l ? a > c ? a : c : l > c ? l : c, p = n.next; p !== t;) {
        if (p.x >= u && p.x <= d && p.y >= h && p.y <= f && Ta(i, a, s, l, o, c, p.x, p.y) && wt(p.prev, p, p.next) >= 0) return !1;
        p = p.next
    }
    return !0
}

function r7(e, t, r, n) {
    var i = e.prev,
        s = e,
        o = e.next;
    if (wt(i, s, o) >= 0) return !1;
    for (var a = i.x, l = s.x, c = o.x, u = i.y, h = s.y, d = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, p = u < h ? u < d ? u : d : h < d ? h : d, m = a > l ? a > c ? a : c : l > c ? l : c, w = u > h ? u > d ? u : d : h > d ? h : d, y = $y(f, p, t, r, n), v = $y(m, w, t, r, n), _ = e.prevZ, E = e.nextZ; _ && _.z >= y && E && E.z <= v;) {
        if (_.x >= f && _.x <= m && _.y >= p && _.y <= w && _ !== i && _ !== o && Ta(a, u, l, h, c, d, _.x, _.y) && wt(_.prev, _, _.next) >= 0 || (_ = _.prevZ, E.x >= f && E.x <= m && E.y >= p && E.y <= w && E !== i && E !== o && Ta(a, u, l, h, c, d, E.x, E.y) && wt(E.prev, E, E.next) >= 0)) return !1;
        E = E.nextZ
    }
    for (; _ && _.z >= y;) {
        if (_.x >= f && _.x <= m && _.y >= p && _.y <= w && _ !== i && _ !== o && Ta(a, u, l, h, c, d, _.x, _.y) && wt(_.prev, _, _.next) >= 0) return !1;
        _ = _.prevZ
    }
    for (; E && E.z <= v;) {
        if (E.x >= f && E.x <= m && E.y >= p && E.y <= w && E !== i && E !== o && Ta(a, u, l, h, c, d, E.x, E.y) && wt(E.prev, E, E.next) >= 0) return !1;
        E = E.nextZ
    }
    return !0
}

function n7(e, t, r) {
    var n = e;
    do {
        var i = n.prev,
            s = n.next.next;
        !$m(i, s) && XI(i, n, n.next, s) && Qc(i, s) && Qc(s, i) && (t.push(i.i / r | 0), t.push(n.i / r | 0), t.push(s.i / r | 0), Zc(n), Zc(n.next), n = e = s), n = n.next
    } while (n !== e);
    return vo(n)
}

function i7(e, t, r, n, i, s) {
    var o = e;
    do {
        for (var a = o.next.next; a !== o.prev;) {
            if (o.i !== a.i && f7(o, a)) {
                var l = YI(o, a);
                o = vo(o, o.next), l = vo(l, l.next), qc(o, t, r, n, i, s, 0), qc(l, t, r, n, i, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== e)
}

function s7(e, t, r, n) {
    var i = [],
        s, o, a, l, c;
    for (s = 0, o = t.length; s < o; s++) a = t[s] * n, l = s < o - 1 ? t[s + 1] * n : e.length, c = WI(e, a, l, n, !1), c === c.next && (c.steiner = !0), i.push(d7(c));
    for (i.sort(o7), s = 0; s < i.length; s++) r = a7(i[s], r);
    return r
}

function o7(e, t) {
    return e.x - t.x
}

function a7(e, t) {
    var r = l7(e, t);
    if (!r) return t;
    var n = YI(r, e);
    return vo(n, n.next), vo(r, r.next)
}

function l7(e, t) {
    var r = t,
        n = e.x,
        i = e.y,
        s = -1 / 0,
        o;
    do {
        if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {
            var a = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
            if (a <= n && a > s && (s = a, o = r.x < r.next.x ? r : r.next, a === n)) return o
        }
        r = r.next
    } while (r !== t);
    if (!o) return null;
    var l = o,
        c = o.x,
        u = o.y,
        h = 1 / 0,
        d;
    r = o;
    do n >= r.x && r.x >= c && n !== r.x && Ta(i < u ? n : s, i, c, u, i < u ? s : n, i, r.x, r.y) && (d = Math.abs(i - r.y) / (n - r.x), Qc(r, e) && (d < h || d === h && (r.x > o.x || r.x === o.x && c7(o, r))) && (o = r, h = d)), r = r.next; while (r !== l);
    return o
}

function c7(e, t) {
    return wt(e.prev, e, t.prev) < 0 && wt(t.next, e, e.next) < 0
}

function u7(e, t, r, n) {
    var i = e;
    do i.z === 0 && (i.z = $y(i.x, i.y, t, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== e);
    i.prevZ.nextZ = null, i.prevZ = null, h7(i)
}

function h7(e) {
    var t, r, n, i, s, o, a, l, c = 1;
    do {
        for (r = e, e = null, s = null, o = 0; r;) {
            for (o++, n = r, a = 0, t = 0; t < c && (a++, n = n.nextZ, !!n); t++);
            for (l = c; a > 0 || l > 0 && n;) a !== 0 && (l === 0 || !n || r.z <= n.z) ? (i = r, r = r.nextZ, a--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : e = i, i.prevZ = s, s = i;
            r = n
        }
        s.nextZ = null, c *= 2
    } while (o > 1);
    return e
}

function $y(e, t, r, n, i) {
    return e = (e - r) * i | 0, t = (t - n) * i | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1
}

function d7(e) {
    var t = e,
        r = e;
    do(t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next; while (t !== e);
    return r
}

function Ta(e, t, r, n, i, s, o, a) {
    return (i - o) * (t - a) >= (e - o) * (s - a) && (e - o) * (n - a) >= (r - o) * (t - a) && (r - o) * (s - a) >= (i - o) * (n - a)
}

function f7(e, t) {
    return e.next.i !== t.i && e.prev.i !== t.i && !p7(e, t) && (Qc(e, t) && Qc(t, e) && m7(e, t) && (wt(e.prev, e, t.prev) || wt(e, t.prev, t)) || $m(e, t) && wt(e.prev, e, e.next) > 0 && wt(t.prev, t, t.next) > 0)
}

function wt(e, t, r) {
    return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y)
}

function $m(e, t) {
    return e.x === t.x && e.y === t.y
}

function XI(e, t, r, n) {
    var i = gh(wt(e, t, r)),
        s = gh(wt(e, t, n)),
        o = gh(wt(r, n, e)),
        a = gh(wt(r, n, t));
    return !!(i !== s && o !== a || i === 0 && mh(e, r, t) || s === 0 && mh(e, n, t) || o === 0 && mh(r, e, n) || a === 0 && mh(r, t, n))
}

function mh(e, t, r) {
    return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y)
}

function gh(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
}

function p7(e, t) {
    var r = e;
    do {
        if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && XI(r, r.next, e, t)) return !0;
        r = r.next
    } while (r !== e);
    return !1
}

function Qc(e, t) {
    return wt(e.prev, e, e.next) < 0 ? wt(e, t, e.next) >= 0 && wt(e, e.prev, t) >= 0 : wt(e, t, e.prev) < 0 || wt(e, e.next, t) < 0
}

function m7(e, t) {
    var r = e,
        n = !1,
        i = (e.x + t.x) / 2,
        s = (e.y + t.y) / 2;
    do r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next; while (r !== e);
    return n
}

function YI(e, t) {
    var r = new Ry(e.i, e.x, e.y),
        n = new Ry(t.i, t.x, t.y),
        i = e.next,
        s = t.prev;
    return e.next = t, t.prev = e, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n
}

function DE(e, t, r, n) {
    var i = new Ry(e, t, r);
    return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i
}

function Zc(e) {
    e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
}

function Ry(e, t, r) {
    this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}
Im.deviation = function(e, t, r, n) {
    var i = t && t.length,
        s = i ? t[0] * r : e.length,
        o = Math.abs(ky(e, 0, s, r));
    if (i)
        for (var a = 0, l = t.length; a < l; a++) {
            var c = t[a] * r,
                u = a < l - 1 ? t[a + 1] * r : e.length;
            o -= Math.abs(ky(e, c, u, r))
        }
    var h = 0;
    for (a = 0; a < n.length; a += 3) {
        var d = n[a] * r,
            f = n[a + 1] * r,
            p = n[a + 2] * r;
        h += Math.abs((e[d] - e[p]) * (e[f + 1] - e[d + 1]) - (e[d] - e[f]) * (e[p + 1] - e[d + 1]))
    }
    return o === 0 && h === 0 ? 0 : Math.abs((h - o) / o)
};

function ky(e, t, r, n) {
    for (var i = 0, s = t, o = r - n; s < r; s += n) i += (e[o] - e[s]) * (e[s + 1] + e[o + 1]), o = s;
    return i
}
Im.flatten = function(e) {
    for (var t = e[0][0].length, r = {
            vertices: [],
            holes: [],
            dimensions: t
        }, n = 0, i = 0; i < e.length; i++) {
        for (var s = 0; s < e[i].length; s++)
            for (var o = 0; o < t; o++) r.vertices.push(e[i][s][o]);
        i > 0 && (n += e[i - 1].length, r.holes.push(n))
    }
    return r
};
var gf = {},
    g7 = {
        get exports() {
            return gf
        },
        set exports(e) {
            gf = e
        }
    }; /*! https://mths.be/punycode v1.3.2 by @mathias */
(function(e, t) {
    (function(r) {
        var n = t && !t.nodeType && t,
            i = e && !e.nodeType && e,
            s = typeof cd == "object" && cd;
        (s.global === s || s.window === s || s.self === s) && (r = s);
        var o, a = 2147483647,
            l = 36,
            c = 1,
            u = 26,
            h = 38,
            d = 700,
            f = 72,
            p = 128,
            m = "-",
            w = /^xn--/,
            y = /[^\x20-\x7E]/,
            v = /[\x2E\u3002\uFF0E\uFF61]/g,
            _ = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            },
            E = l - c,
            P = Math.floor,
            C = String.fromCharCode,
            T;

        function O(z) {
            throw RangeError(_[z])
        }

        function k(z, Q) {
            for (var ie = z.length, _e = []; ie--;) _e[ie] = Q(z[ie]);
            return _e
        }

        function D(z, Q) {
            var ie = z.split("@"),
                _e = "";
            ie.length > 1 && (_e = ie[0] + "@", z = ie[1]), z = z.replace(v, ".");
            var we = z.split("."),
                De = k(we, Q).join(".");
            return _e + De
        }

        function B(z) {
            for (var Q = [], ie = 0, _e = z.length, we, De; ie < _e;) we = z.charCodeAt(ie++), we >= 55296 && we <= 56319 && ie < _e ? (De = z.charCodeAt(ie++), (De & 64512) == 56320 ? Q.push(((we & 1023) << 10) + (De & 1023) + 65536) : (Q.push(we), ie--)) : Q.push(we);
            return Q
        }

        function j(z) {
            return k(z, function(Q) {
                var ie = "";
                return Q > 65535 && (Q -= 65536, ie += C(Q >>> 10 & 1023 | 55296), Q = 56320 | Q & 1023), ie += C(Q), ie
            }).join("")
        }

        function L(z) {
            return z - 48 < 10 ? z - 22 : z - 65 < 26 ? z - 65 : z - 97 < 26 ? z - 97 : l
        }

        function M(z, Q) {
            return z + 22 + 75 * (z < 26) - ((Q != 0) << 5)
        }

        function W(z, Q, ie) {
            var _e = 0;
            for (z = ie ? P(z / d) : z >> 1, z += P(z / Q); z > E * u >> 1; _e += l) z = P(z / E);
            return P(_e + (E + 1) * z / (z + h))
        }

        function Z(z) {
            var Q = [],
                ie = z.length,
                _e, we = 0,
                De = p,
                Te = f,
                Ne, et, Le, tt, Ue, Ve, rt, Dt, zt;
            for (Ne = z.lastIndexOf(m), Ne < 0 && (Ne = 0), et = 0; et < Ne; ++et) z.charCodeAt(et) >= 128 && O("not-basic"), Q.push(z.charCodeAt(et));
            for (Le = Ne > 0 ? Ne + 1 : 0; Le < ie;) {
                for (tt = we, Ue = 1, Ve = l; Le >= ie && O("invalid-input"), rt = L(z.charCodeAt(Le++)), (rt >= l || rt > P((a - we) / Ue)) && O("overflow"), we += rt * Ue, Dt = Ve <= Te ? c : Ve >= Te + u ? u : Ve - Te, !(rt < Dt); Ve += l) zt = l - Dt, Ue > P(a / zt) && O("overflow"), Ue *= zt;
                _e = Q.length + 1, Te = W(we - tt, _e, tt == 0), P(we / _e) > a - De && O("overflow"), De += P(we / _e), we %= _e, Q.splice(we++, 0, De)
            }
            return j(Q)
        }

        function q(z) {
            var Q, ie, _e, we, De, Te, Ne, et, Le, tt, Ue, Ve = [],
                rt, Dt, zt, Vr;
            for (z = B(z), rt = z.length, Q = p, ie = 0, De = f, Te = 0; Te < rt; ++Te) Ue = z[Te], Ue < 128 && Ve.push(C(Ue));
            for (_e = we = Ve.length, we && Ve.push(m); _e < rt;) {
                for (Ne = a, Te = 0; Te < rt; ++Te) Ue = z[Te], Ue >= Q && Ue < Ne && (Ne = Ue);
                for (Dt = _e + 1, Ne - Q > P((a - ie) / Dt) && O("overflow"), ie += (Ne - Q) * Dt, Q = Ne, Te = 0; Te < rt; ++Te)
                    if (Ue = z[Te], Ue < Q && ++ie > a && O("overflow"), Ue == Q) {
                        for (et = ie, Le = l; tt = Le <= De ? c : Le >= De + u ? u : Le - De, !(et < tt); Le += l) Vr = et - tt, zt = l - tt, Ve.push(C(M(tt + Vr % zt, 0))), et = P(Vr / zt);
                        Ve.push(C(M(et, 0))), De = W(ie, Dt, _e == we), ie = 0, ++_e
                    }++ie, ++Q
            }
            return Ve.join("")
        }

        function G(z) {
            return D(z, function(Q) {
                return w.test(Q) ? Z(Q.slice(4).toLowerCase()) : Q
            })
        }

        function X(z) {
            return D(z, function(Q) {
                return y.test(Q) ? "xn--" + q(Q) : Q
            })
        }
        if (o = {
                version: "1.3.2",
                ucs2: {
                    decode: B,
                    encode: j
                },
                decode: Z,
                encode: q,
                toASCII: X,
                toUnicode: G
            }, n && i)
            if (e.exports == n) i.exports = o;
            else
                for (T in o) o.hasOwnProperty(T) && (n[T] = o[T]);
        else r.punycode = o
    })(cd)
})(g7, gf);
var v7 = {
        isString: function(e) {
            return typeof e == "string"
        },
        isObject: function(e) {
            return typeof e == "object" && e !== null
        },
        isNull: function(e) {
            return e === null
        },
        isNullOrUndefined: function(e) {
            return e == null
        }
    },
    Jc = {};

function y7(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}
var _7 = function(e, t, r, n) {
        t = t || "&", r = r || "=";
        var i = {};
        if (typeof e != "string" || e.length === 0) return i;
        var s = /\+/g;
        e = e.split(t);
        var o = 1e3;
        n && typeof n.maxKeys == "number" && (o = n.maxKeys);
        var a = e.length;
        o > 0 && a > o && (a = o);
        for (var l = 0; l < a; ++l) {
            var c = e[l].replace(s, "%20"),
                u = c.indexOf(r),
                h, d, f, p;
            u >= 0 ? (h = c.substr(0, u), d = c.substr(u + 1)) : (h = c, d = ""), f = decodeURIComponent(h), p = decodeURIComponent(d), y7(i, f) ? Array.isArray(i[f]) ? i[f].push(p) : i[f] = [i[f], p] : i[f] = p
        }
        return i
    },
    zl = function(e) {
        switch (typeof e) {
            case "string":
                return e;
            case "boolean":
                return e ? "true" : "false";
            case "number":
                return isFinite(e) ? e : "";
            default:
                return ""
        }
    },
    w7 = function(e, t, r, n) {
        return t = t || "&", r = r || "=", e === null && (e = void 0), typeof e == "object" ? Object.keys(e).map(function(i) {
            var s = encodeURIComponent(zl(i)) + r;
            return Array.isArray(e[i]) ? e[i].map(function(o) {
                return s + encodeURIComponent(zl(o))
            }).join(t) : s + encodeURIComponent(zl(e[i]))
        }).join(t) : n ? encodeURIComponent(zl(n)) + r + encodeURIComponent(zl(e)) : ""
    };
Jc.decode = Jc.parse = _7;
Jc.encode = Jc.stringify = w7;
var b7 = gf,
    Wn = v7,
    x7 = Rm,
    E7 = M7,
    S7 = k7;

function On() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
}
var P7 = /^([a-z0-9.+-]+:)/i,
    C7 = /:[0-9]*$/,
    T7 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    O7 = ["<", ">", '"', "`", " ", "\r", `
`, "	"],
    A7 = ["{", "}", "|", "\\", "^", "`"].concat(O7),
    My = ["'"].concat(A7),
    NE = ["%", "/", "?", ";", "#"].concat(My),
    LE = ["/", "?", "#"],
    I7 = 255,
    FE = /^[+a-z0-9A-Z_-]{0,63}$/,
    $7 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    R7 = {
        javascript: !0,
        "javascript:": !0
    },
    Dy = {
        javascript: !0,
        "javascript:": !0
    },
    Na = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
    },
    Ny = Jc;

function Rm(e, t, r) {
    if (e && Wn.isObject(e) && e instanceof On) return e;
    var n = new On;
    return n.parse(e, t, r), n
}
On.prototype.parse = function(e, t, r) {
    if (!Wn.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var n = e.indexOf("?"),
        i = n !== -1 && n < e.indexOf("#") ? "?" : "#",
        s = e.split(i),
        o = /\\/g;
    s[0] = s[0].replace(o, "/"), e = s.join(i);
    var a = e;
    if (a = a.trim(), !r && e.split("#").length === 1) {
        var l = T7.exec(a);
        if (l) return this.path = a, this.href = a, this.pathname = l[1], l[2] ? (this.search = l[2], t ? this.query = Ny.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this
    }
    var c = P7.exec(a);
    if (c) {
        c = c[0];
        var u = c.toLowerCase();
        this.protocol = u, a = a.substr(c.length)
    }
    if (r || c || a.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var h = a.substr(0, 2) === "//";
        h && !(c && Dy[c]) && (a = a.substr(2), this.slashes = !0)
    }
    if (!Dy[c] && (h || c && !Na[c])) {
        for (var d = -1, f = 0; f < LE.length; f++) {
            var p = a.indexOf(LE[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        var m, w;
        d === -1 ? w = a.lastIndexOf("@") : w = a.lastIndexOf("@", d), w !== -1 && (m = a.slice(0, w), a = a.slice(w + 1), this.auth = decodeURIComponent(m)), d = -1;
        for (var f = 0; f < NE.length; f++) {
            var p = a.indexOf(NE[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        d === -1 && (d = a.length), this.host = a.slice(0, d), a = a.slice(d), this.parseHost(), this.hostname = this.hostname || "";
        var y = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!y)
            for (var v = this.hostname.split(/\./), f = 0, _ = v.length; f < _; f++) {
                var E = v[f];
                if (E && !E.match(FE)) {
                    for (var P = "", C = 0, T = E.length; C < T; C++) E.charCodeAt(C) > 127 ? P += "x" : P += E[C];
                    if (!P.match(FE)) {
                        var O = v.slice(0, f),
                            k = v.slice(f + 1),
                            D = E.match($7);
                        D && (O.push(D[1]), k.unshift(D[2])), k.length && (a = "/" + k.join(".") + a), this.hostname = O.join(".");
                        break
                    }
                }
            }
        this.hostname.length > I7 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), y || (this.hostname = b7.toASCII(this.hostname));
        var B = this.port ? ":" + this.port : "",
            j = this.hostname || "";
        this.host = j + B, this.href += this.host, y && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a[0] !== "/" && (a = "/" + a))
    }
    if (!R7[u])
        for (var f = 0, _ = My.length; f < _; f++) {
            var L = My[f];
            if (a.indexOf(L) !== -1) {
                var M = encodeURIComponent(L);
                M === L && (M = escape(L)), a = a.split(L).join(M)
            }
        }
    var W = a.indexOf("#");
    W !== -1 && (this.hash = a.substr(W), a = a.slice(0, W));
    var Z = a.indexOf("?");
    if (Z !== -1 ? (this.search = a.substr(Z), this.query = a.substr(Z + 1), t && (this.query = Ny.parse(this.query)), a = a.slice(0, Z)) : t && (this.search = "", this.query = {}), a && (this.pathname = a), Na[u] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var B = this.pathname || "",
            q = this.search || "";
        this.path = B + q
    }
    return this.href = this.format(), this
};

function k7(e) {
    return Wn.isString(e) && (e = Rm(e)), e instanceof On ? e.format() : On.prototype.format.call(e)
}
On.prototype.format = function() {
    var e = this.auth || "";
    e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
    var t = this.protocol || "",
        r = this.pathname || "",
        n = this.hash || "",
        i = !1,
        s = "";
    this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && Wn.isObject(this.query) && Object.keys(this.query).length && (s = Ny.stringify(this.query));
    var o = this.search || s && "?" + s || "";
    return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Na[t]) && i !== !1 ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), o && o.charAt(0) !== "?" && (o = "?" + o), r = r.replace(/[?#]/g, function(a) {
        return encodeURIComponent(a)
    }), o = o.replace("#", "%23"), t + i + r + o + n
};

function M7(e, t) {
    return Rm(e, !1, !0).resolve(t)
}
On.prototype.resolve = function(e) {
    return this.resolveObject(Rm(e, !1, !0)).format()
};
On.prototype.resolveObject = function(e) {
    if (Wn.isString(e)) {
        var t = new On;
        t.parse(e, !1, !0), e = t
    }
    for (var r = new On, n = Object.keys(this), i = 0; i < n.length; i++) {
        var s = n[i];
        r[s] = this[s]
    }
    if (r.hash = e.hash, e.href === "") return r.href = r.format(), r;
    if (e.slashes && !e.protocol) {
        for (var o = Object.keys(e), a = 0; a < o.length; a++) {
            var l = o[a];
            l !== "protocol" && (r[l] = e[l])
        }
        return Na[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r
    }
    if (e.protocol && e.protocol !== r.protocol) {
        if (!Na[e.protocol]) {
            for (var c = Object.keys(e), u = 0; u < c.length; u++) {
                var h = c[u];
                r[h] = e[h]
            }
            return r.href = r.format(), r
        }
        if (r.protocol = e.protocol, !e.host && !Dy[e.protocol]) {
            for (var _ = (e.pathname || "").split("/"); _.length && !(e.host = _.shift()););
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), _[0] !== "" && _.unshift(""), _.length < 2 && _.unshift(""), r.pathname = _.join("/")
        } else r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
            var d = r.pathname || "",
                f = r.search || "";
            r.path = d + f
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r
    }
    var p = r.pathname && r.pathname.charAt(0) === "/",
        m = e.host || e.pathname && e.pathname.charAt(0) === "/",
        w = m || p || r.host && e.pathname,
        y = w,
        v = r.pathname && r.pathname.split("/") || [],
        _ = e.pathname && e.pathname.split("/") || [],
        E = r.protocol && !Na[r.protocol];
    if (E && (r.hostname = "", r.port = null, r.host && (v[0] === "" ? v[0] = r.host : v.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (_[0] === "" ? _[0] = e.host : _.unshift(e.host)), e.host = null), w = w && (_[0] === "" || v[0] === "")), m) r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, v = _;
    else if (_.length) v || (v = []), v.pop(), v = v.concat(_), r.search = e.search, r.query = e.query;
    else if (!Wn.isNullOrUndefined(e.search)) {
        if (E) {
            r.hostname = r.host = v.shift();
            var P = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
            P && (r.auth = P.shift(), r.host = r.hostname = P.shift())
        }
        return r.search = e.search, r.query = e.query, (!Wn.isNull(r.pathname) || !Wn.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r
    }
    if (!v.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
    for (var C = v.slice(-1)[0], T = (r.host || e.host || v.length > 1) && (C === "." || C === "..") || C === "", O = 0, k = v.length; k >= 0; k--) C = v[k], C === "." ? v.splice(k, 1) : C === ".." ? (v.splice(k, 1), O++) : O && (v.splice(k, 1), O--);
    if (!w && !y)
        for (; O--; O) v.unshift("..");
    w && v[0] !== "" && (!v[0] || v[0].charAt(0) !== "/") && v.unshift(""), T && v.join("/").substr(-1) !== "/" && v.push("");
    var D = v[0] === "" || v[0] && v[0].charAt(0) === "/";
    if (E) {
        r.hostname = r.host = D ? "" : v.length ? v.shift() : "";
        var P = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
        P && (r.auth = P.shift(), r.host = r.hostname = P.shift())
    }
    return w = w || r.host && v.length, w && !D && v.unshift(""), v.length ? r.pathname = v.join("/") : (r.pathname = null, r.path = null), (!Wn.isNull(r.pathname) || !Wn.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r
};
On.prototype.parseHost = function() {
    var e = this.host,
        t = C7.exec(e);
    t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e)
};
const D7 = {
    parse: x7,
    format: S7,
    resolve: E7
};

function dn(e) {
    if (typeof e != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(e)}`)
}

function jl(e) {
    return e.split("?")[0].split("#")[0]
}

function N7(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}

function L7(e, t, r) {
    return e.replace(new RegExp(N7(t), "g"), r)
}

function F7(e, t) {
    let r = "",
        n = 0,
        i = -1,
        s = 0,
        o = -1;
    for (let a = 0; a <= e.length; ++a) {
        if (a < e.length) o = e.charCodeAt(a);
        else {
            if (o === 47) break;
            o = 47
        }
        if (o === 47) {
            if (!(i === a - 1 || s === 1))
                if (i !== a - 1 && s === 2) {
                    if (r.length < 2 || n !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                        if (r.length > 2) {
                            const l = r.lastIndexOf("/");
                            if (l !== r.length - 1) {
                                l === -1 ? (r = "", n = 0) : (r = r.slice(0, l), n = r.length - 1 - r.lastIndexOf("/")), i = a, s = 0;
                                continue
                            }
                        } else if (r.length === 2 || r.length === 1) {
                            r = "", n = 0, i = a, s = 0;
                            continue
                        }
                    }
                    t && (r.length > 0 ? r += "/.." : r = "..", n = 2)
                } else r.length > 0 ? r += `/${e.slice(i+1,a)}` : r = e.slice(i + 1, a), n = a - i - 1;
            i = a, s = 0
        } else o === 46 && s !== -1 ? ++s : s = -1
    }
    return r
}
const hr = {
        toPosix(e) {
            return L7(e, "\\", "/")
        },
        isUrl(e) {
            return /^https?:/.test(this.toPosix(e))
        },
        isDataUrl(e) {
            return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(e)
        },
        hasProtocol(e) {
            return /^[^/:]+:\//.test(this.toPosix(e))
        },
        getProtocol(e) {
            dn(e), e = this.toPosix(e);
            let t = "";
            const r = /^file:\/\/\//.exec(e),
                n = /^[^/:]+:\/\//.exec(e),
                i = /^[^/:]+:\//.exec(e);
            if (r || n || i) {
                const s = (r == null ? void 0 : r[0]) || (n == null ? void 0 : n[0]) || (i == null ? void 0 : i[0]);
                t = s, e = e.slice(s.length)
            }
            return t
        },
        toAbsolute(e, t, r) {
            if (this.isDataUrl(e)) return e;
            const n = jl(this.toPosix(t??ce.ADAPTER.getBaseUrl())),
                i = jl(this.toPosix(r??this.rootname(n)));
            return dn(e), e = this.toPosix(e), e.startsWith("/") ? hr.join(i, e.slice(1)) : this.isAbsolute(e) ? e : this.join(n, e)
        },
        normalize(e) {
            if (e = this.toPosix(e), dn(e), e.length === 0) return ".";
            let t = "";
            const r = e.startsWith("/");
            this.hasProtocol(e) && (t = this.rootname(e), e = e.slice(t.length));
            const n = e.endsWith("/");
            return e = F7(e, !1), e.length > 0 && n && (e += "/"), r ? `/${e}` : t + e
        },
        isAbsolute(e) {
            return dn(e), e = this.toPosix(e), this.hasProtocol(e) ? !0 : e.startsWith("/")
        },
        join(...e) {
            if (e.length === 0) return ".";
            let t;
            for (let r = 0; r < e.length; ++r) {
                const n = e[r];
                if (dn(n), n.length > 0)
                    if (t === void 0) t = n;
                    else {
                        const i = e[r - 1]??"";
                        this.extname(i) ? t += `/../${n}` : t += `/${n}`
                    }
            }
            return t === void 0 ? "." : this.normalize(t)
        },
        dirname(e) {
            if (dn(e), e.length === 0) return ".";
            e = this.toPosix(e);
            let t = e.charCodeAt(0);
            const r = t === 47;
            let n = -1,
                i = !0;
            const s = this.getProtocol(e),
                o = e;
            e = e.slice(s.length);
            for (let a = e.length - 1; a >= 1; --a)
                if (t = e.charCodeAt(a), t === 47) {
                    if (!i) {
                        n = a;
                        break
                    }
                } else i = !1;
            return n === -1 ? r ? "/" : this.isUrl(o) ? s + e : s : r && n === 1 ? "//" : s + e.slice(0, n)
        },
        rootname(e) {
            dn(e), e = this.toPosix(e);
            let t = "";
            if (e.startsWith("/") ? t = "/" : t = this.getProtocol(e), this.isUrl(e)) {
                const r = e.indexOf("/", t.length);
                r !== -1 ? t = e.slice(0, r) : t = e, t.endsWith("/") || (t += "/")
            }
            return t
        },
        basename(e, t) {
            dn(e), t && dn(t), e = jl(this.toPosix(e));
            let r = 0,
                n = -1,
                i = !0,
                s;
            if (t !== void 0 && t.length > 0 && t.length <= e.length) {
                if (t.length === e.length && t === e) return "";
                let o = t.length - 1,
                    a = -1;
                for (s = e.length - 1; s >= 0; --s) {
                    const l = e.charCodeAt(s);
                    if (l === 47) {
                        if (!i) {
                            r = s + 1;
                            break
                        }
                    } else a === -1 && (i = !1, a = s + 1), o >= 0 && (l === t.charCodeAt(o) ? --o === -1 && (n = s) : (o = -1, n = a))
                }
                return r === n ? n = a : n === -1 && (n = e.length), e.slice(r, n)
            }
            for (s = e.length - 1; s >= 0; --s)
                if (e.charCodeAt(s) === 47) {
                    if (!i) {
                        r = s + 1;
                        break
                    }
                } else n === -1 && (i = !1, n = s + 1);
            return n === -1 ? "" : e.slice(r, n)
        },
        extname(e) {
            dn(e), e = jl(this.toPosix(e));
            let t = -1,
                r = 0,
                n = -1,
                i = !0,
                s = 0;
            for (let o = e.length - 1; o >= 0; --o) {
                const a = e.charCodeAt(o);
                if (a === 47) {
                    if (!i) {
                        r = o + 1;
                        break
                    }
                    continue
                }
                n === -1 && (i = !1, n = o + 1), a === 46 ? t === -1 ? t = o : s !== 1 && (s = 1) : t !== -1 && (s = -1)
            }
            return t === -1 || n === -1 || s === 0 || s === 1 && t === n - 1 && t === r + 1 ? "" : e.slice(t, n)
        },
        parse(e) {
            dn(e);
            const t = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
            };
            if (e.length === 0) return t;
            e = jl(this.toPosix(e));
            let r = e.charCodeAt(0);
            const n = this.isAbsolute(e);
            let i;
            t.root = this.rootname(e), n || this.hasProtocol(e) ? i = 1 : i = 0;
            let s = -1,
                o = 0,
                a = -1,
                l = !0,
                c = e.length - 1,
                u = 0;
            for (; c >= i; --c) {
                if (r = e.charCodeAt(c), r === 47) {
                    if (!l) {
                        o = c + 1;
                        break
                    }
                    continue
                }
                a === -1 && (l = !1, a = c + 1), r === 46 ? s === -1 ? s = c : u !== 1 && (u = 1) : s !== -1 && (u = -1)
            }
            return s === -1 || a === -1 || u === 0 || u === 1 && s === a - 1 && s === o + 1 ? a !== -1 && (o === 0 && n ? t.base = t.name = e.slice(1, a) : t.base = t.name = e.slice(o, a)) : (o === 0 && n ? (t.name = e.slice(1, s), t.base = e.slice(1, a)) : (t.name = e.slice(o, s), t.base = e.slice(o, a)), t.ext = e.slice(s, a)), t.dir = this.dirname(e), t
        },
        sep: "/",
        delimiter: ":"
    },
    BE = {};

function ze(e, t, r = 3) {
    if (BE[t]) return;
    let n = new Error().stack;
    typeof n > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`) : (n = n.split(`
`).splice(r).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${e}`), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`), console.warn(n))), BE[t] = !0
}
let Iv;

function B7() {
    return typeof Iv > "u" && (Iv = function() {
        var r;
        const t = {
            stencil: !0,
            failIfMajorPerformanceCaveat: ce.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
            if (!ce.ADAPTER.getWebGLRenderingContext()) return !1;
            const n = ce.ADAPTER.createCanvas();
            let i = n.getContext("webgl", t) || n.getContext("experimental-webgl", t);
            const s = !!((r = i == null ? void 0 : i.getContextAttributes()) != null && r.stencil);
            if (i) {
                const o = i.getExtension("WEBGL_lose_context");
                o && o.loseContext()
            }
            return i = null, s
        } catch {
            return !1
        }
    }()), Iv
}
var z7 = {
        grad: .9,
        turn: 360,
        rad: 360 / (2 * Math.PI)
    },
    di = function(e) {
        return typeof e == "string" ? e.length > 0 : typeof e == "number"
    },
    Gt = function(e, t, r) {
        return t === void 0 && (t = 0), r === void 0 && (r = Math.pow(10, t)), Math.round(r * e) / r + 0
    },
    en = function(e, t, r) {
        return t === void 0 && (t = 0), r === void 0 && (r = 1), e > r ? r : e > t ? e : t
    },
    KI = function(e) {
        return (e = isFinite(e) ? e % 360 : 0) > 0 ? e : e + 360
    },
    zE = function(e) {
        return {
            r: en(e.r, 0, 255),
            g: en(e.g, 0, 255),
            b: en(e.b, 0, 255),
            a: en(e.a)
        }
    },
    $v = function(e) {
        return {
            r: Gt(e.r),
            g: Gt(e.g),
            b: Gt(e.b),
            a: Gt(e.a, 3)
        }
    },
    j7 = /^#([0-9a-f]{3,8})$/i,
    vh = function(e) {
        var t = e.toString(16);
        return t.length < 2 ? "0" + t : t
    },
    qI = function(e) {
        var t = e.r,
            r = e.g,
            n = e.b,
            i = e.a,
            s = Math.max(t, r, n),
            o = s - Math.min(t, r, n),
            a = o ? s === t ? (r - n) / o : s === r ? 2 + (n - t) / o : 4 + (t - r) / o : 0;
        return {
            h: 60 * (a < 0 ? a + 6 : a),
            s: s ? o / s * 100 : 0,
            v: s / 255 * 100,
            a: i
        }
    },
    QI = function(e) {
        var t = e.h,
            r = e.s,
            n = e.v,
            i = e.a;
        t = t / 360 * 6, r /= 100, n /= 100;
        var s = Math.floor(t),
            o = n * (1 - r),
            a = n * (1 - (t - s) * r),
            l = n * (1 - (1 - t + s) * r),
            c = s % 6;
        return {
            r: 255 * [n, a, o, o, l, n][c],
            g: 255 * [l, n, n, a, o, o][c],
            b: 255 * [o, o, l, n, n, a][c],
            a: i
        }
    },
    jE = function(e) {
        return {
            h: KI(e.h),
            s: en(e.s, 0, 100),
            l: en(e.l, 0, 100),
            a: en(e.a)
        }
    },
    UE = function(e) {
        return {
            h: Gt(e.h),
            s: Gt(e.s),
            l: Gt(e.l),
            a: Gt(e.a, 3)
        }
    },
    HE = function(e) {
        return QI((r = (t = e).s, {
            h: t.h,
            s: (r *= ((n = t.l) < 50 ? n : 100 - n) / 100) > 0 ? 2 * r / (n + r) * 100 : 0,
            v: n + r,
            a: t.a
        }));
        var t, r, n
    },
    Sc = function(e) {
        return {
            h: (t = qI(e)).h,
            s: (i = (200 - (r = t.s)) * (n = t.v) / 100) > 0 && i < 200 ? r * n / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
            l: i / 2,
            a: t.a
        };
        var t, r, n, i
    },
    U7 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    H7 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    G7 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    V7 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    Ly = {
        string: [
            [function(e) {
                var t = j7.exec(e);
                return t ? (e = t[1]).length <= 4 ? {
                    r: parseInt(e[0] + e[0], 16),
                    g: parseInt(e[1] + e[1], 16),
                    b: parseInt(e[2] + e[2], 16),
                    a: e.length === 4 ? Gt(parseInt(e[3] + e[3], 16) / 255, 2) : 1
                } : e.length === 6 || e.length === 8 ? {
                    r: parseInt(e.substr(0, 2), 16),
                    g: parseInt(e.substr(2, 2), 16),
                    b: parseInt(e.substr(4, 2), 16),
                    a: e.length === 8 ? Gt(parseInt(e.substr(6, 2), 16) / 255, 2) : 1
                } : null : null
            }, "hex"],
            [function(e) {
                var t = G7.exec(e) || V7.exec(e);
                return t ? t[2] !== t[4] || t[4] !== t[6] ? null : zE({
                    r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
                    g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
                    b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
                    a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
                }) : null
            }, "rgb"],
            [function(e) {
                var t = U7.exec(e) || H7.exec(e);
                if (!t) return null;
                var r, n, i = jE({
                    h: (r = t[1], n = t[2], n === void 0 && (n = "deg"), Number(r) * (z7[n] || 1)),
                    s: Number(t[3]),
                    l: Number(t[4]),
                    a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
                });
                return HE(i)
            }, "hsl"]
        ],
        object: [
            [function(e) {
                var t = e.r,
                    r = e.g,
                    n = e.b,
                    i = e.a,
                    s = i === void 0 ? 1 : i;
                return di(t) && di(r) && di(n) ? zE({
                    r: Number(t),
                    g: Number(r),
                    b: Number(n),
                    a: Number(s)
                }) : null
            }, "rgb"],
            [function(e) {
                var t = e.h,
                    r = e.s,
                    n = e.l,
                    i = e.a,
                    s = i === void 0 ? 1 : i;
                if (!di(t) || !di(r) || !di(n)) return null;
                var o = jE({
                    h: Number(t),
                    s: Number(r),
                    l: Number(n),
                    a: Number(s)
                });
                return HE(o)
            }, "hsl"],
            [function(e) {
                var t = e.h,
                    r = e.s,
                    n = e.v,
                    i = e.a,
                    s = i === void 0 ? 1 : i;
                if (!di(t) || !di(r) || !di(n)) return null;
                var o = function(a) {
                    return {
                        h: KI(a.h),
                        s: en(a.s, 0, 100),
                        v: en(a.v, 0, 100),
                        a: en(a.a)
                    }
                }({
                    h: Number(t),
                    s: Number(r),
                    v: Number(n),
                    a: Number(s)
                });
                return QI(o)
            }, "hsv"]
        ]
    },
    GE = function(e, t) {
        for (var r = 0; r < t.length; r++) {
            var n = t[r][0](e);
            if (n) return [n, t[r][1]]
        }
        return [null, void 0]
    },
    W7 = function(e) {
        return typeof e == "string" ? GE(e.trim(), Ly.string) : typeof e == "object" && e !== null ? GE(e, Ly.object) : [null, void 0]
    },
    Rv = function(e, t) {
        var r = Sc(e);
        return {
            h: r.h,
            s: en(r.s + 100 * t, 0, 100),
            l: r.l,
            a: r.a
        }
    },
    kv = function(e) {
        return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3 / 255
    },
    VE = function(e, t) {
        var r = Sc(e);
        return {
            h: r.h,
            s: r.s,
            l: en(r.l + 100 * t, 0, 100),
            a: r.a
        }
    },
    Fy = function() {
        function e(t) {
            this.parsed = W7(t)[0], this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        }
        return e.prototype.isValid = function() {
            return this.parsed !== null
        }, e.prototype.brightness = function() {
            return Gt(kv(this.rgba), 2)
        }, e.prototype.isDark = function() {
            return kv(this.rgba) < .5
        }, e.prototype.isLight = function() {
            return kv(this.rgba) >= .5
        }, e.prototype.toHex = function() {
            return t = $v(this.rgba), r = t.r, n = t.g, i = t.b, o = (s = t.a) < 1 ? vh(Gt(255 * s)) : "", "#" + vh(r) + vh(n) + vh(i) + o;
            var t, r, n, i, s, o
        }, e.prototype.toRgb = function() {
            return $v(this.rgba)
        }, e.prototype.toRgbString = function() {
            return t = $v(this.rgba), r = t.r, n = t.g, i = t.b, (s = t.a) < 1 ? "rgba(" + r + ", " + n + ", " + i + ", " + s + ")" : "rgb(" + r + ", " + n + ", " + i + ")";
            var t, r, n, i, s
        }, e.prototype.toHsl = function() {
            return UE(Sc(this.rgba))
        }, e.prototype.toHslString = function() {
            return t = UE(Sc(this.rgba)), r = t.h, n = t.s, i = t.l, (s = t.a) < 1 ? "hsla(" + r + ", " + n + "%, " + i + "%, " + s + ")" : "hsl(" + r + ", " + n + "%, " + i + "%)";
            var t, r, n, i, s
        }, e.prototype.toHsv = function() {
            return t = qI(this.rgba), {
                h: Gt(t.h),
                s: Gt(t.s),
                v: Gt(t.v),
                a: Gt(t.a, 3)
            };
            var t
        }, e.prototype.invert = function() {
            return jn({
                r: 255 - (t = this.rgba).r,
                g: 255 - t.g,
                b: 255 - t.b,
                a: t.a
            });
            var t
        }, e.prototype.saturate = function(t) {
            return t === void 0 && (t = .1), jn(Rv(this.rgba, t))
        }, e.prototype.desaturate = function(t) {
            return t === void 0 && (t = .1), jn(Rv(this.rgba, -t))
        }, e.prototype.grayscale = function() {
            return jn(Rv(this.rgba, -1))
        }, e.prototype.lighten = function(t) {
            return t === void 0 && (t = .1), jn(VE(this.rgba, t))
        }, e.prototype.darken = function(t) {
            return t === void 0 && (t = .1), jn(VE(this.rgba, -t))
        }, e.prototype.rotate = function(t) {
            return t === void 0 && (t = 15), this.hue(this.hue() + t)
        }, e.prototype.alpha = function(t) {
            return typeof t == "number" ? jn({
                r: (r = this.rgba).r,
                g: r.g,
                b: r.b,
                a: t
            }) : Gt(this.rgba.a, 3);
            var r
        }, e.prototype.hue = function(t) {
            var r = Sc(this.rgba);
            return typeof t == "number" ? jn({
                h: t,
                s: r.s,
                l: r.l,
                a: r.a
            }) : Gt(r.h)
        }, e.prototype.isEqual = function(t) {
            return this.toHex() === jn(t).toHex()
        }, e
    }(),
    jn = function(e) {
        return e instanceof Fy ? e : new Fy(e)
    },
    WE = [],
    X7 = function(e) {
        e.forEach(function(t) {
            WE.indexOf(t) < 0 && (t(Fy, Ly), WE.push(t))
        })
    };

function Y7(e, t) {
    var r = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000"
        },
        n = {};
    for (var i in r) n[r[i]] = i;
    var s = {};
    e.prototype.toName = function(o) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
        var a, l, c = n[this.toHex()];
        if (c) return c;
        if (o != null && o.closest) {
            var u = this.toRgb(),
                h = 1 / 0,
                d = "black";
            if (!s.length)
                for (var f in r) s[f] = new e(r[f]).toRgb();
            for (var p in r) {
                var m = (a = u, l = s[p], Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
                m < h && (h = m, d = p)
            }
            return d
        }
    }, t.string.push([function(o) {
        var a = o.toLowerCase(),
            l = a === "transparent" ? "#0000" : r[a];
        return l ? new e(l).toRgb() : null
    }, "name"])
}
X7([Y7]);
const La = class {
    constructor(e = 16777215) {
        this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e
    }
    get red() {
        return this._components[0]
    }
    get green() {
        return this._components[1]
    }
    get blue() {
        return this._components[2]
    }
    get alpha() {
        return this._components[3]
    }
    setValue(e) {
        return this.value = e, this
    }
    set value(e) {
        if (e instanceof La) this._value = this.cloneSource(e._value), this._int = e._int, this._components.set(e._components);
        else {
            if (e === null) throw new Error("Cannot set PIXI.Color#value to null");
            (this._value === null || !this.isSourceEqual(this._value, e)) && (this.normalize(e), this._value = this.cloneSource(e))
        }
    }
    get value() {
        return this._value
    }
    cloneSource(e) {
        return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? { ...e
        } : e
    }
    isSourceEqual(e, t) {
        const r = typeof e;
        if (r !== typeof t) return !1;
        if (r === "number" || r === "string" || e instanceof Number) return e === t;
        if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) return e.length !== t.length ? !1 : e.every((i, s) => i === t[s]);
        if (e !== null && t !== null) {
            const i = Object.keys(e),
                s = Object.keys(t);
            return i.length !== s.length ? !1 : i.every(o => e[o] === t[o])
        }
        return e === t
    }
    toRgba() {
        const [e, t, r, n] = this._components;
        return {
            r: e,
            g: t,
            b: r,
            a: n
        }
    }
    toRgb() {
        const [e, t, r] = this._components;
        return {
            r: e,
            g: t,
            b: r
        }
    }
    toRgbaString() {
        const [e, t, r] = this.toUint8RgbArray();
        return `rgba(${e},${t},${r},${this.alpha})`
    }
    toUint8RgbArray(e) {
        const [t, r, n] = this._components;
        return e = e??[], e[0] = Math.round(t * 255), e[1] = Math.round(r * 255), e[2] = Math.round(n * 255), e
    }
    toRgbArray(e) {
        e = e??[];
        const [t, r, n] = this._components;
        return e[0] = t, e[1] = r, e[2] = n, e
    }
    toNumber() {
        return this._int
    }
    toLittleEndianNumber() {
        const e = this._int;
        return (e >> 16) + (e & 65280) + ((e & 255) << 16)
    }
    multiply(e) {
        const [t, r, n, i] = La.temp.setValue(e)._components;
        return this._components[0] *= t, this._components[1] *= r, this._components[2] *= n, this._components[3] *= i, this.refreshInt(), this._value = null, this
    }
    premultiply(e, t = !0) {
        return t && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this.refreshInt(), this._value = null, this
    }
    toPremultiplied(e, t = !0) {
        if (e === 1) return (255 << 24) + this._int;
        if (e === 0) return t ? 0 : this._int;
        let r = this._int >> 16 & 255,
            n = this._int >> 8 & 255,
            i = this._int & 255;
        return t && (r = r * e + .5 | 0, n = n * e + .5 | 0, i = i * e + .5 | 0), (e * 255 << 24) + (r << 16) + (n << 8) + i
    }
    toHex() {
        const e = this._int.toString(16);
        return `#${"000000".substring(0,6-e.length)+e}`
    }
    toHexa() {
        const t = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + "00".substring(0, 2 - t.length) + t
    }
    setAlpha(e) {
        return this._components[3] = this._clamp(e), this
    }
    round(e) {
        const [t, r, n] = this._components;
        return this._components[0] = Math.round(t * e) / e, this._components[1] = Math.round(r * e) / e, this._components[2] = Math.round(n * e) / e, this.refreshInt(), this._value = null, this
    }
    toArray(e) {
        e = e??[];
        const [t, r, n, i] = this._components;
        return e[0] = t, e[1] = r, e[2] = n, e[3] = i, e
    }
    normalize(e) {
        let t, r, n, i;
        if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
            const s = e;
            t = (s >> 16 & 255) / 255, r = (s >> 8 & 255) / 255, n = (s & 255) / 255, i = 1
        } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [t, r, n, i = 1] = e;
        else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [t, r, n, i = 255] = e, t /= 255, r /= 255, n /= 255, i /= 255;
        else if (typeof e == "string" || typeof e == "object") {
            if (typeof e == "string") {
                const o = La.HEX_PATTERN.exec(e);
                o && (e = `#${o[2]}`)
            }
            const s = jn(e);
            s.isValid() && ({
                r: t,
                g: r,
                b: n,
                a: i
            } = s.rgba, t /= 255, r /= 255, n /= 255)
        }
        if (t !== void 0) this._components[0] = t, this._components[1] = r, this._components[2] = n, this._components[3] = i, this.refreshInt();
        else throw new Error(`Unable to convert color ${e}`)
    }
    refreshInt() {
        this._clamp(this._components);
        const [e, t, r] = this._components;
        this._int = (e * 255 << 16) + (t * 255 << 8) + (r * 255 | 0)
    }
    _clamp(e, t = 0, r = 1) {
        return typeof e == "number" ? Math.min(Math.max(e, t), r) : (e.forEach((n, i) => {
            e[i] = Math.min(Math.max(n, t), r)
        }), e)
    }
};
let ot = La;
ot.shared = new La;
ot.temp = new La;
ot.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;

function K7(e) {
    return ze("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"), ot.shared.setValue(e).toHex()
}

function q7(e) {
    return ze("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"), ot.shared.setValue(e).toNumber()
}

function Q7() {
    const e = [],
        t = [];
    for (let n = 0; n < 32; n++) e[n] = n, t[n] = n;
    e[Ce.NORMAL_NPM] = Ce.NORMAL, e[Ce.ADD_NPM] = Ce.ADD, e[Ce.SCREEN_NPM] = Ce.SCREEN, t[Ce.NORMAL] = Ce.NORMAL_NPM, t[Ce.ADD] = Ce.ADD_NPM, t[Ce.SCREEN] = Ce.SCREEN_NPM;
    const r = [];
    return r.push(t), r.push(e), r
}
const ZI = Q7();

function JI(e, t) {
    return ZI[t ? 1 : 0][e]
}

function Z7(e, t = null) {
    const r = e * 6;
    if (t = t || new Uint16Array(r), t.length !== r) throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${r}`);
    for (let n = 0, i = 0; n < r; n += 6, i += 4) t[n + 0] = i + 0, t[n + 1] = i + 1, t[n + 2] = i + 2, t[n + 3] = i + 0, t[n + 4] = i + 2, t[n + 5] = i + 3;
    return t
}

function e$(e) {
    if (e.BYTES_PER_ELEMENT === 4) return e instanceof Float32Array ? "Float32Array" : e instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (e.BYTES_PER_ELEMENT === 2) {
        if (e instanceof Uint16Array) return "Uint16Array"
    } else if (e.BYTES_PER_ELEMENT === 1 && e instanceof Uint8Array) return "Uint8Array";
    return null
}

function vf(e) {
    return e += e === 0 ? 1 : 0, --e, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e + 1
}

function XE(e) {
    return !(e & e - 1) && !!e
}

function YE(e) {
    let t = (e > 65535 ? 1 : 0) << 4;
    e >>>= t;
    let r = (e > 255 ? 1 : 0) << 3;
    return e >>>= r, t |= r, r = (e > 15 ? 1 : 0) << 2, e >>>= r, t |= r, r = (e > 3 ? 1 : 0) << 1, e >>>= r, t |= r, t | e >> 1
}

function Fa(e, t, r) {
    const n = e.length;
    let i;
    if (t >= n || r === 0) return;
    r = t + r > n ? n - t : r;
    const s = n - r;
    for (i = t; i < s; ++i) e[i] = e[i + r];
    e.length = s
}

function is(e) {
    return e === 0 ? 0 : e < 0 ? -1 : 1
}
let J7 = 0;

function yo() {
    return ++J7
}
const t$ = class {
    constructor(e, t, r, n) {
        this.left = e, this.top = t, this.right = r, this.bottom = n
    }
    get width() {
        return this.right - this.left
    }
    get height() {
        return this.bottom - this.top
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
};
let By = t$;
By.EMPTY = new t$(0, 0, 0, 0);
const KE = {},
    Un = Object.create(null),
    Hi = Object.create(null);
class ez {
    constructor(t, r, n) {
        this._canvas = ce.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = n || ce.RESOLUTION, this.resize(t, r)
    }
    clear() {
        this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
    }
    resize(t, r) {
        this._checkDestroyed(), this._canvas.width = Math.round(t * this.resolution), this._canvas.height = Math.round(r * this.resolution)
    }
    destroy() {
        this._context = null, this._canvas = null
    }
    get width() {
        return this._checkDestroyed(), this._canvas.width
    }
    set width(t) {
        this._checkDestroyed(), this._canvas.width = Math.round(t)
    }
    get height() {
        return this._checkDestroyed(), this._canvas.height
    }
    set height(t) {
        this._checkDestroyed(), this._canvas.height = Math.round(t)
    }
    get canvas() {
        return this._checkDestroyed(), this._canvas
    }
    get context() {
        return this._checkDestroyed(), this._context
    }
    _checkDestroyed() {
        if (this._canvas === null) throw new TypeError("The CanvasRenderTarget has already been destroyed")
    }
}

function qE(e, t, r) {
    for (let n = 0, i = 4 * r * t; n < t; ++n, i += 4)
        if (e[i + 3] !== 0) return !1;
    return !0
}

function QE(e, t, r, n, i) {
    const s = 4 * t;
    for (let o = n, a = n * s + 4 * r; o <= i; ++o, a += s)
        if (e[a + 3] !== 0) return !1;
    return !0
}

function tz(e) {
    const {
        width: t,
        height: r
    } = e, n = e.getContext("2d", {
        willReadFrequently: !0
    });
    if (n === null) throw new TypeError("Failed to get canvas 2D context");
    const s = n.getImageData(0, 0, t, r).data;
    let o = 0,
        a = 0,
        l = t - 1,
        c = r - 1;
    for (; a < r && qE(s, t, a);) ++a;
    if (a === r) return By.EMPTY;
    for (; qE(s, t, c);) --c;
    for (; QE(s, t, o, a, c);) ++o;
    for (; QE(s, t, l, a, c);) --l;
    return ++l, ++c, new By(o, a, l, c)
}

function rz(e) {
    const t = tz(e),
        {
            width: r,
            height: n
        } = t;
    let i = null;
    if (!t.isEmpty()) {
        const s = e.getContext("2d");
        if (s === null) throw new TypeError("Failed to get canvas 2D context");
        i = s.getImageData(t.left, t.top, r, n)
    }
    return {
        width: r,
        height: n,
        data: i
    }
}
let yh;

function nz(e, t = globalThis.location) {
    if (e.startsWith("data:")) return "";
    t = t || globalThis.location, yh || (yh = document.createElement("a")), yh.href = e;
    const r = D7.parse(yh.href),
        n = !r.port && t.port === "" || r.port === t.port;
    return r.hostname !== t.hostname || !n || r.protocol !== t.protocol ? "anonymous" : ""
}

function Ss(e, t = 1) {
    var n;
    const r = (n = ce.RETINA_PREFIX) == null ? void 0 : n.exec(e);
    return r ? parseFloat(r[1]) : t
}
var ue = (e => (e.Renderer = "renderer", e.Application = "application", e.RendererSystem = "renderer-webgl-system", e.RendererPlugin = "renderer-webgl-plugin", e.CanvasRendererSystem = "renderer-canvas-system", e.CanvasRendererPlugin = "renderer-canvas-plugin", e.Asset = "asset", e.LoadParser = "load-parser", e.ResolveParser = "resolve-parser", e.CacheParser = "cache-parser", e.DetectionParser = "detection-parser", e))(ue || {});
const zy = e => {
        if (typeof e == "function" || typeof e == "object" && e.extension) {
            if (!e.extension) throw new Error("Extension class must have an extension object");
            e = { ...typeof e.extension != "object" ? {
                    type: e.extension
                } : e.extension,
                ref: e
            }
        }
        if (typeof e == "object") e = { ...e
        };
        else throw new Error("Invalid extension type");
        return typeof e.type == "string" && (e.type = [e.type]), e
    },
    ZE = (e, t) => zy(e).priority??t,
    ye = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...e) {
            return e.map(zy).forEach(t => {
                t.type.forEach(r => {
                    var n, i;
                    return (i = (n = this._removeHandlers)[r]) == null ? void 0 : i.call(n, t)
                })
            }), this
        },
        add(...e) {
            return e.map(zy).forEach(t => {
                t.type.forEach(r => {
                    const n = this._addHandlers,
                        i = this._queue;
                    n[r] ? n[r](t) : (i[r] = i[r] || [], i[r].push(t))
                })
            }), this
        },
        handle(e, t, r) {
            const n = this._addHandlers,
                i = this._removeHandlers;
            if (n[e] || i[e]) throw new Error(`Extension type ${e} already has a handler`);
            n[e] = t, i[e] = r;
            const s = this._queue;
            return s[e] && (s[e].forEach(o => t(o)), delete s[e]), this
        },
        handleByMap(e, t) {
            return this.handle(e, r => {
                t[r.name] = r.ref
            }, r => {
                delete t[r.name]
            })
        },
        handleByList(e, t, r = -1) {
            return this.handle(e, n => {
                t.includes(n.ref) || (t.push(n.ref), t.sort((i, s) => ZE(s, r) - ZE(i, r)))
            }, n => {
                const i = t.indexOf(n.ref);
                i !== -1 && t.splice(i, 1)
            })
        }
    };
class jy {
    constructor(t) {
        typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
    }
    get uint16View() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
    }
    view(t) {
        return this[`${t}View`]
    }
    destroy() {
        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
    }
    static sizeOf(t) {
        switch (t) {
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${t} isn't a valid view type`)
        }
    }
}
const iz = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);

function sz(e) {
    let t = "";
    for (let r = 0; r < e; ++r) r > 0 && (t += `
else `), r < e - 1 && (t += `if(test == ${r}.0){}`);
    return t
}

function oz(e, t) {
    if (e === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const r = t.createShader(t.FRAGMENT_SHADER);
    for (;;) {
        const n = iz.replace(/%forloop%/gi, sz(e));
        if (t.shaderSource(r, n), t.compileShader(r), !t.getShaderParameter(r, t.COMPILE_STATUS)) e = e / 2 | 0;
        else break
    }
    return e
}
const Mv = 0,
    Dv = 1,
    Nv = 2,
    Lv = 3,
    Fv = 4,
    Bv = 5;
class ki {
    constructor() {
        this.data = 0, this.blendMode = Ce.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
    }
    get blend() {
        return !!(this.data & 1 << Mv)
    }
    set blend(t) {
        !!(this.data & 1 << Mv) !== t && (this.data ^= 1 << Mv)
    }
    get offsets() {
        return !!(this.data & 1 << Dv)
    }
    set offsets(t) {
        !!(this.data & 1 << Dv) !== t && (this.data ^= 1 << Dv)
    }
    get culling() {
        return !!(this.data & 1 << Nv)
    }
    set culling(t) {
        !!(this.data & 1 << Nv) !== t && (this.data ^= 1 << Nv)
    }
    get depthTest() {
        return !!(this.data & 1 << Lv)
    }
    set depthTest(t) {
        !!(this.data & 1 << Lv) !== t && (this.data ^= 1 << Lv)
    }
    get depthMask() {
        return !!(this.data & 1 << Bv)
    }
    set depthMask(t) {
        !!(this.data & 1 << Bv) !== t && (this.data ^= 1 << Bv)
    }
    get clockwiseFrontFace() {
        return !!(this.data & 1 << Fv)
    }
    set clockwiseFrontFace(t) {
        !!(this.data & 1 << Fv) !== t && (this.data ^= 1 << Fv)
    }
    get blendMode() {
        return this._blendMode
    }
    set blendMode(t) {
        this.blend = t !== Ce.NONE, this._blendMode = t
    }
    get polygonOffset() {
        return this._polygonOffset
    }
    set polygonOffset(t) {
        this.offsets = !!t, this._polygonOffset = t
    }
    toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
    }
    static for2d() {
        const t = new ki;
        return t.depthTest = !1, t.blend = !0, t
    }
}
const Uy = [];

function r$(e, t) {
    if (!e) return null;
    let r = "";
    if (typeof e == "string") {
        const n = /\.(\w{3,4})(?:$|\?|#)/i.exec(e);
        n && (r = n[1].toLowerCase())
    }
    for (let n = Uy.length - 1; n >= 0; --n) {
        const i = Uy[n];
        if (i.test && i.test(e, r)) return new i(e, t)
    }
    throw new Error("Unrecognized source type to auto-detect Resource")
}
class An {
    constructor(t) {
        this.items = [], this._name = t, this._aliasCount = 0
    }
    emit(t, r, n, i, s, o, a, l) {
        if (arguments.length > 8) throw new Error("max arguments reached");
        const {
            name: c,
            items: u
        } = this;
        this._aliasCount++;
        for (let h = 0, d = u.length; h < d; h++) u[h][c](t, r, n, i, s, o, a, l);
        return u === this.items && this._aliasCount--, this
    }
    ensureNonAliasedItems() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
    }
    add(t) {
        return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
    }
    remove(t) {
        const r = this.items.indexOf(t);
        return r !== -1 && (this.ensureNonAliasedItems(), this.items.splice(r, 1)), this
    }
    contains(t) {
        return this.items.includes(t)
    }
    removeAll() {
        return this.ensureNonAliasedItems(), this.items.length = 0, this
    }
    destroy() {
        this.removeAll(), this.items = null, this._name = null
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
Object.defineProperties(An.prototype, {
    dispatch: {
        value: An.prototype.emit
    },
    run: {
        value: An.prototype.emit
    }
});
class eu {
    constructor(t = 0, r = 0) {
        this._width = t, this._height = r, this.destroyed = !1, this.internal = !1, this.onResize = new An("setRealSize"), this.onUpdate = new An("update"), this.onError = new An("onError")
    }
    bind(t) {
        this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
    }
    unbind(t) {
        this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
    }
    resize(t, r) {
        (t !== this._width || r !== this._height) && (this._width = t, this._height = r, this.onResize.emit(t, r))
    }
    get valid() {
        return !!this._width && !!this._height
    }
    update() {
        this.destroyed || this.onUpdate.emit()
    }
    load() {
        return Promise.resolve(this)
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    style(t, r, n) {
        return !1
    }
    dispose() {}
    destroy() {
        this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
    }
    static test(t, r) {
        return !1
    }
}
class xu extends eu {
    constructor(t, r) {
        const {
            width: n,
            height: i
        } = r || {};
        if (!n || !i) throw new Error("BufferResource width or height invalid");
        super(n, i), this.data = t
    }
    upload(t, r, n) {
        const i = t.gl;
        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === Nn.UNPACK);
        const s = r.realWidth,
            o = r.realHeight;
        return n.width === s && n.height === o ? i.texSubImage2D(r.target, 0, 0, 0, s, o, r.format, n.type, this.data) : (n.width = s, n.height = o, i.texImage2D(r.target, 0, n.internalFormat, s, o, 0, r.format, n.type, this.data)), !0
    }
    dispose() {
        this.data = null
    }
    static test(t) {
        return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
    }
}
const az = {
        scaleMode: bi.NEAREST,
        format: se.RGBA,
        alphaMode: Nn.NPM
    },
    oa = class extends go {
        constructor(e = null, t = null) {
            super(), t = Object.assign({}, oa.defaultOptions, t);
            const {
                alphaMode: r,
                mipmap: n,
                anisotropicLevel: i,
                scaleMode: s,
                width: o,
                height: a,
                wrapMode: l,
                format: c,
                type: u,
                target: h,
                resolution: d,
                resourceOptions: f
            } = t;
            e && !(e instanceof eu) && (e = r$(e, f), e.internal = !0), this.resolution = d || ce.RESOLUTION, this.width = Math.round((o || 0) * this.resolution) / this.resolution, this.height = Math.round((a || 0) * this.resolution) / this.resolution, this._mipmap = n, this.anisotropicLevel = i, this._wrapMode = l, this._scaleMode = s, this.format = c, this.type = u, this.target = h, this.alphaMode = r, this.uid = yo(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = o > 0 && a > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(e)
        }
        get realWidth() {
            return Math.round(this.width * this.resolution)
        }
        get realHeight() {
            return Math.round(this.height * this.resolution)
        }
        get mipmap() {
            return this._mipmap
        }
        set mipmap(e) {
            this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++)
        }
        get scaleMode() {
            return this._scaleMode
        }
        set scaleMode(e) {
            this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++)
        }
        get wrapMode() {
            return this._wrapMode
        }
        set wrapMode(e) {
            this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++)
        }
        setStyle(e, t) {
            let r;
            return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, r = !0), t !== void 0 && t !== this.mipmap && (this.mipmap = t, r = !0), r && this.dirtyStyleId++, this
        }
        setSize(e, t, r) {
            return r = r || this.resolution, this.setRealSize(e * r, t * r, r)
        }
        setRealSize(e, t, r) {
            return this.resolution = r || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(t) / this.resolution, this._refreshPOT(), this.update(), this
        }
        _refreshPOT() {
            this.isPowerOfTwo = XE(this.realWidth) && XE(this.realHeight)
        }
        setResolution(e) {
            const t = this.resolution;
            return t === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * t) / e, this.height = Math.round(this.height * t) / e, this.emit("update", this)), this._refreshPOT(), this)
        }
        setResource(e) {
            if (this.resource === e) return this;
            if (this.resource) throw new Error("Resource can be set only once");
            return e.bind(this), this.resource = e, this
        }
        update() {
            this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
        }
        onError(e) {
            this.emit("error", this, e)
        }
        destroy() {
            this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Hi[this.cacheId], delete Un[this.cacheId], this.cacheId = null), this.dispose(), oa.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
        }
        dispose() {
            this.emit("dispose", this)
        }
        castToBaseTexture() {
            return this
        }
        static from(e, t, r = ce.STRICT_TEXTURE_CACHE) {
            const n = typeof e == "string";
            let i = null;
            if (n) i = e;
            else {
                if (!e._pixiId) {
                    const o = (t == null ? void 0 : t.pixiIdPrefix) || "pixiid";
                    e._pixiId = `${o}_${yo()}`
                }
                i = e._pixiId
            }
            let s = Hi[i];
            if (n && r && !s) throw new Error(`The cacheId "${i}" does not exist in BaseTextureCache.`);
            return s || (s = new oa(e, t), s.cacheId = i, oa.addToCache(s, i)), s
        }
        static fromBuffer(e, t, r, n) {
            e = e || new Float32Array(t * r * 4);
            const i = new xu(e, {
                    width: t,
                    height: r
                }),
                s = e instanceof Float32Array ? be.FLOAT : be.UNSIGNED_BYTE;
            return new oa(i, Object.assign({}, az, {
                type: s
            }, n))
        }
        static addToCache(e, t) {
            t && (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t), Hi[t] && Hi[t] !== e && console.warn(`BaseTexture added to the cache with an id [${t}] that already had an entry`), Hi[t] = e)
        }
        static removeFromCache(e) {
            if (typeof e == "string") {
                const t = Hi[e];
                if (t) {
                    const r = t.textureCacheIds.indexOf(e);
                    return r > -1 && t.textureCacheIds.splice(r, 1), delete Hi[e], t
                }
            } else if (e != null && e.textureCacheIds) {
                for (let t = 0; t < e.textureCacheIds.length; ++t) delete Hi[e.textureCacheIds[t]];
                return e.textureCacheIds.length = 0, e
            }
            return null
        }
    };
let Oe = oa;
Oe.defaultOptions = {
    mipmap: si.POW2,
    anisotropicLevel: 0,
    scaleMode: bi.LINEAR,
    wrapMode: vs.CLAMP,
    alphaMode: Nn.UNPACK,
    target: Da.TEXTURE_2D,
    format: se.RGBA,
    type: be.UNSIGNED_BYTE
};
Oe._globalBatch = 0;
class Hy {
    constructor() {
        this.texArray = null, this.blend = 0, this.type = Zn.TRIANGLES, this.start = 0, this.size = 0, this.data = null
    }
}
let lz = 0;
class Ct {
    constructor(t, r = !0, n = !1) {
        this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = n, this.static = r, this.id = lz++, this.disposeRunner = new An("disposeBuffer")
    }
    update(t) {
        t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(), this.data = null
    }
    set index(t) {
        this.type = t ? ri.ELEMENT_ARRAY_BUFFER : ri.ARRAY_BUFFER
    }
    get index() {
        return this.type === ri.ELEMENT_ARRAY_BUFFER
    }
    static from(t) {
        return t instanceof Array && (t = new Float32Array(t)), new Ct(t)
    }
}
class yf {
    constructor(t, r = 0, n = !1, i = be.FLOAT, s, o, a, l = 1) {
        this.buffer = t, this.size = r, this.normalized = n, this.type = i, this.stride = s, this.start = o, this.instance = a, this.divisor = l
    }
    destroy() {
        this.buffer = null
    }
    static from(t, r, n, i, s) {
        return new yf(t, r, n, i, s)
    }
}
const cz = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};

function uz(e, t) {
    let r = 0,
        n = 0;
    const i = {};
    for (let l = 0; l < e.length; l++) n += t[l], r += e[l].length;
    const s = new ArrayBuffer(r * 4);
    let o = null,
        a = 0;
    for (let l = 0; l < e.length; l++) {
        const c = t[l],
            u = e[l],
            h = e$(u);
        i[h] || (i[h] = new cz[h](s)), o = i[h];
        for (let d = 0; d < u.length; d++) {
            const f = (d / c | 0) * n + a,
                p = d % c;
            o[f + p] = u[d]
        }
        a += c
    }
    return new Float32Array(s)
}
const JE = {
    5126: 4,
    5123: 2,
    5121: 1
};
let hz = 0;
const dz = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
};
class Ps {
    constructor(t = [], r = {}) {
        this.buffers = t, this.indexBuffer = null, this.attributes = r, this.glVertexArrayObjects = {}, this.id = hz++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new An("disposeGeometry"), this.refCount = 0
    }
    addAttribute(t, r, n = 0, i = !1, s, o, a, l = !1) {
        if (!r) throw new Error("You must pass a buffer when creating an attribute");
        r instanceof Ct || (r instanceof Array && (r = new Float32Array(r)), r = new Ct(r));
        const c = t.split("|");
        if (c.length > 1) {
            for (let h = 0; h < c.length; h++) this.addAttribute(c[h], r, n, i, s);
            return this
        }
        let u = this.buffers.indexOf(r);
        return u === -1 && (this.buffers.push(r), u = this.buffers.length - 1), this.attributes[t] = new yf(u, n, i, s, o, a, l), this.instanced = this.instanced || l, this
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    getBuffer(t) {
        return this.buffers[this.getAttribute(t).buffer]
    }
    addIndex(t) {
        return t instanceof Ct || (t instanceof Array && (t = new Uint16Array(t)), t = new Ct(t)), t.type = ri.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.includes(t) || this.buffers.push(t), this
    }
    getIndex() {
        return this.indexBuffer
    }
    interleave() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this;
        const t = [],
            r = [],
            n = new Ct;
        let i;
        for (i in this.attributes) {
            const s = this.attributes[i],
                o = this.buffers[s.buffer];
            t.push(o.data), r.push(s.size * JE[s.type] / 4), s.buffer = 0
        }
        for (n.data = uz(t, r), i = 0; i < this.buffers.length; i++) this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy();
        return this.buffers = [n], this.indexBuffer && this.buffers.push(this.indexBuffer), this
    }
    getSize() {
        for (const t in this.attributes) {
            const r = this.attributes[t];
            return this.buffers[r.buffer].data.length / (r.stride / 4 || r.size)
        }
        return 0
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
    }
    clone() {
        const t = new Ps;
        for (let r = 0; r < this.buffers.length; r++) t.buffers[r] = new Ct(this.buffers[r].data.slice(0));
        for (const r in this.attributes) {
            const n = this.attributes[r];
            t.attributes[r] = new yf(n.buffer, n.size, n.normalized, n.type, n.stride, n.start, n.instance)
        }
        return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = ri.ELEMENT_ARRAY_BUFFER), t
    }
    static merge(t) {
        const r = new Ps,
            n = [],
            i = [],
            s = [];
        let o;
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++) i[l] = i[l] || 0, i[l] += o.buffers[l].data.length, s[l] = 0
        }
        for (let a = 0; a < o.buffers.length; a++) n[a] = new dz[e$(o.buffers[a].data)](i[a]), r.buffers[a] = new Ct(n[a]);
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++) n[l].set(o.buffers[l].data, s[l]), s[l] += o.buffers[l].data.length
        }
        if (r.attributes = o.attributes, o.indexBuffer) {
            r.indexBuffer = r.buffers[o.buffers.indexOf(o.indexBuffer)], r.indexBuffer.type = ri.ELEMENT_ARRAY_BUFFER;
            let a = 0,
                l = 0,
                c = 0,
                u = 0;
            for (let h = 0; h < o.buffers.length; h++)
                if (o.buffers[h] !== o.indexBuffer) {
                    u = h;
                    break
                }
            for (const h in o.attributes) {
                const d = o.attributes[h];
                (d.buffer | 0) === u && (l += d.size * JE[d.type] / 4)
            }
            for (let h = 0; h < t.length; h++) {
                const d = t[h].indexBuffer.data;
                for (let f = 0; f < d.length; f++) r.indexBuffer.data[f + c] += a;
                a += t[h].buffers[u].data.length / l, c += d.length
            }
        }
        return r
    }
}
class n$ extends Ps {
    constructor(t = !1) {
        super(), this._buffer = new Ct(null, t, !1), this._indexBuffer = new Ct(null, t, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, be.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, be.FLOAT).addAttribute("aColor", this._buffer, 4, !0, be.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, be.FLOAT).addIndex(this._indexBuffer)
    }
}
const _f = Math.PI * 2,
    fz = 180 / Math.PI,
    pz = Math.PI / 180;
var tr = (e => (e[e.POLY = 0] = "POLY", e[e.RECT = 1] = "RECT", e[e.CIRC = 2] = "CIRC", e[e.ELIP = 3] = "ELIP", e[e.RREC = 4] = "RREC", e))(tr || {});
class Se {
    constructor(t = 0, r = 0) {
        this.x = 0, this.y = 0, this.x = t, this.y = r
    }
    clone() {
        return new Se(this.x, this.y)
    }
    copyFrom(t) {
        return this.set(t.x, t.y), this
    }
    copyTo(t) {
        return t.set(this.x, this.y), t
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    set(t = 0, r = t) {
        return this.x = t, this.y = r, this
    }
    toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`
    }
}
const _h = [new Se, new Se, new Se, new Se];
class $e {
    constructor(t = 0, r = 0, n = 0, i = 0) {
        this.x = Number(t), this.y = Number(r), this.width = Number(n), this.height = Number(i), this.type = tr.RECT
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    static get EMPTY() {
        return new $e(0, 0, 0, 0)
    }
    clone() {
        return new $e(this.x, this.y, this.width, this.height)
    }
    copyFrom(t) {
        return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
    }
    copyTo(t) {
        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
    }
    contains(t, r) {
        return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && r >= this.y && r < this.y + this.height
    }
    intersects(t, r) {
        if (!r) {
            const O = this.x < t.x ? t.x : this.x;
            if ((this.right > t.right ? t.right : this.right) <= O) return !1;
            const D = this.y < t.y ? t.y : this.y;
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > D
        }
        const n = this.left,
            i = this.right,
            s = this.top,
            o = this.bottom;
        if (i <= n || o <= s) return !1;
        const a = _h[0].set(t.left, t.top),
            l = _h[1].set(t.left, t.bottom),
            c = _h[2].set(t.right, t.top),
            u = _h[3].set(t.right, t.bottom);
        if (c.x <= a.x || l.y <= a.y) return !1;
        const h = Math.sign(r.a * r.d - r.b * r.c);
        if (h === 0 || (r.apply(a, a), r.apply(l, l), r.apply(c, c), r.apply(u, u), Math.max(a.x, l.x, c.x, u.x) <= n || Math.min(a.x, l.x, c.x, u.x) >= i || Math.max(a.y, l.y, c.y, u.y) <= s || Math.min(a.y, l.y, c.y, u.y) >= o)) return !1;
        const d = h * (l.y - a.y),
            f = h * (a.x - l.x),
            p = d * n + f * s,
            m = d * i + f * s,
            w = d * n + f * o,
            y = d * i + f * o;
        if (Math.max(p, m, w, y) <= d * a.x + f * a.y || Math.min(p, m, w, y) >= d * u.x + f * u.y) return !1;
        const v = h * (a.y - c.y),
            _ = h * (c.x - a.x),
            E = v * n + _ * s,
            P = v * i + _ * s,
            C = v * n + _ * o,
            T = v * i + _ * o;
        return !(Math.max(E, P, C, T) <= v * a.x + _ * a.y || Math.min(E, P, C, T) >= v * u.x + _ * u.y)
    }
    pad(t = 0, r = t) {
        return this.x -= t, this.y -= r, this.width += t * 2, this.height += r * 2, this
    }
    fit(t) {
        const r = Math.max(this.x, t.x),
            n = Math.min(this.x + this.width, t.x + t.width),
            i = Math.max(this.y, t.y),
            s = Math.min(this.y + this.height, t.y + t.height);
        return this.x = r, this.width = Math.max(n - r, 0), this.y = i, this.height = Math.max(s - i, 0), this
    }
    ceil(t = 1, r = .001) {
        const n = Math.ceil((this.x + this.width - r) * t) / t,
            i = Math.ceil((this.y + this.height - r) * t) / t;
        return this.x = Math.floor((this.x + r) * t) / t, this.y = Math.floor((this.y + r) * t) / t, this.width = n - this.x, this.height = i - this.y, this
    }
    enlarge(t) {
        const r = Math.min(this.x, t.x),
            n = Math.max(this.x + this.width, t.x + t.width),
            i = Math.min(this.y, t.y),
            s = Math.max(this.y + this.height, t.y + t.height);
        return this.x = r, this.width = n - r, this.y = i, this.height = s - i, this
    }
    toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
class Y1 {
    constructor(t = 0, r = 0, n = 0) {
        this.x = t, this.y = r, this.radius = n, this.type = tr.CIRC
    }
    clone() {
        return new Y1(this.x, this.y, this.radius)
    }
    contains(t, r) {
        if (this.radius <= 0) return !1;
        const n = this.radius * this.radius;
        let i = this.x - t,
            s = this.y - r;
        return i *= i, s *= s, i + s <= n
    }
    getBounds() {
        return new $e(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2)
    }
    toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
    }
}
class K1 {
    constructor(t = 0, r = 0, n = 0, i = 0) {
        this.x = t, this.y = r, this.width = n, this.height = i, this.type = tr.ELIP
    }
    clone() {
        return new K1(this.x, this.y, this.width, this.height)
    }
    contains(t, r) {
        if (this.width <= 0 || this.height <= 0) return !1;
        let n = (t - this.x) / this.width,
            i = (r - this.y) / this.height;
        return n *= n, i *= i, n + i <= 1
    }
    getBounds() {
        return new $e(this.x - this.width, this.y - this.height, this.width, this.height)
    }
    toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
class Ba {
    constructor(...t) {
        let r = Array.isArray(t[0]) ? t[0] : t;
        if (typeof r[0] != "number") {
            const n = [];
            for (let i = 0, s = r.length; i < s; i++) n.push(r[i].x, r[i].y);
            r = n
        }
        this.points = r, this.type = tr.POLY, this.closeStroke = !0
    }
    clone() {
        const t = this.points.slice(),
            r = new Ba(t);
        return r.closeStroke = this.closeStroke, r
    }
    contains(t, r) {
        let n = !1;
        const i = this.points.length / 2;
        for (let s = 0, o = i - 1; s < i; o = s++) {
            const a = this.points[s * 2],
                l = this.points[s * 2 + 1],
                c = this.points[o * 2],
                u = this.points[o * 2 + 1];
            l > r != u > r && t < (c - a) * ((r - l) / (u - l)) + a && (n = !n)
        }
        return n
    }
    toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((t,r)=>`${t}, ${r}`,"")}]`
    }
}
class q1 {
    constructor(t = 0, r = 0, n = 0, i = 0, s = 20) {
        this.x = t, this.y = r, this.width = n, this.height = i, this.radius = s, this.type = tr.RREC
    }
    clone() {
        return new q1(this.x, this.y, this.width, this.height, this.radius)
    }
    contains(t, r) {
        if (this.width <= 0 || this.height <= 0) return !1;
        if (t >= this.x && t <= this.x + this.width && r >= this.y && r <= this.y + this.height) {
            const n = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (r >= this.y + n && r <= this.y + this.height - n || t >= this.x + n && t <= this.x + this.width - n) return !0;
            let i = t - (this.x + n),
                s = r - (this.y + n);
            const o = n * n;
            if (i * i + s * s <= o || (i = t - (this.x + this.width - n), i * i + s * s <= o) || (s = r - (this.y + this.height - n), i * i + s * s <= o) || (i = t - (this.x + n), i * i + s * s <= o)) return !0
        }
        return !1
    }
    toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
    }
}
class mt {
    constructor(t = 1, r = 0, n = 0, i = 1, s = 0, o = 0) {
        this.array = null, this.a = t, this.b = r, this.c = n, this.d = i, this.tx = s, this.ty = o
    }
    fromArray(t) {
        this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
    }
    set(t, r, n, i, s, o) {
        return this.a = t, this.b = r, this.c = n, this.d = i, this.tx = s, this.ty = o, this
    }
    toArray(t, r) {
        this.array || (this.array = new Float32Array(9));
        const n = r || this.array;
        return t ? (n[0] = this.a, n[1] = this.b, n[2] = 0, n[3] = this.c, n[4] = this.d, n[5] = 0, n[6] = this.tx, n[7] = this.ty, n[8] = 1) : (n[0] = this.a, n[1] = this.c, n[2] = this.tx, n[3] = this.b, n[4] = this.d, n[5] = this.ty, n[6] = 0, n[7] = 0, n[8] = 1), n
    }
    apply(t, r) {
        r = r || new Se;
        const n = t.x,
            i = t.y;
        return r.x = this.a * n + this.c * i + this.tx, r.y = this.b * n + this.d * i + this.ty, r
    }
    applyInverse(t, r) {
        r = r || new Se;
        const n = 1 / (this.a * this.d + this.c * -this.b),
            i = t.x,
            s = t.y;
        return r.x = this.d * n * i + -this.c * n * s + (this.ty * this.c - this.tx * this.d) * n, r.y = this.a * n * s + -this.b * n * i + (-this.ty * this.a + this.tx * this.b) * n, r
    }
    translate(t, r) {
        return this.tx += t, this.ty += r, this
    }
    scale(t, r) {
        return this.a *= t, this.d *= r, this.c *= t, this.b *= r, this.tx *= t, this.ty *= r, this
    }
    rotate(t) {
        const r = Math.cos(t),
            n = Math.sin(t),
            i = this.a,
            s = this.c,
            o = this.tx;
        return this.a = i * r - this.b * n, this.b = i * n + this.b * r, this.c = s * r - this.d * n, this.d = s * n + this.d * r, this.tx = o * r - this.ty * n, this.ty = o * n + this.ty * r, this
    }
    append(t) {
        const r = this.a,
            n = this.b,
            i = this.c,
            s = this.d;
        return this.a = t.a * r + t.b * i, this.b = t.a * n + t.b * s, this.c = t.c * r + t.d * i, this.d = t.c * n + t.d * s, this.tx = t.tx * r + t.ty * i + this.tx, this.ty = t.tx * n + t.ty * s + this.ty, this
    }
    setTransform(t, r, n, i, s, o, a, l, c) {
        return this.a = Math.cos(a + c) * s, this.b = Math.sin(a + c) * s, this.c = -Math.sin(a - l) * o, this.d = Math.cos(a - l) * o, this.tx = t - (n * this.a + i * this.c), this.ty = r - (n * this.b + i * this.d), this
    }
    prepend(t) {
        const r = this.tx;
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
            const n = this.a,
                i = this.c;
            this.a = n * t.a + this.b * t.c, this.b = n * t.b + this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d
        }
        return this.tx = r * t.a + this.ty * t.c + t.tx, this.ty = r * t.b + this.ty * t.d + t.ty, this
    }
    decompose(t) {
        const r = this.a,
            n = this.b,
            i = this.c,
            s = this.d,
            o = t.pivot,
            a = -Math.atan2(-i, s),
            l = Math.atan2(n, r),
            c = Math.abs(a + l);
        return c < 1e-5 || Math.abs(_f - c) < 1e-5 ? (t.rotation = l, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = l), t.scale.x = Math.sqrt(r * r + n * n), t.scale.y = Math.sqrt(i * i + s * s), t.position.x = this.tx + (o.x * r + o.y * i), t.position.y = this.ty + (o.x * n + o.y * s), t
    }
    invert() {
        const t = this.a,
            r = this.b,
            n = this.c,
            i = this.d,
            s = this.tx,
            o = t * i - r * n;
        return this.a = i / o, this.b = -r / o, this.c = -n / o, this.d = t / o, this.tx = (n * this.ty - i * s) / o, this.ty = -(t * this.ty - r * s) / o, this
    }
    identity() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
    }
    clone() {
        const t = new mt;
        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
    }
    copyTo(t) {
        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
    }
    copyFrom(t) {
        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
    }
    toString() {
        return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
    }
    static get IDENTITY() {
        return new mt
    }
    static get TEMP_MATRIX() {
        return new mt
    }
}
const Hs = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    Gs = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    Vs = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    Ws = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    Gy = [],
    i$ = [],
    wh = Math.sign;

function mz() {
    for (let e = 0; e < 16; e++) {
        const t = [];
        Gy.push(t);
        for (let r = 0; r < 16; r++) {
            const n = wh(Hs[e] * Hs[r] + Vs[e] * Gs[r]),
                i = wh(Gs[e] * Hs[r] + Ws[e] * Gs[r]),
                s = wh(Hs[e] * Vs[r] + Vs[e] * Ws[r]),
                o = wh(Gs[e] * Vs[r] + Ws[e] * Ws[r]);
            for (let a = 0; a < 16; a++)
                if (Hs[a] === n && Gs[a] === i && Vs[a] === s && Ws[a] === o) {
                    t.push(a);
                    break
                }
        }
    }
    for (let e = 0; e < 16; e++) {
        const t = new mt;
        t.set(Hs[e], Gs[e], Vs[e], Ws[e], 0, 0), i$.push(t)
    }
}
mz();
const vt = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: e => Hs[e],
    uY: e => Gs[e],
    vX: e => Vs[e],
    vY: e => Ws[e],
    inv: e => e & 8 ? e & 15 : -e & 7,
    add: (e, t) => Gy[e][t],
    sub: (e, t) => Gy[e][vt.inv(t)],
    rotate180: e => e ^ 4,
    isVertical: e => (e & 3) === 2,
    byDirection: (e, t) => Math.abs(e) * 2 <= Math.abs(t) ? t >= 0 ? vt.S : vt.N : Math.abs(t) * 2 <= Math.abs(e) ? e > 0 ? vt.E : vt.W : t > 0 ? e > 0 ? vt.SE : vt.SW : e > 0 ? vt.NE : vt.NW,
    matrixAppendRotationInv: (e, t, r = 0, n = 0) => {
        const i = i$[vt.inv(t)];
        i.tx = r, i.ty = n, e.append(i)
    }
};
class ss {
    constructor(t, r, n = 0, i = 0) {
        this._x = n, this._y = i, this.cb = t, this.scope = r
    }
    clone(t = this.cb, r = this.scope) {
        return new ss(t, r, this._x, this._y)
    }
    set(t = 0, r = t) {
        return (this._x !== t || this._y !== r) && (this._x = t, this._y = r, this.cb.call(this.scope)), this
    }
    copyFrom(t) {
        return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
    }
    copyTo(t) {
        return t.set(this._x, this._y), t
    }
    equals(t) {
        return t.x === this._x && t.y === this._y
    }
    toString() {
        return `[@pixi/math:ObservablePoint x=0 y=0 scope=${this.scope}]`
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x !== t && (this._x = t, this.cb.call(this.scope))
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y !== t && (this._y = t, this.cb.call(this.scope))
    }
}
const s$ = class {
    constructor() {
        this.worldTransform = new mt, this.localTransform = new mt, this.position = new ss(this.onChange, this, 0, 0), this.scale = new ss(this.onChange, this, 1, 1), this.pivot = new ss(this.onChange, this, 0, 0), this.skew = new ss(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
    }
    onChange() {
        this._localID++
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
    }
    toString() {
        return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
    }
    updateLocalTransform() {
        const e = this.localTransform;
        this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1)
    }
    updateTransform(e) {
        const t = this.localTransform;
        if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== e._worldID) {
            const r = e.worldTransform,
                n = this.worldTransform;
            n.a = t.a * r.a + t.b * r.c, n.b = t.a * r.b + t.b * r.d, n.c = t.c * r.a + t.d * r.c, n.d = t.c * r.b + t.d * r.d, n.tx = t.tx * r.a + t.ty * r.c + r.tx, n.ty = t.tx * r.b + t.ty * r.d + r.ty, this._parentID = e._worldID, this._worldID++
        }
    }
    setFromMatrix(e) {
        e.decompose(this), this._localID++
    }
    get rotation() {
        return this._rotation
    }
    set rotation(e) {
        this._rotation !== e && (this._rotation = e, this.updateSkew())
    }
};
let Q1 = s$;
Q1.IDENTITY = new s$;
var gz = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`,
    vz = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;

function eS(e, t, r) {
    const n = e.createShader(t);
    return e.shaderSource(n, r), e.compileShader(n), n
}

function zv(e) {
    const t = new Array(e);
    for (let r = 0; r < t.length; r++) t[r] = !1;
    return t
}

function o$(e, t) {
    switch (e) {
        case "float":
            return 0;
        case "vec2":
            return new Float32Array(2 * t);
        case "vec3":
            return new Float32Array(3 * t);
        case "vec4":
            return new Float32Array(4 * t);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
            return 0;
        case "ivec2":
            return new Int32Array(2 * t);
        case "ivec3":
            return new Int32Array(3 * t);
        case "ivec4":
            return new Int32Array(4 * t);
        case "uvec2":
            return new Uint32Array(2 * t);
        case "uvec3":
            return new Uint32Array(3 * t);
        case "uvec4":
            return new Uint32Array(4 * t);
        case "bool":
            return !1;
        case "bvec2":
            return zv(2 * t);
        case "bvec3":
            return zv(3 * t);
        case "bvec4":
            return zv(4 * t);
        case "mat2":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const za = [{
        test: e => e.type === "float" && e.size === 1 && !e.isArray,
        code: e => `
            if(uv["${e}"] !== ud["${e}"].value)
            {
                ud["${e}"].value = uv["${e}"]
                gl.uniform1f(ud["${e}"].location, uv["${e}"])
            }
            `
    }, {
        test: (e, t) => (e.type === "sampler2D" || e.type === "samplerCube" || e.type === "sampler2DArray") && e.size === 1 && !e.isArray && (t == null || t.castToBaseTexture !== void 0),
        code: e => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${e}"], t);

            if(ud["${e}"].value !== t)
            {
                ud["${e}"].value = t;
                gl.uniform1i(ud["${e}"].location, t);
; // eslint-disable-line max-len
            }`
    }, {
        test: (e, t) => e.type === "mat3" && e.size === 1 && !e.isArray && t.a !== void 0,
        code: e => `
            gl.uniformMatrix3fv(ud["${e}"].location, false, uv["${e}"].toArray(true));
            `,
        codeUbo: e => `
                var ${e}_matrix = uv.${e}.toArray(true);

                data[offset] = ${e}_matrix[0];
                data[offset+1] = ${e}_matrix[1];
                data[offset+2] = ${e}_matrix[2];
        
                data[offset + 4] = ${e}_matrix[3];
                data[offset + 5] = ${e}_matrix[4];
                data[offset + 6] = ${e}_matrix[5];
        
                data[offset + 8] = ${e}_matrix[6];
                data[offset + 9] = ${e}_matrix[7];
                data[offset + 10] = ${e}_matrix[8];
            `
    }, {
        test: (e, t) => e.type === "vec2" && e.size === 1 && !e.isArray && t.x !== void 0,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${e}"].location, v.x, v.y);
                }`,
        codeUbo: e => `
                v = uv.${e};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
    }, {
        test: e => e.type === "vec2" && e.size === 1 && !e.isArray,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${e}"].location, v[0], v[1]);
                }
            `
    }, {
        test: (e, t) => e.type === "vec4" && e.size === 1 && !e.isArray && t.width !== void 0,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${e}"].location, v.x, v.y, v.width, v.height)
                }`,
        codeUbo: e => `
                    v = uv.${e};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
    }, {
        test: (e, t) => e.type === "vec4" && e.size === 1 && !e.isArray && t.red !== void 0,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${e}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
        codeUbo: e => `
                    v = uv.${e};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `
    }, {
        test: (e, t) => e.type === "vec3" && e.size === 1 && !e.isArray && t.red !== void 0,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${e}"].location, v.red, v.green, v.blue)
                }`,
        codeUbo: e => `
                    v = uv.${e};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `
    }, {
        test: e => e.type === "vec4" && e.size === 1 && !e.isArray,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${e}"].location, v[0], v[1], v[2], v[3])
                }`
    }],
    yz = {
        float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
        vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
        vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
        vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
        int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
        uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
        uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
        uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
        bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
        bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
    },
    _z = {
        float: "gl.uniform1fv(location, v)",
        vec2: "gl.uniform2fv(location, v)",
        vec3: "gl.uniform3fv(location, v)",
        vec4: "gl.uniform4fv(location, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        int: "gl.uniform1iv(location, v)",
        ivec2: "gl.uniform2iv(location, v)",
        ivec3: "gl.uniform3iv(location, v)",
        ivec4: "gl.uniform4iv(location, v)",
        uint: "gl.uniform1uiv(location, v)",
        uvec2: "gl.uniform2uiv(location, v)",
        uvec3: "gl.uniform3uiv(location, v)",
        uvec4: "gl.uniform4uiv(location, v)",
        bool: "gl.uniform1iv(location, v)",
        bvec2: "gl.uniform2iv(location, v)",
        bvec3: "gl.uniform3iv(location, v)",
        bvec4: "gl.uniform4iv(location, v)",
        sampler2D: "gl.uniform1iv(location, v)",
        samplerCube: "gl.uniform1iv(location, v)",
        sampler2DArray: "gl.uniform1iv(location, v)"
    };

function wz(e, t) {
    var n;
    const r = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const i in e.uniforms) {
        const s = t[i];
        if (!s) {
            (n = e.uniforms[i]) != null && n.group && (e.uniforms[i].ubo ? r.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `) : r.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `));
            continue
        }
        const o = e.uniforms[i];
        let a = !1;
        for (let l = 0; l < za.length; l++)
            if (za[l].test(s, o)) {
                r.push(za[l].code(i, o)), a = !0;
                break
            }
        if (!a) {
            const c = (s.size === 1 && !s.isArray ? yz : _z)[s.type].replace("location", `ud["${i}"].location`);
            r.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${c};`)
        }
    }
    return new Function("ud", "uv", "renderer", "syncData", r.join(`
`))
}
const a$ = {};
let Ko = a$;

function bz() {
    if (Ko === a$ || Ko != null && Ko.isContextLost()) {
        const e = ce.ADAPTER.createCanvas();
        let t;
        ce.PREFER_ENV >= Po.WEBGL2 && (t = e.getContext("webgl2", {})), t || (t = e.getContext("webgl", {}) || e.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), Ko = t
    }
    return Ko
}
let bh;

function xz() {
    if (!bh) {
        bh = Jr.MEDIUM;
        const e = bz();
        e && e.getShaderPrecisionFormat && (bh = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision ? Jr.HIGH : Jr.MEDIUM)
    }
    return bh
}

function tS(e, t) {
    const r = e.getShaderSource(t).split(`
`).map((c, u) => `${u}: ${c}`),
        n = e.getShaderInfoLog(t),
        i = n.split(`
`),
        s = {},
        o = i.map(c => parseFloat(c.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(c => c && !s[c] ? (s[c] = !0, !0) : !1),
        a = [""];
    o.forEach(c => {
        r[c - 1] = `%c${r[c-1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    });
    const l = r.join(`
`);
    a[0] = l, console.error(n), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd()
}

function Ez(e, t, r, n) {
    e.getProgramParameter(t, e.LINK_STATUS) || (e.getShaderParameter(r, e.COMPILE_STATUS) || tS(e, r), e.getShaderParameter(n, e.COMPILE_STATUS) || tS(e, n), console.error("PixiJS Error: Could not initialize shader."), e.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", e.getProgramInfoLog(t)))
}
const Sz = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
};

function l$(e) {
    return Sz[e]
}
let xh = null;
const rS = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};

function c$(e, t) {
    if (!xh) {
        const r = Object.keys(rS);
        xh = {};
        for (let n = 0; n < r.length; ++n) {
            const i = r[n];
            xh[e[i]] = rS[i]
        }
    }
    return xh[t]
}

function nS(e, t, r) {
    if (e.substring(0, 9) !== "precision") {
        let n = t;
        return t === Jr.HIGH && r !== Jr.HIGH && (n = Jr.MEDIUM), `precision ${n} float;
${e}`
    } else if (r !== Jr.HIGH && e.substring(0, 15) === "precision highp") return e.replace("precision highp", "precision mediump");
    return e
}
let Ul;

function Pz() {
    if (typeof Ul == "boolean") return Ul;
    try {
        Ul = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
            a: "b"
        }, "a", "b") === !0
    } catch {
        Ul = !1
    }
    return Ul
}
let Cz = 0;
const Eh = {},
    aa = class {
        constructor(e, t, r = "pixi-shader", n = {}) {
            this.extra = {}, this.id = Cz++, this.vertexSrc = e || aa.defaultVertexSrc, this.fragmentSrc = t || aa.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = n, this.vertexSrc.substring(0, 8) !== "#version" && (r = r.replace(/\s+/g, "-"), Eh[r] ? (Eh[r]++, r += `-${Eh[r]}`) : Eh[r] = 1, this.vertexSrc = `#define SHADER_NAME ${r}
${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${r}
${this.fragmentSrc}`, this.vertexSrc = nS(this.vertexSrc, aa.defaultVertexPrecision, Jr.HIGH), this.fragmentSrc = nS(this.fragmentSrc, aa.defaultFragmentPrecision, xz())), this.glPrograms = {}, this.syncUniforms = null
        }
        static get defaultVertexSrc() {
            return vz
        }
        static get defaultFragmentSrc() {
            return gz
        }
        static from(e, t, r) {
            const n = e + t;
            let i = KE[n];
            return i || (KE[n] = i = new aa(e, t, r)), i
        }
    };
let En = aa;
En.defaultVertexPrecision = Jr.HIGH;
En.defaultFragmentPrecision = xi.apple.device ? Jr.HIGH : Jr.MEDIUM;
let Tz = 0;
class In {
    constructor(t, r, n) {
        this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = Tz++, this.static = !!r, this.ubo = !!n, t instanceof Ct ? (this.buffer = t, this.buffer.type = ri.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Ct(new Float32Array(1)), this.buffer.type = ri.UNIFORM_BUFFER, this.autoManage = !0))
    }
    update() {
        this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update()
    }
    add(t, r, n) {
        if (!this.ubo) this.uniforms[t] = new In(r, n);
        else throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")
    }
    static from(t, r, n) {
        return new In(t, r, n)
    }
    static uboFrom(t, r) {
        return new In(t, r??!0, !0)
    }
}
class ni {
    constructor(t, r) {
        this.uniformBindCount = 0, this.program = t, r ? r instanceof In ? this.uniformGroup = r : this.uniformGroup = new In(r) : this.uniformGroup = new In({}), this.disposeRunner = new An("disposeShader")
    }
    checkUniformExists(t, r) {
        if (r.uniforms[t]) return !0;
        for (const n in r.uniforms) {
            const i = r.uniforms[n];
            if (i.group && this.checkUniformExists(t, i)) return !0
        }
        return !1
    }
    destroy() {
        this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy()
    }
    get uniforms() {
        return this.uniformGroup.uniforms
    }
    static from(t, r, n) {
        const i = En.from(t, r);
        return new ni(i, n)
    }
}
class Oz {
    constructor(t, r) {
        if (this.vertexSrc = t, this.fragTemplate = r, this.programCache = {}, this.defaultGroupCache = {}, !r.includes("%count%")) throw new Error('Fragment template must contain "%count%".');
        if (!r.includes("%forloop%")) throw new Error('Fragment template must contain "%forloop%".')
    }
    generateShader(t) {
        if (!this.programCache[t]) {
            const n = new Int32Array(t);
            for (let s = 0; s < t; s++) n[s] = s;
            this.defaultGroupCache[t] = In.from({
                uSamplers: n
            }, !0);
            let i = this.fragTemplate;
            i = i.replace(/%count%/gi, `${t}`), i = i.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new En(this.vertexSrc, i)
        }
        const r = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new mt,
            default: this.defaultGroupCache[t]
        };
        return new ni(this.programCache[t], r)
    }
    generateSampleSrc(t) {
        let r = "";
        r += `
`, r += `
`;
        for (let n = 0; n < t; n++) n > 0 && (r += `
else `), n < t - 1 && (r += `if(vTextureId < ${n}.5)`), r += `
{`, r += `
	color = texture2D(uSamplers[${n}], vTextureCoord);`, r += `
}`;
        return r += `
`, r += `
`, r
    }
}
class Vy {
    constructor() {
        this.elements = [], this.ids = [], this.count = 0
    }
    clear() {
        for (let t = 0; t < this.count; t++) this.elements[t] = null;
        this.count = 0
    }
}

function Az() {
    return !xi.apple.device
}

function Iz(e) {
    let t = !0;
    const r = ce.ADAPTER.getNavigator();
    if (xi.tablet || xi.phone) {
        if (xi.apple.device) {
            const n = r.userAgent.match(/OS (\d+)_(\d+)?/);
            n && parseInt(n[1], 10) < 11 && (t = !1)
        }
        if (xi.android.device) {
            const n = r.userAgent.match(/Android\s([0-9.]*)/);
            n && parseInt(n[1], 10) < 7 && (t = !1)
        }
    }
    return t ? e : 4
}
class km {
    constructor(t) {
        this.renderer = t
    }
    flush() {}
    destroy() {
        this.renderer = null
    }
    start() {}
    stop() {
        this.flush()
    }
    render(t) {}
}
var $z = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`,
    Rz = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const pn = class extends km {
    constructor(e) {
        super(e), this.setShaderGenerator(), this.geometryClass = n$, this.vertexSize = 6, this.state = ki.for2d(), this.size = pn.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), e.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = []
    }
    static get defaultMaxTextures() {
        return this._defaultMaxTextures = this._defaultMaxTextures??Iz(32), this._defaultMaxTextures
    }
    static set defaultMaxTextures(e) {
        this._defaultMaxTextures = e
    }
    static get canUploadSameBuffer() {
        return this._canUploadSameBuffer = this._canUploadSameBuffer??Az(), this._canUploadSameBuffer
    }
    static set canUploadSameBuffer(e) {
        this._canUploadSameBuffer = e
    }
    get MAX_TEXTURES() {
        return ze("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures
    }
    static get defaultVertexSrc() {
        return Rz
    }
    static get defaultFragmentTemplate() {
        return $z
    }
    setShaderGenerator({
        vertex: e = pn.defaultVertexSrc,
        fragment: t = pn.defaultFragmentTemplate
    } = {}) {
        this.shaderGenerator = new Oz(e, t)
    }
    contextChange() {
        const e = this.renderer.gl;
        ce.PREFER_ENV === Po.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), pn.defaultMaxTextures), this.maxTextures = oz(this.maxTextures, e)), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
        for (let t = 0; t < this._packedGeometryPoolSize; t++) this._packedGeometries[t] = new this.geometryClass;
        this.initFlushBuffers()
    }
    initFlushBuffers() {
        const {
            _drawCallPool: e,
            _textureArrayPool: t
        } = pn, r = this.size / 4, n = Math.floor(r / this.maxTextures) + 1;
        for (; e.length < r;) e.push(new Hy);
        for (; t.length < n;) t.push(new Vy);
        for (let i = 0; i < this.maxTextures; i++) this._tempBoundTextures[i] = null
    }
    onPrerender() {
        this._flushId = 0
    }
    render(e) {
        e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e)
    }
    buildTexturesAndDrawCalls() {
        const {
            _bufferedTextures: e,
            maxTextures: t
        } = this, r = pn._textureArrayPool, n = this.renderer.batch, i = this._tempBoundTextures, s = this.renderer.textureGC.count;
        let o = ++Oe._globalBatch,
            a = 0,
            l = r[0],
            c = 0;
        n.copyBoundTextures(i, t);
        for (let u = 0; u < this._bufferSize; ++u) {
            const h = e[u];
            e[u] = null, h._batchEnabled !== o && (l.count >= t && (n.boundArray(l, i, o, t), this.buildDrawCalls(l, c, u), c = u, l = r[++a], ++o), h._batchEnabled = o, h.touched = s, l.elements[l.count++] = h)
        }
        l.count > 0 && (n.boundArray(l, i, o, t), this.buildDrawCalls(l, c, this._bufferSize), ++a, ++o);
        for (let u = 0; u < i.length; u++) i[u] = null;
        Oe._globalBatch = o
    }
    buildDrawCalls(e, t, r) {
        const {
            _bufferedElements: n,
            _attributeBuffer: i,
            _indexBuffer: s,
            vertexSize: o
        } = this, a = pn._drawCallPool;
        let l = this._dcIndex,
            c = this._aIndex,
            u = this._iIndex,
            h = a[l];
        h.start = this._iIndex, h.texArray = e;
        for (let d = t; d < r; ++d) {
            const f = n[d],
                p = f._texture.baseTexture,
                m = ZI[p.alphaMode ? 1 : 0][f.blendMode];
            n[d] = null, t < d && h.blend !== m && (h.size = u - h.start, t = d, h = a[++l], h.texArray = e, h.start = u), this.packInterleavedGeometry(f, i, s, c, u), c += f.vertexData.length / 2 * o, u += f.indices.length, h.blend = m
        }
        t < r && (h.size = u - h.start, ++l), this._dcIndex = l, this._aIndex = c, this._iIndex = u
    }
    bindAndClearTexArray(e) {
        const t = this.renderer.texture;
        for (let r = 0; r < e.count; r++) t.bind(e.elements[r], e.ids[r]), e.elements[r] = null;
        e.count = 0
    }
    updateGeometry() {
        const {
            _packedGeometries: e,
            _attributeBuffer: t,
            _indexBuffer: r
        } = this;
        pn.canUploadSameBuffer ? (e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(r), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, e[this._flushId] = new this.geometryClass), e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(r), this.renderer.geometry.bind(e[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
    }
    drawBatches() {
        const e = this._dcIndex,
            {
                gl: t,
                state: r
            } = this.renderer,
            n = pn._drawCallPool;
        let i = null;
        for (let s = 0; s < e; s++) {
            const {
                texArray: o,
                type: a,
                size: l,
                start: c,
                blend: u
            } = n[s];
            i !== o && (i = o, this.bindAndClearTexArray(o)), this.state.blendMode = u, r.set(this.state), t.drawElements(a, l, t.UNSIGNED_SHORT, c * 2)
        }
    }
    flush() {
        this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
    }
    start() {
        this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), pn.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
    }
    stop() {
        this.flush()
    }
    destroy() {
        for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy();
        this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy()
    }
    getAttributeBuffer(e) {
        const t = vf(Math.ceil(e / 8)),
            r = YE(t),
            n = t * 8;
        this._aBuffers.length <= r && (this._iBuffers.length = r + 1);
        let i = this._aBuffers[n];
        return i || (this._aBuffers[n] = i = new jy(n * this.vertexSize * 4)), i
    }
    getIndexBuffer(e) {
        const t = vf(Math.ceil(e / 12)),
            r = YE(t),
            n = t * 12;
        this._iBuffers.length <= r && (this._iBuffers.length = r + 1);
        let i = this._iBuffers[r];
        return i || (this._iBuffers[r] = i = new Uint16Array(n)), i
    }
    packInterleavedGeometry(e, t, r, n, i) {
        const {
            uint32View: s,
            float32View: o
        } = t, a = n / this.vertexSize, l = e.uvs, c = e.indices, u = e.vertexData, h = e._texture.baseTexture._batchLocation, d = Math.min(e.worldAlpha, 1), f = ot.shared.setValue(e._tintRGB).toPremultiplied(d, e._texture.baseTexture.alphaMode > 0);
        for (let p = 0; p < u.length; p += 2) o[n++] = u[p], o[n++] = u[p + 1], o[n++] = l[p], o[n++] = l[p + 1], s[n++] = f, o[n++] = h;
        for (let p = 0; p < c.length; p++) r[i++] = a + c[p]
    }
};
let wn = pn;
wn.defaultBatchSize = 4096;
wn.extension = {
    name: "batch",
    type: ue.RendererPlugin
};
wn._drawCallPool = [];
wn._textureArrayPool = [];
ye.add(wn);
var kz = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`,
    Mz = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const lc = class extends ni {
    constructor(e, t, r) {
        const n = En.from(e || lc.defaultVertexSrc, t || lc.defaultFragmentSrc);
        super(n, r), this.padding = 0, this.resolution = lc.defaultResolution, this.multisample = lc.defaultMultisample, this.enabled = !0, this.autoFit = !0, this.state = new ki
    }
    apply(e, t, r, n, i) {
        e.applyFilter(this, t, r, n)
    }
    get blendMode() {
        return this.state.blendMode
    }
    set blendMode(e) {
        this.state.blendMode = e
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._resolution = e
    }
    static get defaultVertexSrc() {
        return Mz
    }
    static get defaultFragmentSrc() {
        return kz
    }
};
let rr = lc;
rr.defaultResolution = 1;
rr.defaultMultisample = Rt.NONE;
class Mm {
    constructor() {
        this.clearBeforeRender = !0, this._backgroundColor = new ot(0), this.alpha = 1
    }
    init(t) {
        this.clearBeforeRender = t.clearBeforeRender;
        const {
            backgroundColor: r,
            background: n,
            backgroundAlpha: i
        } = t, s = n??r;
        s !== void 0 && (this.color = s), this.alpha = i
    }
    get color() {
        return this._backgroundColor.value
    }
    set color(t) {
        this._backgroundColor.setValue(t)
    }
    get alpha() {
        return this._backgroundColor.alpha
    }
    set alpha(t) {
        this._backgroundColor.setAlpha(t)
    }
    get backgroundColor() {
        return this._backgroundColor
    }
    destroy() {}
}
Mm.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0
};
Mm.extension = {
    type: [ue.RendererSystem, ue.CanvasRendererSystem],
    name: "background"
};
ye.add(Mm);
class u$ {
    constructor(t) {
        this.renderer = t, this.emptyRenderer = new km(t), this.currentRenderer = this.emptyRenderer
    }
    setObjectRenderer(t) {
        this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
    }
    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    copyBoundTextures(t, r) {
        const {
            boundTextures: n
        } = this.renderer.texture;
        for (let i = r - 1; i >= 0; --i) t[i] = n[i] || null, t[i] && (t[i]._batchLocation = i)
    }
    boundArray(t, r, n, i) {
        const {
            elements: s,
            ids: o,
            count: a
        } = t;
        let l = 0;
        for (let c = 0; c < a; c++) {
            const u = s[c],
                h = u._batchLocation;
            if (h >= 0 && h < i && r[h] === u) {
                o[c] = h;
                continue
            }
            for (; l < i;) {
                const d = r[l];
                if (d && d._batchEnabled === n && d._batchLocation === l) {
                    l++;
                    continue
                }
                o[c] = l, u._batchLocation = l, r[l] = u;
                break
            }
        }
    }
    destroy() {
        this.renderer = null
    }
}
u$.extension = {
    type: ue.RendererSystem,
    name: "batch"
};
ye.add(u$);
let iS = 0;
class Dm {
    constructor(t) {
        this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
            uint32Indices: !1
        }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(t) {
        this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = iS++
    }
    init(t) {
        if (t.context) this.initFromContext(t.context);
        else {
            const r = this.renderer.background.alpha < 1,
                n = t.premultipliedAlpha;
            this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.useContextAlpha = t.useContextAlpha, this.powerPreference = t.powerPreference, this.initFromOptions({
                alpha: r,
                premultipliedAlpha: n,
                antialias: t.antialias,
                stencil: !0,
                preserveDrawingBuffer: t.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            })
        }
    }
    initFromContext(t) {
        this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = iS++, this.renderer.runners.contextChange.emit(t);
        const r = this.renderer.view;
        r.addEventListener !== void 0 && (r.addEventListener("webglcontextlost", this.handleContextLost, !1), r.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
    }
    initFromOptions(t) {
        const r = this.createContext(this.renderer.view, t);
        this.initFromContext(r)
    }
    createContext(t, r) {
        let n;
        if (ce.PREFER_ENV >= Po.WEBGL2 && (n = t.getContext("webgl2", r)), n) this.webGLVersion = 2;
        else if (this.webGLVersion = 1, n = t.getContext("webgl", r) || t.getContext("experimental-webgl", r), !n) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = n, this.getExtensions(), this.gl
    }
    getExtensions() {
        const {
            gl: t
        } = this, r = {
            loseContext: t.getExtension("WEBGL_lose_context"),
            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: t.getExtension("WEBGL_compressed_texture_etc"),
            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: t.getExtension("WEBGL_compressed_texture_atc"),
            astc: t.getExtension("WEBGL_compressed_texture_astc")
        };
        this.webGLVersion === 1 ? Object.assign(this.extensions, r, {
            drawBuffers: t.getExtension("WEBGL_draw_buffers"),
            depthTexture: t.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: t.getExtension("OES_element_index_uint"),
            floatTexture: t.getExtension("OES_texture_float"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            textureHalfFloat: t.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
        }) : this.webGLVersion === 2 && Object.assign(this.extensions, r, {
            colorBufferFloat: t.getExtension("EXT_color_buffer_float")
        })
    }
    handleContextLost(t) {
        t.preventDefault(), setTimeout(() => {
            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
        }, 0)
    }
    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        const t = this.renderer.view;
        this.renderer = null, t.removeEventListener !== void 0 && (t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }
    validateContext(t) {
        const r = t.getContextAttributes(),
            n = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
        n && (this.webGLVersion = 2), r && !r.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const i = n || !!t.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = i, i || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
    }
}
Dm.defaultOptions = {
    context: null,
    antialias: !1,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: "default"
};
Dm.extension = {
    type: ue.RendererSystem,
    name: "context"
};
ye.add(Dm);
class Dz extends xu {
    upload(t, r, n) {
        const i = t.gl;
        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === Nn.UNPACK);
        const s = r.realWidth,
            o = r.realHeight;
        return n.width === s && n.height === o ? i.texSubImage2D(r.target, 0, 0, 0, s, o, r.format, n.type, this.data) : (n.width = s, n.height = o, i.texImage2D(r.target, 0, n.internalFormat, s, o, 0, r.format, n.type, this.data)), !0
    }
}
class Wy {
    constructor(t, r) {
        this.width = Math.round(t || 100), this.height = Math.round(r || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new An("disposeFramebuffer"), this.multisample = Rt.NONE
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    addColorTexture(t = 0, r) {
        return this.colorTextures[t] = r || new Oe(null, {
            scaleMode: bi.NEAREST,
            resolution: 1,
            mipmap: si.OFF,
            width: this.width,
            height: this.height
        }), this.dirtyId++, this.dirtyFormat++, this
    }
    addDepthTexture(t) {
        return this.depthTexture = t || new Oe(new Dz(null, {
            width: this.width,
            height: this.height
        }), {
            scaleMode: bi.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: si.OFF,
            format: se.DEPTH_COMPONENT,
            type: be.UNSIGNED_SHORT
        }), this.dirtyId++, this.dirtyFormat++, this
    }
    enableDepth() {
        return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
    }
    enableStencil() {
        return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
    }
    resize(t, r) {
        if (t = Math.round(t), r = Math.round(r), !(t === this.width && r === this.height)) {
            this.width = t, this.height = r, this.dirtyId++, this.dirtySize++;
            for (let n = 0; n < this.colorTextures.length; n++) {
                const i = this.colorTextures[n],
                    s = i.resolution;
                i.setSize(t / s, r / s)
            }
            if (this.depthTexture) {
                const n = this.depthTexture.resolution;
                this.depthTexture.setSize(t / n, r / n)
            }
        }
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroyDepthTexture() {
        this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
    }
}
class h$ extends Oe {
    constructor(t = {}) {
        if (typeof t == "number") {
            const r = arguments[0],
                n = arguments[1],
                i = arguments[2],
                s = arguments[3];
            t = {
                width: r,
                height: n,
                scaleMode: i,
                resolution: s
            }
        }
        t.width = t.width || 100, t.height = t.height || 100, t.multisample??(t.multisample = Rt.NONE), super(null, t), this.mipmap = si.OFF, this.valid = !0, this._clear = new ot([0, 0, 0, 0]), this.framebuffer = new Wy(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = t.multisample, this.maskStack = [], this.filterStack = [{}]
    }
    set clearColor(t) {
        this._clear.setValue(t)
    }
    get clearColor() {
        return this._clear.value
    }
    get clear() {
        return this._clear
    }
    resize(t, r) {
        this.framebuffer.resize(t * this.resolution, r * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height)
    }
    dispose() {
        this.framebuffer.dispose(), super.dispose()
    }
    destroy() {
        super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
    }
}
class Cs extends eu {
    constructor(t) {
        const r = t,
            n = r.naturalWidth || r.videoWidth || r.width,
            i = r.naturalHeight || r.videoHeight || r.height;
        super(n, i), this.source = t, this.noSubImage = !1
    }
    static crossOrigin(t, r, n) {
        n === void 0 && !r.startsWith("data:") ? t.crossOrigin = nz(r) : n !== !1 && (t.crossOrigin = typeof n == "string" ? n : "anonymous")
    }
    upload(t, r, n, i) {
        const s = t.gl,
            o = r.realWidth,
            a = r.realHeight;
        if (i = i || this.source, typeof HTMLImageElement < "u" && i instanceof HTMLImageElement) {
            if (!i.complete || i.naturalWidth === 0) return !1
        } else if (typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement && i.readyState <= 1 && i.buffered.length === 0) return !1;
        return s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === Nn.UNPACK), !this.noSubImage && r.target === s.TEXTURE_2D && n.width === o && n.height === a ? s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, r.format, n.type, i) : (n.width = o, n.height = a, s.texImage2D(r.target, 0, n.internalFormat, r.format, n.type, i)), !0
    }
    update() {
        if (this.destroyed) return;
        const t = this.source,
            r = t.naturalWidth || t.videoWidth || t.width,
            n = t.naturalHeight || t.videoHeight || t.height;
        this.resize(r, n), super.update()
    }
    dispose() {
        this.source = null
    }
}
class d$ extends Cs {
    constructor(t, r) {
        if (r = r || {}, typeof t == "string") {
            const n = new Image;
            Cs.crossOrigin(n, t, r.crossorigin), n.src = t, t = n
        }
        super(t), !t.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = t.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (r.createBitmap??ce.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof r.alphaMode == "number" ? r.alphaMode : null, this.bitmap = null, this._load = null, r.autoLoad !== !1 && this.load()
    }
    load(t) {
        return this._load ? this._load : (t !== void 0 && (this.createBitmap = t), this._load = new Promise((r, n) => {
            const i = this.source;
            this.url = i.src;
            const s = () => {
                this.destroyed || (i.onload = null, i.onerror = null, this.resize(i.width, i.height), this._load = null, this.createBitmap ? r(this.process()) : r(this))
            };
            i.complete && i.src ? s() : (i.onload = s, i.onerror = o => {
                n(o), this.onError.emit(o)
            })
        }), this._load)
    }
    process() {
        const t = this.source;
        if (this._process !== null) return this._process;
        if (this.bitmap !== null || !globalThis.createImageBitmap) return Promise.resolve(this);
        const r = globalThis.createImageBitmap,
            n = !t.crossOrigin || t.crossOrigin === "anonymous";
        return this._process = fetch(t.src, {
            mode: n ? "cors" : "no-cors"
        }).then(i => i.blob()).then(i => r(i, 0, 0, t.width, t.height, {
            premultiplyAlpha: this.alphaMode === null || this.alphaMode === Nn.UNPACK ? "premultiply" : "none"
        })).then(i => this.destroyed ? Promise.reject() : (this.bitmap = i, this.update(), this._process = null, Promise.resolve(this))), this._process
    }
    upload(t, r, n) {
        if (typeof this.alphaMode == "number" && (r.alphaMode = this.alphaMode), !this.createBitmap) return super.upload(t, r, n);
        if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
        if (super.upload(t, r, n, this.bitmap), !this.preserveBitmap) {
            let i = !0;
            const s = r._glTextures;
            for (const o in s) {
                const a = s[o];
                if (a !== n && a.dirtyId !== r.dirtyId) {
                    i = !1;
                    break
                }
            }
            i && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
        }
        return !0
    }
    dispose() {
        this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
    }
    static test(t) {
        return typeof HTMLImageElement < "u" && (typeof t == "string" || t instanceof HTMLImageElement)
    }
}
class f$ {
    constructor() {
        this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
    }
    set(t, r, n) {
        const i = r.width,
            s = r.height;
        if (n) {
            const o = t.width / 2 / i,
                a = t.height / 2 / s,
                l = t.x / i + o,
                c = t.y / s + a;
            n = vt.add(n, vt.NW), this.x0 = l + o * vt.uX(n), this.y0 = c + a * vt.uY(n), n = vt.add(n, 2), this.x1 = l + o * vt.uX(n), this.y1 = c + a * vt.uY(n), n = vt.add(n, 2), this.x2 = l + o * vt.uX(n), this.y2 = c + a * vt.uY(n), n = vt.add(n, 2), this.x3 = l + o * vt.uX(n), this.y3 = c + a * vt.uY(n)
        } else this.x0 = t.x / i, this.y0 = t.y / s, this.x1 = (t.x + t.width) / i, this.y1 = t.y / s, this.x2 = (t.x + t.width) / i, this.y2 = (t.y + t.height) / s, this.x3 = t.x / i, this.y3 = (t.y + t.height) / s;
        this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
    }
    toString() {
        return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
    }
}
const sS = new f$;

function Sh(e) {
    e.destroy = function() {}, e.on = function() {}, e.once = function() {}, e.emit = function() {}
}
class ge extends go {
    constructor(t, r, n, i, s, o, a) {
        if (super(), this.noFrame = !1, r || (this.noFrame = !0, r = new $e(0, 0, 1, 1)), t instanceof ge && (t = t.baseTexture), this.baseTexture = t, this._frame = r, this.trim = i, this.valid = !1, this._uvs = sS, this.uvMatrix = null, this.orig = n || r, this._rotate = Number(s || 0), s === !0) this._rotate = 2;
        else if (this._rotate % 2 !== 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        this.defaultAnchor = o ? new Se(o.x, o.y) : new Se(0, 0), this.defaultBorders = a, this._updateID = 0, this.textureCacheIds = [], t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = r : t.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
    }
    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }
    onBaseTextureUpdated(t) {
        if (this.noFrame) {
            if (!this.baseTexture.valid) return;
            this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
        } else this.frame = this._frame;
        this.emit("update", this)
    }
    destroy(t) {
        if (this.baseTexture) {
            if (t) {
                const {
                    resource: r
                } = this.baseTexture;
                r != null && r.url && Un[r.url] && ge.removeFromCache(r.url), this.baseTexture.destroy()
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
        }
        this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, ge.removeFromCache(this), this.textureCacheIds = null
    }
    clone() {
        var i;
        const t = this._frame.clone(),
            r = this._frame === this.orig ? t : this.orig.clone(),
            n = new ge(this.baseTexture, !this.noFrame && t, r, (i = this.trim) == null ? void 0 : i.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
        return this.noFrame && (n._frame = t), n
    }
    updateUvs() {
        this._uvs === sS && (this._uvs = new f$), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
    }
    static from(t, r = {}, n = ce.STRICT_TEXTURE_CACHE) {
        const i = typeof t == "string";
        let s = null;
        if (i) s = t;
        else if (t instanceof Oe) {
            if (!t.cacheId) {
                const a = (r == null ? void 0 : r.pixiIdPrefix) || "pixiid";
                t.cacheId = `${a}-${yo()}`, Oe.addToCache(t, t.cacheId)
            }
            s = t.cacheId
        } else {
            if (!t._pixiId) {
                const a = (r == null ? void 0 : r.pixiIdPrefix) || "pixiid";
                t._pixiId = `${a}_${yo()}`
            }
            s = t._pixiId
        }
        let o = Un[s];
        if (i && n && !o) throw new Error(`The cacheId "${s}" does not exist in TextureCache.`);
        return !o && !(t instanceof Oe) ? (r.resolution || (r.resolution = Ss(t)), o = new ge(new Oe(t, r)), o.baseTexture.cacheId = s, Oe.addToCache(o.baseTexture, s), ge.addToCache(o, s)) : !o && t instanceof Oe && (o = new ge(t), ge.addToCache(o, s)), o
    }
    static fromURL(t, r) {
        const n = Object.assign({
                autoLoad: !1
            }, r == null ? void 0 : r.resourceOptions),
            i = ge.from(t, Object.assign({
                resourceOptions: n
            }, r), !1),
            s = i.baseTexture.resource;
        return i.baseTexture.valid ? Promise.resolve(i) : s.load().then(() => Promise.resolve(i))
    }
    static fromBuffer(t, r, n, i) {
        return new ge(Oe.fromBuffer(t, r, n, i))
    }
    static fromLoader(t, r, n, i) {
        const s = new Oe(t, Object.assign({
                scaleMode: Oe.defaultOptions.scaleMode,
                resolution: Ss(r)
            }, i)),
            {
                resource: o
            } = s;
        o instanceof d$ && (o.url = r);
        const a = new ge(s);
        return n || (n = r), Oe.addToCache(a.baseTexture, n), ge.addToCache(a, n), n !== r && (Oe.addToCache(a.baseTexture, r), ge.addToCache(a, r)), a.baseTexture.valid ? Promise.resolve(a) : new Promise(l => {
            a.baseTexture.once("loaded", () => l(a))
        })
    }
    static addToCache(t, r) {
        r && (t.textureCacheIds.includes(r) || t.textureCacheIds.push(r), Un[r] && Un[r] !== t && console.warn(`Texture added to the cache with an id [${r}] that already had an entry`), Un[r] = t)
    }
    static removeFromCache(t) {
        if (typeof t == "string") {
            const r = Un[t];
            if (r) {
                const n = r.textureCacheIds.indexOf(t);
                return n > -1 && r.textureCacheIds.splice(n, 1), delete Un[t], r
            }
        } else if (t != null && t.textureCacheIds) {
            for (let r = 0; r < t.textureCacheIds.length; ++r) Un[t.textureCacheIds[r]] === t && delete Un[t.textureCacheIds[r]];
            return t.textureCacheIds.length = 0, t
        }
        return null
    }
    get resolution() {
        return this.baseTexture.resolution
    }
    get frame() {
        return this._frame
    }
    set frame(t) {
        this._frame = t, this.noFrame = !1;
        const {
            x: r,
            y: n,
            width: i,
            height: s
        } = t, o = r + i > this.baseTexture.width, a = n + s > this.baseTexture.height;
        if (o || a) {
            const l = o && a ? "and" : "or",
                c = `X: ${r} + ${i} = ${r+i} > ${this.baseTexture.width}`,
                u = `Y: ${n} + ${s} = ${n+s} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${c} ${l} ${u}`)
        }
        this.valid = i && s && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = t), this.valid && this.updateUvs()
    }
    get rotate() {
        return this._rotate
    }
    set rotate(t) {
        this._rotate = t, this.valid && this.updateUvs()
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    castToBaseTexture() {
        return this.baseTexture
    }
    static get EMPTY() {
        return ge._EMPTY || (ge._EMPTY = new ge(new Oe), Sh(ge._EMPTY), Sh(ge._EMPTY.baseTexture)), ge._EMPTY
    }
    static get WHITE() {
        if (!ge._WHITE) {
            const t = ce.ADAPTER.createCanvas(16, 16),
                r = t.getContext("2d");
            t.width = 16, t.height = 16, r.fillStyle = "white", r.fillRect(0, 0, 16, 16), ge._WHITE = new ge(Oe.from(t)), Sh(ge._WHITE), Sh(ge._WHITE.baseTexture)
        }
        return ge._WHITE
    }
}
class Co extends ge {
    constructor(t, r) {
        super(t, r), this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs()
    }
    get framebuffer() {
        return this.baseTexture.framebuffer
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, r, n = !0) {
        const i = this.baseTexture.resolution,
            s = Math.round(t * i) / i,
            o = Math.round(r * i) / i;
        this.valid = s > 0 && o > 0, this._frame.width = this.orig.width = s, this._frame.height = this.orig.height = o, n && this.baseTexture.resize(s, o), this.updateUvs()
    }
    setResolution(t) {
        const {
            baseTexture: r
        } = this;
        r.resolution !== t && (r.setResolution(t), this.resize(r.width, r.height, !1))
    }
    static create(t) {
        return new Co(new h$(t))
    }
}
class p$ {
    constructor(t) {
        this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
    }
    createTexture(t, r, n = Rt.NONE) {
        const i = new h$(Object.assign({
            width: t,
            height: r,
            resolution: 1,
            multisample: n
        }, this.textureOptions));
        return new Co(i)
    }
    getOptimalTexture(t, r, n = 1, i = Rt.NONE) {
        let s;
        t = Math.ceil(t * n - 1e-6), r = Math.ceil(r * n - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || r !== this._pixelsHeight ? (t = vf(t), r = vf(r), s = ((t & 65535) << 16 | r & 65535) >>> 0, i > 1 && (s += i * 4294967296)) : s = i > 1 ? -i : -1, this.texturePool[s] || (this.texturePool[s] = []);
        let o = this.texturePool[s].pop();
        return o || (o = this.createTexture(t, r, i)), o.filterPoolKey = s, o.setResolution(n), o
    }
    getFilterTexture(t, r, n) {
        const i = this.getOptimalTexture(t.width, t.height, r || t.resolution, n || Rt.NONE);
        return i.filterFrame = t.filterFrame, i
    }
    returnTexture(t) {
        const r = t.filterPoolKey;
        t.filterFrame = null, this.texturePool[r].push(t)
    }
    returnFilterTexture(t) {
        this.returnTexture(t)
    }
    clear(t) {
        if (t = t !== !1, t)
            for (const r in this.texturePool) {
                const n = this.texturePool[r];
                if (n)
                    for (let i = 0; i < n.length; i++) n[i].destroy(!0)
            }
        this.texturePool = {}
    }
    setScreenSize(t) {
        if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
            this.enableFullScreen = t.width > 0 && t.height > 0;
            for (const r in this.texturePool) {
                if (!(Number(r) < 0)) continue;
                const n = this.texturePool[r];
                if (n)
                    for (let i = 0; i < n.length; i++) n[i].destroy(!0);
                this.texturePool[r] = []
            }
            this._pixelsWidth = t.width, this._pixelsHeight = t.height
        }
    }
}
p$.SCREEN_KEY = -1;
class Nz extends Ps {
    constructor() {
        super(), this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
    }
}
class m$ extends Ps {
    constructor() {
        super(), this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.vertexBuffer = new Ct(this.vertices), this.uvBuffer = new Ct(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
    }
    map(t, r) {
        let n = 0,
            i = 0;
        return this.uvs[0] = n, this.uvs[1] = i, this.uvs[2] = n + r.width / t.width, this.uvs[3] = i, this.uvs[4] = n + r.width / t.width, this.uvs[5] = i + r.height / t.height, this.uvs[6] = n, this.uvs[7] = i + r.height / t.height, n = r.x, i = r.y, this.vertices[0] = n, this.vertices[1] = i, this.vertices[2] = n + r.width, this.vertices[3] = i, this.vertices[4] = n + r.width, this.vertices[5] = i + r.height, this.vertices[6] = n, this.vertices[7] = i + r.height, this.invalidate(), this
    }
    invalidate() {
        return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
    }
}
class Lz {
    constructor() {
        this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = Rt.NONE, this.sourceFrame = new $e, this.destinationFrame = new $e, this.bindingSourceFrame = new $e, this.bindingDestinationFrame = new $e, this.filters = [], this.transform = null
    }
    clear() {
        this.target = null, this.filters = null, this.renderTexture = null
    }
}
const Ph = [new Se, new Se, new Se, new Se],
    jv = new mt;
class g$ {
    constructor(t) {
        this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new p$, this.statePool = [], this.quad = new Nz, this.quadUv = new m$, this.tempRect = new $e, this.activeState = {}, this.globalUniforms = new In({
            outputFrame: new $e,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4)
        }, !0), this.forceClear = !1, this.useMaxPadding = !1
    }
    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    push(t, r) {
        const n = this.renderer,
            i = this.defaultFilterStack,
            s = this.statePool.pop() || new Lz,
            o = this.renderer.renderTexture;
        let a = r[0].resolution,
            l = r[0].multisample,
            c = r[0].padding,
            u = r[0].autoFit,
            h = r[0].legacy??!0;
        for (let p = 1; p < r.length; p++) {
            const m = r[p];
            a = Math.min(a, m.resolution), l = Math.min(l, m.multisample), c = this.useMaxPadding ? Math.max(c, m.padding) : c + m.padding, u = u && m.autoFit, h = h || (m.legacy??!0)
        }
        i.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current), i.push(s), s.resolution = a, s.multisample = l, s.legacy = h, s.target = t, s.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), s.sourceFrame.pad(c);
        const d = this.tempRect.copyFrom(o.sourceFrame);
        n.projection.transform && this.transformAABB(jv.copyFrom(n.projection.transform).invert(), d), u ? (s.sourceFrame.fit(d), (s.sourceFrame.width <= 0 || s.sourceFrame.height <= 0) && (s.sourceFrame.width = 0, s.sourceFrame.height = 0)) : s.sourceFrame.intersects(d) || (s.sourceFrame.width = 0, s.sourceFrame.height = 0), this.roundFrame(s.sourceFrame, o.current ? o.current.resolution : n.resolution, o.sourceFrame, o.destinationFrame, n.projection.transform), s.renderTexture = this.getOptimalFilterTexture(s.sourceFrame.width, s.sourceFrame.height, a, l), s.filters = r, s.destinationFrame.width = s.renderTexture.width, s.destinationFrame.height = s.renderTexture.height;
        const f = this.tempRect;
        f.x = 0, f.y = 0, f.width = s.sourceFrame.width, f.height = s.sourceFrame.height, s.renderTexture.filterFrame = s.sourceFrame, s.bindingSourceFrame.copyFrom(o.sourceFrame), s.bindingDestinationFrame.copyFrom(o.destinationFrame), s.transform = n.projection.transform, n.projection.transform = null, o.bind(s.renderTexture, s.sourceFrame, f), n.framebuffer.clear(0, 0, 0, 0)
    }
    pop() {
        const t = this.defaultFilterStack,
            r = t.pop(),
            n = r.filters;
        this.activeState = r;
        const i = this.globalUniforms.uniforms;
        i.outputFrame = r.sourceFrame, i.resolution = r.resolution;
        const s = i.inputSize,
            o = i.inputPixel,
            a = i.inputClamp;
        if (s[0] = r.destinationFrame.width, s[1] = r.destinationFrame.height, s[2] = 1 / s[0], s[3] = 1 / s[1], o[0] = Math.round(s[0] * r.resolution), o[1] = Math.round(s[1] * r.resolution), o[2] = 1 / o[0], o[3] = 1 / o[1], a[0] = .5 * o[2], a[1] = .5 * o[3], a[2] = r.sourceFrame.width * s[2] - .5 * o[2], a[3] = r.sourceFrame.height * s[3] - .5 * o[3], r.legacy) {
            const c = i.filterArea;
            c[0] = r.destinationFrame.width, c[1] = r.destinationFrame.height, c[2] = r.sourceFrame.x, c[3] = r.sourceFrame.y, i.filterClamp = i.inputClamp
        }
        this.globalUniforms.update();
        const l = t[t.length - 1];
        if (this.renderer.framebuffer.blit(), n.length === 1) n[0].apply(this, r.renderTexture, l.renderTexture, Vn.BLEND, r), this.returnFilterTexture(r.renderTexture);
        else {
            let c = r.renderTexture,
                u = this.getOptimalFilterTexture(c.width, c.height, r.resolution);
            u.filterFrame = c.filterFrame;
            let h = 0;
            for (h = 0; h < n.length - 1; ++h) {
                h === 1 && r.multisample > 1 && (u = this.getOptimalFilterTexture(c.width, c.height, r.resolution), u.filterFrame = c.filterFrame), n[h].apply(this, c, u, Vn.CLEAR, r);
                const d = c;
                c = u, u = d
            }
            n[h].apply(this, c, l.renderTexture, Vn.BLEND, r), h > 1 && r.multisample > 1 && this.returnFilterTexture(r.renderTexture), this.returnFilterTexture(c), this.returnFilterTexture(u)
        }
        r.clear(), this.statePool.push(r)
    }
    bindAndClear(t, r = Vn.CLEAR) {
        const {
            renderTexture: n,
            state: i
        } = this.renderer;
        if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t != null && t.filterFrame) {
            const o = this.tempRect;
            o.x = 0, o.y = 0, o.width = t.filterFrame.width, o.height = t.filterFrame.height, n.bind(t, t.filterFrame, o)
        } else t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        const s = i.stateId & 1 || this.forceClear;
        (r === Vn.CLEAR || r === Vn.BLIT && s) && this.renderer.framebuffer.clear(0, 0, 0, 0)
    }
    applyFilter(t, r, n, i) {
        const s = this.renderer;
        s.state.set(t.state), this.bindAndClear(n, i), t.uniforms.uSampler = r, t.uniforms.filterGlobals = this.globalUniforms, s.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(r._frame, r.filterFrame), s.geometry.bind(this.quadUv), s.geometry.draw(Zn.TRIANGLES)) : (s.geometry.bind(this.quad), s.geometry.draw(Zn.TRIANGLE_STRIP))
    }
    calculateSpriteMatrix(t, r) {
        const {
            sourceFrame: n,
            destinationFrame: i
        } = this.activeState, {
            orig: s
        } = r._texture, o = t.set(i.width, 0, 0, i.height, n.x, n.y), a = r.worldTransform.copyTo(mt.TEMP_MATRIX);
        return a.invert(), o.prepend(a), o.scale(1 / s.width, 1 / s.height), o.translate(r.anchor.x, r.anchor.y), o
    }
    destroy() {
        this.renderer = null, this.texturePool.clear(!1)
    }
    getOptimalFilterTexture(t, r, n = 1, i = Rt.NONE) {
        return this.texturePool.getOptimalTexture(t, r, n, i)
    }
    getFilterTexture(t, r, n) {
        if (typeof t == "number") {
            const s = t;
            t = r, r = s
        }
        t = t || this.activeState.renderTexture;
        const i = this.texturePool.getOptimalTexture(t.width, t.height, r || t.resolution, n || Rt.NONE);
        return i.filterFrame = t.filterFrame, i
    }
    returnFilterTexture(t) {
        this.texturePool.returnTexture(t)
    }
    emptyPool() {
        this.texturePool.clear(!0)
    }
    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    transformAABB(t, r) {
        const n = Ph[0],
            i = Ph[1],
            s = Ph[2],
            o = Ph[3];
        n.set(r.left, r.top), i.set(r.left, r.bottom), s.set(r.right, r.top), o.set(r.right, r.bottom), t.apply(n, n), t.apply(i, i), t.apply(s, s), t.apply(o, o);
        const a = Math.min(n.x, i.x, s.x, o.x),
            l = Math.min(n.y, i.y, s.y, o.y),
            c = Math.max(n.x, i.x, s.x, o.x),
            u = Math.max(n.y, i.y, s.y, o.y);
        r.x = a, r.y = l, r.width = c - a, r.height = u - l
    }
    roundFrame(t, r, n, i, s) {
        if (!(t.width <= 0 || t.height <= 0 || n.width <= 0 || n.height <= 0)) {
            if (s) {
                const {
                    a: o,
                    b: a,
                    c: l,
                    d: c
                } = s;
                if ((Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(c) > 1e-4)) return
            }
            s = s ? jv.copyFrom(s) : jv.identity(), s.translate(-n.x, -n.y).scale(i.width / n.width, i.height / n.height).translate(i.x, i.y), this.transformAABB(s, t), t.ceil(r), this.transformAABB(s.invert(), t)
        }
    }
}
g$.extension = {
    type: ue.RendererSystem,
    name: "filter"
};
ye.add(g$);
class Fz {
    constructor(t) {
        this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = Rt.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0
    }
}
const Bz = new $e;
class v$ {
    constructor(t) {
        this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new Wy(10, 10), this.msaaSamples = null
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new $e, this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
            let r = this.renderer.context.extensions.drawBuffers,
                n = this.renderer.context.extensions.depthTexture;
            ce.PREFER_ENV === Po.WEBGL_LEGACY && (r = null, n = null), r ? t.drawBuffers = i => r.drawBuffersWEBGL(i) : (this.hasMRT = !1, t.drawBuffers = () => {}), n || (this.writeDepthTexture = !1)
        } else this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
    }
    bind(t, r, n = 0) {
        const {
            gl: i
        } = this;
        if (t) {
            const s = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
            this.current !== t && (this.current = t, i.bindFramebuffer(i.FRAMEBUFFER, s.framebuffer)), s.mipLevel !== n && (t.dirtyId++, t.dirtyFormat++, s.mipLevel = n), s.dirtyId !== t.dirtyId && (s.dirtyId = t.dirtyId, s.dirtyFormat !== t.dirtyFormat ? (s.dirtyFormat = t.dirtyFormat, s.dirtySize = t.dirtySize, this.updateFramebuffer(t, n)) : s.dirtySize !== t.dirtySize && (s.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
            for (let o = 0; o < t.colorTextures.length; o++) {
                const a = t.colorTextures[o];
                this.renderer.texture.unbind(a.parentTextureArray || a)
            }
            if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), r) {
                const o = r.width >> n,
                    a = r.height >> n,
                    l = o / r.width;
                this.setViewport(r.x * l, r.y * l, o, a)
            } else {
                const o = t.width >> n,
                    a = t.height >> n;
                this.setViewport(0, 0, o, a)
            }
        } else this.current && (this.current = null, i.bindFramebuffer(i.FRAMEBUFFER, null)), r ? this.setViewport(r.x, r.y, r.width, r.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
    }
    setViewport(t, r, n, i) {
        const s = this.viewport;
        t = Math.round(t), r = Math.round(r), n = Math.round(n), i = Math.round(i), (s.width !== n || s.height !== i || s.x !== t || s.y !== r) && (s.x = t, s.y = r, s.width = n, s.height = i, this.gl.viewport(t, r, n, i))
    }
    get size() {
        return this.current ? {
            x: 0,
            y: 0,
            width: this.current.width,
            height: this.current.height
        } : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height
        }
    }
    clear(t, r, n, i, s = Ay.COLOR | Ay.DEPTH) {
        const {
            gl: o
        } = this;
        o.clearColor(t, r, n, i), o.clear(s)
    }
    initFramebuffer(t) {
        const {
            gl: r
        } = this, n = new Fz(r.createFramebuffer());
        return n.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = n, this.managedFramebuffers.push(t), t.disposeRunner.add(this), n
    }
    resizeFramebuffer(t) {
        const {
            gl: r
        } = this, n = t.glFramebuffers[this.CONTEXT_UID];
        n.stencil && (r.bindRenderbuffer(r.RENDERBUFFER, n.stencil), n.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, n.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height));
        const i = t.colorTextures;
        let s = i.length;
        r.drawBuffers || (s = Math.min(s, 1));
        for (let o = 0; o < s; o++) {
            const a = i[o],
                l = a.parentTextureArray || a;
            this.renderer.texture.bind(l, 0), o === 0 && n.msaaBuffer && (r.bindRenderbuffer(r.RENDERBUFFER, n.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, n.multisample, l._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
        }
        t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
    }
    updateFramebuffer(t, r) {
        const {
            gl: n
        } = this, i = t.glFramebuffers[this.CONTEXT_UID], s = t.colorTextures;
        let o = s.length;
        n.drawBuffers || (o = Math.min(o, 1)), i.multisample > 1 && this.canMultisampleFramebuffer(t) ? i.msaaBuffer = i.msaaBuffer || n.createRenderbuffer() : i.msaaBuffer && (n.deleteRenderbuffer(i.msaaBuffer), i.msaaBuffer = null, i.blitFramebuffer && (i.blitFramebuffer.dispose(), i.blitFramebuffer = null));
        const a = [];
        for (let l = 0; l < o; l++) {
            const c = s[l],
                u = c.parentTextureArray || c;
            this.renderer.texture.bind(u, 0), l === 0 && i.msaaBuffer ? (n.bindRenderbuffer(n.RENDERBUFFER, i.msaaBuffer), n.renderbufferStorageMultisample(n.RENDERBUFFER, i.multisample, u._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, i.msaaBuffer)) : (n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + l, c.target, u._glTextures[this.CONTEXT_UID].texture, r), a.push(n.COLOR_ATTACHMENT0 + l))
        }
        if (a.length > 1 && n.drawBuffers(a), t.depthTexture && this.writeDepthTexture) {
            const c = t.depthTexture;
            this.renderer.texture.bind(c, 0), n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, c._glTextures[this.CONTEXT_UID].texture, r)
        }(t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (i.stencil = i.stencil || n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, i.stencil), i.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, i.multisample, n.DEPTH24_STENCIL8, t.width, t.height) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, t.width, t.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, i.stencil)) : i.stencil && (n.deleteRenderbuffer(i.stencil), i.stencil = null)
    }
    canMultisampleFramebuffer(t) {
        return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
    }
    detectSamples(t) {
        const {
            msaaSamples: r
        } = this;
        let n = Rt.NONE;
        if (t <= 1 || r === null) return n;
        for (let i = 0; i < r.length; i++)
            if (r[i] <= t) {
                n = r[i];
                break
            }
        return n === 1 && (n = Rt.NONE), n
    }
    blit(t, r, n) {
        const {
            current: i,
            renderer: s,
            gl: o,
            CONTEXT_UID: a
        } = this;
        if (s.context.webGLVersion !== 2 || !i) return;
        const l = i.glFramebuffers[a];
        if (!l) return;
        if (!t) {
            if (!l.msaaBuffer) return;
            const u = i.colorTextures[0];
            if (!u) return;
            l.blitFramebuffer || (l.blitFramebuffer = new Wy(i.width, i.height), l.blitFramebuffer.addColorTexture(0, u)), t = l.blitFramebuffer, t.colorTextures[0] !== u && (t.colorTextures[0] = u, t.dirtyId++, t.dirtyFormat++), (t.width !== i.width || t.height !== i.height) && (t.width = i.width, t.height = i.height, t.dirtyId++, t.dirtySize++)
        }
        r || (r = Bz, r.width = i.width, r.height = i.height), n || (n = r);
        const c = r.width === n.width && r.height === n.height;
        this.bind(t), o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer), o.blitFramebuffer(r.left, r.top, r.right, r.bottom, n.left, n.top, n.right, n.bottom, o.COLOR_BUFFER_BIT, c ? o.NEAREST : o.LINEAR), o.bindFramebuffer(o.READ_FRAMEBUFFER, t.glFramebuffers[this.CONTEXT_UID].framebuffer)
    }
    disposeFramebuffer(t, r) {
        const n = t.glFramebuffers[this.CONTEXT_UID],
            i = this.gl;
        if (!n) return;
        delete t.glFramebuffers[this.CONTEXT_UID];
        const s = this.managedFramebuffers.indexOf(t);
        s >= 0 && this.managedFramebuffers.splice(s, 1), t.disposeRunner.remove(this), r || (i.deleteFramebuffer(n.framebuffer), n.msaaBuffer && i.deleteRenderbuffer(n.msaaBuffer), n.stencil && i.deleteRenderbuffer(n.stencil)), n.blitFramebuffer && this.disposeFramebuffer(n.blitFramebuffer, r)
    }
    disposeAll(t) {
        const r = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (let n = 0; n < r.length; n++) this.disposeFramebuffer(r[n], t)
    }
    forceStencil() {
        const t = this.current;
        if (!t) return;
        const r = t.glFramebuffers[this.CONTEXT_UID];
        if (!r || r.stencil) return;
        t.stencil = !0;
        const n = t.width,
            i = t.height,
            s = this.gl,
            o = s.createRenderbuffer();
        s.bindRenderbuffer(s.RENDERBUFFER, o), r.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, r.multisample, s.DEPTH24_STENCIL8, n, i) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, n, i), r.stencil = o, s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, o)
    }
    reset() {
        this.current = this.unknownFramebuffer, this.viewport = new $e
    }
    destroy() {
        this.renderer = null
    }
}
v$.extension = {
    type: ue.RendererSystem,
    name: "framebuffer"
};
ye.add(v$);
const Uv = {
    5126: 4,
    5123: 2,
    5121: 1
};
class y$ {
    constructor(t) {
        this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {}
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl,
            r = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, r.webGLVersion !== 2) {
            let n = this.renderer.context.extensions.vertexArrayObject;
            ce.PREFER_ENV === Po.WEBGL_LEGACY && (n = null), n ? (t.createVertexArray = () => n.createVertexArrayOES(), t.bindVertexArray = i => n.bindVertexArrayOES(i), t.deleteVertexArray = i => n.deleteVertexArrayOES(i)) : (this.hasVao = !1, t.createVertexArray = () => null, t.bindVertexArray = () => null, t.deleteVertexArray = () => null)
        }
        if (r.webGLVersion !== 2) {
            const n = t.getExtension("ANGLE_instanced_arrays");
            n ? (t.vertexAttribDivisor = (i, s) => n.vertexAttribDivisorANGLE(i, s), t.drawElementsInstanced = (i, s, o, a, l) => n.drawElementsInstancedANGLE(i, s, o, a, l), t.drawArraysInstanced = (i, s, o, a) => n.drawArraysInstancedANGLE(i, s, o, a)) : this.hasInstance = !1
        }
        this.canUseUInt32ElementIndex = r.webGLVersion === 2 || !!r.extensions.uint32ElementIndex
    }
    bind(t, r) {
        r = r || this.renderer.shader.shader;
        const {
            gl: n
        } = this;
        let i = t.glVertexArrayObjects[this.CONTEXT_UID],
            s = !1;
        i || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = i = {}, s = !0);
        const o = i[r.program.id] || this.initGeometryVao(t, r, s);
        this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? n.bindVertexArray(o) : this.activateVao(t, r.program)), this.updateBuffers()
    }
    reset() {
        this.unbind()
    }
    updateBuffers() {
        const t = this._activeGeometry,
            r = this.renderer.buffer;
        for (let n = 0; n < t.buffers.length; n++) {
            const i = t.buffers[n];
            r.update(i)
        }
    }
    checkCompatibility(t, r) {
        const n = t.attributes,
            i = r.attributeData;
        for (const s in i)
            if (!n[s]) throw new Error(`shader and geometry incompatible, geometry missing the "${s}" attribute`)
    }
    getSignature(t, r) {
        const n = t.attributes,
            i = r.attributeData,
            s = ["g", t.id];
        for (const o in n) i[o] && s.push(o, i[o].location);
        return s.join("-")
    }
    initGeometryVao(t, r, n = !0) {
        const i = this.gl,
            s = this.CONTEXT_UID,
            o = this.renderer.buffer,
            a = r.program;
        a.glPrograms[s] || this.renderer.shader.generateProgram(r), this.checkCompatibility(t, a);
        const l = this.getSignature(t, a),
            c = t.glVertexArrayObjects[this.CONTEXT_UID];
        let u = c[l];
        if (u) return c[a.id] = u, u;
        const h = t.buffers,
            d = t.attributes,
            f = {},
            p = {};
        for (const m in h) f[m] = 0, p[m] = 0;
        for (const m in d) !d[m].size && a.attributeData[m] ? d[m].size = a.attributeData[m].size : d[m].size || console.warn(`PIXI Geometry attribute '${m}' size cannot be determined (likely the bound shader does not have the attribute)`), f[d[m].buffer] += d[m].size * Uv[d[m].type];
        for (const m in d) {
            const w = d[m],
                y = w.size;
            w.stride === void 0 && (f[w.buffer] === y * Uv[w.type] ? w.stride = 0 : w.stride = f[w.buffer]), w.start === void 0 && (w.start = p[w.buffer], p[w.buffer] += y * Uv[w.type])
        }
        u = i.createVertexArray(), i.bindVertexArray(u);
        for (let m = 0; m < h.length; m++) {
            const w = h[m];
            o.bind(w), n && w._glBuffers[s].refCount++
        }
        return this.activateVao(t, a), c[a.id] = u, c[l] = u, i.bindVertexArray(null), o.unbind(ri.ARRAY_BUFFER), u
    }
    disposeGeometry(t, r) {
        var a;
        if (!this.managedGeometries[t.id]) return;
        delete this.managedGeometries[t.id];
        const n = t.glVertexArrayObjects[this.CONTEXT_UID],
            i = this.gl,
            s = t.buffers,
            o = (a = this.renderer) == null ? void 0 : a.buffer;
        if (t.disposeRunner.remove(this), !!n) {
            if (o)
                for (let l = 0; l < s.length; l++) {
                    const c = s[l]._glBuffers[this.CONTEXT_UID];
                    c && (c.refCount--, c.refCount === 0 && !r && o.dispose(s[l], r))
                }
            if (!r) {
                for (const l in n)
                    if (l[0] === "g") {
                        const c = n[l];
                        this._activeVao === c && this.unbind(), i.deleteVertexArray(c)
                    }
            }
            delete t.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }
    disposeAll(t) {
        const r = Object.keys(this.managedGeometries);
        for (let n = 0; n < r.length; n++) this.disposeGeometry(this.managedGeometries[r[n]], t)
    }
    activateVao(t, r) {
        const n = this.gl,
            i = this.CONTEXT_UID,
            s = this.renderer.buffer,
            o = t.buffers,
            a = t.attributes;
        t.indexBuffer && s.bind(t.indexBuffer);
        let l = null;
        for (const c in a) {
            const u = a[c],
                h = o[u.buffer],
                d = h._glBuffers[i];
            if (r.attributeData[c]) {
                l !== d && (s.bind(h), l = d);
                const f = r.attributeData[c].location;
                if (n.enableVertexAttribArray(f), n.vertexAttribPointer(f, u.size, u.type || n.FLOAT, u.normalized, u.stride, u.start), u.instance)
                    if (this.hasInstance) n.vertexAttribDivisor(f, u.divisor);
                    else throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }
    draw(t, r, n, i) {
        const {
            gl: s
        } = this, o = this._activeGeometry;
        if (o.indexBuffer) {
            const a = o.indexBuffer.data.BYTES_PER_ELEMENT,
                l = a === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
            a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? s.drawElementsInstanced(t, r || o.indexBuffer.data.length, l, (n || 0) * a, i || 1) : s.drawElements(t, r || o.indexBuffer.data.length, l, (n || 0) * a) : console.warn("unsupported index buffer type: uint32")
        } else o.instanced ? s.drawArraysInstanced(t, n, r || o.getSize(), i || 1) : s.drawArrays(t, n, r || o.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
    }
    destroy() {
        this.renderer = null
    }
}
y$.extension = {
    type: ue.RendererSystem,
    name: "geometry"
};
ye.add(y$);
const oS = new mt;
class _$ {
    constructor(t, r) {
        this._texture = t, this.mapCoord = new mt, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof r > "u" ? .5 : r, this.isSimple = !1
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture = t, this._textureID = -1
    }
    multiplyUvs(t, r) {
        r === void 0 && (r = t);
        const n = this.mapCoord;
        for (let i = 0; i < t.length; i += 2) {
            const s = t[i],
                o = t[i + 1];
            r[i] = s * n.a + o * n.c + n.tx, r[i + 1] = s * n.b + o * n.d + n.ty
        }
        return r
    }
    update(t) {
        const r = this._texture;
        if (!r || !r.valid || !t && this._textureID === r._updateID) return !1;
        this._textureID = r._updateID, this._updateID++;
        const n = r._uvs;
        this.mapCoord.set(n.x1 - n.x0, n.y1 - n.y0, n.x3 - n.x0, n.y3 - n.y0, n.x0, n.y0);
        const i = r.orig,
            s = r.trim;
        s && (oS.set(i.width / s.width, 0, 0, i.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(oS));
        const o = r.baseTexture,
            a = this.uClampFrame,
            l = this.clampMargin / o.resolution,
            c = this.clampOffset;
        return a[0] = (r._frame.x + l + c) / o.width, a[1] = (r._frame.y + l + c) / o.height, a[2] = (r._frame.x + r._frame.width - l + c) / o.width, a[3] = (r._frame.y + r._frame.height - l + c) / o.height, this.uClampOffset[0] = c / o.realWidth, this.uClampOffset[1] = c / o.realHeight, this.isSimple = r._frame.width === o.width && r._frame.height === o.height && r.rotate === 0, !0
    }
}
var zz = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`,
    jz = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
class Uz extends rr {
    constructor(t, r, n) {
        let i = null;
        typeof t != "string" && r === void 0 && n === void 0 && (i = t, t = void 0, r = void 0, n = void 0), super(t || jz, r || zz, n), this.maskSprite = i, this.maskMatrix = new mt
    }
    get maskSprite() {
        return this._maskSprite
    }
    set maskSprite(t) {
        this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1)
    }
    apply(t, r, n, i) {
        const s = this._maskSprite,
            o = s._texture;
        o.valid && (o.uvMatrix || (o.uvMatrix = new _$(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, s).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = s.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, r, n, i))
    }
}
class Hz {
    constructor(t = null) {
        this.type = Lt.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = rr.defaultMultisample, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null
    }
    get filter() {
        return this._filters ? this._filters[0] : null
    }
    set filter(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
    }
    reset() {
        this.pooled && (this.maskObject = null, this.type = Lt.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null
    }
    copyCountersOrReset(t) {
        t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
    }
}
class w$ {
    constructor(t) {
        this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
    }
    setMaskStack(t) {
        this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
    }
    push(t, r) {
        let n = r;
        if (!n.isMaskData) {
            const s = this.maskDataPool.pop() || new Hz;
            s.pooled = !0, s.maskObject = r, n = s
        }
        const i = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        if (n.copyCountersOrReset(i), n._colorMask = i ? i._colorMask : 15, n.autoDetect && this.detect(n), n._target = t, n.type !== Lt.SPRITE && this.maskStack.push(n), n.enabled) switch (n.type) {
            case Lt.SCISSOR:
                this.renderer.scissor.push(n);
                break;
            case Lt.STENCIL:
                this.renderer.stencil.push(n);
                break;
            case Lt.SPRITE:
                n.copyCountersOrReset(null), this.pushSpriteMask(n);
                break;
            case Lt.COLOR:
                this.pushColorMask(n);
                break
        }
        n.type === Lt.SPRITE && this.maskStack.push(n)
    }
    pop(t) {
        const r = this.maskStack.pop();
        if (!(!r || r._target !== t)) {
            if (r.enabled) switch (r.type) {
                case Lt.SCISSOR:
                    this.renderer.scissor.pop(r);
                    break;
                case Lt.STENCIL:
                    this.renderer.stencil.pop(r.maskObject);
                    break;
                case Lt.SPRITE:
                    this.popSpriteMask(r);
                    break;
                case Lt.COLOR:
                    this.popColorMask(r);
                    break
            }
            if (r.reset(), r.pooled && this.maskDataPool.push(r), this.maskStack.length !== 0) {
                const n = this.maskStack[this.maskStack.length - 1];
                n.type === Lt.SPRITE && n._filters && (n._filters[0].maskSprite = n.maskObject)
            }
        }
    }
    detect(t) {
        const r = t.maskObject;
        r ? r.isSprite ? t.type = Lt.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = Lt.SCISSOR : t.type = Lt.STENCIL : t.type = Lt.COLOR
    }
    pushSpriteMask(t) {
        const {
            maskObject: r
        } = t, n = t._target;
        let i = t._filters;
        i || (i = this.alphaMaskPool[this.alphaMaskIndex], i || (i = this.alphaMaskPool[this.alphaMaskIndex] = [new Uz]));
        const s = this.renderer,
            o = s.renderTexture;
        let a, l;
        if (o.current) {
            const u = o.current;
            a = t.resolution || u.resolution, l = t.multisample??u.multisample
        } else a = t.resolution || s.resolution, l = t.multisample??s.multisample;
        i[0].resolution = a, i[0].multisample = l, i[0].maskSprite = r;
        const c = n.filterArea;
        n.filterArea = r.getBounds(!0), s.filter.push(n, i), n.filterArea = c, t._filters || this.alphaMaskIndex++
    }
    popSpriteMask(t) {
        this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
    }
    pushColorMask(t) {
        const r = t._colorMask,
            n = t._colorMask = r & t.colorMask;
        n !== r && this.renderer.gl.colorMask((n & 1) !== 0, (n & 2) !== 0, (n & 4) !== 0, (n & 8) !== 0)
    }
    popColorMask(t) {
        const r = t._colorMask,
            n = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
        n !== r && this.renderer.gl.colorMask((n & 1) !== 0, (n & 2) !== 0, (n & 4) !== 0, (n & 8) !== 0)
    }
    destroy() {
        this.renderer = null
    }
}
w$.extension = {
    type: ue.RendererSystem,
    name: "mask"
};
ye.add(w$);
class b$ {
    constructor(t) {
        this.renderer = t, this.maskStack = [], this.glConst = 0
    }
    getStackLength() {
        return this.maskStack.length
    }
    setMaskStack(t) {
        const {
            gl: r
        } = this.renderer, n = this.getStackLength();
        this.maskStack = t;
        const i = this.getStackLength();
        i !== n && (i === 0 ? r.disable(this.glConst) : (r.enable(this.glConst), this._useCurrent()))
    }
    _useCurrent() {}
    destroy() {
        this.renderer = null, this.maskStack = null
    }
}
const aS = new mt,
    lS = [],
    xd = class extends b$ {
        constructor(e) {
            super(e), this.glConst = ce.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
        }
        getStackLength() {
            const e = this.maskStack[this.maskStack.length - 1];
            return e ? e._scissorCounter : 0
        }
        calcScissorRect(e) {
            if (e._scissorRectLocal) return;
            const t = e._scissorRect,
                {
                    maskObject: r
                } = e,
                {
                    renderer: n
                } = this,
                i = n.renderTexture,
                s = r.getBounds(!0, lS.pop()??new $e);
            this.roundFrameToPixels(s, i.current ? i.current.resolution : n.resolution, i.sourceFrame, i.destinationFrame, n.projection.transform), t && s.fit(t), e._scissorRectLocal = s
        }
        static isMatrixRotated(e) {
            if (!e) return !1;
            const {
                a: t,
                b: r,
                c: n,
                d: i
            } = e;
            return (Math.abs(r) > 1e-4 || Math.abs(n) > 1e-4) && (Math.abs(t) > 1e-4 || Math.abs(i) > 1e-4)
        }
        testScissor(e) {
            const {
                maskObject: t
            } = e;
            if (!t.isFastRect || !t.isFastRect() || xd.isMatrixRotated(t.worldTransform) || xd.isMatrixRotated(this.renderer.projection.transform)) return !1;
            this.calcScissorRect(e);
            const r = e._scissorRectLocal;
            return r.width > 0 && r.height > 0
        }
        roundFrameToPixels(e, t, r, n, i) {
            xd.isMatrixRotated(i) || (i = i ? aS.copyFrom(i) : aS.identity(), i.translate(-r.x, -r.y).scale(n.width / r.width, n.height / r.height).translate(n.x, n.y), this.renderer.filter.transformAABB(i, e), e.fit(n), e.x = Math.round(e.x * t), e.y = Math.round(e.y * t), e.width = Math.round(e.width * t), e.height = Math.round(e.height * t))
        }
        push(e) {
            e._scissorRectLocal || this.calcScissorRect(e);
            const {
                gl: t
            } = this.renderer;
            e._scissorRect || t.enable(t.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent()
        }
        pop(e) {
            const {
                gl: t
            } = this.renderer;
            e && lS.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
        }
        _useCurrent() {
            const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
            let t;
            this.renderer.renderTexture.current ? t = e.y : t = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, t, e.width, e.height)
        }
    };
let x$ = xd;
x$.extension = {
    type: ue.RendererSystem,
    name: "scissor"
};
ye.add(x$);
class E$ extends b$ {
    constructor(t) {
        super(t), this.glConst = ce.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._stencilCounter : 0
    }
    push(t) {
        const r = t.maskObject,
            {
                gl: n
            } = this.renderer,
            i = t._stencilCounter;
        i === 0 && (this.renderer.framebuffer.forceStencil(), n.clearStencil(0), n.clear(n.STENCIL_BUFFER_BIT), n.enable(n.STENCIL_TEST)), t._stencilCounter++;
        const s = t._colorMask;
        s !== 0 && (t._colorMask = 0, n.colorMask(!1, !1, !1, !1)), n.stencilFunc(n.EQUAL, i, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), r.renderable = !0, r.render(this.renderer), this.renderer.batch.flush(), r.renderable = !1, s !== 0 && (t._colorMask = s, n.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)), this._useCurrent()
    }
    pop(t) {
        const r = this.renderer.gl;
        if (this.getStackLength() === 0) r.disable(r.STENCIL_TEST);
        else {
            const n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null,
                i = n ? n._colorMask : 15;
            i !== 0 && (n._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilOp(r.KEEP, r.KEEP, r.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, i !== 0 && (n._colorMask = i, r.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)), this._useCurrent()
        }
    }
    _useCurrent() {
        const t = this.renderer.gl;
        t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
    }
}
E$.extension = {
    type: ue.RendererSystem,
    name: "stencil"
};
ye.add(E$);
class S$ {
    constructor(t) {
        this.renderer = t, this.plugins = {}, Object.defineProperties(this.plugins, {
            extract: {
                enumerable: !1,
                get() {
                    return ze("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), t.extract
                }
            },
            prepare: {
                enumerable: !1,
                get() {
                    return ze("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), t.prepare
                }
            },
            interaction: {
                enumerable: !1,
                get() {
                    return ze("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), t.events
                }
            }
        })
    }
    init() {
        const t = this.rendererPlugins;
        for (const r in t) this.plugins[r] = new t[r](this.renderer)
    }
    destroy() {
        for (const t in this.plugins) this.plugins[t].destroy(), this.plugins[t] = null
    }
}
S$.extension = {
    type: [ue.RendererSystem, ue.CanvasRendererSystem],
    name: "_plugin"
};
ye.add(S$);
class P$ {
    constructor(t) {
        this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new mt, this.transform = null
    }
    update(t, r, n, i) {
        this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = r || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, n, i), this.transform && this.projectionMatrix.append(this.transform);
        const s = this.renderer;
        s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, s.globalUniforms.update(), s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals)
    }
    calculateProjection(t, r, n, i) {
        const s = this.projectionMatrix,
            o = i ? -1 : 1;
        s.identity(), s.a = 1 / r.width * 2, s.d = o * (1 / r.height * 2), s.tx = -1 - r.x * s.a, s.ty = -o - r.y * s.d
    }
    setTransform(t) {}
    destroy() {
        this.renderer = null
    }
}
P$.extension = {
    type: ue.RendererSystem,
    name: "projection"
};
ye.add(P$);
const Gz = new Q1;
class C$ {
    constructor(t) {
        this.renderer = t, this._tempMatrix = new mt
    }
    generateTexture(t, r) {
        const {
            region: n,
            ...i
        } = r || {}, s = n || t.getLocalBounds(null, !0);
        s.width === 0 && (s.width = 1), s.height === 0 && (s.height = 1);
        const o = Co.create({
            width: s.width,
            height: s.height,
            ...i
        });
        this._tempMatrix.tx = -s.x, this._tempMatrix.ty = -s.y;
        const a = t.transform;
        return t.transform = Gz, this.renderer.render(t, {
            renderTexture: o,
            transform: this._tempMatrix,
            skipUpdateTransform: !!t.parent,
            blit: !0
        }), t.transform = a, o
    }
    destroy() {}
}
C$.extension = {
    type: [ue.RendererSystem, ue.CanvasRendererSystem],
    name: "textureGenerator"
};
ye.add(C$);
const Ls = new $e,
    Hl = new $e;
class T$ {
    constructor(t) {
        this.renderer = t, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new $e, this.destinationFrame = new $e, this.viewportFrame = new $e
    }
    contextChange() {
        var r;
        const t = (r = this.renderer) == null ? void 0 : r.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(t && t.alpha && t.premultipliedAlpha)
    }
    bind(t = null, r, n) {
        const i = this.renderer;
        this.current = t;
        let s, o, a;
        t ? (s = t.baseTexture, a = s.resolution, r || (Ls.width = t.frame.width, Ls.height = t.frame.height, r = Ls), n || (Hl.x = t.frame.x, Hl.y = t.frame.y, Hl.width = r.width, Hl.height = r.height, n = Hl), o = s.framebuffer) : (a = i.resolution, r || (Ls.width = i._view.screen.width, Ls.height = i._view.screen.height, r = Ls), n || (n = Ls, n.width = r.width, n.height = r.height));
        const l = this.viewportFrame;
        l.x = n.x * a, l.y = n.y * a, l.width = n.width * a, l.height = n.height * a, t || (l.y = i.view.height - (l.y + l.height)), l.ceil(), this.renderer.framebuffer.bind(o, l), this.renderer.projection.update(n, r, a, !o), t ? this.renderer.mask.setMaskStack(s.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(r), this.destinationFrame.copyFrom(n)
    }
    clear(t, r) {
        const n = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor,
            i = ot.shared.setValue(t || n);
        (this.current && this.current.baseTexture.alphaMode > 0 || !this.current && this._rendererPremultipliedAlpha) && i.premultiply(i.alpha);
        const s = this.destinationFrame,
            o = this.current ? this.current.baseTexture : this.renderer._view.screen,
            a = s.width !== o.width || s.height !== o.height;
        if (a) {
            let {
                x: l,
                y: c,
                width: u,
                height: h
            } = this.viewportFrame;
            l = Math.round(l), c = Math.round(c), u = Math.round(u), h = Math.round(h), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(l, c, u, h)
        }
        this.renderer.framebuffer.clear(i.red, i.green, i.blue, i.alpha, r), a && this.renderer.scissor.pop()
    }
    resize() {
        this.bind(null)
    }
    reset() {
        this.bind(null)
    }
    destroy() {
        this.renderer = null
    }
}
T$.extension = {
    type: ue.RendererSystem,
    name: "renderTexture"
};
ye.add(T$);
class Vz {
    constructor(t, r) {
        this.program = t, this.uniformData = r, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {}
    }
    destroy() {
        this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null
    }
}

function Wz(e, t) {
    const r = {},
        n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
        const s = t.getActiveAttrib(e, i);
        if (s.name.startsWith("gl_")) continue;
        const o = c$(t, s.type),
            a = {
                type: o,
                name: s.name,
                size: l$(o),
                location: t.getAttribLocation(e, s.name)
            };
        r[s.name] = a
    }
    return r
}

function Xz(e, t) {
    const r = {},
        n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; i++) {
        const s = t.getActiveUniform(e, i),
            o = s.name.replace(/\[.*?\]$/, ""),
            a = !!s.name.match(/\[.*?\]$/),
            l = c$(t, s.type);
        r[o] = {
            name: o,
            index: i,
            type: l,
            size: s.size,
            isArray: a,
            value: o$(l, s.size)
        }
    }
    return r
}

function Yz(e, t) {
    var l;
    const r = eS(e, e.VERTEX_SHADER, t.vertexSrc),
        n = eS(e, e.FRAGMENT_SHADER, t.fragmentSrc),
        i = e.createProgram();
    e.attachShader(i, r), e.attachShader(i, n);
    const s = (l = t.extra) == null ? void 0 : l.transformFeedbackVaryings;
    if (s && (typeof e.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : e.transformFeedbackVaryings(i, s.names, s.bufferMode === "separate" ? e.SEPARATE_ATTRIBS : e.INTERLEAVED_ATTRIBS)), e.linkProgram(i), e.getProgramParameter(i, e.LINK_STATUS) || Ez(e, i, r, n), t.attributeData = Wz(i, e), t.uniformData = Xz(i, e), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
        const c = Object.keys(t.attributeData);
        c.sort((u, h) => u > h ? 1 : -1);
        for (let u = 0; u < c.length; u++) t.attributeData[c[u]].location = u, e.bindAttribLocation(i, u, c[u]);
        e.linkProgram(i)
    }
    e.deleteShader(r), e.deleteShader(n);
    const o = {};
    for (const c in t.uniformData) {
        const u = t.uniformData[c];
        o[c] = {
            location: e.getUniformLocation(i, c),
            value: o$(u.type, u.size)
        }
    }
    return new Vz(i, o)
}

function Kz(e, t, r, n, i) {
    r.buffer.update(i)
}
const qz = {
        float: `
        data[offset] = v;
    `,
        vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
        vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
        vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
        mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
        mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
        mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
    },
    O$ = {
        float: 4,
        vec2: 8,
        vec3: 12,
        vec4: 16,
        int: 4,
        ivec2: 8,
        ivec3: 12,
        ivec4: 16,
        uint: 4,
        uvec2: 8,
        uvec3: 12,
        uvec4: 16,
        bool: 4,
        bvec2: 8,
        bvec3: 12,
        bvec4: 16,
        mat2: 16 * 2,
        mat3: 16 * 3,
        mat4: 16 * 4
    };

function Qz(e) {
    const t = e.map(s => ({
        data: s,
        offset: 0,
        dataLen: 0,
        dirty: 0
    }));
    let r = 0,
        n = 0,
        i = 0;
    for (let s = 0; s < t.length; s++) {
        const o = t[s];
        if (r = O$[o.data.type], o.data.size > 1 && (r = Math.max(r, 16) * o.data.size), o.dataLen = r, n % r !== 0 && n < 16) {
            const a = n % r % 16;
            n += a, i += a
        }
        n + r > 16 ? (i = Math.ceil(i / 16) * 16, o.offset = i, i += r, n = r) : (o.offset = i, n += r, i += r)
    }
    return i = Math.ceil(i / 16) * 16, {
        uboElements: t,
        size: i
    }
}

function Zz(e, t) {
    const r = [];
    for (const n in e) t[n] && r.push(t[n]);
    return r.sort((n, i) => n.index - i.index), r
}

function Jz(e, t) {
    if (!e.autoManage) return {
        size: 0,
        syncFunc: Kz
    };
    const r = Zz(e.uniforms, t),
        {
            uboElements: n,
            size: i
        } = Qz(r),
        s = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let o = 0; o < n.length; o++) {
        const a = n[o],
            l = e.uniforms[a.data.name],
            c = a.data.name;
        let u = !1;
        for (let h = 0; h < za.length; h++) {
            const d = za[h];
            if (d.codeUbo && d.test(a.data, l)) {
                s.push(`offset = ${a.offset/4};`, za[h].codeUbo(a.data.name, l)), u = !0;
                break
            }
        }
        if (!u)
            if (a.data.size > 1) {
                const h = l$(a.data.type),
                    d = Math.max(O$[a.data.type] / 16, 1),
                    f = h / d,
                    p = (4 - f % 4) % 4;
                s.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${a.offset/4};

                t = 0;

                for(var i=0; i < ${a.data.size*d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${p};
                }

                `)
            } else {
                const h = qz[a.data.type];
                s.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${a.offset/4};
                ${h};
                `)
            }
    }
    return s.push(`
       renderer.buffer.update(buffer);
    `), {
        size: i,
        syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", s.join(`
`))
    }
}
let ej = 0;
const Ch = {
    textureCount: 0,
    uboCount: 0
};
class Z1 {
    constructor(t) {
        this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = ej++
    }
    systemCheck() {
        if (!Pz()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
    }
    contextChange(t) {
        this.gl = t, this.reset()
    }
    bind(t, r) {
        t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
        const n = t.program,
            i = n.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
        return this.shader = t, this.program !== n && (this.program = n, this.gl.useProgram(i.program)), r || (Ch.textureCount = 0, Ch.uboCount = 0, this.syncUniformGroup(t.uniformGroup, Ch)), i
    }
    setUniforms(t) {
        const r = this.shader.program,
            n = r.glPrograms[this.renderer.CONTEXT_UID];
        r.syncUniforms(n.uniformData, t, this.renderer)
    }
    syncUniformGroup(t, r) {
        const n = this.getGlProgram();
        (!t.static || t.dirtyId !== n.uniformDirtyGroups[t.id]) && (n.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, n, r))
    }
    syncUniforms(t, r, n) {
        (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(r.uniformData, t.uniforms, this.renderer, n)
    }
    createSyncGroups(t) {
        const r = this.getSignature(t, this.shader.program.uniformData, "u");
        return this.cache[r] || (this.cache[r] = wz(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[r], t.syncUniforms[this.shader.program.id]
    }
    syncUniformBufferGroup(t, r) {
        const n = this.getGlProgram();
        if (!t.static || t.dirtyId !== 0 || !n.uniformGroups[t.id]) {
            t.dirtyId = 0;
            const i = n.uniformGroups[t.id] || this.createSyncBufferGroup(t, n, r);
            t.buffer.update(), i(n.uniformData, t.uniforms, this.renderer, Ch, t.buffer)
        }
        this.renderer.buffer.bindBufferBase(t.buffer, n.uniformBufferBindings[r])
    }
    createSyncBufferGroup(t, r, n) {
        const {
            gl: i
        } = this.renderer;
        this.renderer.buffer.bind(t.buffer);
        const s = this.gl.getUniformBlockIndex(r.program, n);
        r.uniformBufferBindings[n] = this.shader.uniformBindCount, i.uniformBlockBinding(r.program, s, this.shader.uniformBindCount), this.shader.uniformBindCount++;
        const o = this.getSignature(t, this.shader.program.uniformData, "ubo");
        let a = this._uboCache[o];
        if (a || (a = this._uboCache[o] = Jz(t, this.shader.program.uniformData)), t.autoManage) {
            const l = new Float32Array(a.size / 4);
            t.buffer.update(l)
        }
        return r.uniformGroups[t.id] = a.syncFunc, r.uniformGroups[t.id]
    }
    getSignature(t, r, n) {
        const i = t.uniforms,
            s = [`${n}-`];
        for (const o in i) s.push(o), r[o] && s.push(r[o].type);
        return s.join("-")
    }
    getGlProgram() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
    }
    generateProgram(t) {
        const r = this.gl,
            n = t.program,
            i = Yz(r, n);
        return n.glPrograms[this.renderer.CONTEXT_UID] = i, i
    }
    reset() {
        this.program = null, this.shader = null
    }
    disposeShader(t) {
        this.shader === t && (this.shader = null)
    }
    destroy() {
        this.renderer = null, this.destroyed = !0
    }
}
Z1.extension = {
    type: ue.RendererSystem,
    name: "shader"
};
ye.add(Z1);
class Nm {
    constructor(t) {
        this.renderer = t
    }
    run(t) {
        const {
            renderer: r
        } = this;
        r.runners.init.emit(r.options), t.hello && console.log(`PixiJS 7.2.4 - ${r.rendererLogId} - https://pixijs.com`), r.resize(r.screen.width, r.screen.height)
    }
    destroy() {}
}
Nm.defaultOptions = {
    hello: !1
};
Nm.extension = {
    type: [ue.RendererSystem, ue.CanvasRendererSystem],
    name: "startup"
};
ye.add(Nm);

function tj(e, t = []) {
    return t[Ce.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.ADD] = [e.ONE, e.ONE], t[Ce.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.NONE] = [0, 0], t[Ce.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE], t[Ce.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[Ce.SRC_IN] = [e.DST_ALPHA, e.ZERO], t[Ce.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO], t[Ce.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], t[Ce.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE], t[Ce.DST_IN] = [e.ZERO, e.SRC_ALPHA], t[Ce.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA], t[Ce.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA], t[Ce.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], t[Ce.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD], t
}
const rj = 0,
    nj = 1,
    ij = 2,
    sj = 3,
    oj = 4,
    aj = 5,
    Xy = class {
        constructor() {
            this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = Ce.NONE, this._blendEq = !1, this.map = [], this.map[rj] = this.setBlend, this.map[nj] = this.setOffset, this.map[ij] = this.setCullFace, this.map[sj] = this.setDepthTest, this.map[oj] = this.setFrontFace, this.map[aj] = this.setDepthMask, this.checks = [], this.defaultState = new ki, this.defaultState.blend = !0
        }
        contextChange(e) {
            this.gl = e, this.blendModes = tj(e), this.set(this.defaultState), this.reset()
        }
        set(e) {
            if (e = e || this.defaultState, this.stateId !== e.data) {
                let t = this.stateId ^ e.data,
                    r = 0;
                for (; t;) t & 1 && this.map[r].call(this, !!(e.data & 1 << r)), t = t >> 1, r++;
                this.stateId = e.data
            }
            for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e)
        }
        forceState(e) {
            e = e || this.defaultState;
            for (let t = 0; t < this.map.length; t++) this.map[t].call(this, !!(e.data & 1 << t));
            for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
            this.stateId = e.data
        }
        setBlend(e) {
            this.updateCheck(Xy.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND)
        }
        setOffset(e) {
            this.updateCheck(Xy.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
        }
        setDepthMask(e) {
            this.gl.depthMask(e)
        }
        setCullFace(e) {
            this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE)
        }
        setFrontFace(e) {
            this.gl.frontFace(this.gl[e ? "CW" : "CCW"])
        }
        setBlendMode(e) {
            if (e === this.blendMode) return;
            this.blendMode = e;
            const t = this.blendModes[e],
                r = this.gl;
            t.length === 2 ? r.blendFunc(t[0], t[1]) : r.blendFuncSeparate(t[0], t[1], t[2], t[3]), t.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
        }
        setPolygonOffset(e, t) {
            this.gl.polygonOffset(e, t)
        }
        reset() {
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
        }
        updateCheck(e, t) {
            const r = this.checks.indexOf(e);
            t && r === -1 ? this.checks.push(e) : !t && r !== -1 && this.checks.splice(r, 1)
        }
        static checkBlendMode(e, t) {
            e.setBlendMode(t.blendMode)
        }
        static checkPolygonOffset(e, t) {
            e.setPolygonOffset(1, t.polygonOffset)
        }
        destroy() {
            this.gl = null
        }
    };
let A$ = Xy;
A$.extension = {
    type: ue.RendererSystem,
    name: "state"
};
ye.add(A$);
class lj extends go {
    constructor() {
        super(...arguments), this.runners = {}, this._systemsHash = {}
    }
    setup(t) {
        this.addRunners(...t.runners);
        const r = (t.priority??[]).filter(i => t.systems[i]),
            n = [...r, ...Object.keys(t.systems).filter(i => !r.includes(i))];
        for (const i of n) this.addSystem(t.systems[i], i)
    }
    addRunners(...t) {
        t.forEach(r => {
            this.runners[r] = new An(r)
        })
    }
    addSystem(t, r) {
        const n = new t(this);
        if (this[r]) throw new Error(`Whoops! The name "${r}" is already in use`);
        this[r] = n, this._systemsHash[r] = n;
        for (const i in this.runners) this.runners[i].add(n);
        return this
    }
    emitWithCustomOptions(t, r) {
        const n = Object.keys(this._systemsHash);
        t.items.forEach(i => {
            const s = n.find(o => this._systemsHash[o] === i);
            i[t.name](r[s])
        })
    }
    destroy() {
        Object.values(this.runners).forEach(t => {
            t.destroy()
        }), this._systemsHash = {}
    }
}
const Ed = class {
    constructor(e) {
        this.renderer = e, this.count = 0, this.checkCount = 0, this.maxIdle = Ed.defaultMaxIdle, this.checkCountMax = Ed.defaultCheckCountMax, this.mode = Ed.defaultMode
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== X1.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
    }
    run() {
        const e = this.renderer.texture,
            t = e.managedTextures;
        let r = !1;
        for (let n = 0; n < t.length; n++) {
            const i = t[n];
            !i.framebuffer && this.count - i.touched > this.maxIdle && (e.destroyTexture(i, !0), t[n] = null, r = !0)
        }
        if (r) {
            let n = 0;
            for (let i = 0; i < t.length; i++) t[i] !== null && (t[n++] = t[i]);
            t.length = n
        }
    }
    unload(e) {
        const t = this.renderer.texture,
            r = e._texture;
        r && !r.framebuffer && t.destroyTexture(r);
        for (let n = e.children.length - 1; n >= 0; n--) this.unload(e.children[n])
    }
    destroy() {
        this.renderer = null
    }
};
let bn = Ed;
bn.defaultMode = X1.AUTO;
bn.defaultMaxIdle = 60 * 60;
bn.defaultCheckCountMax = 60 * 10;
bn.extension = {
    type: ue.RendererSystem,
    name: "textureGC"
};
ye.add(bn);
class Hv {
    constructor(t) {
        this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = be.UNSIGNED_BYTE, this.internalFormat = se.RGBA, this.samplerType = 0
    }
}

function cj(e) {
    let t;
    return "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext ? t = {
        [be.UNSIGNED_BYTE]: {
            [se.RGBA]: e.RGBA8,
            [se.RGB]: e.RGB8,
            [se.RG]: e.RG8,
            [se.RED]: e.R8,
            [se.RGBA_INTEGER]: e.RGBA8UI,
            [se.RGB_INTEGER]: e.RGB8UI,
            [se.RG_INTEGER]: e.RG8UI,
            [se.RED_INTEGER]: e.R8UI,
            [se.ALPHA]: e.ALPHA,
            [se.LUMINANCE]: e.LUMINANCE,
            [se.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [be.BYTE]: {
            [se.RGBA]: e.RGBA8_SNORM,
            [se.RGB]: e.RGB8_SNORM,
            [se.RG]: e.RG8_SNORM,
            [se.RED]: e.R8_SNORM,
            [se.RGBA_INTEGER]: e.RGBA8I,
            [se.RGB_INTEGER]: e.RGB8I,
            [se.RG_INTEGER]: e.RG8I,
            [se.RED_INTEGER]: e.R8I
        },
        [be.UNSIGNED_SHORT]: {
            [se.RGBA_INTEGER]: e.RGBA16UI,
            [se.RGB_INTEGER]: e.RGB16UI,
            [se.RG_INTEGER]: e.RG16UI,
            [se.RED_INTEGER]: e.R16UI,
            [se.DEPTH_COMPONENT]: e.DEPTH_COMPONENT16
        },
        [be.SHORT]: {
            [se.RGBA_INTEGER]: e.RGBA16I,
            [se.RGB_INTEGER]: e.RGB16I,
            [se.RG_INTEGER]: e.RG16I,
            [se.RED_INTEGER]: e.R16I
        },
        [be.UNSIGNED_INT]: {
            [se.RGBA_INTEGER]: e.RGBA32UI,
            [se.RGB_INTEGER]: e.RGB32UI,
            [se.RG_INTEGER]: e.RG32UI,
            [se.RED_INTEGER]: e.R32UI,
            [se.DEPTH_COMPONENT]: e.DEPTH_COMPONENT24
        },
        [be.INT]: {
            [se.RGBA_INTEGER]: e.RGBA32I,
            [se.RGB_INTEGER]: e.RGB32I,
            [se.RG_INTEGER]: e.RG32I,
            [se.RED_INTEGER]: e.R32I
        },
        [be.FLOAT]: {
            [se.RGBA]: e.RGBA32F,
            [se.RGB]: e.RGB32F,
            [se.RG]: e.RG32F,
            [se.RED]: e.R32F,
            [se.DEPTH_COMPONENT]: e.DEPTH_COMPONENT32F
        },
        [be.HALF_FLOAT]: {
            [se.RGBA]: e.RGBA16F,
            [se.RGB]: e.RGB16F,
            [se.RG]: e.RG16F,
            [se.RED]: e.R16F
        },
        [be.UNSIGNED_SHORT_5_6_5]: {
            [se.RGB]: e.RGB565
        },
        [be.UNSIGNED_SHORT_4_4_4_4]: {
            [se.RGBA]: e.RGBA4
        },
        [be.UNSIGNED_SHORT_5_5_5_1]: {
            [se.RGBA]: e.RGB5_A1
        },
        [be.UNSIGNED_INT_2_10_10_10_REV]: {
            [se.RGBA]: e.RGB10_A2,
            [se.RGBA_INTEGER]: e.RGB10_A2UI
        },
        [be.UNSIGNED_INT_10F_11F_11F_REV]: {
            [se.RGB]: e.R11F_G11F_B10F
        },
        [be.UNSIGNED_INT_5_9_9_9_REV]: {
            [se.RGB]: e.RGB9_E5
        },
        [be.UNSIGNED_INT_24_8]: {
            [se.DEPTH_STENCIL]: e.DEPTH24_STENCIL8
        },
        [be.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
            [se.DEPTH_STENCIL]: e.DEPTH32F_STENCIL8
        }
    } : t = {
        [be.UNSIGNED_BYTE]: {
            [se.RGBA]: e.RGBA,
            [se.RGB]: e.RGB,
            [se.ALPHA]: e.ALPHA,
            [se.LUMINANCE]: e.LUMINANCE,
            [se.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [be.UNSIGNED_SHORT_5_6_5]: {
            [se.RGB]: e.RGB
        },
        [be.UNSIGNED_SHORT_4_4_4_4]: {
            [se.RGBA]: e.RGBA
        },
        [be.UNSIGNED_SHORT_5_5_5_1]: {
            [se.RGBA]: e.RGBA
        }
    }, t
}
class I$ {
    constructor(t) {
        this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new Oe, this.hasIntegerTextures = !1
    }
    contextChange() {
        const t = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = cj(t);
        const r = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = r;
        for (let i = 0; i < r; i++) this.boundTextures[i] = null;
        this.emptyTextures = {};
        const n = new Hv(t.createTexture());
        t.bindTexture(t.TEXTURE_2D, n.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = n, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new Hv(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
        for (let i = 0; i < 6; i++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
        for (let i = 0; i < this.boundTextures.length; i++) this.bind(null, i)
    }
    bind(t, r = 0) {
        const {
            gl: n
        } = this;
        if (t = t == null ? void 0 : t.castToBaseTexture(), t != null && t.valid && !t.parentTextureArray) {
            t.touched = this.renderer.textureGC.count;
            const i = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
            this.boundTextures[r] !== t && (this.currentLocation !== r && (this.currentLocation = r, n.activeTexture(n.TEXTURE0 + r)), n.bindTexture(t.target, i.texture)), i.dirtyId !== t.dirtyId ? (this.currentLocation !== r && (this.currentLocation = r, n.activeTexture(n.TEXTURE0 + r)), this.updateTexture(t)) : i.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[r] = t
        } else this.currentLocation !== r && (this.currentLocation = r, n.activeTexture(n.TEXTURE0 + r)), n.bindTexture(n.TEXTURE_2D, this.emptyTextures[n.TEXTURE_2D].texture), this.boundTextures[r] = null
    }
    reset() {
        this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
        for (let t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
    }
    unbind(t) {
        const {
            gl: r,
            boundTextures: n
        } = this;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (let i = 0; i < n.length; i++) n[i] === this.unknownTexture && this.bind(null, i)
        }
        for (let i = 0; i < n.length; i++) n[i] === t && (this.currentLocation !== i && (r.activeTexture(r.TEXTURE0 + i), this.currentLocation = i), r.bindTexture(t.target, this.emptyTextures[t.target].texture), n[i] = null)
    }
    ensureSamplerType(t) {
        const {
            boundTextures: r,
            hasIntegerTextures: n,
            CONTEXT_UID: i
        } = this;
        if (n)
            for (let s = t - 1; s >= 0; --s) {
                const o = r[s];
                o && o._glTextures[i].samplerType !== Iy.FLOAT && this.renderer.texture.unbind(o)
            }
    }
    initTexture(t) {
        const r = new Hv(this.gl.createTexture());
        return r.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = r, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), r
    }
    initTextureType(t, r) {
        var n;
        r.internalFormat = ((n = this.internalFormats[t.type]) == null ? void 0 : n[t.format])??t.format, this.webGLVersion === 2 && t.type === be.HALF_FLOAT ? r.type = this.gl.HALF_FLOAT : r.type = t.type
    }
    updateTexture(t) {
        var i;
        const r = t._glTextures[this.CONTEXT_UID];
        if (!r) return;
        const n = this.renderer;
        if (this.initTextureType(t, r), (i = t.resource) != null && i.upload(n, t, r)) r.samplerType !== Iy.FLOAT && (this.hasIntegerTextures = !0);
        else {
            const s = t.realWidth,
                o = t.realHeight,
                a = n.gl;
            (r.width !== s || r.height !== o || r.dirtyId < 0) && (r.width = s, r.height = o, a.texImage2D(t.target, 0, r.internalFormat, s, o, 0, t.format, r.type, null))
        }
        t.dirtyStyleId !== r.dirtyStyleId && this.updateTextureStyle(t), r.dirtyId = t.dirtyId
    }
    destroyTexture(t, r) {
        const {
            gl: n
        } = this;
        if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), n.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !r)) {
            const i = this.managedTextures.indexOf(t);
            i !== -1 && Fa(this.managedTextures, i, 1)
        }
    }
    updateTextureStyle(t) {
        var n;
        const r = t._glTextures[this.CONTEXT_UID];
        r && ((t.mipmap === si.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? r.mipmap = !1 : r.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? r.wrapMode = vs.CLAMP : r.wrapMode = t.wrapMode, (n = t.resource) != null && n.style(this.renderer, t, r) || this.setStyle(t, r), r.dirtyStyleId = t.dirtyStyleId)
    }
    setStyle(t, r) {
        const n = this.gl;
        if (r.mipmap && t.mipmap !== si.ON_MANUAL && n.generateMipmap(t.target), n.texParameteri(t.target, n.TEXTURE_WRAP_S, r.wrapMode), n.texParameteri(t.target, n.TEXTURE_WRAP_T, r.wrapMode), r.mipmap) {
            n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === bi.LINEAR ? n.LINEAR_MIPMAP_LINEAR : n.NEAREST_MIPMAP_NEAREST);
            const i = this.renderer.context.extensions.anisotropicFiltering;
            if (i && t.anisotropicLevel > 0 && t.scaleMode === bi.LINEAR) {
                const s = Math.min(t.anisotropicLevel, n.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                n.texParameterf(t.target, i.TEXTURE_MAX_ANISOTROPY_EXT, s)
            }
        } else n.texParameteri(t.target, n.TEXTURE_MIN_FILTER, t.scaleMode === bi.LINEAR ? n.LINEAR : n.NEAREST);
        n.texParameteri(t.target, n.TEXTURE_MAG_FILTER, t.scaleMode === bi.LINEAR ? n.LINEAR : n.NEAREST)
    }
    destroy() {
        this.renderer = null
    }
}
I$.extension = {
    type: ue.RendererSystem,
    name: "texture"
};
ye.add(I$);
class $$ {
    constructor(t) {
        this.renderer = t
    }
    contextChange() {
        this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {
            gl: r,
            CONTEXT_UID: n
        } = this, i = t._glTransformFeedbacks[n] || this.createGLTransformFeedback(t);
        r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, i)
    }
    unbind() {
        const {
            gl: t
        } = this;
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
    }
    beginTransformFeedback(t, r) {
        const {
            gl: n,
            renderer: i
        } = this;
        r && i.shader.bind(r), n.beginTransformFeedback(t)
    }
    endTransformFeedback() {
        const {
            gl: t
        } = this;
        t.endTransformFeedback()
    }
    createGLTransformFeedback(t) {
        const {
            gl: r,
            renderer: n,
            CONTEXT_UID: i
        } = this, s = r.createTransformFeedback();
        t._glTransformFeedbacks[i] = s, r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, s);
        for (let o = 0; o < t.buffers.length; o++) {
            const a = t.buffers[o];
            a && (n.buffer.update(a), a._glBuffers[i].refCount++, r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER, o, a._glBuffers[i].buffer || null))
        }
        return r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, null), t.disposeRunner.add(this), s
    }
    disposeTransformFeedback(t, r) {
        const n = t._glTransformFeedbacks[this.CONTEXT_UID],
            i = this.gl;
        t.disposeRunner.remove(this);
        const s = this.renderer.buffer;
        if (s)
            for (let o = 0; o < t.buffers.length; o++) {
                const a = t.buffers[o];
                if (!a) continue;
                const l = a._glBuffers[this.CONTEXT_UID];
                l && (l.refCount--, l.refCount === 0 && !r && s.dispose(a, r))
            }
        n && (r || i.deleteTransformFeedback(n), delete t._glTransformFeedbacks[this.CONTEXT_UID])
    }
    destroy() {
        this.renderer = null
    }
}
$$.extension = {
    type: ue.RendererSystem,
    name: "transformFeedback"
};
ye.add($$);
class Lm {
    constructor(t) {
        this.renderer = t
    }
    init(t) {
        this.screen = new $e(0, 0, t.width, t.height), this.element = t.view || ce.ADAPTER.createCanvas(), this.resolution = t.resolution || ce.RESOLUTION, this.autoDensity = !!t.autoDensity
    }
    resizeView(t, r) {
        this.element.width = Math.round(t * this.resolution), this.element.height = Math.round(r * this.resolution);
        const n = this.element.width / this.resolution,
            i = this.element.height / this.resolution;
        this.screen.width = n, this.screen.height = i, this.autoDensity && (this.element.style.width = `${n}px`, this.element.style.height = `${i}px`), this.renderer.emit("resize", n, i), this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
    }
    destroy(t) {
        var r;
        t && ((r = this.element.parentNode) == null || r.removeChild(this.element)), this.renderer = null, this.element = null, this.screen = null
    }
}
Lm.defaultOptions = {
    width: 800,
    height: 600,
    resolution: ce.RESOLUTION,
    autoDensity: !1
};
Lm.extension = {
    type: [ue.RendererSystem, ue.CanvasRendererSystem],
    name: "_view"
};
ye.add(Lm);
ce.PREFER_ENV = Po.WEBGL2;
ce.STRICT_TEXTURE_CACHE = !1;
ce.RENDER_OPTIONS = { ...Dm.defaultOptions,
    ...Mm.defaultOptions,
    ...Lm.defaultOptions,
    ...Nm.defaultOptions
};
Object.defineProperties(ce, {
    WRAP_MODE: {
        get() {
            return Oe.defaultOptions.wrapMode
        },
        set(e) {
            ze("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), Oe.defaultOptions.wrapMode = e
        }
    },
    SCALE_MODE: {
        get() {
            return Oe.defaultOptions.scaleMode
        },
        set(e) {
            ze("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), Oe.defaultOptions.scaleMode = e
        }
    },
    MIPMAP_TEXTURES: {
        get() {
            return Oe.defaultOptions.mipmap
        },
        set(e) {
            ze("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), Oe.defaultOptions.mipmap = e
        }
    },
    ANISOTROPIC_LEVEL: {
        get() {
            return Oe.defaultOptions.anisotropicLevel
        },
        set(e) {
            ze("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"), Oe.defaultOptions.anisotropicLevel = e
        }
    },
    FILTER_RESOLUTION: {
        get() {
            return ze("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), rr.defaultResolution
        },
        set(e) {
            rr.defaultResolution = e
        }
    },
    FILTER_MULTISAMPLE: {
        get() {
            return ze("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), rr.defaultMultisample
        },
        set(e) {
            rr.defaultMultisample = e
        }
    },
    SPRITE_MAX_TEXTURES: {
        get() {
            return wn.defaultMaxTextures
        },
        set(e) {
            ze("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), wn.defaultMaxTextures = e
        }
    },
    SPRITE_BATCH_SIZE: {
        get() {
            return wn.defaultBatchSize
        },
        set(e) {
            ze("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), wn.defaultBatchSize = e
        }
    },
    CAN_UPLOAD_SAME_BUFFER: {
        get() {
            return wn.canUploadSameBuffer
        },
        set(e) {
            ze("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), wn.canUploadSameBuffer = e
        }
    },
    GC_MODE: {
        get() {
            return bn.defaultMode
        },
        set(e) {
            ze("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), bn.defaultMode = e
        }
    },
    GC_MAX_IDLE: {
        get() {
            return bn.defaultMaxIdle
        },
        set(e) {
            ze("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), bn.defaultMaxIdle = e
        }
    },
    GC_MAX_CHECK_COUNT: {
        get() {
            return bn.defaultCheckCountMax
        },
        set(e) {
            ze("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), bn.defaultCheckCountMax = e
        }
    },
    PRECISION_VERTEX: {
        get() {
            return En.defaultVertexPrecision
        },
        set(e) {
            ze("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), En.defaultVertexPrecision = e
        }
    },
    PRECISION_FRAGMENT: {
        get() {
            return En.defaultFragmentPrecision
        },
        set(e) {
            ze("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), En.defaultFragmentPrecision = e
        }
    }
});
var _o = (e => (e[e.INTERACTION = 50] = "INTERACTION", e[e.HIGH = 25] = "HIGH", e[e.NORMAL = 0] = "NORMAL", e[e.LOW = -25] = "LOW", e[e.UTILITY = -50] = "UTILITY", e))(_o || {});
class Gv {
    constructor(t, r = null, n = 0, i = !1) {
        this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = r, this.priority = n, this.once = i
    }
    match(t, r = null) {
        return this.fn === t && this.context === r
    }
    emit(t) {
        this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
        const r = this.next;
        return this.once && this.destroy(!0), this._destroyed && (this.next = null), r
    }
    connect(t) {
        this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
    }
    destroy(t = !1) {
        this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
        const r = this.next;
        return this.next = t ? null : r, this.previous = null, r
    }
}
const $r = class {
    constructor() {
        this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Gv(null, null, 1 / 0), this.deltaMS = 1 / $r.targetFPMS, this.elapsedMS = 1 / $r.targetFPMS, this._tick = e => {
            this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }
    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(e, t, r = _o.NORMAL) {
        return this._addListener(new Gv(e, t, r))
    }
    addOnce(e, t, r = _o.NORMAL) {
        return this._addListener(new Gv(e, t, r, !0))
    }
    _addListener(e) {
        let t = this._head.next,
            r = this._head;
        if (!t) e.connect(r);
        else {
            for (; t;) {
                if (e.priority > t.priority) {
                    e.connect(r);
                    break
                }
                r = t, t = t.next
            }
            e.previous || e.connect(r)
        }
        return this._startIfPossible(), this
    }
    remove(e, t) {
        let r = this._head.next;
        for (; r;) r.match(e, t) ? r = r.destroy() : r = r.next;
        return this._head.next || this._cancelIfNeeded(), this
    }
    get count() {
        if (!this._head) return 0;
        let e = 0,
            t = this._head;
        for (; t = t.next;) e++;
        return e
    }
    start() {
        this.started || (this.started = !0, this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1, this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let e = this._head.next;
            for (; e;) e = e.destroy(!0);
            this._head.destroy(), this._head = null
        }
    }
    update(e = performance.now()) {
        let t;
        if (e > this.lastTime) {
            if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
                const i = e - this._lastFrame | 0;
                if (i < this._minElapsedMS) return;
                this._lastFrame = e - i % this._minElapsedMS
            }
            this.deltaMS = t, this.deltaTime = this.deltaMS * $r.targetFPMS;
            const r = this._head;
            let n = r.next;
            for (; n;) n = n.emit(this.deltaTime);
            r.next || this._cancelIfNeeded()
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(e) {
        const t = Math.min(this.maxFPS, e),
            r = Math.min(Math.max(0, t) / 1e3, $r.targetFPMS);
        this._maxElapsedMS = 1 / r
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(e) {
        if (e === 0) this._minElapsedMS = 0;
        else {
            const t = Math.max(this.minFPS, e);
            this._minElapsedMS = 1 / (t / 1e3)
        }
    }
    static get shared() {
        if (!$r._shared) {
            const e = $r._shared = new $r;
            e.autoStart = !0, e._protected = !0
        }
        return $r._shared
    }
    static get system() {
        if (!$r._system) {
            const e = $r._system = new $r;
            e.autoStart = !0, e._protected = !0
        }
        return $r._system
    }
};
let Jt = $r;
Jt.targetFPMS = .06;
Object.defineProperties(ce, {
    TARGET_FPMS: {
        get() {
            return Jt.targetFPMS
        },
        set(e) {
            ze("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), Jt.targetFPMS = e
        }
    }
});
class R$ {
    static init(t) {
        t = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, t), Object.defineProperty(this, "ticker", {
            set(r) {
                this._ticker && this._ticker.remove(this.render, this), this._ticker = r, r && r.add(this.render, this, _o.LOW)
            },
            get() {
                return this._ticker
            }
        }), this.stop = () => {
            this._ticker.stop()
        }, this.start = () => {
            this._ticker.start()
        }, this._ticker = null, this.ticker = t.sharedTicker ? Jt.shared : new Jt, t.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const t = this._ticker;
            this.ticker = null, t.destroy()
        }
    }
}
R$.extension = ue.Application;
ye.add(R$);
const k$ = [];
ye.handleByList(ue.Renderer, k$);

function uj(e) {
    for (const t of k$)
        if (t.test(e)) return new t(e);
    throw new Error("Unable to auto-detect a suitable renderer.")
}
var hj = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
    dj = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const fj = hj,
    M$ = dj;
class D$ {
    constructor(t) {
        this.renderer = t
    }
    contextChange(t) {
        let r;
        if (this.renderer.context.webGLVersion === 1) {
            const n = t.getParameter(t.FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.FRAMEBUFFER, null), r = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.FRAMEBUFFER, n)
        } else {
            const n = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), r = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, n)
        }
        r >= Rt.HIGH ? this.multisample = Rt.HIGH : r >= Rt.MEDIUM ? this.multisample = Rt.MEDIUM : r >= Rt.LOW ? this.multisample = Rt.LOW : this.multisample = Rt.NONE
    }
    destroy() {}
}
D$.extension = {
    type: ue.RendererSystem,
    name: "_multisample"
};
ye.add(D$);
class pj {
    constructor(t) {
        this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
    }
}
class N$ {
    constructor(t) {
        this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {}
    }
    destroy() {
        this.renderer = null
    }
    contextChange() {
        this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {
            gl: r,
            CONTEXT_UID: n
        } = this, i = t._glBuffers[n] || this.createGLBuffer(t);
        r.bindBuffer(t.type, i.buffer)
    }
    unbind(t) {
        const {
            gl: r
        } = this;
        r.bindBuffer(t, null)
    }
    bindBufferBase(t, r) {
        const {
            gl: n,
            CONTEXT_UID: i
        } = this;
        if (this.boundBufferBases[r] !== t) {
            const s = t._glBuffers[i] || this.createGLBuffer(t);
            this.boundBufferBases[r] = t, n.bindBufferBase(n.UNIFORM_BUFFER, r, s.buffer)
        }
    }
    bindBufferRange(t, r, n) {
        const {
            gl: i,
            CONTEXT_UID: s
        } = this;
        n = n || 0;
        const o = t._glBuffers[s] || this.createGLBuffer(t);
        i.bindBufferRange(i.UNIFORM_BUFFER, r || 0, o.buffer, n * 256, 256)
    }
    update(t) {
        const {
            gl: r,
            CONTEXT_UID: n
        } = this, i = t._glBuffers[n] || this.createGLBuffer(t);
        if (t._updateID !== i.updateID)
            if (i.updateID = t._updateID, r.bindBuffer(t.type, i.buffer), i.byteLength >= t.data.byteLength) r.bufferSubData(t.type, 0, t.data);
            else {
                const s = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;
                i.byteLength = t.data.byteLength, r.bufferData(t.type, t.data, s)
            }
    }
    dispose(t, r) {
        if (!this.managedBuffers[t.id]) return;
        delete this.managedBuffers[t.id];
        const n = t._glBuffers[this.CONTEXT_UID],
            i = this.gl;
        t.disposeRunner.remove(this), n && (r || i.deleteBuffer(n.buffer), delete t._glBuffers[this.CONTEXT_UID])
    }
    disposeAll(t) {
        const r = Object.keys(this.managedBuffers);
        for (let n = 0; n < r.length; n++) this.dispose(this.managedBuffers[r[n]], t)
    }
    createGLBuffer(t) {
        const {
            CONTEXT_UID: r,
            gl: n
        } = this;
        return t._glBuffers[r] = new pj(n.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[r]
    }
}
N$.extension = {
    type: ue.RendererSystem,
    name: "buffer"
};
ye.add(N$);
class L$ {
    constructor(t) {
        this.renderer = t
    }
    render(t, r) {
        const n = this.renderer;
        let i, s, o, a;
        if (r && (i = r.renderTexture, s = r.clear, o = r.transform, a = r.skipUpdateTransform), this.renderingToScreen = !i, n.runners.prerender.emit(), n.emit("prerender"), n.projection.transform = o, !n.context.isLost) {
            if (i || (this.lastObjectRendered = t), !a) {
                const l = t.enableTempParent();
                t.updateTransform(), t.disableTempParent(l)
            }
            n.renderTexture.bind(i), n.batch.currentRenderer.start(), (s??n.background.clearBeforeRender) && n.renderTexture.clear(), t.render(n), n.batch.currentRenderer.flush(), i && (r.blit && n.framebuffer.blit(), i.baseTexture.update()), n.runners.postrender.emit(), n.projection.transform = null, n.emit("postrender")
        }
    }
    destroy() {
        this.renderer = null, this.lastObjectRendered = null
    }
}
L$.extension = {
    type: ue.RendererSystem,
    name: "objectRenderer"
};
ye.add(L$);
const Yy = class extends lj {
    constructor(e) {
        super(), this.type = VI.WEBGL, e = Object.assign({}, ce.RENDER_OPTIONS, e), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new In({
            projectionMatrix: new mt
        }, !0);
        const t = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: Yy.__systems,
            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
        };
        this.setup(t), "useContextAlpha" in e && (ze("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), e.premultipliedAlpha = e.useContextAlpha && e.useContextAlpha !== "notMultiplied", e.backgroundAlpha = e.useContextAlpha === !1 ? 1 : e.backgroundAlpha), this._plugin.rendererPlugins = Yy.__plugins, this.options = e, this.startup.run(this.options)
    }
    static test(e) {
        return e != null && e.forceCanvas ? !1 : B7()
    }
    render(e, t) {
        this.objectRenderer.render(e, t)
    }
    resize(e, t) {
        this._view.resizeView(e, t)
    }
    reset() {
        return this.runners.reset.emit(), this
    }
    clear() {
        this.renderTexture.bind(), this.renderTexture.clear()
    }
    destroy(e = !1) {
        this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
            _view: e
        }), super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    get multisample() {
        return this._multisample.multisample
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(e) {
        this._view.resolution = e, this.runners.resolutionChange.emit(e)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }
    get clearBeforeRender() {
        return ze("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender
    }
    get useContextAlpha() {
        return ze("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha
    }
    get preserveDrawingBuffer() {
        return ze("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer
    }
    get backgroundColor() {
        return ze("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color
    }
    set backgroundColor(e) {
        ze("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = e
    }
    get backgroundAlpha() {
        return ze("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha
    }
    set backgroundAlpha(e) {
        ze("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = e
    }
    get powerPreference() {
        return ze("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference
    }
    generateTexture(e, t) {
        return this.textureGenerator.generateTexture(e, t)
    }
};
let fl = Yy;
fl.extension = {
    type: ue.Renderer,
    priority: 1
};
fl.__plugins = {};
fl.__systems = {};
ye.handleByMap(ue.RendererPlugin, fl.__plugins);
ye.handleByMap(ue.RendererSystem, fl.__systems);
ye.add(fl);
class F$ extends eu {
    constructor(t, r) {
        const {
            width: n,
            height: i
        } = r || {};
        super(n, i), this.items = [], this.itemDirtyIds = [];
        for (let s = 0; s < t; s++) {
            const o = new Oe;
            this.items.push(o), this.itemDirtyIds.push(-2)
        }
        this.length = t, this._load = null, this.baseTexture = null
    }
    initFromArray(t, r) {
        for (let n = 0; n < this.length; n++) t[n] && (t[n].castToBaseTexture ? this.addBaseTextureAt(t[n].castToBaseTexture(), n) : t[n] instanceof eu ? this.addResourceAt(t[n], n) : this.addResourceAt(r$(t[n], r), n))
    }
    dispose() {
        for (let t = 0, r = this.length; t < r; t++) this.items[t].destroy();
        this.items = null, this.itemDirtyIds = null, this._load = null
    }
    addResourceAt(t, r) {
        if (!this.items[r]) throw new Error(`Index ${r} is out of bounds`);
        return t.valid && !this.valid && this.resize(t.width, t.height), this.items[r].setResource(t), this
    }
    bind(t) {
        if (this.baseTexture !== null) throw new Error("Only one base texture per TextureArray is allowed");
        super.bind(t);
        for (let r = 0; r < this.length; r++) this.items[r].parentTextureArray = t, this.items[r].on("update", t.update, t)
    }
    unbind(t) {
        super.unbind(t);
        for (let r = 0; r < this.length; r++) this.items[r].parentTextureArray = null, this.items[r].off("update", t.update, t)
    }
    load() {
        if (this._load) return this._load;
        const r = this.items.map(n => n.resource).filter(n => n).map(n => n.load());
        return this._load = Promise.all(r).then(() => {
            const {
                realWidth: n,
                realHeight: i
            } = this.items[0];
            return this.resize(n, i), Promise.resolve(this)
        }), this._load
    }
}
class mj extends F$ {
    constructor(t, r) {
        const {
            width: n,
            height: i
        } = r || {};
        let s, o;
        Array.isArray(t) ? (s = t, o = t.length) : o = t, super(o, {
            width: n,
            height: i
        }), s && this.initFromArray(s, r)
    }
    addBaseTextureAt(t, r) {
        if (t.resource) this.addResourceAt(t.resource, r);
        else throw new Error("ArrayResource does not support RenderTexture");
        return this
    }
    bind(t) {
        super.bind(t), t.target = Da.TEXTURE_2D_ARRAY
    }
    upload(t, r, n) {
        const {
            length: i,
            itemDirtyIds: s,
            items: o
        } = this, {
            gl: a
        } = t;
        n.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, i, 0, r.format, n.type, null);
        for (let l = 0; l < i; l++) {
            const c = o[l];
            s[l] < c.dirtyId && (s[l] = c.dirtyId, c.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, l, c.resource.width, c.resource.height, 1, r.format, n.type, c.resource.source))
        }
        return !0
    }
}
class gj extends Cs {
    constructor(t) {
        super(t)
    }
    static test(t) {
        const {
            OffscreenCanvas: r
        } = globalThis;
        return r && t instanceof r ? !0 : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
    }
}
const cc = class extends F$ {
    constructor(e, t) {
        const {
            width: r,
            height: n,
            autoLoad: i,
            linkBaseTexture: s
        } = t || {};
        if (e && e.length !== cc.SIDES) throw new Error(`Invalid length. Got ${e.length}, expected 6`);
        super(6, {
            width: r,
            height: n
        });
        for (let o = 0; o < cc.SIDES; o++) this.items[o].target = Da.TEXTURE_CUBE_MAP_POSITIVE_X + o;
        this.linkBaseTexture = s !== !1, e && this.initFromArray(e, t), i !== !1 && this.load()
    }
    bind(e) {
        super.bind(e), e.target = Da.TEXTURE_CUBE_MAP
    }
    addBaseTextureAt(e, t, r) {
        if (r === void 0 && (r = this.linkBaseTexture), !this.items[t]) throw new Error(`Index ${t} is out of bounds`);
        if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
            if (e.resource) this.addResourceAt(e.resource, t);
            else throw new Error("CubeResource does not support copying of renderTexture.");
        else e.target = Da.TEXTURE_CUBE_MAP_POSITIVE_X + t, e.parentTextureArray = this.baseTexture, this.items[t] = e;
        return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[t] = e, this
    }
    upload(e, t, r) {
        const n = this.itemDirtyIds;
        for (let i = 0; i < cc.SIDES; i++) {
            const s = this.items[i];
            (n[i] < s.dirtyId || r.dirtyId < t.dirtyId) && (s.valid && s.resource ? (s.resource.upload(e, s, r), n[i] = s.dirtyId) : n[i] < -1 && (e.gl.texImage2D(s.target, 0, r.internalFormat, t.realWidth, t.realHeight, 0, t.format, r.type, null), n[i] = -1))
        }
        return !0
    }
    static test(e) {
        return Array.isArray(e) && e.length === cc.SIDES
    }
};
let B$ = cc;
B$.SIDES = 6;
class Oa extends Cs {
    constructor(t, r) {
        r = r || {};
        let n, i;
        typeof t == "string" ? (n = Oa.EMPTY, i = t) : (n = t, i = null), super(n), this.url = i, this.crossOrigin = r.crossOrigin??!0, this.alphaMode = typeof r.alphaMode == "number" ? r.alphaMode : null, this._load = null, r.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(async (t, r) => {
            if (this.url === null) {
                t(this);
                return
            }
            try {
                const n = await ce.ADAPTER.fetch(this.url, {
                    mode: this.crossOrigin ? "cors" : "no-cors"
                });
                if (this.destroyed) return;
                const i = await n.blob();
                if (this.destroyed) return;
                const s = await createImageBitmap(i, {
                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === Nn.UNPACK ? "premultiply" : "none"
                });
                if (this.destroyed) return;
                this.source = s, this.update(), t(this)
            } catch (n) {
                if (this.destroyed) return;
                r(n), this.onError.emit(n)
            }
        }), this._load)
    }
    upload(t, r, n) {
        return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (r.alphaMode = this.alphaMode), super.upload(t, r, n)) : (this.load(), !1)
    }
    dispose() {
        this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null
    }
    static test(t) {
        return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof t == "string" || t instanceof ImageBitmap)
    }
    static get EMPTY() {
        return Oa._EMPTY = Oa._EMPTY??ce.ADAPTER.createCanvas(0, 0), Oa._EMPTY
    }
}
const Sd = class extends Cs {
    constructor(e, t) {
        t = t || {}, super(ce.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = e, this.scale = t.scale || 1, this._overrideWidth = t.width, this._overrideHeight = t.height, this._resolve = null, this._crossorigin = t.crossorigin, this._load = null, t.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(e => {
            if (this._resolve = () => {
                    this.resize(this.source.width, this.source.height), e(this)
                }, Sd.SVG_XML.test(this.svg.trim())) {
                if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
            }
            this._loadSvg()
        }), this._load)
    }
    _loadSvg() {
        const e = new Image;
        Cs.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = t => {
            this._resolve && (e.onerror = null, this.onError.emit(t))
        }, e.onload = () => {
            if (!this._resolve) return;
            const t = e.width,
                r = e.height;
            if (!t || !r) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            let n = t * this.scale,
                i = r * this.scale;
            (this._overrideWidth || this._overrideHeight) && (n = this._overrideWidth || this._overrideHeight / r * t, i = this._overrideHeight || this._overrideWidth / t * r), n = Math.round(n), i = Math.round(i);
            const s = this.source;
            s.width = n, s.height = i, s._pixiId = `canvas_${yo()}`, s.getContext("2d").drawImage(e, 0, 0, t, r, 0, 0, n, i), this._resolve(), this._resolve = null
        }
    }
    static getSize(e) {
        const t = Sd.SVG_SIZE.exec(e),
            r = {};
        return t && (r[t[1]] = Math.round(parseFloat(t[3])), r[t[5]] = Math.round(parseFloat(t[7]))), r
    }
    dispose() {
        super.dispose(), this._resolve = null, this._crossorigin = null
    }
    static test(e, t) {
        return t === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && Sd.SVG_XML.test(e)
    }
};
let tu = Sd;
tu.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
tu.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
const Ky = class extends Cs {
    constructor(e, t) {
        if (t = t || {}, !(e instanceof HTMLVideoElement)) {
            const r = document.createElement("video");
            r.setAttribute("preload", "auto"), r.setAttribute("webkit-playsinline", ""), r.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
            const n = e[0].src || e[0];
            Cs.crossOrigin(r, n, t.crossorigin);
            for (let i = 0; i < e.length; ++i) {
                const s = document.createElement("source");
                let {
                    src: o,
                    mime: a
                } = e[i];
                o = o || e[i];
                const l = o.split("?").shift().toLowerCase(),
                    c = l.slice(l.lastIndexOf(".") + 1);
                a = a || Ky.MIME_TYPES[c] || `video/${c}`, s.src = o, s.type = a, r.appendChild(s)
            }
            e = r
        }
        super(e), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this._load = null, this._resolve = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), t.autoLoad !== !1 && this.load()
    }
    update(e = 0) {
        if (!this.destroyed) {
            const t = Jt.shared.elapsedMS * this.source.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - t), (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
        }
    }
    load() {
        if (this._load) return this._load;
        const e = this.source;
        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise(t => {
            this.valid ? t(this) : (this._resolve = t, e.load())
        }), this._load
    }
    _onError(e) {
        this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e)
    }
    _isSourcePlaying() {
        const e = this.source;
        return !e.paused && !e.ended && this._isSourceReady()
    }
    _isSourceReady() {
        return this.source.readyState > 2
    }
    _onPlayStart() {
        this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Jt.shared.add(this.update, this), this._isConnectedToTicker = !0)
    }
    _onPlayStop() {
        this._isConnectedToTicker && (Jt.shared.remove(this.update, this), this._isConnectedToTicker = !1)
    }
    _onCanPlay() {
        const e = this.source;
        e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
        const t = this.valid;
        this.resize(e.videoWidth, e.videoHeight), !t && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play()
    }
    dispose() {
        this._isConnectedToTicker && (Jt.shared.remove(this.update, this), this._isConnectedToTicker = !1);
        const e = this.source;
        e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.dispose()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Jt.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Jt.shared.add(this.update, this), this._isConnectedToTicker = !0))
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(e) {
        e !== this._updateFPS && (this._updateFPS = e)
    }
    static test(e, t) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || Ky.TYPES.includes(t)
    }
};
let J1 = Ky;
J1.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
J1.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
};
Uy.push(Oa, d$, gj, J1, tu, xu, B$, mj);
class wf {
    constructor() {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    clear() {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
    }
    getRectangle(t) {
        return this.minX > this.maxX || this.minY > this.maxY ? $e.EMPTY : (t = t || new $e(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
    }
    addPoint(t) {
        this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
    }
    addPointMatrix(t, r) {
        const {
            a: n,
            b: i,
            c: s,
            d: o,
            tx: a,
            ty: l
        } = t, c = n * r.x + s * r.y + a, u = i * r.x + o * r.y + l;
        this.minX = Math.min(this.minX, c), this.maxX = Math.max(this.maxX, c), this.minY = Math.min(this.minY, u), this.maxY = Math.max(this.maxY, u)
    }
    addQuad(t) {
        let r = this.minX,
            n = this.minY,
            i = this.maxX,
            s = this.maxY,
            o = t[0],
            a = t[1];
        r = o < r ? o : r, n = a < n ? a : n, i = o > i ? o : i, s = a > s ? a : s, o = t[2], a = t[3], r = o < r ? o : r, n = a < n ? a : n, i = o > i ? o : i, s = a > s ? a : s, o = t[4], a = t[5], r = o < r ? o : r, n = a < n ? a : n, i = o > i ? o : i, s = a > s ? a : s, o = t[6], a = t[7], r = o < r ? o : r, n = a < n ? a : n, i = o > i ? o : i, s = a > s ? a : s, this.minX = r, this.minY = n, this.maxX = i, this.maxY = s
    }
    addFrame(t, r, n, i, s) {
        this.addFrameMatrix(t.worldTransform, r, n, i, s)
    }
    addFrameMatrix(t, r, n, i, s) {
        const o = t.a,
            a = t.b,
            l = t.c,
            c = t.d,
            u = t.tx,
            h = t.ty;
        let d = this.minX,
            f = this.minY,
            p = this.maxX,
            m = this.maxY,
            w = o * r + l * n + u,
            y = a * r + c * n + h;
        d = w < d ? w : d, f = y < f ? y : f, p = w > p ? w : p, m = y > m ? y : m, w = o * i + l * n + u, y = a * i + c * n + h, d = w < d ? w : d, f = y < f ? y : f, p = w > p ? w : p, m = y > m ? y : m, w = o * r + l * s + u, y = a * r + c * s + h, d = w < d ? w : d, f = y < f ? y : f, p = w > p ? w : p, m = y > m ? y : m, w = o * i + l * s + u, y = a * i + c * s + h, d = w < d ? w : d, f = y < f ? y : f, p = w > p ? w : p, m = y > m ? y : m, this.minX = d, this.minY = f, this.maxX = p, this.maxY = m
    }
    addVertexData(t, r, n) {
        let i = this.minX,
            s = this.minY,
            o = this.maxX,
            a = this.maxY;
        for (let l = r; l < n; l += 2) {
            const c = t[l],
                u = t[l + 1];
            i = c < i ? c : i, s = u < s ? u : s, o = c > o ? c : o, a = u > a ? u : a
        }
        this.minX = i, this.minY = s, this.maxX = o, this.maxY = a
    }
    addVertices(t, r, n, i) {
        this.addVerticesMatrix(t.worldTransform, r, n, i)
    }
    addVerticesMatrix(t, r, n, i, s = 0, o = s) {
        const a = t.a,
            l = t.b,
            c = t.c,
            u = t.d,
            h = t.tx,
            d = t.ty;
        let f = this.minX,
            p = this.minY,
            m = this.maxX,
            w = this.maxY;
        for (let y = n; y < i; y += 2) {
            const v = r[y],
                _ = r[y + 1],
                E = a * v + c * _ + h,
                P = u * _ + l * v + d;
            f = Math.min(f, E - s), m = Math.max(m, E + s), p = Math.min(p, P - o), w = Math.max(w, P + o)
        }
        this.minX = f, this.minY = p, this.maxX = m, this.maxY = w
    }
    addBounds(t) {
        const r = this.minX,
            n = this.minY,
            i = this.maxX,
            s = this.maxY;
        this.minX = t.minX < r ? t.minX : r, this.minY = t.minY < n ? t.minY : n, this.maxX = t.maxX > i ? t.maxX : i, this.maxY = t.maxY > s ? t.maxY : s
    }
    addBoundsMask(t, r) {
        const n = t.minX > r.minX ? t.minX : r.minX,
            i = t.minY > r.minY ? t.minY : r.minY,
            s = t.maxX < r.maxX ? t.maxX : r.maxX,
            o = t.maxY < r.maxY ? t.maxY : r.maxY;
        if (n <= s && i <= o) {
            const a = this.minX,
                l = this.minY,
                c = this.maxX,
                u = this.maxY;
            this.minX = n < a ? n : a, this.minY = i < l ? i : l, this.maxX = s > c ? s : c, this.maxY = o > u ? o : u
        }
    }
    addBoundsMatrix(t, r) {
        this.addFrameMatrix(r, t.minX, t.minY, t.maxX, t.maxY)
    }
    addBoundsArea(t, r) {
        const n = t.minX > r.x ? t.minX : r.x,
            i = t.minY > r.y ? t.minY : r.y,
            s = t.maxX < r.x + r.width ? t.maxX : r.x + r.width,
            o = t.maxY < r.y + r.height ? t.maxY : r.y + r.height;
        if (n <= s && i <= o) {
            const a = this.minX,
                l = this.minY,
                c = this.maxX,
                u = this.maxY;
            this.minX = n < a ? n : a, this.minY = i < l ? i : l, this.maxX = s > c ? s : c, this.maxY = o > u ? o : u
        }
    }
    pad(t = 0, r = t) {
        this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= r, this.maxY += r)
    }
    addFramePad(t, r, n, i, s, o) {
        t -= s, r -= o, n += s, i += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > n ? this.maxX : n, this.minY = this.minY < r ? this.minY : r, this.maxY = this.maxY > i ? this.maxY : i
    }
}
class St extends go {
    constructor() {
        super(), this.tempDisplayObjectParent = null, this.transform = new Q1, this.alpha = 1, this.visible = !0, this.renderable = !0, this.cullable = !1, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new wf, this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = !1, this.isSprite = !1, this.isMask = !1
    }
    static mixin(t) {
        const r = Object.keys(t);
        for (let n = 0; n < r.length; ++n) {
            const i = r[n];
            Object.defineProperty(St.prototype, i, Object.getOwnPropertyDescriptor(t, i))
        }
    }
    get destroyed() {
        return this._destroyed
    }
    _recursivePostUpdateTransform() {
        this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
    }
    updateTransform() {
        this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
    }
    getBounds(t, r) {
        return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), r || (this._boundsRect || (this._boundsRect = new $e), r = this._boundsRect), this._bounds.getRectangle(r)
    }
    getLocalBounds(t) {
        t || (this._localBoundsRect || (this._localBoundsRect = new $e), t = this._localBoundsRect), this._localBounds || (this._localBounds = new wf);
        const r = this.transform,
            n = this.parent;
        this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
        const i = this._bounds,
            s = this._boundsID;
        this._bounds = this._localBounds;
        const o = this.getBounds(!1, t);
        return this.parent = n, this.transform = r, this._bounds = i, this._bounds.updateID += this._boundsID - s, o
    }
    toGlobal(t, r, n = !1) {
        return n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, r)
    }
    toLocal(t, r, n, i) {
        return r && (t = r.toGlobal(t, n, i)), i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, n)
    }
    setParent(t) {
        if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container");
        return t.addChild(this), t
    }
    removeFromParent() {
        var t;
        (t = this.parent) == null || t.removeChild(this)
    }
    setTransform(t = 0, r = 0, n = 1, i = 1, s = 0, o = 0, a = 0, l = 0, c = 0) {
        return this.position.x = t, this.position.y = r, this.scale.x = n || 1, this.scale.y = i || 1, this.rotation = s, this.skew.x = o, this.skew.y = a, this.pivot.x = l, this.pivot.y = c, this
    }
    destroy(t) {
        this.removeFromParent(), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.eventMode = "auto", this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners()
    }
    get _tempDisplayObjectParent() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new vj), this.tempDisplayObjectParent
    }
    enableTempParent() {
        const t = this.parent;
        return this.parent = this._tempDisplayObjectParent, t
    }
    disableTempParent(t) {
        this.parent = t
    }
    get x() {
        return this.position.x
    }
    set x(t) {
        this.transform.position.x = t
    }
    get y() {
        return this.position.y
    }
    set y(t) {
        this.transform.position.y = t
    }
    get worldTransform() {
        return this.transform.worldTransform
    }
    get localTransform() {
        return this.transform.localTransform
    }
    get position() {
        return this.transform.position
    }
    set position(t) {
        this.transform.position.copyFrom(t)
    }
    get scale() {
        return this.transform.scale
    }
    set scale(t) {
        this.transform.scale.copyFrom(t)
    }
    get pivot() {
        return this.transform.pivot
    }
    set pivot(t) {
        this.transform.pivot.copyFrom(t)
    }
    get skew() {
        return this.transform.skew
    }
    set skew(t) {
        this.transform.skew.copyFrom(t)
    }
    get rotation() {
        return this.transform.rotation
    }
    set rotation(t) {
        this.transform.rotation = t
    }
    get angle() {
        return this.transform.rotation * fz
    }
    set angle(t) {
        this.transform.rotation = t * pz
    }
    get zIndex() {
        return this._zIndex
    }
    set zIndex(t) {
        this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
    }
    get worldVisible() {
        let t = this;
        do {
            if (!t.visible) return !1;
            t = t.parent
        } while (t);
        return !0
    }
    get mask() {
        return this._mask
    }
    set mask(t) {
        if (this._mask !== t) {
            if (this._mask) {
                const r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                r && (r._maskRefCount--, r._maskRefCount === 0 && (r.renderable = !0, r.isMask = !1))
            }
            if (this._mask = t, this._mask) {
                const r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                r && (r._maskRefCount === 0 && (r.renderable = !1, r.isMask = !0), r._maskRefCount++)
            }
        }
    }
}
class vj extends St {
    constructor() {
        super(...arguments), this.sortDirty = null
    }
}
St.prototype.displayObjectUpdateTransform = St.prototype.updateTransform;
const yj = new mt;

function _j(e, t) {
    return e.zIndex === t.zIndex ? e._lastSortedIndex - t._lastSortedIndex : e.zIndex - t.zIndex
}
const qy = class extends St {
    constructor() {
        super(), this.children = [], this.sortableChildren = qy.defaultSortableChildren, this.sortDirty = !1
    }
    onChildrenChange(e) {}
    addChild(...e) {
        if (e.length > 1)
            for (let t = 0; t < e.length; t++) this.addChild(e[t]);
        else {
            const t = e[0];
            t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.push(t), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this)
        }
        return e[0]
    }
    addChildAt(e, t) {
        if (t < 0 || t > this.children.length) throw new Error(`${e}addChildAt: The index ${t} supplied is out of bounds ${this.children.length}`);
        return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(t, 0, e), this._boundsID++, this.onChildrenChange(t), e.emit("added", this), this.emit("childAdded", e, this, t), e
    }
    swapChildren(e, t) {
        if (e === t) return;
        const r = this.getChildIndex(e),
            n = this.getChildIndex(t);
        this.children[r] = t, this.children[n] = e, this.onChildrenChange(r < n ? r : n)
    }
    getChildIndex(e) {
        const t = this.children.indexOf(e);
        if (t === -1) throw new Error("The supplied DisplayObject must be a child of the caller");
        return t
    }
    setChildIndex(e, t) {
        if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
        const r = this.getChildIndex(e);
        Fa(this.children, r, 1), this.children.splice(t, 0, e), this.onChildrenChange(t)
    }
    getChildAt(e) {
        if (e < 0 || e >= this.children.length) throw new Error(`getChildAt: Index (${e}) does not exist.`);
        return this.children[e]
    }
    removeChild(...e) {
        if (e.length > 1)
            for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
        else {
            const t = e[0],
                r = this.children.indexOf(t);
            if (r === -1) return null;
            t.parent = null, t.transform._parentID = -1, Fa(this.children, r, 1), this._boundsID++, this.onChildrenChange(r), t.emit("removed", this), this.emit("childRemoved", t, this, r)
        }
        return e[0]
    }
    removeChildAt(e) {
        const t = this.getChildAt(e);
        return t.parent = null, t.transform._parentID = -1, Fa(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), t.emit("removed", this), this.emit("childRemoved", t, this, e), t
    }
    removeChildren(e = 0, t = this.children.length) {
        const r = e,
            n = t,
            i = n - r;
        let s;
        if (i > 0 && i <= n) {
            s = this.children.splice(r, i);
            for (let o = 0; o < s.length; ++o) s[o].parent = null, s[o].transform && (s[o].transform._parentID = -1);
            this._boundsID++, this.onChildrenChange(e);
            for (let o = 0; o < s.length; ++o) s[o].emit("removed", this), this.emit("childRemoved", s[o], this, o);
            return s
        } else if (i === 0 && this.children.length === 0) return [];
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
    }
    sortChildren() {
        let e = !1;
        for (let t = 0, r = this.children.length; t < r; ++t) {
            const n = this.children[t];
            n._lastSortedIndex = t, !e && n.zIndex !== 0 && (e = !0)
        }
        e && this.children.length > 1 && this.children.sort(_j), this.sortDirty = !1
    }
    updateTransform() {
        this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (let e = 0, t = this.children.length; e < t; ++e) {
            const r = this.children[e];
            r.visible && r.updateTransform()
        }
    }
    calculateBounds() {
        this._bounds.clear(), this._calculateBounds();
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            if (!(!t.visible || !t.renderable))
                if (t.calculateBounds(), t._mask) {
                    const r = t._mask.isMaskData ? t._mask.maskObject : t._mask;
                    r ? (r.calculateBounds(), this._bounds.addBoundsMask(t._bounds, r._bounds)) : this._bounds.addBounds(t._bounds)
                } else t.filterArea ? this._bounds.addBoundsArea(t._bounds, t.filterArea) : this._bounds.addBounds(t._bounds)
        }
        this._bounds.updateID = this._boundsID
    }
    getLocalBounds(e, t = !1) {
        const r = super.getLocalBounds(e);
        if (!t)
            for (let n = 0, i = this.children.length; n < i; ++n) {
                const s = this.children[n];
                s.visible && s.updateTransform()
            }
        return r
    }
    _calculateBounds() {}
    _renderWithCulling(e) {
        const t = e.renderTexture.sourceFrame;
        if (!(t.width > 0 && t.height > 0)) return;
        let r, n;
        this.cullArea ? (r = this.cullArea, n = this.worldTransform) : this._render !== qy.prototype._render && (r = this.getBounds(!0));
        const i = e.projection.transform;
        if (i && (n ? (n = yj.copyFrom(n), n.prepend(i)) : n = i), r && t.intersects(r, n)) this._render(e);
        else if (this.cullArea) return;
        for (let s = 0, o = this.children.length; s < o; ++s) {
            const a = this.children[s],
                l = a.cullable;
            a.cullable = l || !this.cullArea, a.render(e), a.cullable = l
        }
    }
    render(e) {
        var t;
        if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
            if (this._mask || (t = this.filters) != null && t.length) this.renderAdvanced(e);
            else if (this.cullable) this._renderWithCulling(e);
        else {
            this._render(e);
            for (let r = 0, n = this.children.length; r < n; ++r) this.children[r].render(e)
        }
    }
    renderAdvanced(e) {
        var i, s, o;
        const t = this.filters,
            r = this._mask;
        if (t) {
            this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
            for (let a = 0; a < t.length; a++) t[a].enabled && this._enabledFilters.push(t[a])
        }
        const n = t && ((i = this._enabledFilters) == null ? void 0 : i.length) || r && (!r.isMaskData || r.enabled && (r.autoDetect || r.type !== Lt.NONE));
        if (n && e.batch.flush(), t && ((s = this._enabledFilters) != null && s.length) && e.filter.push(this, this._enabledFilters), r && e.mask.push(this, this._mask), this.cullable) this._renderWithCulling(e);
        else {
            this._render(e);
            for (let a = 0, l = this.children.length; a < l; ++a) this.children[a].render(e)
        }
        n && e.batch.flush(), r && e.mask.pop(this), t && ((o = this._enabledFilters) != null && o.length) && e.filter.pop()
    }
    _render(e) {}
    destroy(e) {
        super.destroy(), this.sortDirty = !1;
        const t = typeof e == "boolean" ? e : e == null ? void 0 : e.children,
            r = this.removeChildren(0, this.children.length);
        if (t)
            for (let n = 0; n < r.length; ++n) r[n].destroy(e)
    }
    get width() {
        return this.scale.x * this.getLocalBounds().width
    }
    set width(e) {
        const t = this.getLocalBounds().width;
        t !== 0 ? this.scale.x = e / t : this.scale.x = 1, this._width = e
    }
    get height() {
        return this.scale.y * this.getLocalBounds().height
    }
    set height(e) {
        const t = this.getLocalBounds().height;
        t !== 0 ? this.scale.y = e / t : this.scale.y = 1, this._height = e
    }
};
let jr = qy;
jr.defaultSortableChildren = !1;
jr.prototype.containerUpdateTransform = jr.prototype.updateTransform;
Object.defineProperties(ce, {
    SORTABLE_CHILDREN: {
        get() {
            return jr.defaultSortableChildren
        },
        set(e) {
            ze("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), jr.defaultSortableChildren = e
        }
    }
});
var wj = Object.defineProperty,
    bj = (e, t, r) => t in e ? wj(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    K = (e, t, r) => (bj(e, typeof t != "symbol" ? t + "" : t, r), r);
let on = class {
    constructor(t) {
        K(this, "parent"), K(this, "paused"), this.parent = t, this.paused = !1
    }
    destroy() {}
    down(t) {
        return !1
    }
    move(t) {
        return !1
    }
    up(t) {
        return !1
    }
    wheel(t) {
        return !1
    }
    update(t) {}
    resize() {}
    reset() {}
    pause() {
        this.paused = !0
    }
    resume() {
        this.paused = !1
    }
};
const Pc = {
    linear(e, t, r, n) {
        return r * e / n + t
    },
    easeInQuad(e, t, r, n) {
        return r * (e /= n) * e + t
    },
    easeOutQuad(e, t, r, n) {
        return -r * (e /= n) * (e - 2) + t
    },
    easeInOutQuad(e, t, r, n) {
        return (e /= n / 2) < 1 ? r / 2 * e * e + t : -r / 2 * (--e * (e - 2) - 1) + t
    },
    easeInCubic(e, t, r, n) {
        return r * (e /= n) * e * e + t
    },
    easeOutCubic(e, t, r, n) {
        return r * ((e = e / n - 1) * e * e + 1) + t
    },
    easeInOutCubic(e, t, r, n) {
        return (e /= n / 2) < 1 ? r / 2 * e * e * e + t : r / 2 * ((e -= 2) * e * e + 2) + t
    },
    easeInQuart(e, t, r, n) {
        return r * (e /= n) * e * e * e + t
    },
    easeOutQuart(e, t, r, n) {
        return -r * ((e = e / n - 1) * e * e * e - 1) + t
    },
    easeInOutQuart(e, t, r, n) {
        return (e /= n / 2) < 1 ? r / 2 * e * e * e * e + t : -r / 2 * ((e -= 2) * e * e * e - 2) + t
    },
    easeInQuint(e, t, r, n) {
        return r * (e /= n) * e * e * e * e + t
    },
    easeOutQuint(e, t, r, n) {
        return r * ((e = e / n - 1) * e * e * e * e + 1) + t
    },
    easeInOutQuint(e, t, r, n) {
        return (e /= n / 2) < 1 ? r / 2 * e * e * e * e * e + t : r / 2 * ((e -= 2) * e * e * e * e + 2) + t
    },
    easeInSine(e, t, r, n) {
        return -r * Math.cos(e / n * (Math.PI / 2)) + r + t
    },
    easeOutSine(e, t, r, n) {
        return r * Math.sin(e / n * (Math.PI / 2)) + t
    },
    easeInOutSine(e, t, r, n) {
        return -r / 2 * (Math.cos(Math.PI * e / n) - 1) + t
    },
    easeInExpo(e, t, r, n) {
        return e === 0 ? t : r * Math.pow(2, 10 * (e / n - 1)) + t
    },
    easeOutExpo(e, t, r, n) {
        return e === n ? t + r : r * (-Math.pow(2, -10 * e / n) + 1) + t
    },
    easeInOutExpo(e, t, r, n) {
        return e === 0 ? t : e === n ? t + r : (e /= n / 2) < 1 ? r / 2 * Math.pow(2, 10 * (e - 1)) + t : r / 2 * (-Math.pow(2, -10 * --e) + 2) + t
    },
    easeInCirc(e, t, r, n) {
        return -r * (Math.sqrt(1 - (e /= n) * e) - 1) + t
    },
    easeOutCirc(e, t, r, n) {
        return r * Math.sqrt(1 - (e = e / n - 1) * e) + t
    },
    easeInOutCirc(e, t, r, n) {
        return (e /= n / 2) < 1 ? -r / 2 * (Math.sqrt(1 - e * e) - 1) + t : r / 2 * (Math.sqrt(1 - (e -= 2) * e) + 1) + t
    },
    easeInElastic(e, t, r, n) {
        let i = 1.70158,
            s = 0,
            o = r;
        return e === 0 ? t : (e /= n) === 1 ? t + r : (s || (s = n * .3), o < Math.abs(r) ? (o = r, i = s / 4) : i = s / (2 * Math.PI) * Math.asin(r / o), -(o * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * n - i) * (2 * Math.PI) / s)) + t)
    },
    easeOutElastic(e, t, r, n) {
        let i, s, o;
        return o = 1.70158, s = 0, i = r, e === 0 ? t : (e /= n) === 1 ? t + r : (s || (s = n * .3), i < Math.abs(r) ? (i = r, o = s / 4) : o = s / (2 * Math.PI) * Math.asin(r / i), i * Math.pow(2, -10 * e) * Math.sin((e * n - o) * (2 * Math.PI) / s) + r + t)
    },
    easeInOutElastic(e, t, r, n) {
        let i, s, o;
        return o = 1.70158, s = 0, i = r, e === 0 ? t : (e /= n / 2) === 2 ? t + r : (s || (s = n * (.3 * 1.5)), i < Math.abs(r) ? (i = r, o = s / 4) : o = s / (2 * Math.PI) * Math.asin(r / i), e < 1 ? -.5 * (i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e * n - o) * (2 * Math.PI) / s)) + t : i * Math.pow(2, -10 * (e -= 1)) * Math.sin((e * n - o) * (2 * Math.PI) / s) * .5 + r + t)
    },
    easeInBack(e, t, r, n, i) {
        return i === void 0 && (i = 1.70158), r * (e /= n) * e * ((i + 1) * e - i) + t
    },
    easeOutBack(e, t, r, n, i) {
        return i === void 0 && (i = 1.70158), r * ((e = e / n - 1) * e * ((i + 1) * e + i) + 1) + t
    },
    easeInOutBack(e, t, r, n, i) {
        return i === void 0 && (i = 1.70158), (e /= n / 2) < 1 ? r / 2 * (e * e * (((i *= 1.525) + 1) * e - i)) + t : r / 2 * ((e -= 2) * e * (((i *= 1.525) + 1) * e + i) + 2) + t
    },
    easeInBounce(e, t, r, n) {
        const i = Pc.easeOutBounce(n - e, 0, r, n);
        return r - i + t
    },
    easeOutBounce(e, t, r, n) {
        return (e /= n) < 1 / 2.75 ? r * (7.5625 * e * e) + t : e < 2 / 2.75 ? r * (7.5625 * (e -= 1.5 / 2.75) * e + .75) + t : e < 2.5 / 2.75 ? r * (7.5625 * (e -= 2.25 / 2.75) * e + .9375) + t : r * (7.5625 * (e -= 2.625 / 2.75) * e + .984375) + t
    },
    easeInOutBounce(e, t, r, n) {
        let i;
        return e < n / 2 ? (i = Pc.easeInBounce(e * 2, 0, r, n), i * .5 + t) : (i = Pc.easeOutBounce(e * 2 - n, 0, r, n), i * .5 + r * .5 + t)
    }
};

function Fm(e, t) {
    if (e) {
        if (typeof e == "function") return e;
        if (typeof e == "string") return Pc[e]
    } else return Pc[t]
}
const xj = {
    removeOnInterrupt: !1,
    ease: "linear",
    time: 1e3
};
let Ej = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), K(this, "startX"), K(this, "startY"), K(this, "deltaX"), K(this, "deltaY"), K(this, "keepCenter"), K(this, "startWidth", null), K(this, "startHeight", null), K(this, "deltaWidth", null), K(this, "deltaHeight", null), K(this, "width", null), K(this, "height", null), K(this, "time", 0), this.options = Object.assign({}, xj, r), this.options.ease = Fm(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0
    }
    setupPosition() {
        typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = !1) : this.keepCenter = !0
    }
    setupZoom() {
        this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight)
    }
    down() {
        return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), !1
    }
    complete() {
        this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent)
    }
    update(t) {
        if (this.paused) return;
        this.time += t;
        const r = new Se(this.parent.scale.x, this.parent.scale.y);
        if (this.time >= this.options.time) {
            const n = this.parent.width,
                i = this.parent.height;
            this.complete(), (n !== this.parent.width || i !== this.parent.height) && this.parent.emit("zoomed", {
                viewport: this.parent,
                original: r,
                type: "animate"
            })
        } else {
            const n = this.options.ease(this.time, 0, 1, this.options.time);
            if (this.width !== null) {
                const i = this.startWidth,
                    s = this.deltaWidth;
                this.parent.fitWidth(i + s * n, this.keepCenter, this.height === null)
            }
            if (this.height !== null) {
                const i = this.startHeight,
                    s = this.deltaHeight;
                this.parent.fitHeight(i + s * n, this.keepCenter, this.width === null)
            }
            if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
                const i = this.startX,
                    s = this.startY,
                    o = this.deltaX,
                    a = this.deltaY,
                    l = new Se(this.parent.x, this.parent.y);
                this.parent.moveCenter(i + o * n, s + a * n), this.parent.emit("moved", {
                    viewport: this.parent,
                    original: l,
                    type: "animate"
                })
            }(this.width || this.height) && this.parent.emit("zoomed", {
                viewport: this.parent,
                original: r,
                type: "animate"
            })
        }
    }
};
const Sj = {
    sides: "all",
    friction: .5,
    time: 150,
    ease: "easeInOutSine",
    underflow: "center",
    bounceBox: null
};
let Pj = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), K(this, "left"), K(this, "top"), K(this, "right"), K(this, "bottom"), K(this, "underflowX"), K(this, "underflowY"), K(this, "ease"), K(this, "toX"), K(this, "toY"), this.options = Object.assign({}, Sj, r), this.ease = Fm(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = !0 : this.options.sides === "horizontal" ? (this.right = this.left = !0, this.top = this.bottom = !1) : this.options.sides === "vertical" ? (this.left = this.right = !1, this.top = this.bottom = !0) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = !1;
        const n = this.options.underflow.toLowerCase();
        n === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = n.indexOf("left") !== -1 ? -1 : n.indexOf("right") !== -1 ? 1 : 0, this.underflowY = n.indexOf("top") !== -1 ? -1 : n.indexOf("bottom") !== -1 ? 1 : 0), this.reset()
    }
    isActive() {
        return this.toX !== null || this.toY !== null
    }
    down() {
        return this.toX = this.toY = null, !1
    }
    up() {
        return this.bounce(), !1
    }
    update(t) {
        if (!this.paused) {
            if (this.bounce(), this.toX) {
                const r = this.toX;
                r.time += t, this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "bounce-x"
                }), r.time >= this.options.time ? (this.parent.x = r.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(r.time, r.start, r.delta, this.options.time)
            }
            if (this.toY) {
                const r = this.toY;
                r.time += t, this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "bounce-y"
                }), r.time >= this.options.time ? (this.parent.y = r.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(r.time, r.start, r.delta, this.options.time)
            }
        }
    }
    calcUnderflowX() {
        let t;
        switch (this.underflowX) {
            case -1:
                t = 0;
                break;
            case 1:
                t = this.parent.screenWidth - this.parent.screenWorldWidth;
                break;
            default:
                t = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2
        }
        return t
    }
    calcUnderflowY() {
        let t;
        switch (this.underflowY) {
            case -1:
                t = 0;
                break;
            case 1:
                t = this.parent.screenHeight - this.parent.screenWorldHeight;
                break;
            default:
                t = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2
        }
        return t
    }
    oob() {
        const t = this.options.bounceBox;
        if (t) {
            const r = typeof t.x > "u" ? 0 : t.x,
                n = typeof t.y > "u" ? 0 : t.y,
                i = typeof t.width > "u" ? this.parent.worldWidth : t.width,
                s = typeof t.height > "u" ? this.parent.worldHeight : t.height;
            return {
                left: this.parent.left < r,
                right: this.parent.right > i,
                top: this.parent.top < n,
                bottom: this.parent.bottom > s,
                topLeft: new Se(r * this.parent.scale.x, n * this.parent.scale.y),
                bottomRight: new Se(i * this.parent.scale.x - this.parent.screenWidth, s * this.parent.scale.y - this.parent.screenHeight)
            }
        }
        return {
            left: this.parent.left < 0,
            right: this.parent.right > this.parent.worldWidth,
            top: this.parent.top < 0,
            bottom: this.parent.bottom > this.parent.worldHeight,
            topLeft: new Se(0, 0),
            bottomRight: new Se(this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth, this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight)
        }
    }
    bounce() {
        var t, r;
        if (this.paused) return;
        let n, i = this.parent.plugins.get("decelerate", !0);
        i && (i.x || i.y) && (i.x && i.percentChangeX === ((t = i.options) == null ? void 0 : t.friction) || i.y && i.percentChangeY === ((r = i.options) == null ? void 0 : r.friction)) && (n = this.oob(), (n.left && this.left || n.right && this.right) && (i.percentChangeX = this.options.friction), (n.top && this.top || n.bottom && this.bottom) && (i.percentChangeY = this.options.friction));
        const s = this.parent.plugins.get("drag", !0) || {},
            o = this.parent.plugins.get("pinch", !0) || {};
        if (i = i || {}, !(s != null && s.active) && !(o != null && o.active) && (!this.toX || !this.toY) && (!i.x || !i.y)) {
            n = n || this.oob();
            const a = n.topLeft,
                l = n.bottomRight;
            if (!this.toX && !i.x) {
                let c = null;
                n.left && this.left ? c = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -a.x : n.right && this.right && (c = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -l.x), c !== null && this.parent.x !== c && (this.toX = {
                    time: 0,
                    start: this.parent.x,
                    delta: c - this.parent.x,
                    end: c
                }, this.parent.emit("bounce-x-start", this.parent))
            }
            if (!this.toY && !i.y) {
                let c = null;
                n.top && this.top ? c = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -a.y : n.bottom && this.bottom && (c = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -l.y), c !== null && this.parent.y !== c && (this.toY = {
                    time: 0,
                    start: this.parent.y,
                    delta: c - this.parent.y,
                    end: c
                }, this.parent.emit("bounce-y-start", this.parent))
            }
        }
    }
    reset() {
        this.toX = this.toY = null, this.bounce()
    }
};
const Cj = {
    left: !1,
    right: !1,
    top: !1,
    bottom: !1,
    direction: null,
    underflow: "center"
};
let Tj = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), K(this, "last"), K(this, "noUnderflow"), K(this, "underflowX"), K(this, "underflowY"), this.options = Object.assign({}, Cj, r), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? !0 : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? !0 : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? !0 : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? !0 : null), this.parseUnderflow(), this.last = {
            x: null,
            y: null,
            scaleX: null,
            scaleY: null
        }, this.update()
    }
    parseUnderflow() {
        const t = this.options.underflow.toLowerCase();
        t === "none" ? this.noUnderflow = !0 : t === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = !1) : (this.underflowX = t.indexOf("left") !== -1 ? -1 : t.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t.indexOf("top") !== -1 ? -1 : t.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = !1)
    }
    move() {
        return this.update(), !1
    }
    update() {
        if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY) return;
        const t = new Se(this.parent.x, this.parent.y),
            r = this.parent.plugins.decelerate || {};
        if (this.options.left !== null || this.options.right !== null) {
            let n = !1;
            if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth) switch (this.underflowX) {
                case -1:
                    this.parent.x !== 0 && (this.parent.x = 0, n = !0);
                    break;
                case 1:
                    this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, n = !0);
                    break;
                default:
                    this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, n = !0)
            } else this.options.left !== null && this.parent.left < (this.options.left === !0 ? 0 : this.options.left) && (this.parent.x = -(this.options.left === !0 ? 0 : this.options.left) * this.parent.scale.x, r.x = 0, n = !0), this.options.right !== null && this.parent.right > (this.options.right === !0 ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === !0 ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, r.x = 0, n = !0);
            n && this.parent.emit("moved", {
                viewport: this.parent,
                original: t,
                type: "clamp-x"
            })
        }
        if (this.options.top !== null || this.options.bottom !== null) {
            let n = !1;
            if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight) switch (this.underflowY) {
                case -1:
                    this.parent.y !== 0 && (this.parent.y = 0, n = !0);
                    break;
                case 1:
                    this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, n = !0);
                    break;
                default:
                    this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, n = !0)
            } else this.options.top !== null && this.parent.top < (this.options.top === !0 ? 0 : this.options.top) && (this.parent.y = -(this.options.top === !0 ? 0 : this.options.top) * this.parent.scale.y, r.y = 0, n = !0), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === !0 ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === !0 ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, r.y = 0, n = !0);
            n && this.parent.emit("moved", {
                viewport: this.parent,
                original: t,
                type: "clamp-y"
            })
        }
        this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y
    }
    reset() {
        this.update()
    }
};
const Oj = {
    minWidth: null,
    minHeight: null,
    maxWidth: null,
    maxHeight: null,
    minScale: null,
    maxScale: null
};
let Aj = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), this.options = Object.assign({}, Oj, r), this.clamp()
    }
    resize() {
        this.clamp()
    }
    clamp() {
        if (!this.paused) {
            if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
                let t = this.parent.worldScreenWidth,
                    r = this.parent.worldScreenHeight;
                if (this.options.minWidth !== null && t < this.options.minWidth) {
                    const n = this.parent.scale.x;
                    this.parent.fitWidth(this.options.minWidth, !1, !1, !0), this.parent.scale.y *= this.parent.scale.x / n, t = this.parent.worldScreenWidth, r = this.parent.worldScreenHeight, this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "clamp-zoom"
                    })
                }
                if (this.options.maxWidth !== null && t > this.options.maxWidth) {
                    const n = this.parent.scale.x;
                    this.parent.fitWidth(this.options.maxWidth, !1, !1, !0), this.parent.scale.y *= this.parent.scale.x / n, t = this.parent.worldScreenWidth, r = this.parent.worldScreenHeight, this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "clamp-zoom"
                    })
                }
                if (this.options.minHeight !== null && r < this.options.minHeight) {
                    const n = this.parent.scale.y;
                    this.parent.fitHeight(this.options.minHeight, !1, !1, !0), this.parent.scale.x *= this.parent.scale.y / n, t = this.parent.worldScreenWidth, r = this.parent.worldScreenHeight, this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "clamp-zoom"
                    })
                }
                if (this.options.maxHeight !== null && r > this.options.maxHeight) {
                    const n = this.parent.scale.y;
                    this.parent.fitHeight(this.options.maxHeight, !1, !1, !0), this.parent.scale.x *= this.parent.scale.y / n, this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "clamp-zoom"
                    })
                }
            } else if (this.options.minScale || this.options.maxScale) {
                const t = {
                        x: null,
                        y: null
                    },
                    r = {
                        x: null,
                        y: null
                    };
                if (typeof this.options.minScale == "number") t.x = this.options.minScale, t.y = this.options.minScale;
                else if (this.options.minScale !== null) {
                    const s = this.options.minScale;
                    t.x = typeof s.x > "u" ? null : s.x, t.y = typeof s.y > "u" ? null : s.y
                }
                if (typeof this.options.maxScale == "number") r.x = this.options.maxScale, r.y = this.options.maxScale;
                else if (this.options.maxScale !== null) {
                    const s = this.options.maxScale;
                    r.x = typeof s.x > "u" ? null : s.x, r.y = typeof s.y > "u" ? null : s.y
                }
                let n = this.parent.scale.x,
                    i = this.parent.scale.y;
                t.x !== null && n < t.x && (n = t.x), r.x !== null && n > r.x && (n = r.x), t.y !== null && i < t.y && (i = t.y), r.y !== null && i > r.y && (i = r.y), (n !== this.parent.scale.x || i !== this.parent.scale.y) && (this.parent.scale.set(n, i), this.parent.emit("zoomed", {
                    viewport: this.parent,
                    type: "clamp-zoom"
                }))
            }
        }
    }
    reset() {
        this.clamp()
    }
};
const Ij = {
        friction: .98,
        bounce: .8,
        minSpeed: .01
    },
    Gi = 16;
let $j = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), K(this, "x"), K(this, "y"), K(this, "percentChangeX"), K(this, "percentChangeY"), K(this, "saved"), K(this, "timeSinceRelease"), this.options = Object.assign({}, Ij, r), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", n => this.handleMoved(n))
    }
    down() {
        return this.saved = [], this.x = this.y = null, !1
    }
    isActive() {
        return !!(this.x || this.y)
    }
    move() {
        if (this.paused) return !1;
        const t = this.parent.input.count();
        return (t === 1 || t > 1 && !this.parent.plugins.get("pinch", !0)) && (this.saved.push({
            x: this.parent.x,
            y: this.parent.y,
            time: performance.now()
        }), this.saved.length > 60 && this.saved.splice(0, 30)), !1
    }
    handleMoved(t) {
        if (this.saved.length) {
            const r = this.saved[this.saved.length - 1];
            t.type === "clamp-x" && t.original ? r.x === t.original.x && (r.x = this.parent.x) : t.type === "clamp-y" && t.original && r.y === t.original.y && (r.y = this.parent.y)
        }
    }
    up() {
        if (this.parent.input.count() === 0 && this.saved.length) {
            const t = performance.now();
            for (const r of this.saved)
                if (r.time >= t - 100) {
                    const n = t - r.time;
                    this.x = (this.parent.x - r.x) / n, this.y = (this.parent.y - r.y) / n, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
                    break
                }
        }
        return !1
    }
    activate(t) {
        t = t || {}, typeof t.x < "u" && (this.x = t.x, this.percentChangeX = this.options.friction), typeof t.y < "u" && (this.y = t.y, this.percentChangeY = this.options.friction)
    }
    update(t) {
        if (this.paused) return;
        const r = this.x || this.y,
            n = this.timeSinceRelease,
            i = this.timeSinceRelease + t;
        if (this.x) {
            const s = this.percentChangeX,
                o = Math.log(s);
            this.parent.x += this.x * Gi / o * (Math.pow(s, i / Gi) - Math.pow(s, n / Gi)), this.x *= Math.pow(this.percentChangeX, t / Gi)
        }
        if (this.y) {
            const s = this.percentChangeY,
                o = Math.log(s);
            this.parent.y += this.y * Gi / o * (Math.pow(s, i / Gi) - Math.pow(s, n / Gi)), this.y *= Math.pow(this.percentChangeY, t / Gi)
        }
        this.timeSinceRelease += t, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), r && this.parent.emit("moved", {
            viewport: this.parent,
            type: "decelerate"
        })
    }
    reset() {
        this.x = this.y = null
    }
};
const Rj = {
    direction: "all",
    pressDrag: !0,
    wheel: !0,
    wheelScroll: 1,
    reverse: !1,
    clampWheel: !1,
    underflow: "center",
    factor: 1,
    mouseButtons: "all",
    keyToPress: null,
    ignoreKeyToPressOnTouch: !1,
    lineHeight: 20,
    wheelSwapAxes: !1
};
let kj = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), K(this, "moved"), K(this, "reverse"), K(this, "xDirection"), K(this, "yDirection"), K(this, "keyIsPressed"), K(this, "mouse"), K(this, "underflowX"), K(this, "underflowY"), K(this, "last"), K(this, "current"), K(this, "windowEventHandlers", []), this.options = Object.assign({}, Rj, r), this.moved = !1, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = !1, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress)
    }
    handleKeyPresses(t) {
        const r = i => {
                t.includes(i.code) && (this.keyIsPressed = !0)
            },
            n = i => {
                t.includes(i.code) && (this.keyIsPressed = !1)
            };
        this.addWindowEventHandler("keyup", n), this.addWindowEventHandler("keydown", r)
    }
    addWindowEventHandler(t, r) {
        window.addEventListener(t, r), this.windowEventHandlers.push({
            event: t,
            handler: r
        })
    }
    destroy() {
        this.windowEventHandlers.forEach(({
            event: t,
            handler: r
        }) => {
            window.removeEventListener(t, r)
        })
    }
    mouseButtons(t) {
        !t || t === "all" ? this.mouse = [!0, !0, !0] : this.mouse = [t.indexOf("left") !== -1, t.indexOf("middle") !== -1, t.indexOf("right") !== -1]
    }
    parseUnderflow() {
        const t = this.options.underflow.toLowerCase();
        t === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t.includes("left") ? this.underflowX = -1 : t.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t.includes("top") ? this.underflowY = -1 : t.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0)
    }
    checkButtons(t) {
        const r = t.pointerType === "mouse",
            n = this.parent.input.count();
        return !!((n === 1 || n > 1 && !this.parent.plugins.get("pinch", !0)) && (!r || this.mouse[t.button]))
    }
    checkKeyPress(t) {
        return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t.pointerType === "touch"
    }
    down(t) {
        return this.paused || !this.options.pressDrag ? !1 : this.checkButtons(t) && this.checkKeyPress(t) ? (this.last = {
            x: t.clientX,
            y: t.clientY
        }, this.current = t.pointerId, !0) : (this.last = null, !1)
    }
    get active() {
        return this.moved
    }
    move(t) {
        if (this.paused || !this.options.pressDrag) return !1;
        if (this.last && this.current === t.pointerId) {
            const r = t.clientX,
                n = t.clientY,
                i = this.parent.input.count();
            if (i === 1 || i > 1 && !this.parent.plugins.get("pinch", !0)) {
                const s = r - this.last.x,
                    o = n - this.last.y;
                if (this.moved || this.xDirection && this.parent.input.checkThreshold(s) || this.yDirection && this.parent.input.checkThreshold(o)) {
                    const a = {
                        x: r,
                        y: n
                    };
                    return this.xDirection && (this.parent.x += (a.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (a.y - this.last.y) * this.options.factor), this.last = a, this.moved || this.parent.emit("drag-start", {
                        event: t,
                        screen: new Se(this.last.x, this.last.y),
                        world: this.parent.toWorld(new Se(this.last.x, this.last.y)),
                        viewport: this.parent
                    }), this.moved = !0, this.parent.emit("moved", {
                        viewport: this.parent,
                        type: "drag"
                    }), !0
                }
            } else this.moved = !1
        }
        return !1
    }
    up(t) {
        if (this.paused) return !1;
        const r = this.parent.input.touches;
        if (r.length === 1) {
            const n = r[0];
            return n.last && (this.last = {
                x: n.last.x,
                y: n.last.y
            }, this.current = n.id), this.moved = !1, !0
        } else if (this.last && this.moved) {
            const n = new Se(this.last.x, this.last.y);
            return this.parent.emit("drag-end", {
                event: t,
                screen: n,
                world: this.parent.toWorld(n),
                viewport: this.parent
            }), this.last = null, this.moved = !1, !0
        }
        return !1
    }
    wheel(t) {
        if (this.paused) return !1;
        if (this.options.wheel) {
            const r = this.parent.plugins.get("wheel", !0);
            if (!r || !r.options.wheelZoom && !t.ctrlKey) {
                const n = t.deltaMode ? this.options.lineHeight : 1,
                    i = [t.deltaX, t.deltaY],
                    [s, o] = this.options.wheelSwapAxes ? i.reverse() : i;
                return this.xDirection && (this.parent.x += s * n * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += o * n * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "wheel"
                }), this.parent.options.passiveWheel || t.preventDefault(), this.parent.options.stopPropagation && t.stopPropagation(), !0
            }
        }
        return !1
    }
    resume() {
        this.last = null, this.paused = !1
    }
    clamp() {
        const t = this.parent.plugins.get("decelerate", !0) || {};
        if (this.options.clampWheel !== "y")
            if (this.parent.screenWorldWidth < this.parent.screenWidth) switch (this.underflowX) {
                case -1:
                    this.parent.x = 0;
                    break;
                case 1:
                    this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
                    break;
                default:
                    this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2
            } else this.parent.left < 0 ? (this.parent.x = 0, t.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t.x = 0);
        if (this.options.clampWheel !== "x")
            if (this.parent.screenWorldHeight < this.parent.screenHeight) switch (this.underflowY) {
                case -1:
                    this.parent.y = 0;
                    break;
                case 1:
                    this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
                    break;
                default:
                    this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2
            } else this.parent.top < 0 && (this.parent.y = 0, t.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t.y = 0)
    }
};
const Mj = {
    speed: 0,
    acceleration: null,
    radius: null
};
let Dj = class extends on {
    constructor(t, r, n = {}) {
        super(t), K(this, "options"), K(this, "target"), K(this, "velocity"), this.target = r, this.options = Object.assign({}, Mj, n), this.velocity = {
            x: 0,
            y: 0
        }
    }
    update(t) {
        if (this.paused) return;
        const r = this.parent.center;
        let n = this.target.x,
            i = this.target.y;
        if (this.options.radius)
            if (Math.sqrt(Math.pow(this.target.y - r.y, 2) + Math.pow(this.target.x - r.x, 2)) > this.options.radius) {
                const a = Math.atan2(this.target.y - r.y, this.target.x - r.x);
                n = this.target.x - Math.cos(a) * this.options.radius, i = this.target.y - Math.sin(a) * this.options.radius
            } else return;
        const s = n - r.x,
            o = i - r.y;
        if (s || o)
            if (this.options.speed)
                if (this.options.acceleration) {
                    const a = Math.atan2(i - r.y, n - r.x),
                        l = Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2));
                    if (l) {
                        const c = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
                        l > c ? this.velocity = {
                            x: Math.min(this.velocity.x + (this.options.acceleration * t, this.options.speed)),
                            y: Math.min(this.velocity.y + (this.options.acceleration * t, this.options.speed))
                        } : this.velocity = {
                            x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
                            y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
                        };
                        const u = Math.cos(a) * this.velocity.x,
                            h = Math.sin(a) * this.velocity.y,
                            d = Math.abs(u) > Math.abs(s) ? n : r.x + u,
                            f = Math.abs(h) > Math.abs(o) ? i : r.y + h;
                        this.parent.moveCenter(d, f), this.parent.emit("moved", {
                            viewport: this.parent,
                            type: "follow"
                        })
                    }
                } else {
                    const a = Math.atan2(i - r.y, n - r.x),
                        l = Math.cos(a) * this.options.speed,
                        c = Math.sin(a) * this.options.speed,
                        u = Math.abs(l) > Math.abs(s) ? n : r.x + l,
                        h = Math.abs(c) > Math.abs(o) ? i : r.y + c;
                    this.parent.moveCenter(u, h), this.parent.emit("moved", {
                        viewport: this.parent,
                        type: "follow"
                    })
                }
        else this.parent.moveCenter(n, i), this.parent.emit("moved", {
            viewport: this.parent,
            type: "follow"
        })
    }
};
const Nj = {
    radius: null,
    distance: null,
    top: null,
    bottom: null,
    left: null,
    right: null,
    speed: 8,
    reverse: !1,
    noDecelerate: !1,
    linear: !1,
    allowButtons: !1
};
let Lj = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), K(this, "reverse"), K(this, "radiusSquared"), K(this, "left"), K(this, "top"), K(this, "right"), K(this, "bottom"), K(this, "horizontal"), K(this, "vertical"), this.options = Object.assign({}, Nj, r), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize()
    }
    resize() {
        const t = this.options.distance;
        t !== null ? (this.left = t, this.top = t, this.right = this.parent.screenWidth - t, this.bottom = this.parent.screenHeight - t) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom)
    }
    down() {
        return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), !1
    }
    move(t) {
        if (this.paused || t.pointerType !== "mouse" && t.pointerId !== 1 || !this.options.allowButtons && t.buttons !== 0) return !1;
        const r = t.x,
            n = t.y;
        if (this.radiusSquared) {
            const i = this.parent.toScreen(this.parent.center);
            if (Math.pow(i.x - r, 2) + Math.pow(i.y - n, 2) >= this.radiusSquared) {
                const s = Math.atan2(i.y - n, i.x - r);
                this.options.linear ? (this.horizontal = Math.round(Math.cos(s)) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.round(Math.sin(s)) * this.options.speed * this.reverse * (60 / 1e3)) : (this.horizontal = Math.cos(s) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.sin(s) * this.options.speed * this.reverse * (60 / 1e3))
            } else this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0
        } else this.left !== null && r < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.right !== null && r > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && n < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.bottom !== null && n > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateVertical(), this.vertical = 0);
        return !1
    }
    decelerateHorizontal() {
        const t = this.parent.plugins.get("decelerate", !0);
        this.horizontal && t && !this.options.noDecelerate && t.activate({
            x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60)
        })
    }
    decelerateVertical() {
        const t = this.parent.plugins.get("decelerate", !0);
        this.vertical && t && !this.options.noDecelerate && t.activate({
            y: this.vertical * this.options.speed * this.reverse / (1e3 / 60)
        })
    }
    up() {
        return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), !1
    }
    update() {
        if (!this.paused && (this.horizontal || this.vertical)) {
            const t = this.parent.center;
            this.horizontal && (t.x += this.horizontal * this.options.speed), this.vertical && (t.y += this.vertical * this.options.speed), this.parent.moveCenter(t), this.parent.emit("moved", {
                viewport: this.parent,
                type: "mouse-edges"
            })
        }
    }
};
const Fj = {
    noDrag: !1,
    percent: 1,
    center: null,
    factor: 1,
    axis: "all"
};
let Bj = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), K(this, "active", !1), K(this, "pinching", !1), K(this, "moved", !1), K(this, "lastCenter"), this.options = Object.assign({}, Fj, r)
    }
    down() {
        return this.parent.input.count() >= 2 ? (this.active = !0, !0) : !1
    }
    isAxisX() {
        return ["all", "x"].includes(this.options.axis)
    }
    isAxisY() {
        return ["all", "y"].includes(this.options.axis)
    }
    move(t) {
        if (this.paused || !this.active) return !1;
        const r = t.x,
            n = t.y,
            i = this.parent.input.touches;
        if (i.length >= 2) {
            const s = i[0],
                o = i[1],
                a = s.last && o.last ? Math.sqrt(Math.pow(o.last.x - s.last.x, 2) + Math.pow(o.last.y - s.last.y, 2)) : null;
            if (s.id === t.pointerId ? s.last = {
                    x: r,
                    y: n,
                    data: t
                } : o.id === t.pointerId && (o.last = {
                    x: r,
                    y: n,
                    data: t
                }), a) {
                let l;
                const c = new Se(s.last.x + (o.last.x - s.last.x) / 2, s.last.y + (o.last.y - s.last.y) / 2);
                this.options.center || (l = this.parent.toLocal(c));
                let u = Math.sqrt(Math.pow(o.last.x - s.last.x, 2) + Math.pow(o.last.y - s.last.y, 2));
                u = u === 0 ? u = 1e-10 : u;
                const h = (1 - a / u) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
                this.isAxisX() && (this.parent.scale.x += h), this.isAxisY() && (this.parent.scale.y += h), this.parent.emit("zoomed", {
                    viewport: this.parent,
                    type: "pinch",
                    center: c
                });
                const d = this.parent.plugins.get("clamp-zoom", !0);
                if (d && d.clamp(), this.options.center) this.parent.moveCenter(this.options.center);
                else {
                    const f = this.parent.toGlobal(l);
                    this.parent.x += (c.x - f.x) * this.options.factor, this.parent.y += (c.y - f.y) * this.options.factor, this.parent.emit("moved", {
                        viewport: this.parent,
                        type: "pinch"
                    })
                }!this.options.noDrag && this.lastCenter && (this.parent.x += (c.x - this.lastCenter.x) * this.options.factor, this.parent.y += (c.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "pinch"
                })), this.lastCenter = c, this.moved = !0
            } else this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = !0);
            return !0
        }
        return !1
    }
    up() {
        return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = !1, this.lastCenter = null, this.pinching = !1, this.moved = !1, this.parent.emit("pinch-end", this.parent), !0) : !1
    }
};
const zj = {
    topLeft: !1,
    friction: .8,
    time: 1e3,
    ease: "easeInOutSine",
    interrupt: !0,
    removeOnComplete: !1,
    removeOnInterrupt: !1,
    forceStart: !1
};
let jj = class extends on {
    constructor(t, r, n, i = {}) {
        super(t), K(this, "options"), K(this, "ease"), K(this, "x"), K(this, "y"), K(this, "percent"), K(this, "snapping"), K(this, "deltaX"), K(this, "deltaY"), K(this, "startX"), K(this, "startY"), this.options = Object.assign({}, zj, i), this.ease = Fm(i.ease, "easeInOutSine"), this.x = r, this.y = n, this.options.forceStart && this.snapStart()
    }
    snapStart() {
        this.percent = 0, this.snapping = {
            time: 0
        };
        const t = this.options.topLeft ? this.parent.corner : this.parent.center;
        this.deltaX = this.x - t.x, this.deltaY = this.y - t.y, this.startX = t.x, this.startY = t.y, this.parent.emit("snap-start", this.parent)
    }
    wheel() {
        return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), !1
    }
    down() {
        return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), !1
    }
    up() {
        if (this.parent.input.count() === 0) {
            const t = this.parent.plugins.get("decelerate", !0);
            t && (t.x || t.y) && (t.percentChangeX = t.percentChangeY = this.options.friction)
        }
        return !1
    }
    update(t) {
        if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
            if (this.snapping) {
                const r = this.snapping;
                r.time += t;
                let n, i, s;
                const o = this.startX,
                    a = this.startY,
                    l = this.deltaX,
                    c = this.deltaY;
                if (r.time > this.options.time) n = !0, i = o + l, s = a + c;
                else {
                    const u = this.ease(r.time, 0, 1, this.options.time);
                    i = o + l * u, s = a + c * u
                }
                this.options.topLeft ? this.parent.moveCorner(i, s) : this.parent.moveCenter(i, s), this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "snap"
                }), n && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null)
            } else {
                const r = this.options.topLeft ? this.parent.corner : this.parent.center;
                (r.x !== this.x || r.y !== this.y) && this.snapStart()
            }
    }
};
const Uj = {
    width: 0,
    height: 0,
    time: 1e3,
    ease: "easeInOutSine",
    center: null,
    interrupt: !0,
    removeOnComplete: !1,
    removeOnInterrupt: !1,
    forceStart: !1,
    noMove: !1
};
let Hj = class extends on {
    constructor(t, r = {}) {
        super(t), K(this, "options"), K(this, "ease"), K(this, "xScale"), K(this, "yScale"), K(this, "xIndependent"), K(this, "yIndependent"), K(this, "snapping"), this.options = Object.assign({}, Uj, r), this.ease = Fm(this.options.ease), this.xIndependent = !1, this.yIndependent = !1, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t.screenWidth / this.options.width, this.xIndependent = !0), this.options.height > 0 && (this.yScale = t.screenHeight / this.options.height, this.yIndependent = !0), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t.container.scale.x = this.xScale, t.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : r.forceStart && this.createSnapping()
    }
    createSnapping() {
        const t = this.parent.worldScreenWidth,
            r = this.parent.worldScreenHeight,
            n = this.parent.screenWidth / this.xScale,
            i = this.parent.screenHeight / this.yScale;
        this.snapping = {
            time: 0,
            startX: t,
            startY: r,
            deltaX: n - t,
            deltaY: i - r
        }, this.parent.emit("snap-zoom-start", this.parent)
    }
    resize() {
        this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale
    }
    wheel() {
        return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), !1
    }
    down() {
        return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), !1
    }
    update(t) {
        if (this.paused || this.options.interrupt && this.parent.input.count() !== 0) return;
        let r;
        if (!this.options.center && !this.options.noMove && (r = this.parent.center), !this.snapping)(this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
        else if (this.snapping) {
            const n = this.snapping;
            if (n.time += t, n.time >= this.options.time) this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
            else {
                const s = this.snapping,
                    o = this.ease(s.time, s.startX, s.deltaX, this.options.time),
                    a = this.ease(s.time, s.startY, s.deltaY, this.options.time);
                this.parent.scale.x = this.parent.screenWidth / o, this.parent.scale.y = this.parent.screenHeight / a
            }
            const i = this.parent.plugins.get("clamp-zoom", !0);
            i && i.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(r))
        }
    }
    resume() {
        this.snapping = null, super.resume()
    }
};
const Gj = {
    percent: .1,
    smooth: !1,
    interrupt: !0,
    reverse: !1,
    center: null,
    lineHeight: 20,
    axis: "all",
    keyToPress: null,
    trackpadPinch: !1,
    wheelZoom: !0
};
let Vj = class extends on {
        constructor(t, r = {}) {
            super(t), K(this, "options"), K(this, "smoothing"), K(this, "smoothingCenter"), K(this, "smoothingCount"), K(this, "keyIsPressed"), this.options = Object.assign({}, Gj, r), this.keyIsPressed = !1, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress)
        }
        handleKeyPresses(t) {
            window.addEventListener("keydown", r => {
                t.includes(r.code) && (this.keyIsPressed = !0)
            }), window.addEventListener("keyup", r => {
                t.includes(r.code) && (this.keyIsPressed = !1)
            })
        }
        checkKeyPress() {
            return !this.options.keyToPress || this.keyIsPressed
        }
        down() {
            return this.options.interrupt && (this.smoothing = null), !1
        }
        isAxisX() {
            return ["all", "x"].includes(this.options.axis)
        }
        isAxisY() {
            return ["all", "y"].includes(this.options.axis)
        }
        update() {
            if (this.smoothing) {
                const t = this.smoothingCenter,
                    r = this.smoothing;
                let n;
                this.options.center || (n = this.parent.toLocal(t)), this.isAxisX() && (this.parent.scale.x += r.x), this.isAxisY() && (this.parent.scale.y += r.y), this.parent.emit("zoomed", {
                    viewport: this.parent,
                    type: "wheel"
                });
                const i = this.parent.plugins.get("clamp-zoom", !0);
                if (i && i.clamp(), this.options.center) this.parent.moveCenter(this.options.center);
                else {
                    const s = this.parent.toGlobal(n);
                    this.parent.x += t.x - s.x, this.parent.y += t.y - s.y
                }
                this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "wheel"
                }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null)
            }
        }
        pinch(t) {
            if (this.paused) return;
            const r = this.parent.input.getPointerPosition(t),
                n = -t.deltaY * (t.deltaMode ? this.options.lineHeight : 1) / 200,
                i = Math.pow(2, (1 + this.options.percent) * n);
            let s;
            this.options.center || (s = this.parent.toLocal(r)), this.isAxisX() && (this.parent.scale.x *= i), this.isAxisY() && (this.parent.scale.y *= i), this.parent.emit("zoomed", {
                viewport: this.parent,
                type: "wheel"
            });
            const o = this.parent.plugins.get("clamp-zoom", !0);
            if (o && o.clamp(), this.options.center) this.parent.moveCenter(this.options.center);
            else {
                const a = this.parent.toGlobal(s);
                this.parent.x += r.x - a.x, this.parent.y += r.y - a.y
            }
            this.parent.emit("moved", {
                viewport: this.parent,
                type: "wheel"
            }), this.parent.emit("wheel-start", {
                event: t,
                viewport: this.parent
            })
        }
        wheel(t) {
            if (this.paused || !this.checkKeyPress()) return !1;
            if (t.ctrlKey && this.options.trackpadPinch) this.pinch(t);
            else if (this.options.wheelZoom) {
                const r = this.parent.input.getPointerPosition(t),
                    n = (this.options.reverse ? -1 : 1) * -t.deltaY * (t.deltaMode ? this.options.lineHeight : 1) / 500,
                    i = Math.pow(2, (1 + this.options.percent) * n);
                if (this.options.smooth) {
                    const s = {
                        x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
                        y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
                    };
                    this.smoothing = {
                        x: ((this.parent.scale.x + s.x) * i - this.parent.scale.x) / this.options.smooth,
                        y: ((this.parent.scale.y + s.y) * i - this.parent.scale.y) / this.options.smooth
                    }, this.smoothingCount = 0, this.smoothingCenter = r
                } else {
                    let s;
                    this.options.center || (s = this.parent.toLocal(r)), this.isAxisX() && (this.parent.scale.x *= i), this.isAxisY() && (this.parent.scale.y *= i), this.parent.emit("zoomed", {
                        viewport: this.parent,
                        type: "wheel"
                    });
                    const o = this.parent.plugins.get("clamp-zoom", !0);
                    if (o && o.clamp(), this.options.center) this.parent.moveCenter(this.options.center);
                    else {
                        const a = this.parent.toGlobal(s);
                        this.parent.x += r.x - a.x, this.parent.y += r.y - a.y
                    }
                }
                this.parent.emit("moved", {
                    viewport: this.parent,
                    type: "wheel"
                }), this.parent.emit("wheel-start", {
                    event: t,
                    viewport: this.parent
                })
            }
            return !this.parent.options.passiveWheel
        }
    },
    Wj = class {
        constructor(t) {
            K(this, "viewport"), K(this, "clickedAvailable"), K(this, "isMouseDown"), K(this, "last"), K(this, "wheelFunction"), K(this, "upFunction"), K(this, "downFunction"), K(this, "moveFunction"), K(this, "touches"), this.viewport = t, this.touches = [], this.addListeners()
        }
        addListeners() {
            this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new $e(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.downFunction = t => this.down(t), this.viewport.options.canvasElement.addEventListener("pointerdown", this.downFunction, {
                passive: !0
            }), this.viewport.options.allowPreserveDragOutside || (this.moveFunction = t => this.move(t), this.viewport.options.canvasElement.addEventListener("pointermove", this.moveFunction, {
                passive: !0
            })), this.upFunction = t => this.up(t), this.viewport.options.canvasElement.addEventListener("pointerup", this.upFunction, {
                passive: !0
            }), this.viewport.options.canvasElement.addEventListener("pointercancel", this.upFunction, {
                passive: !0
            }), this.viewport.options.allowPreserveDragOutside || this.viewport.options.canvasElement.addEventListener("pointerleave", this.upFunction, {
                passive: !0
            }), this.wheelFunction = t => this.handleWheel(t), this.viewport.options.canvasElement.addEventListener("wheel", this.wheelFunction, {
                passive: this.viewport.options.passiveWheel
            }), this.isMouseDown = !1
        }
        destroy() {
            this.viewport.options.canvasElement.removeEventListener("wheel", this.wheelFunction), this.viewport.options.canvasElement.removeEventListener("pointerdown", this.downFunction), this.viewport.options.canvasElement.removeEventListener("pointermove", this.moveFunction), this.viewport.options.canvasElement.removeEventListener("pointerup", this.upFunction), this.viewport.options.canvasElement.removeEventListener("pointercancel", this.upFunction), this.viewport.options.canvasElement.removeEventListener("pointerleave", this.upFunction)
        }
        down(t) {
            if (!(this.viewport.pause || !this.viewport.worldVisible)) {
                if (t.pointerType === "mouse" ? this.isMouseDown = !0 : this.get(t.pointerId) || this.touches.push({
                        id: t.pointerId,
                        last: null
                    }), this.count() === 1) {
                    this.last = new Se(t.clientX, t.clientY);
                    const r = this.viewport.plugins.get("decelerate", !0),
                        n = this.viewport.plugins.get("bounce", !0);
                    (!r || !r.isActive()) && (!n || !n.isActive()) ? this.clickedAvailable = !0: this.clickedAvailable = !1
                } else this.clickedAvailable = !1;
                this.viewport.plugins.down(t) && this.viewport.options.stopPropagation && t.stopPropagation()
            }
        }
        clear() {
            this.isMouseDown = !1, this.touches = [], this.last = null
        }
        checkThreshold(t) {
            return Math.abs(t) >= this.viewport.threshold
        }
        move(t) {
            if (this.viewport.pause || !this.viewport.worldVisible) return;
            const r = this.viewport.plugins.move(t);
            if (this.clickedAvailable && this.last) {
                const n = t.clientX - this.last.x,
                    i = t.clientY - this.last.y;
                (this.checkThreshold(n) || this.checkThreshold(i)) && (this.clickedAvailable = !1)
            }
            r && this.viewport.options.stopPropagation && t.stopPropagation()
        }
        up(t) {
            if (this.viewport.pause || !this.viewport.worldVisible) return;
            t.pointerType === "mouse" && (this.isMouseDown = !1), t.pointerType !== "mouse" && this.remove(t.pointerId);
            const r = this.viewport.plugins.up(t);
            this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
                event: t,
                screen: this.last,
                world: this.viewport.toWorld(this.last),
                viewport: this.viewport
            }), this.clickedAvailable = !1), r && this.viewport.options.stopPropagation && t.stopPropagation()
        }
        getPointerPosition(t) {
            const r = new Se;
            return this.mapPositionToPoint(r, t.clientX, t.clientY), r
        }
        mapPositionToPoint(t, r, n) {
            let i;
            this.viewport.options.canvasElement.parentElement ? i = this.viewport.options.canvasElement.getBoundingClientRect() : i = {
                x: 0,
                y: 0,
                width: this.viewport.options.canvasElement.width,
                height: this.viewport.options.canvasElement.height,
                left: 0,
                top: 0
            };
            const s = 1;
            t.x = (r - i.left) * (this.viewport.options.canvasElement.width / i.width) * s, t.y = (n - i.top) * (this.viewport.options.canvasElement.height / i.height) * s
        }
        handleWheel(t) {
            if (this.viewport.pause || !this.viewport.worldVisible) return;
            const r = this.viewport.toLocal(this.getPointerPosition(t));
            this.viewport.left <= r.x && r.x <= this.viewport.right && this.viewport.top <= r.y && r.y <= this.viewport.bottom && this.viewport.plugins.wheel(t) && !this.viewport.options.passiveWheel && t.preventDefault()
        }
        pause() {
            this.touches = [], this.isMouseDown = !1
        }
        get(t) {
            for (const r of this.touches)
                if (r.id === t) return r;
            return null
        }
        remove(t) {
            for (let r = 0; r < this.touches.length; r++)
                if (this.touches[r].id === t) {
                    this.touches.splice(r, 1);
                    return
                }
        }
        count() {
            return (this.isMouseDown ? 1 : 0) + this.touches.length
        }
    };
const Gl = ["drag", "pinch", "wheel", "follow", "mouse-edges", "decelerate", "animate", "bounce", "snap-zoom", "clamp-zoom", "snap", "clamp"];
let Xj = class {
    constructor(t) {
        K(this, "plugins"), K(this, "list"), K(this, "viewport"), this.viewport = t, this.list = [], this.plugins = {}
    }
    add(t, r, n = Gl.length) {
        const i = this.plugins[t];
        i && i.destroy(), this.plugins[t] = r;
        const s = Gl.indexOf(t);
        s !== -1 && Gl.splice(s, 1), Gl.splice(n, 0, t), this.sort()
    }
    get(t, r) {
        var n;
        return r && (n = this.plugins[t]) != null && n.paused ? null : this.plugins[t]
    }
    update(t) {
        for (const r of this.list) r.update(t)
    }
    resize() {
        for (const t of this.list) t.resize()
    }
    reset() {
        for (const t of this.list) t.reset()
    }
    removeAll() {
        this.list.forEach(t => {
            t.destroy()
        }), this.plugins = {}, this.sort()
    }
    remove(t) {
        var r;
        this.plugins[t] && ((r = this.plugins[t]) == null || r.destroy(), delete this.plugins[t], this.viewport.emit("plugin-remove", t), this.sort())
    }
    pause(t) {
        var r;
        (r = this.plugins[t]) == null || r.pause()
    }
    resume(t) {
        var r;
        (r = this.plugins[t]) == null || r.resume()
    }
    sort() {
        this.list = [];
        for (const t of Gl) this.plugins[t] && this.list.push(this.plugins[t])
    }
    down(t) {
        let r = !1;
        for (const n of this.list) n.down(t) && (r = !0);
        return r
    }
    move(t) {
        let r = !1;
        for (const n of this.viewport.plugins.list) n.move(t) && (r = !0);
        return r
    }
    up(t) {
        let r = !1;
        for (const n of this.list) n.up(t) && (r = !0);
        return r
    }
    wheel(t) {
        let r = !1;
        for (const n of this.list) n.wheel(t) && (r = !0);
        return r
    }
};
const Yj = {
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    worldWidth: null,
    worldHeight: null,
    threshold: 5,
    passiveWheel: !0,
    stopPropagation: !1,
    forceHitArea: null,
    noTicker: !1,
    disableOnContextMenu: !1,
    ticker: Jt.shared,
    allowPreserveDragOutside: !1
};
let Kj = class extends jr {
    constructor(t) {
        super(), K(this, "moving"), K(this, "screenWidth"), K(this, "screenHeight"), K(this, "threshold"), K(this, "input"), K(this, "plugins"), K(this, "zooming"), K(this, "lastViewport"), K(this, "options"), K(this, "_dirty"), K(this, "_forceHitArea"), K(this, "_hitAreaDefault"), K(this, "_pause"), K(this, "tickerFunction"), K(this, "_worldWidth"), K(this, "_worldHeight"), K(this, "_disableOnContextMenu", r => r.preventDefault()), this.options = { ...Yj,
            ...t
        }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.canvasElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new Wj(this), this.plugins = new Xj(this)
    }
    destroy(t) {
        !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && this.options.canvasElement.removeEventListener("contextmenu", this._disableOnContextMenu), this.input.destroy(), super.destroy(t)
    }
    update(t) {
        this.pause || (this.plugins.update(t), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = !0 : this.moving && (this.emit("moved-end", this), this.moving = !1), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = !0 : this.zooming && (this.emit("zoomed-end", this), this.zooming = !1)), this.forceHitArea || (this._hitAreaDefault = new $e(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
            x: this.x,
            y: this.y,
            scaleX: this.scale.x,
            scaleY: this.scale.y
        }, this.emit("frame-end", this))
    }
    resize(t = window.innerWidth, r = window.innerHeight, n, i) {
        this.screenWidth = t, this.screenHeight = r, typeof n < "u" && (this._worldWidth = n), typeof i < "u" && (this._worldHeight = i), this.plugins.resize(), this.dirty = !0
    }
    get worldWidth() {
        return this._worldWidth ? this._worldWidth : this.width / this.scale.x
    }
    set worldWidth(t) {
        this._worldWidth = t, this.plugins.resize()
    }
    get worldHeight() {
        return this._worldHeight ? this._worldHeight : this.height / this.scale.y
    }
    set worldHeight(t) {
        this._worldHeight = t, this.plugins.resize()
    }
    getVisibleBounds() {
        return new $e(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight)
    }
    toWorld(t, r) {
        return arguments.length === 2 ? this.toLocal(new Se(t, r)) : this.toLocal(t)
    }
    toScreen(t, r) {
        return arguments.length === 2 ? this.toGlobal(new Se(t, r)) : this.toGlobal(t)
    }
    get worldScreenWidth() {
        return this.screenWidth / this.scale.x
    }
    get worldScreenHeight() {
        return this.screenHeight / this.scale.y
    }
    get screenWorldWidth() {
        return this.worldWidth * this.scale.x
    }
    get screenWorldHeight() {
        return this.worldHeight * this.scale.y
    }
    get center() {
        return new Se(this.worldScreenWidth / 2 - this.x / this.scale.x, this.worldScreenHeight / 2 - this.y / this.scale.y)
    }
    set center(t) {
        this.moveCenter(t)
    }
    moveCenter(...t) {
        let r, n;
        typeof t[0] == "number" ? (r = t[0], n = t[1]) : (r = t[0].x, n = t[0].y);
        const i = (this.worldScreenWidth / 2 - r) * this.scale.x,
            s = (this.worldScreenHeight / 2 - n) * this.scale.y;
        return (this.x !== i || this.y !== s) && (this.position.set(i, s), this.plugins.reset(), this.dirty = !0), this
    }
    get corner() {
        return new Se(-this.x / this.scale.x, -this.y / this.scale.y)
    }
    set corner(t) {
        this.moveCorner(t)
    }
    moveCorner(...t) {
        let r, n;
        return t.length === 1 ? (r = -t[0].x * this.scale.x, n = -t[0].y * this.scale.y) : (r = -t[0] * this.scale.x, n = -t[1] * this.scale.y), (r !== this.x || n !== this.y) && (this.position.set(r, n), this.plugins.reset(), this.dirty = !0), this
    }
    get screenWidthInWorldPixels() {
        return this.screenWidth / this.scale.x
    }
    get screenHeightInWorldPixels() {
        return this.screenHeight / this.scale.y
    }
    findFitWidth(t) {
        return this.screenWidth / t
    }
    findFitHeight(t) {
        return this.screenHeight / t
    }
    findFit(t, r) {
        const n = this.screenWidth / t,
            i = this.screenHeight / r;
        return Math.min(n, i)
    }
    findCover(t, r) {
        const n = this.screenWidth / t,
            i = this.screenHeight / r;
        return Math.max(n, i)
    }
    fitWidth(t = this.worldWidth, r, n = !0, i) {
        let s;
        r && (s = this.center), this.scale.x = this.screenWidth / t, n && (this.scale.y = this.scale.x);
        const o = this.plugins.get("clamp-zoom", !0);
        return !i && o && o.clamp(), r && s && this.moveCenter(s), this
    }
    fitHeight(t = this.worldHeight, r, n = !0, i) {
        let s;
        r && (s = this.center), this.scale.y = this.screenHeight / t, n && (this.scale.x = this.scale.y);
        const o = this.plugins.get("clamp-zoom", !0);
        return !i && o && o.clamp(), r && s && this.moveCenter(s), this
    }
    fitWorld(t) {
        let r;
        t && (r = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
        const n = this.plugins.get("clamp-zoom", !0);
        return n && n.clamp(), t && r && this.moveCenter(r), this
    }
    fit(t, r = this.worldWidth, n = this.worldHeight) {
        let i;
        t && (i = this.center), this.scale.x = this.screenWidth / r, this.scale.y = this.screenHeight / n, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
        const s = this.plugins.get("clamp-zoom", !0);
        return s && s.clamp(), t && i && this.moveCenter(i), this
    }
    setZoom(t, r) {
        let n;
        r && (n = this.center), this.scale.set(t);
        const i = this.plugins.get("clamp-zoom", !0);
        return i && i.clamp(), r && n && this.moveCenter(n), this
    }
    zoomPercent(t, r) {
        return this.setZoom(this.scale.x + this.scale.x * t, r)
    }
    zoom(t, r) {
        return this.fitWidth(t + this.worldScreenWidth, r), this
    }
    get scaled() {
        return this.scale.x
    }
    set scaled(t) {
        this.setZoom(t, !0)
    }
    snapZoom(t) {
        return this.plugins.add("snap-zoom", new Hj(this, t)), this
    }
    OOB() {
        return {
            left: this.left < 0,
            right: this.right > this.worldWidth,
            top: this.top < 0,
            bottom: this.bottom > this.worldHeight,
            cornerPoint: new Se(this.worldWidth * this.scale.x - this.screenWidth, this.worldHeight * this.scale.y - this.screenHeight)
        }
    }
    get right() {
        return -this.x / this.scale.x + this.worldScreenWidth
    }
    set right(t) {
        this.x = -t * this.scale.x + this.screenWidth, this.plugins.reset()
    }
    get left() {
        return -this.x / this.scale.x
    }
    set left(t) {
        this.x = -t * this.scale.x, this.plugins.reset()
    }
    get top() {
        return -this.y / this.scale.y
    }
    set top(t) {
        this.y = -t * this.scale.y, this.plugins.reset()
    }
    get bottom() {
        return -this.y / this.scale.y + this.worldScreenHeight
    }
    set bottom(t) {
        this.y = -t * this.scale.y + this.screenHeight, this.plugins.reset()
    }
    get dirty() {
        return !!this._dirty
    }
    set dirty(t) {
        this._dirty = t
    }
    get forceHitArea() {
        return this._forceHitArea
    }
    set forceHitArea(t) {
        t ? (this._forceHitArea = t, this.hitArea = t) : (this._forceHitArea = null, this.hitArea = new $e(0, 0, this.worldWidth, this.worldHeight))
    }
    drag(t) {
        return this.plugins.add("drag", new kj(this, t)), this
    }
    clamp(t) {
        return this.plugins.add("clamp", new Tj(this, t)), this
    }
    decelerate(t) {
        return this.plugins.add("decelerate", new $j(this, t)), this
    }
    bounce(t) {
        return this.plugins.add("bounce", new Pj(this, t)), this
    }
    pinch(t) {
        return this.plugins.add("pinch", new Bj(this, t)), this
    }
    snap(t, r, n) {
        return this.plugins.add("snap", new jj(this, t, r, n)), this
    }
    follow(t, r) {
        return this.plugins.add("follow", new Dj(this, t, r)), this
    }
    wheel(t) {
        return this.plugins.add("wheel", new Vj(this, t)), this
    }
    animate(t) {
        return this.plugins.add("animate", new Ej(this, t)), this
    }
    clampZoom(t) {
        return this.plugins.add("clamp-zoom", new Aj(this, t)), this
    }
    mouseEdges(t) {
        return this.plugins.add("mouse-edges", new Lj(this, t)), this
    }
    get pause() {
        return !!this._pause
    }
    set pause(t) {
        this._pause = t, this.lastViewport = null, this.moving = !1, this.zooming = !1, t && this.input.pause()
    }
    ensureVisible(t, r, n, i, s) {
        s && (n > this.worldScreenWidth || i > this.worldScreenHeight) && (this.fit(!0, n, i), this.emit("zoomed", {
            viewport: this,
            type: "ensureVisible"
        }));
        let o = !1;
        t < this.left ? (this.left = t, o = !0) : t + n > this.right && (this.right = t + n, o = !0), r < this.top ? (this.top = r, o = !0) : r + i > this.bottom && (this.bottom = r + i, o = !0), o && this.emit("moved", {
            viewport: this,
            type: "ensureVisible"
        })
    }
};
const Vl = new Se,
    qj = new Uint16Array([0, 1, 2, 0, 2, 3]);
class pl extends jr {
    constructor(t) {
        super(), this._anchor = new ss(this._onAnchorUpdate, this, t ? t.defaultAnchor.x : 0, t ? t.defaultAnchor.y : 0), this._texture = null, this._width = 0, this._height = 0, this._tintColor = new ot(16777215), this._tintRGB = null, this.tint = 16777215, this.blendMode = Ce.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = t || ge.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = qj, this.pluginName = "batch", this.isSprite = !0, this._roundPixels = ce.ROUND_PIXELS
    }
    _onTextureUpdate() {
        this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = is(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = is(this.scale.y) * this._height / this._texture.orig.height)
    }
    _onAnchorUpdate() {
        this._transformID = -1, this._transformTrimmedID = -1
    }
    calculateVertices() {
        const t = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === t._updateID) return;
        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
        const r = this.transform.worldTransform,
            n = r.a,
            i = r.b,
            s = r.c,
            o = r.d,
            a = r.tx,
            l = r.ty,
            c = this.vertexData,
            u = t.trim,
            h = t.orig,
            d = this._anchor;
        let f = 0,
            p = 0,
            m = 0,
            w = 0;
        if (u ? (p = u.x - d._x * h.width, f = p + u.width, w = u.y - d._y * h.height, m = w + u.height) : (p = -d._x * h.width, f = p + h.width, w = -d._y * h.height, m = w + h.height), c[0] = n * p + s * w + a, c[1] = o * w + i * p + l, c[2] = n * f + s * w + a, c[3] = o * w + i * f + l, c[4] = n * f + s * m + a, c[5] = o * m + i * f + l, c[6] = n * p + s * m + a, c[7] = o * m + i * p + l, this._roundPixels) {
            const y = ce.RESOLUTION;
            for (let v = 0; v < c.length; ++v) c[v] = Math.round(c[v] * y) / y
        }
    }
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) this.vertexTrimmedData = new Float32Array(8);
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return;
        this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
        const t = this._texture,
            r = this.vertexTrimmedData,
            n = t.orig,
            i = this._anchor,
            s = this.transform.worldTransform,
            o = s.a,
            a = s.b,
            l = s.c,
            c = s.d,
            u = s.tx,
            h = s.ty,
            d = -i._x * n.width,
            f = d + n.width,
            p = -i._y * n.height,
            m = p + n.height;
        r[0] = o * d + l * p + u, r[1] = c * p + a * d + h, r[2] = o * f + l * p + u, r[3] = c * p + a * f + h, r[4] = o * f + l * m + u, r[5] = c * m + a * f + h, r[6] = o * d + l * m + u, r[7] = c * m + a * d + h
    }
    _render(t) {
        this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
    }
    _calculateBounds() {
        const t = this._texture.trim,
            r = this._texture.orig;
        !t || t.width === r.width && t.height === r.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._localBounds || (this._localBounds = new wf), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new $e), t = this._localBoundsRect), this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, Vl);
        const r = this._texture.orig.width,
            n = this._texture.orig.height,
            i = -r * this.anchor.x;
        let s = 0;
        return Vl.x >= i && Vl.x < i + r && (s = -n * this.anchor.y, Vl.y >= s && Vl.y < s + n)
    }
    destroy(t) {
        if (super.destroy(t), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
            const n = typeof t == "boolean" ? t : t == null ? void 0 : t.baseTexture;
            this._texture.destroy(!!n)
        }
        this._texture = null
    }
    static from(t, r) {
        const n = t instanceof ge ? t : ge.from(t, r);
        return new pl(n)
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        const r = is(this.scale.x) || 1;
        this.scale.x = r * t / this._texture.orig.width, this._width = t
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        const r = is(this.scale.y) || 1;
        this.scale.y = r * t / this._texture.orig.height, this._height = t
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        this._anchor.copyFrom(t)
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        this._tintColor.setValue(t), this._tintRGB = this._tintColor.toLittleEndianNumber()
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || ge.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
    }
}
const z$ = new mt;
St.prototype._cacheAsBitmap = !1;
St.prototype._cacheData = null;
St.prototype._cacheAsBitmapResolution = null;
St.prototype._cacheAsBitmapMultisample = null;
class Qj {
    constructor() {
        this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
    }
}
Object.defineProperties(St.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        },
        set(e) {
            e !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = e, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        },
        set(e) {
            e !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = e, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        },
        set(e) {
            if (this._cacheAsBitmap === e) return;
            this._cacheAsBitmap = e;
            let t;
            e ? (this._cacheData || (this._cacheData = new Qj), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea)
        }
    }
});
St.prototype._renderCached = function(t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
};
St.prototype._initCachedDisplayObject = function(t) {
    var d, f;
    if ((d = this._cacheData) != null && d.sprite) return;
    const r = this.alpha;
    this.alpha = 1, t.batch.flush();
    const n = this.getLocalBounds(null, !0).clone();
    if ((f = this.filters) != null && f.length) {
        const p = this.filters[0].padding;
        n.pad(p)
    }
    n.ceil(ce.RESOLUTION);
    const i = t.renderTexture.current,
        s = t.renderTexture.sourceFrame.clone(),
        o = t.renderTexture.destinationFrame.clone(),
        a = t.projection.transform,
        l = Co.create({
            width: n.width,
            height: n.height,
            resolution: this.cacheAsBitmapResolution || t.resolution,
            multisample: this.cacheAsBitmapMultisample??t.multisample
        }),
        c = `cacheAsBitmap_${yo()}`;
    this._cacheData.textureCacheId = c, Oe.addToCache(l.baseTexture, c), ge.addToCache(l, c);
    const u = this.transform.localTransform.copyTo(z$).invert().translate(-n.x, -n.y);
    this.render = this._cacheData.originalRender, t.render(this, {
        renderTexture: l,
        clear: !0,
        transform: u,
        skipUpdateTransform: !1
    }), t.framebuffer.blit(), t.projection.transform = a, t.renderTexture.bind(i, s, o), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;
    const h = new pl(l);
    h.transform.worldTransform = this.transform.worldTransform, h.anchor.x = -(n.x / n.width), h.anchor.y = -(n.y / n.height), h.alpha = r, h._bounds = this._bounds, this._cacheData.sprite = h, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = h.containsPoint.bind(h)
};
St.prototype._renderCachedCanvas = function(t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
};
St.prototype._initCachedDisplayObjectCanvas = function(t) {
    var u;
    if ((u = this._cacheData) != null && u.sprite) return;
    const r = this.getLocalBounds(null, !0),
        n = this.alpha;
    this.alpha = 1;
    const i = t.canvasContext.activeContext,
        s = t._projTransform;
    r.ceil(ce.RESOLUTION);
    const o = Co.create({
            width: r.width,
            height: r.height
        }),
        a = `cacheAsBitmap_${yo()}`;
    this._cacheData.textureCacheId = a, Oe.addToCache(o.baseTexture, a), ge.addToCache(o, a);
    const l = z$;
    this.transform.localTransform.copyTo(l), l.invert(), l.tx -= r.x, l.ty -= r.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, {
        renderTexture: o,
        clear: !0,
        transform: l,
        skipUpdateTransform: !1
    }), t.canvasContext.activeContext = i, t._projTransform = s, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = n;
    const c = new pl(o);
    c.transform.worldTransform = this.transform.worldTransform, c.anchor.x = -(r.x / r.width), c.anchor.y = -(r.y / r.height), c.alpha = n, c._bounds = this._bounds, this._cacheData.sprite = c, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = c.containsPoint.bind(c)
};
St.prototype._calculateCachedBounds = function() {
    this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
};
St.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null)
};
St.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, Oe.removeFromCache(this._cacheData.textureCacheId), ge.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
};
St.prototype._cacheAsBitmapDestroy = function(t) {
    this.cacheAsBitmap = !1, this.destroy(t)
};
St.prototype.name = null;
jr.prototype.getChildByName = function(t, r) {
    for (let n = 0, i = this.children.length; n < i; n++)
        if (this.children[n].name === t) return this.children[n];
    if (r)
        for (let n = 0, i = this.children.length; n < i; n++) {
            const s = this.children[n];
            if (!s.getChildByName) continue;
            const o = s.getChildByName(t, !0);
            if (o) return o
        }
    return null
};
St.prototype.getGlobalPosition = function(t = new Se, r = !1) {
    return this.parent ? this.parent.toGlobal(this.position, t, r) : (t.x = this.position.x, t.y = this.position.y), t
};
var Zj = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
class Jj extends rr {
    constructor(t = 1) {
        super(fj, Zj, {
            uAlpha: 1
        }), this.alpha = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
const e9 = {
        5: [.153388, .221461, .250301],
        7: [.071303, .131514, .189879, .214607],
        9: [.028532, .067234, .124009, .179044, .20236],
        11: [.0093, .028002, .065984, .121703, .175713, .198596],
        13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
        15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
    },
    t9 = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);

function r9(e) {
    const t = e9[e],
        r = t.length;
    let n = t9,
        i = "";
    const s = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < e; a++) {
        let l = s.replace("%index%", a.toString());
        o = a, a >= r && (o = e - a - 1), l = l.replace("%value%", t[o].toString()), i += l, i += `
`
    }
    return n = n.replace("%blur%", i), n = n.replace("%size%", e.toString()), n
}
const n9 = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;

function i9(e, t) {
    const r = Math.ceil(e / 2);
    let n = n9,
        i = "",
        s;
    t ? s = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : s = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let o = 0; o < e; o++) {
        let a = s.replace("%index%", o.toString());
        a = a.replace("%sampleIndex%", `${o-(r-1)}.0`), i += a, i += `
`
    }
    return n = n.replace("%blur%", i), n = n.replace("%size%", e.toString()), n
}
class Qy extends rr {
    constructor(t, r = 8, n = 4, i = rr.defaultResolution, s = 5) {
        const o = i9(s, t),
            a = r9(s);
        super(o, a), this.horizontal = t, this.resolution = i, this._quality = 0, this.quality = n, this.blur = r
    }
    apply(t, r, n, i) {
        if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / r.width) : this.uniforms.strength = 1 / n.height * (n.height / r.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / r.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / r.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1) t.applyFilter(this, r, n, i);
        else {
            const s = t.getFilterTexture(),
                o = t.renderer;
            let a = r,
                l = s;
            this.state.blend = !1, t.applyFilter(this, a, l, Vn.CLEAR);
            for (let c = 1; c < this.passes - 1; c++) {
                t.bindAndClear(a, Vn.BLIT), this.uniforms.uSampler = l;
                const u = l;
                l = a, a = u, o.shader.bind(this), o.geometry.draw(5)
            }
            this.state.blend = !0, t.applyFilter(this, l, n, i), t.returnFilterTexture(s)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(t) {
        this.padding = 1 + Math.abs(t) * 2, this.strength = t
    }
    get quality() {
        return this._quality
    }
    set quality(t) {
        this._quality = t, this.passes = t
    }
}
class s9 extends rr {
    constructor(t = 8, r = 4, n = rr.defaultResolution, i = 5) {
        super(), this._repeatEdgePixels = !1, this.blurXFilter = new Qy(!0, t, r, n, i), this.blurYFilter = new Qy(!1, t, r, n, i), this.resolution = n, this.quality = r, this.blur = t, this.repeatEdgePixels = !1
    }
    apply(t, r, n, i) {
        const s = Math.abs(this.blurXFilter.strength),
            o = Math.abs(this.blurYFilter.strength);
        if (s && o) {
            const a = t.getFilterTexture();
            this.blurXFilter.apply(t, r, a, Vn.CLEAR), this.blurYFilter.apply(t, a, n, i), t.returnFilterTexture(a)
        } else o ? this.blurYFilter.apply(t, r, n, i) : this.blurXFilter.apply(t, r, n, i)
    }
    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2
    }
    get blur() {
        return this.blurXFilter.blur
    }
    set blur(t) {
        this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(t) {
        this.blurXFilter.quality = this.blurYFilter.quality = t
    }
    get blurX() {
        return this.blurXFilter.blur
    }
    set blurX(t) {
        this.blurXFilter.blur = t, this.updatePadding()
    }
    get blurY() {
        return this.blurYFilter.blur
    }
    set blurY(t) {
        this.blurYFilter.blur = t, this.updatePadding()
    }
    get blendMode() {
        return this.blurYFilter.blendMode
    }
    set blendMode(t) {
        this.blurYFilter.blendMode = t
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(t) {
        this._repeatEdgePixels = t, this.updatePadding()
    }
}
var o9 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
class Zy extends rr {
    constructor() {
        const t = {
            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
            uAlpha: 1
        };
        super(M$, o9, t), this.alpha = 1
    }
    _loadMatrix(t, r = !1) {
        let n = t;
        r && (this._multiply(n, this.uniforms.m, t), n = this._colorMatrix(n)), this.uniforms.m = n
    }
    _multiply(t, r, n) {
        return t[0] = r[0] * n[0] + r[1] * n[5] + r[2] * n[10] + r[3] * n[15], t[1] = r[0] * n[1] + r[1] * n[6] + r[2] * n[11] + r[3] * n[16], t[2] = r[0] * n[2] + r[1] * n[7] + r[2] * n[12] + r[3] * n[17], t[3] = r[0] * n[3] + r[1] * n[8] + r[2] * n[13] + r[3] * n[18], t[4] = r[0] * n[4] + r[1] * n[9] + r[2] * n[14] + r[3] * n[19] + r[4], t[5] = r[5] * n[0] + r[6] * n[5] + r[7] * n[10] + r[8] * n[15], t[6] = r[5] * n[1] + r[6] * n[6] + r[7] * n[11] + r[8] * n[16], t[7] = r[5] * n[2] + r[6] * n[7] + r[7] * n[12] + r[8] * n[17], t[8] = r[5] * n[3] + r[6] * n[8] + r[7] * n[13] + r[8] * n[18], t[9] = r[5] * n[4] + r[6] * n[9] + r[7] * n[14] + r[8] * n[19] + r[9], t[10] = r[10] * n[0] + r[11] * n[5] + r[12] * n[10] + r[13] * n[15], t[11] = r[10] * n[1] + r[11] * n[6] + r[12] * n[11] + r[13] * n[16], t[12] = r[10] * n[2] + r[11] * n[7] + r[12] * n[12] + r[13] * n[17], t[13] = r[10] * n[3] + r[11] * n[8] + r[12] * n[13] + r[13] * n[18], t[14] = r[10] * n[4] + r[11] * n[9] + r[12] * n[14] + r[13] * n[19] + r[14], t[15] = r[15] * n[0] + r[16] * n[5] + r[17] * n[10] + r[18] * n[15], t[16] = r[15] * n[1] + r[16] * n[6] + r[17] * n[11] + r[18] * n[16], t[17] = r[15] * n[2] + r[16] * n[7] + r[17] * n[12] + r[18] * n[17], t[18] = r[15] * n[3] + r[16] * n[8] + r[17] * n[13] + r[18] * n[18], t[19] = r[15] * n[4] + r[16] * n[9] + r[17] * n[14] + r[18] * n[19] + r[19], t
    }
    _colorMatrix(t) {
        const r = new Float32Array(t);
        return r[4] /= 255, r[9] /= 255, r[14] /= 255, r[19] /= 255, r
    }
    brightness(t, r) {
        const n = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, r)
    }
    tint(t, r) {
        const [n, i, s] = ot.shared.setValue(t).toArray(), o = [n, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, s, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(o, r)
    }
    greyscale(t, r) {
        const n = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, r)
    }
    blackAndWhite(t) {
        const r = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    hue(t, r) {
        t = (t || 0) / 180 * Math.PI;
        const n = Math.cos(t),
            i = Math.sin(t),
            s = Math.sqrt,
            o = 1 / 3,
            a = s(o),
            l = n + (1 - n) * o,
            c = o * (1 - n) - a * i,
            u = o * (1 - n) + a * i,
            h = o * (1 - n) + a * i,
            d = n + o * (1 - n),
            f = o * (1 - n) - a * i,
            p = o * (1 - n) - a * i,
            m = o * (1 - n) + a * i,
            w = n + o * (1 - n),
            y = [l, c, u, 0, 0, h, d, f, 0, 0, p, m, w, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(y, r)
    }
    contrast(t, r) {
        const n = (t || 0) + 1,
            i = -.5 * (n - 1),
            s = [n, 0, 0, 0, i, 0, n, 0, 0, i, 0, 0, n, 0, i, 0, 0, 0, 1, 0];
        this._loadMatrix(s, r)
    }
    saturate(t = 0, r) {
        const n = t * 2 / 3 + 1,
            i = (n - 1) * -.5,
            s = [n, i, i, 0, 0, i, n, i, 0, 0, i, i, n, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, r)
    }
    desaturate() {
        this.saturate(-1)
    }
    negative(t) {
        const r = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    sepia(t) {
        const r = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    technicolor(t) {
        const r = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    polaroid(t) {
        const r = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    toBGR(t) {
        const r = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    kodachrome(t) {
        const r = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    browni(t) {
        const r = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    vintage(t) {
        const r = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    colorTone(t, r, n, i, s) {
        t = t || .2, r = r || .15, n = n || 16770432, i = i || 3375104;
        const o = ot.shared,
            [a, l, c] = o.setValue(n).toArray(),
            [u, h, d] = o.setValue(i).toArray(),
            f = [.3, .59, .11, 0, 0, a, l, c, t, 0, u, h, d, r, 0, a - u, l - h, c - d, 0, 0];
        this._loadMatrix(f, s)
    }
    night(t, r) {
        t = t || .1;
        const n = [t * -2, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, t * 2, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, r)
    }
    predator(t, r) {
        const n = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
        this._loadMatrix(n, r)
    }
    lsd(t) {
        const r = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, t)
    }
    reset() {
        const t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(t, !1)
    }
    get matrix() {
        return this.uniforms.m
    }
    set matrix(t) {
        this.uniforms.m = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
Zy.prototype.grayscale = Zy.prototype.greyscale;
var a9 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`,
    l9 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
class c9 extends rr {
    constructor(t, r) {
        const n = new mt;
        t.renderable = !1, super(l9, a9, {
            mapSampler: t._texture,
            filterMatrix: n,
            scale: {
                x: 1,
                y: 1
            },
            rotation: new Float32Array([1, 0, 0, 1])
        }), this.maskSprite = t, this.maskMatrix = n, r == null && (r = 20), this.scale = new Se(r, r)
    }
    apply(t, r, n, i) {
        this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
        const s = this.maskSprite.worldTransform,
            o = Math.sqrt(s.a * s.a + s.b * s.b),
            a = Math.sqrt(s.c * s.c + s.d * s.d);
        o !== 0 && a !== 0 && (this.uniforms.rotation[0] = s.a / o, this.uniforms.rotation[1] = s.b / o, this.uniforms.rotation[2] = s.c / a, this.uniforms.rotation[3] = s.d / a), t.applyFilter(this, r, n, i)
    }
    get map() {
        return this.uniforms.mapSampler
    }
    set map(t) {
        this.uniforms.mapSampler = t
    }
}
var u9 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`,
    h9 = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
class d9 extends rr {
    constructor() {
        super(h9, u9)
    }
}
var f9 = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
class p9 extends rr {
    constructor(t = .5, r = Math.random()) {
        super(M$, f9, {
            uNoise: 0,
            uSeed: 0
        }), this.noise = t, this.seed = r
    }
    get noise() {
        return this.uniforms.uNoise
    }
    set noise(t) {
        this.uniforms.uNoise = t
    }
    get seed() {
        return this.uniforms.uSeed
    }
    set seed(t) {
        this.uniforms.uSeed = t
    }
}
const cS = {
    AlphaFilter: Jj,
    BlurFilter: s9,
    BlurFilterPass: Qy,
    ColorMatrixFilter: Zy,
    DisplacementFilter: c9,
    FXAAFilter: d9,
    NoiseFilter: p9
};
Object.entries(cS).forEach(([e, t]) => {
    Object.defineProperty(cS, e, {
        get() {
            return ze("7.1.0", `filters.${e} has moved to ${e}`), t
        }
    })
});
class m9 {
    constructor() {
        this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this.tickerAdded = !1, this._pauseUpdate = !0
    }
    init(t) {
        this.removeTickerListener(), this.events = t, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this.tickerAdded = !1, this._pauseUpdate = !0
    }
    get pauseUpdate() {
        return this._pauseUpdate
    }
    set pauseUpdate(t) {
        this._pauseUpdate = t
    }
    addTickerListener() {
        this.tickerAdded || !this.domElement || (Jt.system.add(this.tickerUpdate, this, _o.INTERACTION), this.tickerAdded = !0)
    }
    removeTickerListener() {
        this.tickerAdded && (Jt.system.remove(this.tickerUpdate, this), this.tickerAdded = !1)
    }
    pointerMoved() {
        this._didMove = !0
    }
    update() {
        if (!this.domElement || this._pauseUpdate) return;
        if (this._didMove) {
            this._didMove = !1;
            return
        }
        const t = this.events.rootPointerEvent;
        this.events.supportsTouchEvents && t.pointerType === "touch" || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
            clientX: t.clientX,
            clientY: t.clientY
        }))
    }
    tickerUpdate(t) {
        this._deltaTime += t, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update())
    }
}
const es = new m9;
class Eu {
    constructor(t) {
        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = Eu.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new Se, this.page = new Se, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = t
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path
    }
    initEvent(t, r, n) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(t, r, n, i, s) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
class bf extends Eu {
    constructor() {
        super(...arguments), this.client = new Se, this.movement = new Se, this.offset = new Se, this.global = new Se, this.screen = new Se
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getLocalPosition(t, r, n) {
        return t.worldTransform.applyInverse(n || this.global, r)
    }
    getModifierState(t) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t)
    }
    initMouseEvent(t, r, n, i, s, o, a, l, c, u, h, d, f, p, m) {
        throw new Error("Method not implemented.")
    }
}
class Wr extends bf {
    constructor() {
        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1
    }
    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class Ja extends bf {
    constructor() {
        super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2
    }
}
Ja.DOM_DELTA_PIXEL = 0;
Ja.DOM_DELTA_LINE = 1;
Ja.DOM_DELTA_PAGE = 2;
const g9 = 2048,
    v9 = new Se,
    Vv = new Se;
class y9 {
    constructor(t) {
        this.dispatch = new go, this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {
            trackingData: {}
        }, this.eventPool = new Map, this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(t, r) {
        this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({
            fn: r,
            priority: 0
        }), this.mappingTable[t].sort((n, i) => n.priority - i.priority)
    }
    dispatchEvent(t, r) {
        t.propagationStopped = !1, t.propagationImmediatelyStopped = !1, this.propagate(t, r), this.dispatch.emit(r || t.type, t)
    }
    mapEvent(t) {
        if (!this.rootTarget) return;
        const r = this.mappingTable[t.type];
        if (r)
            for (let n = 0, i = r.length; n < i; n++) r[n].fn(t);
        else console.warn(`[EventBoundary]: Event mapping not defined for ${t.type}`)
    }
    hitTest(t, r) {
        es.pauseUpdate = !0;
        const i = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive",
            s = this[i](this.rootTarget, this.rootTarget.eventMode, v9.set(t, r), this.hitTestFn, this.hitPruneFn);
        return s && s[0]
    }
    propagate(t, r) {
        if (!t.target) return;
        const n = t.composedPath();
        t.eventPhase = t.CAPTURING_PHASE;
        for (let i = 0, s = n.length - 1; i < s; i++)
            if (t.currentTarget = n[i], this.notifyTarget(t, r), t.propagationStopped || t.propagationImmediatelyStopped) return;
        if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, r), !(t.propagationStopped || t.propagationImmediatelyStopped)) {
            t.eventPhase = t.BUBBLING_PHASE;
            for (let i = n.length - 2; i >= 0; i--)
                if (t.currentTarget = n[i], this.notifyTarget(t, r), t.propagationStopped || t.propagationImmediatelyStopped) return
        }
    }
    all(t, r, n = this._allInteractiveElements) {
        if (n.length === 0) return;
        t.eventPhase = t.BUBBLING_PHASE;
        const i = Array.isArray(r) ? r : [r];
        for (let s = n.length - 1; s >= 0; s--) i.forEach(o => {
            t.currentTarget = n[s], this.notifyTarget(t, o)
        })
    }
    propagationPath(t) {
        const r = [t];
        for (let n = 0; n < g9 && t !== this.rootTarget; n++) {
            if (!t.parent) throw new Error("Cannot find propagation path to disconnected target");
            r.push(t.parent), t = t.parent
        }
        return r.reverse(), r
    }
    hitTestMoveRecursive(t, r, n, i, s, o = !1) {
        let a = !1;
        if (this._interactivePrune(t)) return null;
        if ((t.eventMode === "dynamic" || r === "dynamic") && (es.pauseUpdate = !1), t.interactiveChildren && t.children) {
            const u = t.children;
            for (let h = u.length - 1; h >= 0; h--) {
                const d = u[h],
                    f = this.hitTestMoveRecursive(d, this._isInteractive(r) ? r : d.eventMode, n, i, s, o || s(t, n));
                if (f) {
                    if (f.length > 0 && !f[f.length - 1].parent) continue;
                    const p = t.isInteractive();
                    (f.length > 0 || p) && (p && this._allInteractiveElements.push(t), f.push(t)), this._hitElements.length === 0 && (this._hitElements = f), a = !0
                }
            }
        }
        const l = this._isInteractive(r),
            c = t.isInteractive();
        return c && c && this._allInteractiveElements.push(t), o || this._hitElements.length > 0 ? null : a ? this._hitElements : l && !s(t, n) && i(t, n) ? c ? [t] : [] : null
    }
    hitTestRecursive(t, r, n, i, s) {
        if (this._interactivePrune(t) || s(t, n)) return null;
        if ((t.eventMode === "dynamic" || r === "dynamic") && (es.pauseUpdate = !1), t.interactiveChildren && t.children) {
            const l = t.children;
            for (let c = l.length - 1; c >= 0; c--) {
                const u = l[c],
                    h = this.hitTestRecursive(u, this._isInteractive(r) ? r : u.eventMode, n, i, s);
                if (h) {
                    if (h.length > 0 && !h[h.length - 1].parent) continue;
                    const d = t.isInteractive();
                    return (h.length > 0 || d) && h.push(t), h
                }
            }
        }
        const o = this._isInteractive(r),
            a = t.isInteractive();
        return o && i(t, n) ? a ? [t] : [] : null
    }
    _isInteractive(t) {
        return t === "static" || t === "dynamic"
    }
    _interactivePrune(t) {
        return !!(!t || t.isMask || !t.visible || !t.renderable || t.eventMode === "none" || t.eventMode === "passive" && !t.interactiveChildren || t.isMask)
    }
    hitPruneFn(t, r) {
        var n;
        if (t.hitArea && (t.worldTransform.applyInverse(r, Vv), !t.hitArea.contains(Vv.x, Vv.y))) return !0;
        if (t._mask) {
            const i = t._mask.isMaskData ? t._mask.maskObject : t._mask;
            if (i && !((n = i.containsPoint) != null && n.call(i, r))) return !0
        }
        return !1
    }
    hitTestFn(t, r) {
        return t.eventMode === "passive" ? !1 : t.hitArea ? !0 : t.containsPoint ? t.containsPoint(r) : !1
    }
    notifyTarget(t, r) {
        var s, o;
        r = r??t.type;
        const n = `on${r}`;
        (o = (s = t.currentTarget)[n]) == null || o.call(s, t);
        const i = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${r}capture` : r;
        this.notifyListeners(t, i), t.eventPhase === t.AT_TARGET && this.notifyListeners(t, r)
    }
    mapPointerDown(t) {
        if (!(t instanceof Wr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = this.createPointerEvent(t);
        if (this.dispatchEvent(r, "pointerdown"), r.pointerType === "touch") this.dispatchEvent(r, "touchstart");
        else if (r.pointerType === "mouse" || r.pointerType === "pen") {
            const i = r.button === 2;
            this.dispatchEvent(r, i ? "rightdown" : "mousedown")
        }
        const n = this.trackingData(t.pointerId);
        n.pressTargetsByButton[t.button] = r.composedPath(), this.freeEvent(r)
    }
    mapPointerMove(t) {
        var l, c;
        if (!(t instanceof Wr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;
        const r = this.createPointerEvent(t);
        this._isPointerMoveEvent = !1;
        const n = r.pointerType === "mouse" || r.pointerType === "pen",
            i = this.trackingData(t.pointerId),
            s = this.findMountedTarget(i.overTargets);
        if (((l = i.overTargets) == null ? void 0 : l.length) > 0 && s !== r.target) {
            const u = t.type === "mousemove" ? "mouseout" : "pointerout",
                h = this.createPointerEvent(t, u, s);
            if (this.dispatchEvent(h, "pointerout"), n && this.dispatchEvent(h, "mouseout"), !r.composedPath().includes(s)) {
                const d = this.createPointerEvent(t, "pointerleave", s);
                for (d.eventPhase = d.AT_TARGET; d.target && !r.composedPath().includes(d.target);) d.currentTarget = d.target, this.notifyTarget(d), n && this.notifyTarget(d, "mouseleave"), d.target = d.target.parent;
                this.freeEvent(d)
            }
            this.freeEvent(h)
        }
        if (s !== r.target) {
            const u = t.type === "mousemove" ? "mouseover" : "pointerover",
                h = this.clonePointerEvent(r, u);
            this.dispatchEvent(h, "pointerover"), n && this.dispatchEvent(h, "mouseover");
            let d = s == null ? void 0 : s.parent;
            for (; d && d !== this.rootTarget.parent && d !== r.target;) d = d.parent;
            if (!d || d === this.rootTarget.parent) {
                const p = this.clonePointerEvent(r, "pointerenter");
                for (p.eventPhase = p.AT_TARGET; p.target && p.target !== s && p.target !== this.rootTarget.parent;) p.currentTarget = p.target, this.notifyTarget(p), n && this.notifyTarget(p, "mouseenter"), p.target = p.target.parent;
                this.freeEvent(p)
            }
            this.freeEvent(h)
        }
        const o = [],
            a = this.enableGlobalMoveEvents??!0;
        this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(r, "pointermove"), a && o.push("globalpointermove"), r.pointerType === "touch" && (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(r, "touchmove"), a && o.push("globaltouchmove")), n && (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(r, "mousemove"), a && o.push("globalmousemove"), this.cursor = (c = r.target) == null ? void 0 : c.cursor), o.length > 0 && this.all(r, o), this._allInteractiveElements.length = 0, this._hitElements.length = 0, i.overTargets = r.composedPath(), this.freeEvent(r)
    }
    mapPointerOver(t) {
        var o;
        if (!(t instanceof Wr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = this.trackingData(t.pointerId),
            n = this.createPointerEvent(t),
            i = n.pointerType === "mouse" || n.pointerType === "pen";
        this.dispatchEvent(n, "pointerover"), i && this.dispatchEvent(n, "mouseover"), n.pointerType === "mouse" && (this.cursor = (o = n.target) == null ? void 0 : o.cursor);
        const s = this.clonePointerEvent(n, "pointerenter");
        for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent;) s.currentTarget = s.target, this.notifyTarget(s), i && this.notifyTarget(s, "mouseenter"), s.target = s.target.parent;
        r.overTargets = n.composedPath(), this.freeEvent(n), this.freeEvent(s)
    }
    mapPointerOut(t) {
        if (!(t instanceof Wr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = this.trackingData(t.pointerId);
        if (r.overTargets) {
            const n = t.pointerType === "mouse" || t.pointerType === "pen",
                i = this.findMountedTarget(r.overTargets),
                s = this.createPointerEvent(t, "pointerout", i);
            this.dispatchEvent(s), n && this.dispatchEvent(s, "mouseout");
            const o = this.createPointerEvent(t, "pointerleave", i);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent;) o.currentTarget = o.target, this.notifyTarget(o), n && this.notifyTarget(o, "mouseleave"), o.target = o.target.parent;
            r.overTargets = null, this.freeEvent(s), this.freeEvent(o)
        }
        this.cursor = null
    }
    mapPointerUp(t) {
        if (!(t instanceof Wr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = performance.now(),
            n = this.createPointerEvent(t);
        if (this.dispatchEvent(n, "pointerup"), n.pointerType === "touch") this.dispatchEvent(n, "touchend");
        else if (n.pointerType === "mouse" || n.pointerType === "pen") {
            const a = n.button === 2;
            this.dispatchEvent(n, a ? "rightup" : "mouseup")
        }
        const i = this.trackingData(t.pointerId),
            s = this.findMountedTarget(i.pressTargetsByButton[t.button]);
        let o = s;
        if (s && !n.composedPath().includes(s)) {
            let a = s;
            for (; a && !n.composedPath().includes(a);) {
                if (n.currentTarget = a, this.notifyTarget(n, "pointerupoutside"), n.pointerType === "touch") this.notifyTarget(n, "touchendoutside");
                else if (n.pointerType === "mouse" || n.pointerType === "pen") {
                    const l = n.button === 2;
                    this.notifyTarget(n, l ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
            }
            delete i.pressTargetsByButton[t.button], o = a
        }
        if (o) {
            const a = this.clonePointerEvent(n, "click");
            a.target = o, a.path = null, i.clicksByButton[t.button] || (i.clicksByButton[t.button] = {
                clickCount: 0,
                target: a.target,
                timeStamp: r
            });
            const l = i.clicksByButton[t.button];
            if (l.target === a.target && r - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1, l.target = a.target, l.timeStamp = r, a.detail = l.clickCount, a.pointerType === "mouse") {
                const c = a.button === 2;
                this.dispatchEvent(a, c ? "rightclick" : "click")
            } else a.pointerType === "touch" && this.dispatchEvent(a, "tap");
            this.dispatchEvent(a, "pointertap"), this.freeEvent(a)
        }
        this.freeEvent(n)
    }
    mapPointerUpOutside(t) {
        if (!(t instanceof Wr)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const r = this.trackingData(t.pointerId),
            n = this.findMountedTarget(r.pressTargetsByButton[t.button]),
            i = this.createPointerEvent(t);
        if (n) {
            let s = n;
            for (; s;) i.currentTarget = s, this.notifyTarget(i, "pointerupoutside"), i.pointerType === "touch" ? this.notifyTarget(i, "touchendoutside") : (i.pointerType === "mouse" || i.pointerType === "pen") && this.notifyTarget(i, i.button === 2 ? "rightupoutside" : "mouseupoutside"), s = s.parent;
            delete r.pressTargetsByButton[t.button]
        }
        this.freeEvent(i)
    }
    mapWheel(t) {
        if (!(t instanceof Ja)) {
            console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const r = this.createWheelEvent(t);
        this.dispatchEvent(r), this.freeEvent(r)
    }
    findMountedTarget(t) {
        if (!t) return null;
        let r = t[0];
        for (let n = 1; n < t.length && t[n].parent === r; n++) r = t[n];
        return r
    }
    createPointerEvent(t, r, n) {
        const i = this.allocateEvent(Wr);
        return this.copyPointerData(t, i), this.copyMouseData(t, i), this.copyData(t, i), i.nativeEvent = t.nativeEvent, i.originalEvent = t, i.target = n??this.hitTest(i.global.x, i.global.y)??this._hitElements[0], typeof r == "string" && (i.type = r), i
    }
    createWheelEvent(t) {
        const r = this.allocateEvent(Ja);
        return this.copyWheelData(t, r), this.copyMouseData(t, r), this.copyData(t, r), r.nativeEvent = t.nativeEvent, r.originalEvent = t, r.target = this.hitTest(r.global.x, r.global.y), r
    }
    clonePointerEvent(t, r) {
        const n = this.allocateEvent(Wr);
        return n.nativeEvent = t.nativeEvent, n.originalEvent = t.originalEvent, this.copyPointerData(t, n), this.copyMouseData(t, n), this.copyData(t, n), n.target = t.target, n.path = t.composedPath().slice(), n.type = r??n.type, n
    }
    copyWheelData(t, r) {
        r.deltaMode = t.deltaMode, r.deltaX = t.deltaX, r.deltaY = t.deltaY, r.deltaZ = t.deltaZ
    }
    copyPointerData(t, r) {
        t instanceof Wr && r instanceof Wr && (r.pointerId = t.pointerId, r.width = t.width, r.height = t.height, r.isPrimary = t.isPrimary, r.pointerType = t.pointerType, r.pressure = t.pressure, r.tangentialPressure = t.tangentialPressure, r.tiltX = t.tiltX, r.tiltY = t.tiltY, r.twist = t.twist)
    }
    copyMouseData(t, r) {
        t instanceof bf && r instanceof bf && (r.altKey = t.altKey, r.button = t.button, r.buttons = t.buttons, r.client.copyFrom(t.client), r.ctrlKey = t.ctrlKey, r.metaKey = t.metaKey, r.movement.copyFrom(t.movement), r.screen.copyFrom(t.screen), r.shiftKey = t.shiftKey, r.global.copyFrom(t.global))
    }
    copyData(t, r) {
        r.isTrusted = t.isTrusted, r.srcElement = t.srcElement, r.timeStamp = performance.now(), r.type = t.type, r.detail = t.detail, r.view = t.view, r.which = t.which, r.layer.copyFrom(t.layer), r.page.copyFrom(t.page)
    }
    trackingData(t) {
        return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }), this.mappingState.trackingData[t]
    }
    allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, []);
        const r = this.eventPool.get(t).pop() || new t(this);
        return r.eventPhase = r.NONE, r.currentTarget = null, r.path = null, r.target = null, r
    }
    freeEvent(t) {
        if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const r = t.constructor;
        this.eventPool.has(r) || this.eventPool.set(r, []), this.eventPool.get(r).push(t)
    }
    notifyListeners(t, r) {
        const n = t.currentTarget._events[r];
        if (n && t.currentTarget.isInteractive())
            if ("fn" in n) n.once && t.currentTarget.removeListener(r, n.fn, void 0, !0), n.fn.call(n.context, t);
            else
                for (let i = 0, s = n.length; i < s && !t.propagationImmediatelyStopped; i++) n[i].once && t.currentTarget.removeListener(r, n[i].fn, void 0, !0), n[i].fn.call(n[i].context, t)
    }
}
const _9 = 1,
    w9 = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
    },
    Jy = class {
        constructor(e) {
            this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = e, this.rootBoundary = new y9(null), es.init(this), this.autoPreventDefault = !0, this.eventsAdded = !1, this.rootPointerEvent = new Wr(null), this.rootWheelEvent = new Ja(null), this.cursorStyles = {
                default: "inherit",
                pointer: "pointer"
            }, this.features = new Proxy({ ...Jy.defaultEventFeatures
            }, {
                set: (t, r, n) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = n), t[r] = n, !0)
            }), this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this)
        }
        static get defaultEventMode() {
            return this._defaultEventMode
        }
        init(e) {
            const {
                view: t,
                resolution: r
            } = this.renderer;
            this.setTargetElement(t), this.resolution = r, Jy._defaultEventMode = e.eventMode??"auto", Object.assign(this.features, e.eventFeatures??{}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
        }
        resolutionChange(e) {
            this.resolution = e
        }
        destroy() {
            this.setTargetElement(null), this.renderer = null
        }
        setCursor(e) {
            e = e || "default";
            let t = !0;
            if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (t = !1), this.currentCursor === e) return;
            this.currentCursor = e;
            const r = this.cursorStyles[e];
            if (r) switch (typeof r) {
                case "string":
                    t && (this.domElement.style.cursor = r);
                    break;
                case "function":
                    r(e);
                    break;
                case "object":
                    t && Object.assign(this.domElement.style, r);
                    break
            } else t && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e)
        }
        get pointer() {
            return this.rootPointerEvent
        }
        onPointerDown(e) {
            if (!this.features.click || (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && e.pointerType === "touch")) return;
            const t = this.normalizeToPointerData(e);
            this.autoPreventDefault && t[0].isNormalized && (e.cancelable || !("cancelable" in e)) && e.preventDefault();
            for (let r = 0, n = t.length; r < n; r++) {
                const i = t[r],
                    s = this.bootstrapEvent(this.rootPointerEvent, i);
                this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerMove(e) {
            if (!this.features.move || (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && e.pointerType === "touch")) return;
            es.pointerMoved();
            const t = this.normalizeToPointerData(e);
            for (let r = 0, n = t.length; r < n; r++) {
                const i = this.bootstrapEvent(this.rootPointerEvent, t[r]);
                this.rootBoundary.mapEvent(i)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerUp(e) {
            if (!this.features.click || (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && e.pointerType === "touch")) return;
            let t = e.target;
            e.composedPath && e.composedPath().length > 0 && (t = e.composedPath()[0]);
            const r = t !== this.domElement ? "outside" : "",
                n = this.normalizeToPointerData(e);
            for (let i = 0, s = n.length; i < s; i++) {
                const o = this.bootstrapEvent(this.rootPointerEvent, n[i]);
                o.type += r, this.rootBoundary.mapEvent(o)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerOverOut(e) {
            if (!this.features.click || (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && e.pointerType === "touch")) return;
            const t = this.normalizeToPointerData(e);
            for (let r = 0, n = t.length; r < n; r++) {
                const i = this.bootstrapEvent(this.rootPointerEvent, t[r]);
                this.rootBoundary.mapEvent(i)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onWheel(e) {
            if (!this.features.wheel) return;
            const t = this.normalizeWheelEvent(e);
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(t)
        }
        setTargetElement(e) {
            this.removeEvents(), this.domElement = e, es.domElement = e, this.addEvents()
        }
        addEvents() {
            if (this.eventsAdded || !this.domElement) return;
            es.addTickerListener();
            const e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0), this.domElement.addEventListener("pointerdown", this.onPointerDown, !0), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0), globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0), this.domElement.addEventListener("mousedown", this.onPointerDown, !0), this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0), globalThis.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0), this.domElement.addEventListener("touchend", this.onPointerUp, !0), this.domElement.addEventListener("touchmove", this.onPointerMove, !0)), this.domElement.addEventListener("wheel", this.onWheel, {
                passive: !0,
                capture: !0
            }), this.eventsAdded = !0
        }
        removeEvents() {
            if (!this.eventsAdded || !this.domElement) return;
            es.removeTickerListener();
            const e = this.domElement.style;
            globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0), this.domElement.removeEventListener("mousedown", this.onPointerDown, !0), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0), this.domElement.removeEventListener("touchend", this.onPointerUp, !0), this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1
        }
        mapPositionToPoint(e, t, r) {
            let n;
            this.domElement.parentElement ? n = this.domElement.getBoundingClientRect() : n = {
                x: 0,
                y: 0,
                width: this.domElement.width,
                height: this.domElement.height,
                left: 0,
                top: 0
            };
            const i = 1 / this.resolution;
            e.x = (t - n.left) * (this.domElement.width / n.width) * i, e.y = (r - n.top) * (this.domElement.height / n.height) * i
        }
        normalizeToPointerData(e) {
            const t = [];
            if (this.supportsTouchEvents && e instanceof TouchEvent)
                for (let r = 0, n = e.changedTouches.length; r < n; r++) {
                    const i = e.changedTouches[r];
                    typeof i.button > "u" && (i.button = 0), typeof i.buttons > "u" && (i.buttons = 1), typeof i.isPrimary > "u" && (i.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof i.width > "u" && (i.width = i.radiusX || 1), typeof i.height > "u" && (i.height = i.radiusY || 1), typeof i.tiltX > "u" && (i.tiltX = 0), typeof i.tiltY > "u" && (i.tiltY = 0), typeof i.pointerType > "u" && (i.pointerType = "touch"), typeof i.pointerId > "u" && (i.pointerId = i.identifier || 0), typeof i.pressure > "u" && (i.pressure = i.force || .5), typeof i.twist > "u" && (i.twist = 0), typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0), typeof i.layerX > "u" && (i.layerX = i.offsetX = i.clientX), typeof i.layerY > "u" && (i.layerY = i.offsetY = i.clientY), i.isNormalized = !0, i.type = e.type, t.push(i)
                } else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
                    const r = e;
                    typeof r.isPrimary > "u" && (r.isPrimary = !0), typeof r.width > "u" && (r.width = 1), typeof r.height > "u" && (r.height = 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "mouse"), typeof r.pointerId > "u" && (r.pointerId = _9), typeof r.pressure > "u" && (r.pressure = .5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), r.isNormalized = !0, t.push(r)
                } else t.push(e);
            return t
        }
        normalizeWheelEvent(e) {
            const t = this.rootWheelEvent;
            return this.transferMouseData(t, e), t.deltaX = e.deltaX, t.deltaY = e.deltaY, t.deltaZ = e.deltaZ, t.deltaMode = e.deltaMode, this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.nativeEvent = e, t.type = e.type, t
        }
        bootstrapEvent(e, t) {
            return e.originalEvent = null, e.nativeEvent = t, e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist, this.transferMouseData(e, t), this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.isTrusted = t.isTrusted, e.type === "pointerleave" && (e.type = "pointerout"), e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")), e.type.startsWith("touch") && (e.type = w9[e.type] || e.type), e
        }
        transferMouseData(e, t) {
            e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.x = t.clientX, e.client.y = t.clientY, e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.x = t.movementX, e.movement.y = t.movementY, e.page.x = t.pageX, e.page.y = t.pageY, e.relatedTarget = null, e.shiftKey = t.shiftKey
        }
    };
let ru = Jy;
ru.extension = {
    name: "events",
    type: [ue.RendererSystem, ue.CanvasRendererSystem]
};
ru.defaultEventFeatures = {
    move: !0,
    globalMove: !0,
    click: !0,
    wheel: !0
};
ye.add(ru);

function uS(e) {
    return e === "dynamic" || e === "static"
}
const b9 = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    _internalInteractive: void 0,
    get interactive() {
        return this._internalInteractive??uS(ru.defaultEventMode)
    },
    set interactive(e) {
        ze("7.2.0", "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."), this._internalInteractive = e, this.eventMode = e ? "static" : "auto"
    },
    _internalEventMode: void 0,
    get eventMode() {
        return this._internalEventMode??ru.defaultEventMode
    },
    set eventMode(e) {
        this._internalInteractive = uS(e), this._internalEventMode = e
    },
    isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic"
    },
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(e, t, r) {
        const n = typeof r == "boolean" && r || typeof r == "object" && r.capture,
            i = typeof t == "function" ? void 0 : t;
        e = n ? `${e}capture` : e, t = typeof t == "function" ? t : t.handleEvent, this.on(e, t, i)
    },
    removeEventListener(e, t, r) {
        const n = typeof r == "boolean" && r || typeof r == "object" && r.capture,
            i = typeof t == "function" ? void 0 : t;
        e = n ? `${e}capture` : e, t = typeof t == "function" ? t : t.handleEvent, this.off(e, t, i)
    },
    dispatchEvent(e) {
        if (!(e instanceof Eu)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return e.defaultPrevented = !1, e.path = null, e.target = this, e.manager.dispatchEvent(e), !e.defaultPrevented
    }
};
St.mixin(b9);
const x9 = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1
};
St.mixin(x9);
const E9 = 9,
    Th = 100,
    S9 = 0,
    P9 = 0,
    hS = 2,
    dS = 1,
    C9 = -1e3,
    T9 = -1e3,
    O9 = 2;
class j$ {
    constructor(t) {
        this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (xi.tablet || xi.phone) && this.createTouchHook();
        const r = document.createElement("div");
        r.style.width = `${Th}px`, r.style.height = `${Th}px`, r.style.position = "absolute", r.style.top = `${S9}px`, r.style.left = `${P9}px`, r.style.zIndex = hS.toString(), this.div = r, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)
    }
    get isActive() {
        return this._isActive
    }
    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }
    createTouchHook() {
        const t = document.createElement("button");
        t.style.width = `${dS}px`, t.style.height = `${dS}px`, t.style.position = "absolute", t.style.top = `${C9}px`, t.style.left = `${T9}px`, t.style.zIndex = O9.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => {
            this._isMobileAccessibility = !0, this.activate(), this.destroyTouchHook()
        }), document.body.appendChild(t), this._hookDiv = t
    }
    destroyTouchHook() {
        this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
    }
    activate() {
        var t;
        this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) == null || t.appendChild(this.div))
    }
    deactivate() {
        var t;
        !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) == null || t.removeChild(this.div))
    }
    updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren) return;
        t.accessible && t.isInteractive() && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
        const r = t.children;
        if (r)
            for (let n = 0; n < r.length; n++) this.updateAccessibleObjects(r[n])
    }
    update() {
        const t = performance.now();
        if (xi.android.device && t < this.androidUpdateCount || (this.androidUpdateCount = t + this.androidUpdateFrequency, !this.renderer.renderingToScreen)) return;
        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
        const {
            x: r,
            y: n,
            width: i,
            height: s
        } = this.renderer.view.getBoundingClientRect(), {
            width: o,
            height: a,
            resolution: l
        } = this.renderer, c = i / o * l, u = s / a * l;
        let h = this.div;
        h.style.left = `${r}px`, h.style.top = `${n}px`, h.style.width = `${o}px`, h.style.height = `${a}px`;
        for (let d = 0; d < this.children.length; d++) {
            const f = this.children[d];
            if (f.renderId !== this.renderId) f._accessibleActive = !1, Fa(this.children, d, 1), this.div.removeChild(f._accessibleDiv), this.pool.push(f._accessibleDiv), f._accessibleDiv = null, d--;
            else {
                h = f._accessibleDiv;
                let p = f.hitArea;
                const m = f.worldTransform;
                f.hitArea ? (h.style.left = `${(m.tx+p.x*m.a)*c}px`, h.style.top = `${(m.ty+p.y*m.d)*u}px`, h.style.width = `${p.width*m.a*c}px`, h.style.height = `${p.height*m.d*u}px`) : (p = f.getBounds(), this.capHitArea(p), h.style.left = `${p.x*c}px`, h.style.top = `${p.y*u}px`, h.style.width = `${p.width*c}px`, h.style.height = `${p.height*u}px`, h.title !== f.accessibleTitle && f.accessibleTitle !== null && (h.title = f.accessibleTitle), h.getAttribute("aria-label") !== f.accessibleHint && f.accessibleHint !== null && h.setAttribute("aria-label", f.accessibleHint)), (f.accessibleTitle !== h.title || f.tabIndex !== h.tabIndex) && (h.title = f.accessibleTitle, h.tabIndex = f.tabIndex, this.debug && this.updateDebugHTML(h))
            }
        }
        this.renderId++
    }
    updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
    }
    capHitArea(t) {
        t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
        const {
            width: r,
            height: n
        } = this.renderer;
        t.x + t.width > r && (t.width = r - t.x), t.y + t.height > n && (t.height = n - t.y)
    }
    addChild(t) {
        let r = this.pool.pop();
        r || (r = document.createElement("button"), r.style.width = `${Th}px`, r.style.height = `${Th}px`, r.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", r.style.position = "absolute", r.style.zIndex = hS.toString(), r.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? r.setAttribute("aria-live", "off") : r.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? r.setAttribute("aria-relevant", "additions") : r.setAttribute("aria-relevant", "text"), r.addEventListener("click", this._onClick.bind(this)), r.addEventListener("focus", this._onFocus.bind(this)), r.addEventListener("focusout", this._onFocusOut.bind(this))), r.style.pointerEvents = t.accessiblePointerEvents, r.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? r.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (r.title = `displayObject ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && r.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(r), t._accessibleActive = !0, t._accessibleDiv = r, r.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
    }
    _dispatchEvent(t, r) {
        const {
            displayObject: n
        } = t.target, i = this.renderer.events.rootBoundary, s = Object.assign(new Eu(i), {
            target: n
        });
        i.rootTarget = this.renderer.lastObjectRendered, r.forEach(o => i.dispatchEvent(s, o))
    }
    _onClick(t) {
        this._dispatchEvent(t, ["click", "pointertap", "tap"])
    }
    _onFocus(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, ["mouseover"])
    }
    _onFocusOut(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, ["mouseout"])
    }
    _onKeyDown(t) {
        t.keyCode === E9 && this.activate()
    }
    _onMouseMove(t) {
        t.movementX === 0 && t.movementY === 0 || this.deactivate()
    }
    destroy() {
        this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
    }
}
j$.extension = {
    name: "accessibility",
    type: [ue.RendererPlugin, ue.CanvasRendererPlugin]
};
ye.add(j$);
const e_ = class {
    constructor(e) {
        this.stage = new jr, e = Object.assign({
            forceCanvas: !1
        }, e), this.renderer = uj(e), e_._plugins.forEach(t => {
            t.init.call(this, e)
        })
    }
    render() {
        this.renderer.render(this.stage)
    }
    get view() {
        return this.renderer.view
    }
    get screen() {
        return this.renderer.screen
    }
    destroy(e, t) {
        const r = e_._plugins.slice(0);
        r.reverse(), r.forEach(n => {
            n.destroy.call(this)
        }), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null
    }
};
let ew = e_;
ew._plugins = [];
ye.handleByList(ue.Application, ew._plugins);
class U$ {
    static init(t) {
        Object.defineProperty(this, "resizeTo", {
            set(r) {
                globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = r, r && (globalThis.addEventListener("resize", this.queueResize), this.resize())
            },
            get() {
                return this._resizeTo
            }
        }), this.queueResize = () => {
            this._resizeTo && (this.cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()))
        }, this.cancelResize = () => {
            this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null)
        }, this.resize = () => {
            if (!this._resizeTo) return;
            this.cancelResize();
            let r, n;
            if (this._resizeTo === globalThis.window) r = globalThis.innerWidth, n = globalThis.innerHeight;
            else {
                const {
                    clientWidth: i,
                    clientHeight: s
                } = this._resizeTo;
                r = i, n = s
            }
            this.renderer.resize(r, n), this.render()
        }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
    }
}
U$.extension = ue.Application;
ye.add(U$);
const fS = {
    loader: ue.LoadParser,
    resolver: ue.ResolveParser,
    cache: ue.CacheParser,
    detection: ue.DetectionParser
};
ye.handle(ue.Asset, e => {
    const t = e.ref;
    Object.entries(fS).filter(([r]) => !!t[r]).forEach(([r, n]) => ye.add(Object.assign(t[r], {
        extension: t[r].extension??n
    })))
}, e => {
    const t = e.ref;
    Object.keys(fS).filter(r => !!t[r]).forEach(r => ye.remove(t[r]))
});
class A9 {
    constructor(t, r = !1) {
        this._loader = t, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = r
    }
    add(t) {
        t.forEach(r => {
            this._assetList.push(r)
        }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const t = [],
                r = Math.min(this._assetList.length, this._maxConcurrent);
            for (let n = 0; n < r; n++) t.push(this._assetList.pop());
            await this._loader.load(t), this._isLoading = !1, this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(t) {
        this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next())
    }
}

function Su(e, t) {
    if (Array.isArray(t)) {
        for (const r of t)
            if (e.startsWith(`data:${r}`)) return !0;
        return !1
    }
    return e.startsWith(`data:${t}`)
}

function To(e, t) {
    const r = e.split("?")[0],
        n = hr.extname(r).toLowerCase();
    return Array.isArray(t) ? t.includes(n) : n === t
}
const Si = (e, t) => (Array.isArray(e) || (e = [e]), t ? e.map(r => typeof r == "string" ? t(r) : r) : e),
    t_ = (e, t) => {
        const r = t.split("?")[1];
        return r && (e += `?${r}`), e
    };

function H$(e, t, r, n, i) {
    const s = t[r];
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        r < t.length - 1 ? H$(e.replace(n[r], a), t, r + 1, n, i) : i.push(e.replace(n[r], a))
    }
}

function I9(e) {
    const t = /\{(.*?)\}/g,
        r = e.match(t),
        n = [];
    if (r) {
        const i = [];
        r.forEach(s => {
            const o = s.substring(1, s.length - 1).split(",");
            i.push(o)
        }), H$(e, i, 0, r, n)
    } else n.push(e);
    return n
}
const xf = e => !Array.isArray(e);
class $9 {
    constructor() {
        this._parsers = [], this._cache = new Map, this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(), this._cache.clear()
    }
    has(t) {
        return this._cache.has(t)
    }
    get(t) {
        const r = this._cache.get(t);
        return r || console.warn(`[Assets] Asset id ${t} was not found in the Cache`), r
    }
    set(t, r) {
        const n = Si(t);
        let i;
        for (let a = 0; a < this.parsers.length; a++) {
            const l = this.parsers[a];
            if (l.test(r)) {
                i = l.getCacheableAssets(n, r);
                break
            }
        }
        i || (i = {}, n.forEach(a => {
            i[a] = r
        }));
        const s = Object.keys(i),
            o = {
                cacheKeys: s,
                keys: n
            };
        if (n.forEach(a => {
                this._cacheMap.set(a, o)
            }), s.forEach(a => {
                this._cache.has(a) && this._cache.get(a) !== r && console.warn("[Cache] already has key:", a), this._cache.set(a, i[a])
            }), r instanceof ge) {
            const a = r;
            n.forEach(l => {
                a.baseTexture !== ge.EMPTY.baseTexture && Oe.addToCache(a.baseTexture, l), ge.addToCache(a, l)
            })
        }
    }
    remove(t) {
        if (this._cacheMap.get(t), !this._cacheMap.has(t)) {
            console.warn(`[Assets] Asset id ${t} was not found in the Cache`);
            return
        }
        const r = this._cacheMap.get(t);
        r.cacheKeys.forEach(i => {
            this._cache.delete(i)
        }), r.keys.forEach(i => {
            this._cacheMap.delete(i)
        })
    }
    get parsers() {
        return this._parsers
    }
}
const Wl = new $9;
let R9 = class {
    constructor() {
        this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
            set: (t, r, n) => (this._parsersValidated = !1, t[r] = n, !0)
        }), this.promiseCache = {}
    }
    reset() {
        this._parsersValidated = !1, this.promiseCache = {}
    }
    _getLoadPromiseAndParser(t, r) {
        const n = {
            promise: null,
            parser: null
        };
        return n.promise = (async () => {
            var o, a;
            let i = null,
                s = null;
            if (r.loadParser && (s = this._parserHash[r.loadParser], s || console.warn(`[Assets] specified load parser "${r.loadParser}" not found while loading ${t}`)), !s) {
                for (let l = 0; l < this.parsers.length; l++) {
                    const c = this.parsers[l];
                    if (c.load && ((o = c.test) != null && o.call(c, t, r, this))) {
                        s = c;
                        break
                    }
                }
                if (!s) return console.warn(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null
            }
            i = await s.load(t, r, this), n.parser = s;
            for (let l = 0; l < this.parsers.length; l++) {
                const c = this.parsers[l];
                c.parse && c.parse && await ((a = c.testParse) == null ? void 0 : a.call(c, i, r, this)) && (i = await c.parse(i, r, this) || i, n.parser = c)
            }
            return i
        })(), n
    }
    async load(t, r) {
        this._parsersValidated || this._validateParsers();
        let n = 0;
        const i = {},
            s = xf(t),
            o = Si(t, c => ({
                src: c
            })),
            a = o.length,
            l = o.map(async c => {
                const u = hr.toAbsolute(c.src);
                if (!i[c.src]) try {
                    this.promiseCache[u] || (this.promiseCache[u] = this._getLoadPromiseAndParser(u, c)), i[c.src] = await this.promiseCache[u].promise, r && r(++n / a)
                } catch (h) {
                    throw delete this.promiseCache[u], delete i[c.src], new Error(`[Loader.load] Failed to load ${u}.
${h}`)
                }
            });
        return await Promise.all(l), s ? i[o[0].src] : i
    }
    async unload(t) {
        const n = Si(t, i => ({
            src: i
        })).map(async i => {
            var a, l;
            const s = hr.toAbsolute(i.src),
                o = this.promiseCache[s];
            if (o) {
                const c = await o.promise;
                (l = (a = o.parser) == null ? void 0 : a.unload) == null || l.call(a, c, i, this), delete this.promiseCache[s]
            }
        });
        await Promise.all(n)
    }
    _validateParsers() {
        this._parsersValidated = !0, this._parserHash = this._parsers.filter(t => t.name).reduce((t, r) => (t[r.name] && console.warn(`[Assets] loadParser name conflict "${r.name}"`), { ...t,
            [r.name]: r
        }), {})
    }
};
var ai = (e => (e[e.Low = 0] = "Low", e[e.Normal = 1] = "Normal", e[e.High = 2] = "High", e))(ai || {});
const k9 = ".json",
    M9 = "application/json",
    D9 = {
        extension: {
            type: ue.LoadParser,
            priority: ai.Low
        },
        name: "loadJson",
        test(e) {
            return Su(e, M9) || To(e, k9)
        },
        async load(e) {
            return await (await ce.ADAPTER.fetch(e)).json()
        }
    };
ye.add(D9);
const N9 = ".txt",
    L9 = "text/plain",
    F9 = {
        name: "loadTxt",
        extension: {
            type: ue.LoadParser,
            priority: ai.Low
        },
        test(e) {
            return Su(e, L9) || To(e, N9)
        },
        async load(e) {
            return await (await ce.ADAPTER.fetch(e)).text()
        }
    };
ye.add(F9);
const B9 = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
    z9 = [".ttf", ".otf", ".woff", ".woff2"],
    j9 = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
    U9 = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;

function H9(e) {
    const t = hr.extname(e),
        i = hr.basename(e, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(a => a.charAt(0).toUpperCase() + a.slice(1));
    let s = i.length > 0;
    for (const a of i)
        if (!a.match(U9)) {
            s = !1;
            break
        }
    let o = i.join(" ");
    return s || (o = `"${o.replace(/[\\"]/g,"\\$&")}"`), o
}
const G9 = {
    extension: {
        type: ue.LoadParser,
        priority: ai.Low
    },
    name: "loadWebFont",
    test(e) {
        return Su(e, j9) || To(e, z9)
    },
    async load(e, t) {
        var n, i, s;
        const r = ce.ADAPTER.getFontFaceSet();
        if (r) {
            const o = [],
                a = ((n = t.data) == null ? void 0 : n.family)??H9(e),
                l = ((s = (i = t.data) == null ? void 0 : i.weights) == null ? void 0 : s.filter(u => B9.includes(u)))??["normal"],
                c = t.data??{};
            for (let u = 0; u < l.length; u++) {
                const h = l[u],
                    d = new FontFace(a, `url(${encodeURI(e)})`, { ...c,
                        weight: h
                    });
                await d.load(), r.add(d), o.push(d)
            }
            return o.length === 1 ? o[0] : o
        }
        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null
    },
    unload(e) {
        (Array.isArray(e) ? e : [e]).forEach(t => ce.ADAPTER.getFontFaceSet().delete(t))
    }
};
ye.add(G9);
let pS = 0,
    Wv;
const V9 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=",
    W9 = {
        id: "checkImageBitmap",
        code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${V9}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
    },
    X9 = {
        id: "loadImageBitmap",
        code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
    };
let Xv;
class Y9 {
    constructor() {
        this._initialized = !1, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {}
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(t => {
            const r = URL.createObjectURL(new Blob([W9.code], {
                    type: "application/javascript"
                })),
                n = new Worker(r);
            n.addEventListener("message", i => {
                n.terminate(), URL.revokeObjectURL(r), t(i.data)
            })
        }), this._isImageBitmapSupported)
    }
    loadImageBitmap(t) {
        return this._run("loadImageBitmap", [t])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    getWorker() {
        Wv === void 0 && (Wv = navigator.hardwareConcurrency || 4);
        let t = this.workerPool.pop();
        return !t && this._createdWorkers < Wv && (Xv || (Xv = URL.createObjectURL(new Blob([X9.code], {
            type: "application/javascript"
        }))), this._createdWorkers++, t = new Worker(Xv), t.addEventListener("message", r => {
            this.complete(r.data), this.returnWorker(r.target), this.next()
        })), t
    }
    returnWorker(t) {
        this.workerPool.push(t)
    }
    complete(t) {
        t.error !== void 0 ? this.resolveHash[t.uuid].reject(t.error) : this.resolveHash[t.uuid].resolve(t.data), this.resolveHash[t.uuid] = null
    }
    async _run(t, r) {
        await this._initWorkers();
        const n = new Promise((i, s) => {
            this.queue.push({
                id: t,
                arguments: r,
                resolve: i,
                reject: s
            })
        });
        return this.next(), n
    }
    next() {
        if (!this.queue.length) return;
        const t = this.getWorker();
        if (!t) return;
        const r = this.queue.pop(),
            n = r.id;
        this.resolveHash[pS] = {
            resolve: r.resolve,
            reject: r.reject
        }, t.postMessage({
            data: r.arguments,
            uuid: pS++,
            id: n
        })
    }
}
const mS = new Y9;

function Bm(e, t, r) {
    const n = new ge(e);
    return n.baseTexture.on("dispose", () => {
        delete t.promiseCache[r]
    }), n
}
const K9 = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
    q9 = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function Q9(e) {
    const t = await ce.ADAPTER.fetch(e);
    if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${t.status} ${t.statusText}`);
    const r = await t.blob();
    return await createImageBitmap(r)
}
const zm = {
    name: "loadTextures",
    extension: {
        type: ue.LoadParser,
        priority: ai.High
    },
    config: {
        preferWorkers: !0,
        preferCreateImageBitmap: !0,
        crossOrigin: "anonymous"
    },
    test(e) {
        return Su(e, q9) || To(e, K9)
    },
    async load(e, t, r) {
        let n = null;
        globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await mS.isImageBitmapSupported() ? n = await mS.loadImageBitmap(e) : n = await Q9(e) : n = await new Promise(s => {
            n = new Image, n.crossOrigin = this.config.crossOrigin, n.src = e, n.complete ? s(n) : n.onload = () => {
                s(n)
            }
        });
        const i = new Oe(n, {
            resolution: Ss(e),
            ...t.data
        });
        return i.resource.src = e, Bm(i, r, e)
    },
    unload(e) {
        e.destroy(!0)
    }
};
ye.add(zm);
const Z9 = ".svg",
    J9 = "image/svg+xml",
    eU = {
        extension: {
            type: ue.LoadParser,
            priority: ai.High
        },
        name: "loadSVG",
        test(e) {
            return Su(e, J9) || To(e, Z9)
        },
        async testParse(e) {
            return tu.test(e)
        },
        async parse(e, t, r) {
            var o;
            const n = new tu(e, (o = t == null ? void 0 : t.data) == null ? void 0 : o.resourceOptions);
            await n.load();
            const i = new Oe(n, {
                resolution: Ss(e),
                ...t == null ? void 0 : t.data
            });
            return i.resource.src = e, Bm(i, r, e)
        },
        async load(e, t) {
            return (await ce.ADAPTER.fetch(e)).text()
        },
        unload: zm.unload
    };
ye.add(eU);
class tU {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (t, r) => `${t}${this._bundleIdConnector}${r}`,
            extractAssetIdFromBundle: (t, r) => r.replace(`${t}${this._bundleIdConnector}`, "")
        }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {}
    }
    setBundleIdentifier(t) {
        if (this._bundleIdConnector = t.connector??this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId??this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle??this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...t) {
        t.forEach(r => {
            this._preferredOrder.push(r), r.priority || (r.priority = Object.keys(r.params))
        }), this._resolverHash = {}
    }
    set basePath(t) {
        this._basePath = t
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(t) {
        this._rootPath = t
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null
    }
    setDefaultSearchParams(t) {
        if (typeof t == "string") this._defaultSearchParams = t;
        else {
            const r = t;
            this._defaultSearchParams = Object.keys(r).map(n => `${encodeURIComponent(n)}=${encodeURIComponent(r[n])}`).join("&")
        }
    }
    addManifest(t) {
        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach(r => {
            this.addBundle(r.name, r.assets)
        })
    }
    addBundle(t, r) {
        const n = [];
        Array.isArray(r) ? r.forEach(i => {
            if (typeof i.name == "string") {
                const s = this._createBundleAssetId(t, i.name);
                n.push(s), this.add([i.name, s], i.srcs, i.data)
            } else {
                const s = i.name.map(o => this._createBundleAssetId(t, o));
                s.forEach(o => {
                    n.push(o)
                }), this.add([...i.name, ...s], i.srcs)
            }
        }) : Object.keys(r).forEach(i => {
            n.push(this._createBundleAssetId(t, i)), this.add([i, this._createBundleAssetId(t, i)], r[i])
        }), this._bundles[t] = n
    }
    add(t, r, n) {
        const i = Si(t);
        i.forEach(o => {
            this.hasKey(o) && console.warn(`[Resolver] already has key: ${o} overwriting`)
        }), Array.isArray(r) || (typeof r == "string" ? r = I9(r) : r = [r]);
        const s = r.map(o => {
            let a = o;
            if (typeof o == "string") {
                let l = !1;
                for (let c = 0; c < this._parsers.length; c++) {
                    const u = this._parsers[c];
                    if (u.test(o)) {
                        a = u.parse(o), l = !0;
                        break
                    }
                }
                l || (a = {
                    src: o
                })
            }
            return a.format || (a.format = a.src.split(".").pop()), a.alias || (a.alias = i), (this._basePath || this._rootPath) && (a.src = hr.toAbsolute(a.src, this._basePath, this._rootPath)), a.src = this._appendDefaultSearchParams(a.src), a.data = a.data??n, a
        });
        i.forEach(o => {
            this._assetMap[o] = s
        })
    }
    resolveBundle(t) {
        const r = xf(t);
        t = Si(t);
        const n = {};
        return t.forEach(i => {
            const s = this._bundles[i];
            if (s) {
                const o = this.resolve(s),
                    a = {};
                for (const l in o) {
                    const c = o[l];
                    a[this._extractAssetIdFromBundle(i, l)] = c
                }
                n[i] = a
            }
        }), r ? n[t[0]] : n
    }
    resolveUrl(t) {
        const r = this.resolve(t);
        if (typeof t != "string") {
            const n = {};
            for (const i in r) n[i] = r[i].src;
            return n
        }
        return r.src
    }
    resolve(t) {
        const r = xf(t);
        t = Si(t);
        const n = {};
        return t.forEach(i => {
            if (!this._resolverHash[i])
                if (this._assetMap[i]) {
                    let s = this._assetMap[i];
                    const o = this._getPreferredOrder(s),
                        a = s[0];
                    o == null || o.priority.forEach(l => {
                        o.params[l].forEach(c => {
                            const u = s.filter(h => h[l] ? h[l] === c : !1);
                            u.length && (s = u)
                        })
                    }), this._resolverHash[i] = s[0]??a
                } else {
                    let s = i;
                    (this._basePath || this._rootPath) && (s = hr.toAbsolute(s, this._basePath, this._rootPath)), s = this._appendDefaultSearchParams(s), this._resolverHash[i] = {
                        src: s
                    }
                }
            n[i] = this._resolverHash[i]
        }), r ? n[t[0]] : n
    }
    hasKey(t) {
        return !!this._assetMap[t]
    }
    hasBundle(t) {
        return !!this._bundles[t]
    }
    _getPreferredOrder(t) {
        for (let r = 0; r < t.length; r++) {
            const n = t[0],
                i = this._preferredOrder.find(s => s.params.format.includes(n.format));
            if (i) return i
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams) return t;
        const r = /\?/.test(t) ? "&" : "?";
        return `${t}${r}${this._defaultSearchParams}`
    }
}
class rU {
    constructor() {
        this._detections = [], this._initialized = !1, this.resolver = new tU, this.loader = new R9, this.cache = Wl, this._backgroundLoader = new A9(this.loader), this._backgroundLoader.active = !0, this.reset()
    }
    async init(t = {}) {
        var s, o, a;
        if (this._initialized) {
            console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
            return
        }
        if (this._initialized = !0, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
            let l = t.manifest;
            typeof l == "string" && (l = await this.load(l)), this.resolver.addManifest(l)
        }
        const r = ((s = t.texturePreference) == null ? void 0 : s.resolution)??1,
            n = typeof r == "number" ? [r] : r;
        let i = [];
        if ((o = t.texturePreference) != null && o.format) {
            const l = (a = t.texturePreference) == null ? void 0 : a.format;
            i = typeof l == "string" ? [l] : l;
            for (const c of this._detections) await c.test() || (i = await c.remove(i))
        } else
            for (const l of this._detections) await l.test() && (i = await l.add(i));
        this.resolver.prefer({
            params: {
                format: i,
                resolution: n
            }
        }), t.preferences && this.setPreferences(t.preferences)
    }
    add(t, r, n) {
        this.resolver.add(t, r, n)
    }
    async load(t, r) {
        this._initialized || await this.init();
        const n = xf(t),
            i = Si(t).map(a => typeof a != "string" ? (this.resolver.add(a.src, a), a.src) : (this.resolver.hasKey(a) || this.resolver.add(a, a), a)),
            s = this.resolver.resolve(i),
            o = await this._mapLoadToResolve(s, r);
        return n ? o[i[0]] : o
    }
    addBundle(t, r) {
        this.resolver.addBundle(t, r)
    }
    async loadBundle(t, r) {
        this._initialized || await this.init();
        let n = !1;
        typeof t == "string" && (n = !0, t = [t]);
        const i = this.resolver.resolveBundle(t),
            s = {},
            o = Object.keys(i);
        let a = 0,
            l = 0;
        const c = () => {
                r == null || r(++a / l)
            },
            u = o.map(h => {
                const d = i[h];
                return l += Object.keys(d).length, this._mapLoadToResolve(d, c).then(f => {
                    s[h] = f
                })
            });
        return await Promise.all(u), n ? s[t[0]] : s
    }
    async backgroundLoad(t) {
        this._initialized || await this.init(), typeof t == "string" && (t = [t]);
        const r = this.resolver.resolve(t);
        this._backgroundLoader.add(Object.values(r))
    }
    async backgroundLoadBundle(t) {
        this._initialized || await this.init(), typeof t == "string" && (t = [t]);
        const r = this.resolver.resolveBundle(t);
        Object.values(r).forEach(n => {
            this._backgroundLoader.add(Object.values(n))
        })
    }
    reset() {
        this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1
    }
    get(t) {
        if (typeof t == "string") return Wl.get(t);
        const r = {};
        for (let n = 0; n < t.length; n++) r[n] = Wl.get(t[n]);
        return r
    }
    async _mapLoadToResolve(t, r) {
        const n = Object.values(t),
            i = Object.keys(t);
        this._backgroundLoader.active = !1;
        const s = await this.loader.load(n, r);
        this._backgroundLoader.active = !0;
        const o = {};
        return n.forEach((a, l) => {
            const c = s[a.src],
                u = [a.src];
            a.alias && u.push(...a.alias), o[i[l]] = c, Wl.set(u, c)
        }), o
    }
    async unload(t) {
        this._initialized || await this.init();
        const r = Si(t).map(i => typeof i != "string" ? i.src : i),
            n = this.resolver.resolve(r);
        await this._unloadFromResolved(n)
    }
    async unloadBundle(t) {
        this._initialized || await this.init(), t = Si(t);
        const r = this.resolver.resolveBundle(t),
            n = Object.keys(r).map(i => this._unloadFromResolved(r[i]));
        await Promise.all(n)
    }
    async _unloadFromResolved(t) {
        const r = Object.values(t);
        r.forEach(n => {
            Wl.remove(n.src)
        }), await this.loader.unload(r)
    }
    get detections() {
        return this._detections
    }
    get preferWorkers() {
        return zm.config.preferWorkers
    }
    set preferWorkers(t) {
        ze("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."), this.setPreferences({
            preferWorkers: t
        })
    }
    setPreferences(t) {
        this.loader.parsers.forEach(r => {
            r.config && Object.keys(r.config).filter(n => n in t).forEach(n => {
                r.config[n] = t[n]
            })
        })
    }
}
const Oh = new rU;
ye.handleByList(ue.LoadParser, Oh.loader.parsers).handleByList(ue.ResolveParser, Oh.resolver.parsers).handleByList(ue.CacheParser, Oh.cache.parsers).handleByList(ue.DetectionParser, Oh.detections);
const nU = {
    extension: ue.CacheParser,
    test: e => Array.isArray(e) && e.every(t => t instanceof ge),
    getCacheableAssets: (e, t) => {
        const r = {};
        return e.forEach(n => {
            t.forEach((i, s) => {
                r[n + (s === 0 ? "" : s + 1)] = i
            })
        }), r
    }
};
ye.add(nU);
const iU = {
    extension: {
        type: ue.DetectionParser,
        priority: 1
    },
    test: async () => {
        if (!globalThis.createImageBitmap) return !1;
        const e = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=",
            t = await ce.ADAPTER.fetch(e).then(r => r.blob());
        return createImageBitmap(t).then(() => !0, () => !1)
    },
    add: async e => [...e, "avif"],
    remove: async e => e.filter(t => t !== "avif")
};
ye.add(iU);
const sU = {
    extension: {
        type: ue.DetectionParser,
        priority: 0
    },
    test: async () => {
        if (!globalThis.createImageBitmap) return !1;
        const e = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=",
            t = await ce.ADAPTER.fetch(e).then(r => r.blob());
        return createImageBitmap(t).then(() => !0, () => !1)
    },
    add: async e => [...e, "webp"],
    remove: async e => e.filter(t => t !== "webp")
};
ye.add(sU);
const gS = ["png", "jpg", "jpeg"],
    oU = {
        extension: {
            type: ue.DetectionParser,
            priority: -1
        },
        test: () => Promise.resolve(!0),
        add: async e => [...e, ...gS],
        remove: async e => e.filter(t => !gS.includes(t))
    };
ye.add(oU);
const aU = {
    extension: ue.ResolveParser,
    test: zm.test,
    parse: e => {
        var t;
        return {
            resolution: parseFloat(((t = ce.RETINA_PREFIX.exec(e)) == null ? void 0 : t[1])??"1"),
            format: e.split(".").pop(),
            src: e
        }
    }
};
ye.add(aU);
var Rr = (e => (e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e))(Rr || {});
const Ef = {
    [33776]: .5,
    [33777]: .5,
    [33778]: 1,
    [33779]: 1,
    [35916]: .5,
    [35917]: .5,
    [35918]: 1,
    [35919]: 1,
    [37488]: .5,
    [37489]: .5,
    [37490]: 1,
    [37491]: 1,
    [37492]: .5,
    [37496]: 1,
    [37493]: .5,
    [37497]: 1,
    [37494]: .5,
    [37495]: .5,
    [35840]: .5,
    [35842]: .5,
    [35841]: .25,
    [35843]: .25,
    [36196]: .5,
    [35986]: .5,
    [35986]: 1,
    [34798]: 1,
    [37808]: 1
};
let fi, la;

function vS() {
    la = {
        s3tc: fi.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: fi.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: fi.getExtension("WEBGL_compressed_texture_etc"),
        etc1: fi.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: fi.getExtension("WEBGL_compressed_texture_pvrtc") || fi.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: fi.getExtension("WEBGL_compressed_texture_atc"),
        astc: fi.getExtension("WEBGL_compressed_texture_astc")
    }
}
const lU = {
    extension: {
        type: ue.DetectionParser,
        priority: 2
    },
    test: async () => {
        const t = ce.ADAPTER.createCanvas().getContext("webgl");
        return t ? (fi = t, !0) : (console.warn("WebGL not available for compressed textures."), !1)
    },
    add: async e => {
        la || vS();
        const t = [];
        for (const r in la) la[r] && t.push(r);
        return [...t, ...e]
    },
    remove: async e => (la || vS(), e.filter(t => !(t in la)))
};
ye.add(lU);
class cU extends xu {
    constructor(t, r = {
        width: 1,
        height: 1,
        autoLoad: !0
    }) {
        let n, i;
        typeof t == "string" ? (n = t, i = new Uint8Array) : (n = null, i = t), super(i, r), this.origin = n, this.buffer = i ? new jy(i) : null, this._load = null, this.loaded = !1, this.origin !== null && r.autoLoad !== !1 && this.load(), this.origin === null && this.buffer && (this._load = Promise.resolve(this), this.loaded = !0, this.onBlobLoaded(this.buffer.rawBinaryData))
    }
    onBlobLoaded(t) {}
    load() {
        return this._load ? this._load : (this._load = fetch(this.origin).then(t => t.blob()).then(t => t.arrayBuffer()).then(t => (this.data = new Uint32Array(t), this.buffer = new jy(t), this.loaded = !0, this.onBlobLoaded(t), this.update(), this)), this._load)
    }
}
class oo extends cU {
    constructor(t, r) {
        super(t, r), this.format = r.format, this.levels = r.levels || 1, this._width = r.width, this._height = r.height, this._extension = oo._formatToExtension(this.format), (r.levelBuffers || this.buffer) && (this._levelBuffers = r.levelBuffers || oo._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
    }
    upload(t, r, n) {
        const i = t.gl;
        if (!t.context.extensions[this._extension]) throw new Error(`${this._extension} textures are not supported on the current machine`);
        if (!this._levelBuffers) return !1;
        for (let o = 0, a = this.levels; o < a; o++) {
            const {
                levelID: l,
                levelWidth: c,
                levelHeight: u,
                levelBuffer: h
            } = this._levelBuffers[o];
            i.compressedTexImage2D(i.TEXTURE_2D, l, this.format, c, u, 0, h)
        }
        return !0
    }
    onBlobLoaded() {
        this._levelBuffers = oo._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
    }
    static _formatToExtension(t) {
        if (t >= 33776 && t <= 33779) return "s3tc";
        if (t >= 37488 && t <= 37497) return "etc";
        if (t >= 35840 && t <= 35843) return "pvrtc";
        if (t >= 36196) return "etc1";
        if (t >= 35986 && t <= 34798) return "atc";
        throw new Error("Invalid (compressed) texture format given!")
    }
    static _createLevelBuffers(t, r, n, i, s, o, a) {
        const l = new Array(n);
        let c = t.byteOffset,
            u = o,
            h = a,
            d = u + i - 1 & ~(i - 1),
            f = h + s - 1 & ~(s - 1),
            p = d * f * Ef[r];
        for (let m = 0; m < n; m++) l[m] = {
            levelID: m,
            levelWidth: n > 1 ? u : d,
            levelHeight: n > 1 ? h : f,
            levelBuffer: new Uint8Array(t.buffer, c, p)
        }, c += p, u = u >> 1 || 1, h = h >> 1 || 1, d = u + i - 1 & ~(i - 1), f = h + s - 1 & ~(s - 1), p = d * f * Ef[r];
        return l
    }
}
const Yv = 4,
    Ah = 124,
    uU = 32,
    yS = 20,
    hU = 542327876,
    Ih = {
        SIZE: 1,
        FLAGS: 2,
        HEIGHT: 3,
        WIDTH: 4,
        MIPMAP_COUNT: 7,
        PIXEL_FORMAT: 19
    },
    dU = {
        SIZE: 0,
        FLAGS: 1,
        FOURCC: 2,
        RGB_BITCOUNT: 3,
        R_BIT_MASK: 4,
        G_BIT_MASK: 5,
        B_BIT_MASK: 6,
        A_BIT_MASK: 7
    },
    $h = {
        DXGI_FORMAT: 0,
        RESOURCE_DIMENSION: 1,
        MISC_FLAG: 2,
        ARRAY_SIZE: 3,
        MISC_FLAGS2: 4
    },
    fU = 1,
    pU = 2,
    mU = 4,
    gU = 64,
    vU = 512,
    yU = 131072,
    _U = 827611204,
    wU = 861165636,
    bU = 894720068,
    xU = 808540228,
    EU = 4,
    SU = {
        [_U]: Rr.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [wU]: Rr.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [bU]: Rr.COMPRESSED_RGBA_S3TC_DXT5_EXT
    },
    PU = {
        [70]: Rr.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [71]: Rr.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [73]: Rr.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [74]: Rr.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [76]: Rr.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        [77]: Rr.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        [72]: Rr.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        [75]: Rr.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        [78]: Rr.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    };

function CU(e) {
    const t = new Uint32Array(e);
    if (t[0] !== hU) throw new Error("Invalid DDS file magic word");
    const n = new Uint32Array(e, 0, Ah / Uint32Array.BYTES_PER_ELEMENT),
        i = n[Ih.HEIGHT],
        s = n[Ih.WIDTH],
        o = n[Ih.MIPMAP_COUNT],
        a = new Uint32Array(e, Ih.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, uU / Uint32Array.BYTES_PER_ELEMENT),
        l = a[fU];
    if (l & mU) {
        const c = a[dU.FOURCC];
        if (c !== xU) {
            const _ = SU[c],
                E = Yv + Ah,
                P = new Uint8Array(e, E);
            return [new oo(P, {
                format: _,
                width: s,
                height: i,
                levels: o
            })]
        }
        const u = Yv + Ah,
            h = new Uint32Array(t.buffer, u, yS / Uint32Array.BYTES_PER_ELEMENT),
            d = h[$h.DXGI_FORMAT],
            f = h[$h.RESOURCE_DIMENSION],
            p = h[$h.MISC_FLAG],
            m = h[$h.ARRAY_SIZE],
            w = PU[d];
        if (w === void 0) throw new Error(`DDSParser cannot parse texture data with DXGI format ${d}`);
        if (p === EU) throw new Error("DDSParser does not support cubemap textures");
        if (f === 6) throw new Error("DDSParser does not supported 3D texture data");
        const y = new Array,
            v = Yv + Ah + yS;
        if (m === 1) y.push(new Uint8Array(e, v));
        else {
            const _ = Ef[w];
            let E = 0,
                P = s,
                C = i;
            for (let O = 0; O < o; O++) {
                const k = Math.max(1, P + 3 & -4),
                    D = Math.max(1, C + 3 & -4),
                    B = k * D * _;
                E += B, P = P >>> 1, C = C >>> 1
            }
            let T = v;
            for (let O = 0; O < m; O++) y.push(new Uint8Array(e, T, E)), T += E
        }
        return y.map(_ => new oo(_, {
            format: w,
            width: s,
            height: i,
            levels: o
        }))
    }
    throw l & gU ? new Error("DDSParser does not support uncompressed texture data.") : l & vU ? new Error("DDSParser does not supported YUV uncompressed texture data.") : l & yU ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : l & pU ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
}
const _S = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
    TU = 67305985,
    fn = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
    },
    r_ = 64,
    wS = {
        [be.UNSIGNED_BYTE]: 1,
        [be.UNSIGNED_SHORT]: 2,
        [be.INT]: 4,
        [be.UNSIGNED_INT]: 4,
        [be.FLOAT]: 4,
        [be.HALF_FLOAT]: 8
    },
    OU = {
        [se.RGBA]: 4,
        [se.RGB]: 3,
        [se.RG]: 2,
        [se.RED]: 1,
        [se.LUMINANCE]: 1,
        [se.LUMINANCE_ALPHA]: 2,
        [se.ALPHA]: 1
    },
    AU = {
        [be.UNSIGNED_SHORT_4_4_4_4]: 2,
        [be.UNSIGNED_SHORT_5_5_5_1]: 2,
        [be.UNSIGNED_SHORT_5_6_5]: 2
    };

function IU(e, t, r = !1) {
    const n = new DataView(t);
    if (!$U(e, n)) return null;
    const i = n.getUint32(fn.ENDIANNESS, !0) === TU,
        s = n.getUint32(fn.GL_TYPE, i),
        o = n.getUint32(fn.GL_FORMAT, i),
        a = n.getUint32(fn.GL_INTERNAL_FORMAT, i),
        l = n.getUint32(fn.PIXEL_WIDTH, i),
        c = n.getUint32(fn.PIXEL_HEIGHT, i) || 1,
        u = n.getUint32(fn.PIXEL_DEPTH, i) || 1,
        h = n.getUint32(fn.NUMBER_OF_ARRAY_ELEMENTS, i) || 1,
        d = n.getUint32(fn.NUMBER_OF_FACES, i),
        f = n.getUint32(fn.NUMBER_OF_MIPMAP_LEVELS, i),
        p = n.getUint32(fn.BYTES_OF_KEY_VALUE_DATA, i);
    if (c === 0 || u !== 1) throw new Error("Only 2D textures are supported");
    if (d !== 1) throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (h !== 1) throw new Error("WebGL does not support array textures");
    const m = 4,
        w = 4,
        y = l + 3 & -4,
        v = c + 3 & -4,
        _ = new Array(h);
    let E = l * c;
    s === 0 && (E = y * v);
    let P;
    if (s !== 0 ? wS[s] ? P = wS[s] * OU[o] : P = AU[s] : P = Ef[a], P === void 0) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const C = r ? kU(n, p, i) : null;
    let O = E * P,
        k = l,
        D = c,
        B = y,
        j = v,
        L = r_ + p;
    for (let M = 0; M < f; M++) {
        const W = n.getUint32(L, i);
        let Z = L + 4;
        for (let q = 0; q < h; q++) {
            let G = _[q];
            G || (G = _[q] = new Array(f)), G[M] = {
                levelID: M,
                levelWidth: f > 1 || s !== 0 ? k : B,
                levelHeight: f > 1 || s !== 0 ? D : j,
                levelBuffer: new Uint8Array(t, Z, O)
            }, Z += O
        }
        L += W + 4, L = L % 4 !== 0 ? L + 4 - L % 4 : L, k = k >> 1 || 1, D = D >> 1 || 1, B = k + m - 1 & ~(m - 1), j = D + w - 1 & ~(w - 1), O = B * j * P
    }
    return s !== 0 ? {
        uncompressed: _.map(M => {
            let W = M[0].levelBuffer,
                Z = !1;
            return s === be.FLOAT ? W = new Float32Array(M[0].levelBuffer.buffer, M[0].levelBuffer.byteOffset, M[0].levelBuffer.byteLength / 4) : s === be.UNSIGNED_INT ? (Z = !0, W = new Uint32Array(M[0].levelBuffer.buffer, M[0].levelBuffer.byteOffset, M[0].levelBuffer.byteLength / 4)) : s === be.INT && (Z = !0, W = new Int32Array(M[0].levelBuffer.buffer, M[0].levelBuffer.byteOffset, M[0].levelBuffer.byteLength / 4)), {
                resource: new xu(W, {
                    width: M[0].levelWidth,
                    height: M[0].levelHeight
                }),
                type: s,
                format: Z ? RU(o) : o
            }
        }),
        kvData: C
    } : {
        compressed: _.map(M => new oo(null, {
            format: a,
            width: l,
            height: c,
            levels: f,
            levelBuffers: M
        })),
        kvData: C
    }
}

function $U(e, t) {
    for (let r = 0; r < _S.length; r++)
        if (t.getUint8(r) !== _S[r]) return console.error(`${e} is not a valid *.ktx file!`), !1;
    return !0
}

function RU(e) {
    switch (e) {
        case se.RGBA:
            return se.RGBA_INTEGER;
        case se.RGB:
            return se.RGB_INTEGER;
        case se.RG:
            return se.RG_INTEGER;
        case se.RED:
            return se.RED_INTEGER;
        default:
            return e
    }
}

function kU(e, t, r) {
    const n = new Map;
    let i = 0;
    for (; i < t;) {
        const s = e.getUint32(r_ + i, r),
            o = r_ + i + 4,
            a = 3 - (s + 3) % 4;
        if (s === 0 || s > t - i) {
            console.error("KTXLoader: keyAndValueByteSize out of bounds");
            break
        }
        let l = 0;
        for (; l < s && e.getUint8(o + l) !== 0; l++);
        if (l === -1) {
            console.error("KTXLoader: Failed to find null byte terminating kvData key");
            break
        }
        const c = new TextDecoder().decode(new Uint8Array(e.buffer, o, l)),
            u = new DataView(e.buffer, o + l + 1, s - l - 1);
        n.set(c, u), i += 4 + s + a
    }
    return n
}
const MU = {
    extension: {
        type: ue.LoadParser,
        priority: ai.High
    },
    name: "loadDDS",
    test(e) {
        return To(e, ".dds")
    },
    async load(e, t, r) {
        const i = await (await ce.ADAPTER.fetch(e)).arrayBuffer(),
            o = CU(i).map(a => {
                const l = new Oe(a, {
                    mipmap: si.OFF,
                    alphaMode: Nn.NO_PREMULTIPLIED_ALPHA,
                    resolution: Ss(e),
                    ...t.data
                });
                return Bm(l, r, e)
            });
        return o.length === 1 ? o[0] : o
    },
    unload(e) {
        Array.isArray(e) ? e.forEach(t => t.destroy(!0)) : e.destroy(!0)
    }
};
ye.add(MU);
const DU = {
    extension: {
        type: ue.LoadParser,
        priority: ai.High
    },
    name: "loadKTX",
    test(e) {
        return To(e, ".ktx")
    },
    async load(e, t, r) {
        const i = await (await ce.ADAPTER.fetch(e)).arrayBuffer(),
            {
                compressed: s,
                uncompressed: o,
                kvData: a
            } = IU(e, i),
            l = s??o,
            c = {
                mipmap: si.OFF,
                alphaMode: Nn.NO_PREMULTIPLIED_ALPHA,
                resolution: Ss(e),
                ...t.data
            },
            u = l.map(h => {
                l === o && Object.assign(c, {
                    type: h.type,
                    format: h.format
                });
                const d = new Oe(h, c);
                return d.ktxKeyValueData = a, Bm(d, r, e)
            });
        return u.length === 1 ? u[0] : u
    },
    unload(e) {
        Array.isArray(e) ? e.forEach(t => t.destroy(!0)) : e.destroy(!0)
    }
};
ye.add(DU);
const NU = {
    extension: ue.ResolveParser,
    test: e => {
        const r = e.split("?")[0].split(".").pop();
        return ["basis", "ktx", "dds"].includes(r)
    },
    parse: e => {
        var n, i;
        if (e.split("?")[0].split(".").pop() === "ktx") {
            const s = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
            if (s.some(o => e.endsWith(o))) return {
                resolution: parseFloat(((n = ce.RETINA_PREFIX.exec(e)) == null ? void 0 : n[1])??"1"),
                format: s.find(o => e.endsWith(o)),
                src: e
            }
        }
        return {
            resolution: parseFloat(((i = ce.RETINA_PREFIX.exec(e)) == null ? void 0 : i[1])??"1"),
            format: e.split(".").pop(),
            src: e
        }
    }
};
ye.add(NU);
const LU = new $e,
    FU = 4,
    uc = class {
        constructor(e) {
            this.renderer = e
        }
        async image(e, t, r) {
            const n = new Image;
            return n.src = await this.base64(e, t, r), n
        }
        async base64(e, t, r) {
            const n = this.canvas(e);
            if (n.toBlob !== void 0) return new Promise((i, s) => {
                n.toBlob(o => {
                    if (!o) {
                        s(new Error("ICanvas.toBlob failed!"));
                        return
                    }
                    const a = new FileReader;
                    a.onload = () => i(a.result), a.onerror = s, a.readAsDataURL(o)
                }, t, r)
            });
            if (n.toDataURL !== void 0) return n.toDataURL(t, r);
            if (n.convertToBlob !== void 0) {
                const i = await n.convertToBlob({
                    type: t,
                    quality: r
                });
                return new Promise((s, o) => {
                    const a = new FileReader;
                    a.onload = () => s(a.result), a.onerror = o, a.readAsDataURL(i)
                })
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
        }
        canvas(e, t) {
            const {
                pixels: r,
                width: n,
                height: i,
                flipY: s
            } = this._rawPixels(e, t);
            s && uc._flipY(r, n, i), uc._unpremultiplyAlpha(r);
            const o = new ez(n, i, 1),
                a = new ImageData(new Uint8ClampedArray(r.buffer), n, i);
            return o.context.putImageData(a, 0, 0), o.canvas
        }
        pixels(e, t) {
            const {
                pixels: r,
                width: n,
                height: i,
                flipY: s
            } = this._rawPixels(e, t);
            return s && uc._flipY(r, n, i), uc._unpremultiplyAlpha(r), r
        }
        _rawPixels(e, t) {
            const r = this.renderer;
            if (!r) throw new Error("The Extract has already been destroyed");
            let n, i = !1,
                s, o = !1;
            if (e && (e instanceof Co ? s = e : (s = r.generateTexture(e, {
                    resolution: r.resolution,
                    multisample: r.multisample
                }), o = !0)), s) {
                if (n = s.baseTexture.resolution, t = t??s.frame, i = !1, !o) {
                    r.renderTexture.bind(s);
                    const h = s.framebuffer.glFramebuffers[r.CONTEXT_UID];
                    h.blitFramebuffer && r.framebuffer.bind(h.blitFramebuffer)
                }
            } else n = r.resolution, t || (t = LU, t.width = r.width / n, t.height = r.height / n), i = !0, r.renderTexture.bind();
            const a = Math.round(t.width * n),
                l = Math.round(t.height * n),
                c = new Uint8Array(FU * a * l),
                u = r.gl;
            return u.readPixels(Math.round(t.x * n), Math.round(t.y * n), a, l, u.RGBA, u.UNSIGNED_BYTE, c), o && (s == null || s.destroy(!0)), {
                pixels: c,
                width: a,
                height: l,
                flipY: i
            }
        }
        destroy() {
            this.renderer = null
        }
        static _flipY(e, t, r) {
            const n = t << 2,
                i = r >> 1,
                s = new Uint8Array(n);
            for (let o = 0; o < i; o++) {
                const a = o * n,
                    l = (r - o - 1) * n;
                s.set(e.subarray(a, a + n)), e.copyWithin(a, l, l + n), e.set(s, l)
            }
        }
        static _unpremultiplyAlpha(e) {
            e instanceof Uint8ClampedArray && (e = new Uint8Array(e.buffer));
            const t = e.length;
            for (let r = 0; r < t; r += 4) {
                const n = e[r + 3];
                if (n !== 0) {
                    const i = 255.001 / n;
                    e[r] = e[r] * i + .5, e[r + 1] = e[r + 1] * i + .5, e[r + 2] = e[r + 2] * i + .5
                }
            }
        }
    };
let G$ = uc;
G$.extension = {
    name: "extract",
    type: ue.RendererSystem
};
ye.add(G$);
const Sf = {
    build(e) {
        const t = e.points;
        let r, n, i, s, o, a;
        if (e.type === tr.CIRC) {
            const p = e.shape;
            r = p.x, n = p.y, o = a = p.radius, i = s = 0
        } else if (e.type === tr.ELIP) {
            const p = e.shape;
            r = p.x, n = p.y, o = p.width, a = p.height, i = s = 0
        } else {
            const p = e.shape,
                m = p.width / 2,
                w = p.height / 2;
            r = p.x + m, n = p.y + w, o = a = Math.max(0, Math.min(p.radius, Math.min(m, w))), i = m - o, s = w - a
        }
        if (!(o >= 0 && a >= 0 && i >= 0 && s >= 0)) {
            t.length = 0;
            return
        }
        const l = Math.ceil(2.3 * Math.sqrt(o + a)),
            c = l * 8 + (i ? 4 : 0) + (s ? 4 : 0);
        if (t.length = c, c === 0) return;
        if (l === 0) {
            t.length = 8, t[0] = t[6] = r + i, t[1] = t[3] = n + s, t[2] = t[4] = r - i, t[5] = t[7] = n - s;
            return
        }
        let u = 0,
            h = l * 4 + (i ? 2 : 0) + 2,
            d = h,
            f = c; {
            const p = i + o,
                m = s,
                w = r + p,
                y = r - p,
                v = n + m;
            if (t[u++] = w, t[u++] = v, t[--h] = v, t[--h] = y, s) {
                const _ = n - m;
                t[d++] = y, t[d++] = _, t[--f] = _, t[--f] = w
            }
        }
        for (let p = 1; p < l; p++) {
            const m = Math.PI / 2 * (p / l),
                w = i + Math.cos(m) * o,
                y = s + Math.sin(m) * a,
                v = r + w,
                _ = r - w,
                E = n + y,
                P = n - y;
            t[u++] = v, t[u++] = E, t[--h] = E, t[--h] = _, t[d++] = _, t[d++] = P, t[--f] = P, t[--f] = v
        } {
            const p = i,
                m = s + a,
                w = r + p,
                y = r - p,
                v = n + m,
                _ = n - m;
            t[u++] = w, t[u++] = v, t[--f] = _, t[--f] = w, i && (t[u++] = y, t[u++] = v, t[--f] = _, t[--f] = y)
        }
    },
    triangulate(e, t) {
        const r = e.points,
            n = t.points,
            i = t.indices;
        if (r.length === 0) return;
        let s = n.length / 2;
        const o = s;
        let a, l;
        if (e.type !== tr.RREC) {
            const u = e.shape;
            a = u.x, l = u.y
        } else {
            const u = e.shape;
            a = u.x + u.width / 2, l = u.y + u.height / 2
        }
        const c = e.matrix;
        n.push(e.matrix ? c.a * a + c.c * l + c.tx : a, e.matrix ? c.b * a + c.d * l + c.ty : l), s++, n.push(r[0], r[1]);
        for (let u = 2; u < r.length; u += 2) n.push(r[u], r[u + 1]), i.push(s++, o, s);
        i.push(o + 1, o, s)
    }
};

function bS(e, t = !1) {
    const r = e.length;
    if (r < 6) return;
    let n = 0;
    for (let i = 0, s = e[r - 2], o = e[r - 1]; i < r; i += 2) {
        const a = e[i],
            l = e[i + 1];
        n += (a - s) * (l + o), s = a, o = l
    }
    if (!t && n > 0 || t && n <= 0) {
        const i = r / 2;
        for (let s = i + i % 2; s < r; s += 2) {
            const o = r - s - 2,
                a = r - s - 1,
                l = s,
                c = s + 1;
            [e[o], e[l]] = [e[l], e[o]], [e[a], e[c]] = [e[c], e[a]]
        }
    }
}
const V$ = {
        build(e) {
            e.points = e.shape.points.slice()
        },
        triangulate(e, t) {
            let r = e.points;
            const n = e.holes,
                i = t.points,
                s = t.indices;
            if (r.length >= 6) {
                bS(r, !1);
                const o = [];
                for (let c = 0; c < n.length; c++) {
                    const u = n[c];
                    bS(u.points, !0), o.push(r.length / 2), r = r.concat(u.points)
                }
                const a = mf(r, o, 2);
                if (!a) return;
                const l = i.length / 2;
                for (let c = 0; c < a.length; c += 3) s.push(a[c] + l), s.push(a[c + 1] + l), s.push(a[c + 2] + l);
                for (let c = 0; c < r.length; c++) i.push(r[c])
            }
        }
    },
    BU = {
        build(e) {
            const t = e.shape,
                r = t.x,
                n = t.y,
                i = t.width,
                s = t.height,
                o = e.points;
            o.length = 0, i >= 0 && s >= 0 && o.push(r, n, r + i, n, r + i, n + s, r, n + s)
        },
        triangulate(e, t) {
            const r = e.points,
                n = t.points;
            if (r.length === 0) return;
            const i = n.length / 2;
            n.push(r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]), t.indices.push(i, i + 1, i + 2, i + 1, i + 2, i + 3)
        }
    },
    zU = {
        build(e) {
            Sf.build(e)
        },
        triangulate(e, t) {
            Sf.triangulate(e, t)
        }
    };
var vn = (e => (e.MITER = "miter", e.BEVEL = "bevel", e.ROUND = "round", e))(vn || {}),
    ro = (e => (e.BUTT = "butt", e.ROUND = "round", e.SQUARE = "square", e))(ro || {});
const el = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(e, t = 20) {
        if (!this.adaptive || !e || isNaN(e)) return t;
        let r = Math.ceil(e / this.maxLength);
        return r < this.minSegments ? r = this.minSegments : r > this.maxSegments && (r = this.maxSegments), r
    }
};
class xS {
    static curveTo(t, r, n, i, s, o) {
        const a = o[o.length - 2],
            c = o[o.length - 1] - r,
            u = a - t,
            h = i - r,
            d = n - t,
            f = Math.abs(c * d - u * h);
        if (f < 1e-8 || s === 0) return (o[o.length - 2] !== t || o[o.length - 1] !== r) && o.push(t, r), null;
        const p = c * c + u * u,
            m = h * h + d * d,
            w = c * h + u * d,
            y = s * Math.sqrt(p) / f,
            v = s * Math.sqrt(m) / f,
            _ = y * w / p,
            E = v * w / m,
            P = y * d + v * u,
            C = y * h + v * c,
            T = u * (v + _),
            O = c * (v + _),
            k = d * (y + E),
            D = h * (y + E),
            B = Math.atan2(O - C, T - P),
            j = Math.atan2(D - C, k - P);
        return {
            cx: P + t,
            cy: C + r,
            radius: s,
            startAngle: B,
            endAngle: j,
            anticlockwise: u * h > d * c
        }
    }
    static arc(t, r, n, i, s, o, a, l, c) {
        const u = a - o,
            h = el._segmentsCount(Math.abs(u) * s, Math.ceil(Math.abs(u) / _f) * 40),
            d = u / (h * 2),
            f = d * 2,
            p = Math.cos(d),
            m = Math.sin(d),
            w = h - 1,
            y = w % 1 / w;
        for (let v = 0; v <= w; ++v) {
            const _ = v + y * v,
                E = d + o + f * _,
                P = Math.cos(E),
                C = -Math.sin(E);
            c.push((p * P + m * C) * s + n, (p * -C + m * P) * s + i)
        }
    }
}
class jU {
    constructor() {
        this.reset()
    }
    begin(t, r, n) {
        this.reset(), this.style = t, this.start = r, this.attribStart = n
    }
    end(t, r) {
        this.attribSize = r - this.attribStart, this.size = t - this.start
    }
    reset() {
        this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
    }
}
class tw {
    static curveLength(t, r, n, i, s, o, a, l) {
        let u = 0,
            h = 0,
            d = 0,
            f = 0,
            p = 0,
            m = 0,
            w = 0,
            y = 0,
            v = 0,
            _ = 0,
            E = 0,
            P = t,
            C = r;
        for (let T = 1; T <= 10; ++T) h = T / 10, d = h * h, f = d * h, p = 1 - h, m = p * p, w = m * p, y = w * t + 3 * m * h * n + 3 * p * d * s + f * a, v = w * r + 3 * m * h * i + 3 * p * d * o + f * l, _ = P - y, E = C - v, P = y, C = v, u += Math.sqrt(_ * _ + E * E);
        return u
    }
    static curveTo(t, r, n, i, s, o, a) {
        const l = a[a.length - 2],
            c = a[a.length - 1];
        a.length -= 2;
        const u = el._segmentsCount(tw.curveLength(l, c, t, r, n, i, s, o));
        let h = 0,
            d = 0,
            f = 0,
            p = 0,
            m = 0;
        a.push(l, c);
        for (let w = 1, y = 0; w <= u; ++w) y = w / u, h = 1 - y, d = h * h, f = d * h, p = y * y, m = p * y, a.push(f * l + 3 * d * y * t + 3 * h * p * n + m * s, f * c + 3 * d * y * r + 3 * h * p * i + m * o)
    }
}

function ES(e, t, r, n, i, s, o, a) {
    const l = e - r * i,
        c = t - n * i,
        u = e + r * s,
        h = t + n * s;
    let d, f;
    o ? (d = n, f = -r) : (d = -n, f = r);
    const p = l + d,
        m = c + f,
        w = u + d,
        y = h + f;
    return a.push(p, m, w, y), 2
}

function Fs(e, t, r, n, i, s, o, a) {
    const l = r - e,
        c = n - t;
    let u = Math.atan2(l, c),
        h = Math.atan2(i - e, s - t);
    a && u < h ? u += Math.PI * 2 : !a && u > h && (h += Math.PI * 2);
    let d = u;
    const f = h - u,
        p = Math.abs(f),
        m = Math.sqrt(l * l + c * c),
        w = (15 * p * Math.sqrt(m) / Math.PI >> 0) + 1,
        y = f / w;
    if (d += y, a) {
        o.push(e, t, r, n);
        for (let v = 1, _ = d; v < w; v++, _ += y) o.push(e, t, e + Math.sin(_) * m, t + Math.cos(_) * m);
        o.push(e, t, i, s)
    } else {
        o.push(r, n, e, t);
        for (let v = 1, _ = d; v < w; v++, _ += y) o.push(e + Math.sin(_) * m, t + Math.cos(_) * m, e, t);
        o.push(i, s, e, t)
    }
    return w * 2
}

function UU(e, t) {
    const r = e.shape;
    let n = e.points || r.points.slice();
    const i = t.closePointEps;
    if (n.length === 0) return;
    const s = e.lineStyle,
        o = new Se(n[0], n[1]),
        a = new Se(n[n.length - 2], n[n.length - 1]),
        l = r.type !== tr.POLY || r.closeStroke,
        c = Math.abs(o.x - a.x) < i && Math.abs(o.y - a.y) < i;
    if (l) {
        n = n.slice(), c && (n.pop(), n.pop(), a.set(n[n.length - 2], n[n.length - 1]));
        const q = (o.x + a.x) * .5,
            G = (a.y + o.y) * .5;
        n.unshift(q, G), n.push(q, G)
    }
    const u = t.points,
        h = n.length / 2;
    let d = n.length;
    const f = u.length / 2,
        p = s.width / 2,
        m = p * p,
        w = s.miterLimit * s.miterLimit;
    let y = n[0],
        v = n[1],
        _ = n[2],
        E = n[3],
        P = 0,
        C = 0,
        T = -(v - E),
        O = y - _,
        k = 0,
        D = 0,
        B = Math.sqrt(T * T + O * O);
    T /= B, O /= B, T *= p, O *= p;
    const j = s.alignment,
        L = (1 - j) * 2,
        M = j * 2;
    l || (s.cap === ro.ROUND ? d += Fs(y - T * (L - M) * .5, v - O * (L - M) * .5, y - T * L, v - O * L, y + T * M, v + O * M, u, !0) + 2 : s.cap === ro.SQUARE && (d += ES(y, v, T, O, L, M, !0, u))), u.push(y - T * L, v - O * L, y + T * M, v + O * M);
    for (let q = 1; q < h - 1; ++q) {
        y = n[(q - 1) * 2], v = n[(q - 1) * 2 + 1], _ = n[q * 2], E = n[q * 2 + 1], P = n[(q + 1) * 2], C = n[(q + 1) * 2 + 1], T = -(v - E), O = y - _, B = Math.sqrt(T * T + O * O), T /= B, O /= B, T *= p, O *= p, k = -(E - C), D = _ - P, B = Math.sqrt(k * k + D * D), k /= B, D /= B, k *= p, D *= p;
        const G = _ - y,
            X = v - E,
            z = _ - P,
            Q = C - E,
            ie = G * z + X * Q,
            _e = X * z - Q * G,
            we = _e < 0;
        if (Math.abs(_e) < .001 * Math.abs(ie)) {
            u.push(_ - T * L, E - O * L, _ + T * M, E + O * M), ie >= 0 && (s.join === vn.ROUND ? d += Fs(_, E, _ - T * L, E - O * L, _ - k * L, E - D * L, u, !1) + 4 : d += 2, u.push(_ - k * M, E - D * M, _ + k * L, E + D * L));
            continue
        }
        const De = (-T + y) * (-O + E) - (-T + _) * (-O + v),
            Te = (-k + P) * (-D + E) - (-k + _) * (-D + C),
            Ne = (G * Te - z * De) / _e,
            et = (Q * De - X * Te) / _e,
            Le = (Ne - _) * (Ne - _) + (et - E) * (et - E),
            tt = _ + (Ne - _) * L,
            Ue = E + (et - E) * L,
            Ve = _ - (Ne - _) * M,
            rt = E - (et - E) * M,
            Dt = Math.min(G * G + X * X, z * z + Q * Q),
            zt = we ? L : M,
            Vr = Dt + zt * zt * m,
            at = Le <= Vr;
        let _r = s.join;
        if (_r === vn.MITER && Le / m > w && (_r = vn.BEVEL), at) switch (_r) {
            case vn.MITER:
                {
                    u.push(tt, Ue, Ve, rt);
                    break
                }
            case vn.BEVEL:
                {
                    we ? u.push(tt, Ue, _ + T * M, E + O * M, tt, Ue, _ + k * M, E + D * M) : u.push(_ - T * L, E - O * L, Ve, rt, _ - k * L, E - D * L, Ve, rt),
                    d += 2;
                    break
                }
            case vn.ROUND:
                {
                    we ? (u.push(tt, Ue, _ + T * M, E + O * M), d += Fs(_, E, _ + T * M, E + O * M, _ + k * M, E + D * M, u, !0) + 4, u.push(tt, Ue, _ + k * M, E + D * M)) : (u.push(_ - T * L, E - O * L, Ve, rt), d += Fs(_, E, _ - T * L, E - O * L, _ - k * L, E - D * L, u, !1) + 4, u.push(_ - k * L, E - D * L, Ve, rt));
                    break
                }
        } else {
            switch (u.push(_ - T * L, E - O * L, _ + T * M, E + O * M), _r) {
                case vn.MITER:
                    {
                        we ? u.push(Ve, rt, Ve, rt) : u.push(tt, Ue, tt, Ue),
                        d += 2;
                        break
                    }
                case vn.ROUND:
                    {
                        we ? d += Fs(_, E, _ + T * M, E + O * M, _ + k * M, E + D * M, u, !0) + 2 : d += Fs(_, E, _ - T * L, E - O * L, _ - k * L, E - D * L, u, !1) + 2;
                        break
                    }
            }
            u.push(_ - k * L, E - D * L, _ + k * M, E + D * M), d += 2
        }
    }
    y = n[(h - 2) * 2], v = n[(h - 2) * 2 + 1], _ = n[(h - 1) * 2], E = n[(h - 1) * 2 + 1], T = -(v - E), O = y - _, B = Math.sqrt(T * T + O * O), T /= B, O /= B, T *= p, O *= p, u.push(_ - T * L, E - O * L, _ + T * M, E + O * M), l || (s.cap === ro.ROUND ? d += Fs(_ - T * (L - M) * .5, E - O * (L - M) * .5, _ - T * L, E - O * L, _ + T * M, E + O * M, u, !1) + 2 : s.cap === ro.SQUARE && (d += ES(_, E, T, O, L, M, !1, u)));
    const W = t.indices,
        Z = el.epsilon * el.epsilon;
    for (let q = f; q < d + f - 2; ++q) y = u[q * 2], v = u[q * 2 + 1], _ = u[(q + 1) * 2], E = u[(q + 1) * 2 + 1], P = u[(q + 2) * 2], C = u[(q + 2) * 2 + 1], !(Math.abs(y * (E - C) + _ * (C - v) + P * (v - E)) < Z) && W.push(q, q + 1, q + 2)
}

function HU(e, t) {
    let r = 0;
    const n = e.shape,
        i = e.points || n.points,
        s = n.type !== tr.POLY || n.closeStroke;
    if (i.length === 0) return;
    const o = t.points,
        a = t.indices,
        l = i.length / 2,
        c = o.length / 2;
    let u = c;
    for (o.push(i[0], i[1]), r = 1; r < l; r++) o.push(i[r * 2], i[r * 2 + 1]), a.push(u, u + 1), u++;
    s && a.push(u, c)
}

function SS(e, t) {
    e.lineStyle.native ? HU(e, t) : UU(e, t)
}
class rw {
    static curveLength(t, r, n, i, s, o) {
        const a = t - 2 * n + s,
            l = r - 2 * i + o,
            c = 2 * n - 2 * t,
            u = 2 * i - 2 * r,
            h = 4 * (a * a + l * l),
            d = 4 * (a * c + l * u),
            f = c * c + u * u,
            p = 2 * Math.sqrt(h + d + f),
            m = Math.sqrt(h),
            w = 2 * h * m,
            y = 2 * Math.sqrt(f),
            v = d / m;
        return (w * p + m * d * (p - y) + (4 * f * h - d * d) * Math.log((2 * m + v + p) / (v + y))) / (4 * w)
    }
    static curveTo(t, r, n, i, s) {
        const o = s[s.length - 2],
            a = s[s.length - 1],
            l = el._segmentsCount(rw.curveLength(o, a, t, r, n, i));
        let c = 0,
            u = 0;
        for (let h = 1; h <= l; ++h) {
            const d = h / l;
            c = o + (t - o) * d, u = a + (r - a) * d, s.push(c + (t + (n - t) * d - c) * d, u + (r + (i - r) * d - u) * d)
        }
    }
}
const Kv = {
        [tr.POLY]: V$,
        [tr.CIRC]: Sf,
        [tr.ELIP]: Sf,
        [tr.RECT]: BU,
        [tr.RREC]: zU
    },
    PS = [],
    Rh = [];
class Pf {
    constructor(t, r = null, n = null, i = null) {
        this.points = [], this.holes = [], this.shape = t, this.lineStyle = n, this.fillStyle = r, this.matrix = i, this.type = t.type
    }
    clone() {
        return new Pf(this.shape, this.fillStyle, this.lineStyle, this.matrix)
    }
    destroy() {
        this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
    }
}
const qo = new Se,
    W$ = class extends n$ {
        constructor() {
            super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = !1, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new wf, this.boundsDirty = -1
        }
        get bounds() {
            return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
        }
        invalidate() {
            this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
            for (let e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), Rh.push(this.drawCalls[e]);
            this.drawCalls.length = 0;
            for (let e = 0; e < this.batches.length; e++) {
                const t = this.batches[e];
                t.reset(), PS.push(t)
            }
            this.batches.length = 0
        }
        clear() {
            return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
        }
        drawShape(e, t = null, r = null, n = null) {
            const i = new Pf(e, t, r, n);
            return this.graphicsData.push(i), this.dirty++, this
        }
        drawHole(e, t = null) {
            if (!this.graphicsData.length) return null;
            const r = new Pf(e, null, null, t),
                n = this.graphicsData[this.graphicsData.length - 1];
            return r.lineStyle = n.lineStyle, n.holes.push(r), this.dirty++, this
        }
        destroy() {
            super.destroy();
            for (let e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy();
            this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
        }
        containsPoint(e) {
            const t = this.graphicsData;
            for (let r = 0; r < t.length; ++r) {
                const n = t[r];
                if (n.fillStyle.visible && n.shape && (n.matrix ? n.matrix.applyInverse(e, qo) : qo.copyFrom(e), n.shape.contains(qo.x, qo.y))) {
                    let i = !1;
                    if (n.holes) {
                        for (let s = 0; s < n.holes.length; s++)
                            if (n.holes[s].shape.contains(qo.x, qo.y)) {
                                i = !0;
                                break
                            }
                    }
                    if (!i) return !0
                }
            }
            return !1
        }
        updateBatches() {
            if (!this.graphicsData.length) {
                this.batchable = !0;
                return
            }
            if (!this.validateBatching()) return;
            this.cacheDirty = this.dirty;
            const e = this.uvs,
                t = this.graphicsData;
            let r = null,
                n = null;
            this.batches.length > 0 && (r = this.batches[this.batches.length - 1], n = r.style);
            for (let a = this.shapeIndex; a < t.length; a++) {
                this.shapeIndex++;
                const l = t[a],
                    c = l.fillStyle,
                    u = l.lineStyle;
                Kv[l.type].build(l), l.matrix && this.transformPoints(l.points, l.matrix), (c.visible || u.visible) && this.processHoles(l.holes);
                for (let d = 0; d < 2; d++) {
                    const f = d === 0 ? c : u;
                    if (!f.visible) continue;
                    const p = f.texture.baseTexture,
                        m = this.indices.length,
                        w = this.points.length / 2;
                    p.wrapMode = vs.REPEAT, d === 0 ? this.processFill(l) : this.processLine(l);
                    const y = this.points.length / 2 - w;
                    y !== 0 && (r && !this._compareStyles(n, f) && (r.end(m, w), r = null), r || (r = PS.pop() || new jU, r.begin(f, m, w), this.batches.push(r), n = f), this.addUvs(this.points, e, f.texture, w, y, f.matrix))
                }
            }
            const i = this.indices.length,
                s = this.points.length / 2;
            if (r && r.end(i, s), this.batches.length === 0) {
                this.batchable = !0;
                return
            }
            const o = s > 65535;
            this.indicesUint16 && this.indices.length === this.indicesUint16.length && o === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = o ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
        }
        _compareStyles(e, t) {
            return !(!e || !t || e.texture.baseTexture !== t.texture.baseTexture || e.color + e.alpha !== t.color + t.alpha || !!e.native != !!t.native)
        }
        validateBatching() {
            if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
            for (let e = 0, t = this.graphicsData.length; e < t; e++) {
                const r = this.graphicsData[e],
                    n = r.fillStyle,
                    i = r.lineStyle;
                if (n && !n.texture.baseTexture.valid || i && !i.texture.baseTexture.valid) return !1
            }
            return !0
        }
        packBatches() {
            this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
            const e = this.batches;
            for (let t = 0, r = e.length; t < r; t++) {
                const n = e[t];
                for (let i = 0; i < n.size; i++) {
                    const s = n.start + i;
                    this.indicesUint16[s] = this.indicesUint16[s] - n.attribStart
                }
            }
        }
        isBatchable() {
            if (this.points.length > 65535 * 2) return !1;
            const e = this.batches;
            for (let t = 0; t < e.length; t++)
                if (e[t].style.native) return !1;
            return this.points.length < W$.BATCHABLE_SIZE * 2
        }
        buildDrawCalls() {
            let e = ++Oe._globalBatch;
            for (let u = 0; u < this.drawCalls.length; u++) this.drawCalls[u].texArray.clear(), Rh.push(this.drawCalls[u]);
            this.drawCalls.length = 0;
            const t = this.colors,
                r = this.textureIds;
            let n = Rh.pop();
            n || (n = new Hy, n.texArray = new Vy), n.texArray.count = 0, n.start = 0, n.size = 0, n.type = Zn.TRIANGLES;
            let i = 0,
                s = null,
                o = 0,
                a = !1,
                l = Zn.TRIANGLES,
                c = 0;
            this.drawCalls.push(n);
            for (let u = 0; u < this.batches.length; u++) {
                const h = this.batches[u],
                    d = 8,
                    f = h.style,
                    p = f.texture.baseTexture;
                a !== !!f.native && (a = !!f.native, l = a ? Zn.LINES : Zn.TRIANGLES, s = null, i = d, e++), s !== p && (s = p, p._batchEnabled !== e && (i === d && (e++, i = 0, n.size > 0 && (n = Rh.pop(), n || (n = new Hy, n.texArray = new Vy), this.drawCalls.push(n)), n.start = c, n.size = 0, n.texArray.count = 0, n.type = l), p.touched = 1, p._batchEnabled = e, p._batchLocation = i, p.wrapMode = vs.REPEAT, n.texArray.elements[n.texArray.count++] = p, i++)), n.size += h.size, c += h.size, o = p._batchLocation, this.addColors(t, f.color, f.alpha, h.attribSize, h.attribStart), this.addTextureIds(r, o, h.attribSize, h.attribStart)
            }
            Oe._globalBatch = e, this.packAttributes()
        }
        packAttributes() {
            const e = this.points,
                t = this.uvs,
                r = this.colors,
                n = this.textureIds,
                i = new ArrayBuffer(e.length * 3 * 4),
                s = new Float32Array(i),
                o = new Uint32Array(i);
            let a = 0;
            for (let l = 0; l < e.length / 2; l++) s[a++] = e[l * 2], s[a++] = e[l * 2 + 1], s[a++] = t[l * 2], s[a++] = t[l * 2 + 1], o[a++] = r[l], s[a++] = n[l];
            this._buffer.update(i), this._indexBuffer.update(this.indicesUint16)
        }
        processFill(e) {
            e.holes.length ? V$.triangulate(e, this) : Kv[e.type].triangulate(e, this)
        }
        processLine(e) {
            SS(e, this);
            for (let t = 0; t < e.holes.length; t++) SS(e.holes[t], this)
        }
        processHoles(e) {
            for (let t = 0; t < e.length; t++) {
                const r = e[t];
                Kv[r.type].build(r), r.matrix && this.transformPoints(r.points, r.matrix)
            }
        }
        calculateBounds() {
            const e = this._bounds;
            e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding)
        }
        transformPoints(e, t) {
            for (let r = 0; r < e.length / 2; r++) {
                const n = e[r * 2],
                    i = e[r * 2 + 1];
                e[r * 2] = t.a * n + t.c * i + t.tx, e[r * 2 + 1] = t.b * n + t.d * i + t.ty
            }
        }
        addColors(e, t, r, n, i = 0) {
            const s = ot.shared.setValue(t).toLittleEndianNumber(),
                o = ot.shared.setValue(s).toPremultiplied(r);
            e.length = Math.max(e.length, i + n);
            for (let a = 0; a < n; a++) e[i + a] = o
        }
        addTextureIds(e, t, r, n = 0) {
            e.length = Math.max(e.length, n + r);
            for (let i = 0; i < r; i++) e[n + i] = t
        }
        addUvs(e, t, r, n, i, s = null) {
            let o = 0;
            const a = t.length,
                l = r.frame;
            for (; o < i;) {
                let u = e[(n + o) * 2],
                    h = e[(n + o) * 2 + 1];
                if (s) {
                    const d = s.a * u + s.c * h + s.tx;
                    h = s.b * u + s.d * h + s.ty, u = d
                }
                o++, t.push(u / l.width, h / l.height)
            }
            const c = r.baseTexture;
            (l.width < c.width || l.height < c.height) && this.adjustUvs(t, r, a, i)
        }
        adjustUvs(e, t, r, n) {
            const i = t.baseTexture,
                s = 1e-6,
                o = r + n * 2,
                a = t.frame,
                l = a.width / i.width,
                c = a.height / i.height;
            let u = a.x / a.width,
                h = a.y / a.height,
                d = Math.floor(e[r] + s),
                f = Math.floor(e[r + 1] + s);
            for (let p = r + 2; p < o; p += 2) d = Math.min(d, Math.floor(e[p] + s)), f = Math.min(f, Math.floor(e[p + 1] + s));
            u -= d, h -= f;
            for (let p = r; p < o; p += 2) e[p] = (e[p] + u) * l, e[p + 1] = (e[p + 1] + h) * c
        }
    };
let X$ = W$;
X$.BATCHABLE_SIZE = 100;
class jm {
    constructor() {
        this.color = 16777215, this.alpha = 1, this.texture = ge.WHITE, this.matrix = null, this.visible = !1, this.reset()
    }
    clone() {
        const t = new jm;
        return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t
    }
    reset() {
        this.color = 16777215, this.alpha = 1, this.texture = ge.WHITE, this.matrix = null, this.visible = !1
    }
    destroy() {
        this.texture = null, this.matrix = null
    }
}
class nw extends jm {
    constructor() {
        super(...arguments), this.width = 0, this.alignment = .5, this.native = !1, this.cap = ro.BUTT, this.join = vn.MITER, this.miterLimit = 10
    }
    clone() {
        const t = new nw;
        return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t
    }
    reset() {
        super.reset(), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1
    }
}
const qv = {},
    Pd = class extends jr {
        constructor(e = null) {
            super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new jm, this._lineStyle = new nw, this._matrix = null, this._holeMode = !1, this.state = ki.for2d(), this._geometry = e || new X$, this._geometry.refCount++, this._transformID = -1, this._tintColor = new ot(16777215), this.blendMode = Ce.NORMAL
        }
        get geometry() {
            return this._geometry
        }
        clone() {
            return this.finishPoly(), new Pd(this._geometry)
        }
        set blendMode(e) {
            this.state.blendMode = e
        }
        get blendMode() {
            return this.state.blendMode
        }
        get tint() {
            return this._tintColor.value
        }
        set tint(e) {
            this._tintColor.setValue(e)
        }
        get fill() {
            return this._fillStyle
        }
        get line() {
            return this._lineStyle
        }
        lineStyle(e = null, t = 0, r, n = .5, i = !1) {
            return typeof e == "number" && (e = {
                width: e,
                color: t,
                alpha: r,
                alignment: n,
                native: i
            }), this.lineTextureStyle(e)
        }
        lineTextureStyle(e) {
            const t = {
                width: 0,
                texture: ge.WHITE,
                color: e != null && e.texture ? 16777215 : 0,
                matrix: null,
                alignment: .5,
                native: !1,
                cap: ro.BUTT,
                join: vn.MITER,
                miterLimit: 10
            };
            e = Object.assign(t, e), this.normalizeColor(e), this.currentPath && this.startPoly();
            const r = e.width > 0 && e.alpha > 0;
            return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, {
                visible: r
            }, e)) : this._lineStyle.reset(), this
        }
        startPoly() {
            if (this.currentPath) {
                const e = this.currentPath.points,
                    t = this.currentPath.points.length;
                t > 2 && (this.drawShape(this.currentPath), this.currentPath = new Ba, this.currentPath.closeStroke = !1, this.currentPath.points.push(e[t - 2], e[t - 1]))
            } else this.currentPath = new Ba, this.currentPath.closeStroke = !1
        }
        finishPoly() {
            this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
        }
        moveTo(e, t) {
            return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = t, this
        }
        lineTo(e, t) {
            this.currentPath || this.moveTo(0, 0);
            const r = this.currentPath.points,
                n = r[r.length - 2],
                i = r[r.length - 1];
            return (n !== e || i !== t) && r.push(e, t), this
        }
        _initCurve(e = 0, t = 0) {
            this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, t]) : this.moveTo(e, t)
        }
        quadraticCurveTo(e, t, r, n) {
            this._initCurve();
            const i = this.currentPath.points;
            return i.length === 0 && this.moveTo(0, 0), rw.curveTo(e, t, r, n, i), this
        }
        bezierCurveTo(e, t, r, n, i, s) {
            return this._initCurve(), tw.curveTo(e, t, r, n, i, s, this.currentPath.points), this
        }
        arcTo(e, t, r, n, i) {
            this._initCurve(e, t);
            const s = this.currentPath.points,
                o = xS.curveTo(e, t, r, n, i, s);
            if (o) {
                const {
                    cx: a,
                    cy: l,
                    radius: c,
                    startAngle: u,
                    endAngle: h,
                    anticlockwise: d
                } = o;
                this.arc(a, l, c, u, h, d)
            }
            return this
        }
        arc(e, t, r, n, i, s = !1) {
            if (n === i) return this;
            if (!s && i <= n ? i += _f : s && n <= i && (n += _f), i - n === 0) return this;
            const a = e + Math.cos(n) * r,
                l = t + Math.sin(n) * r,
                c = this._geometry.closePointEps;
            let u = this.currentPath ? this.currentPath.points : null;
            if (u) {
                const h = Math.abs(u[u.length - 2] - a),
                    d = Math.abs(u[u.length - 1] - l);
                h < c && d < c || u.push(a, l)
            } else this.moveTo(a, l), u = this.currentPath.points;
            return xS.arc(a, l, e, t, r, n, i, s, u), this
        }
        beginFill(e = 0, t) {
            return this.beginTextureFill({
                texture: ge.WHITE,
                color: e,
                alpha: t
            })
        }
        normalizeColor(e) {
            const t = ot.shared.setValue(e.color??0);
            e.color = t.toNumber(), e.alpha??(e.alpha = t.alpha)
        }
        beginTextureFill(e) {
            const t = {
                texture: ge.WHITE,
                color: 16777215,
                matrix: null
            };
            e = Object.assign(t, e), this.normalizeColor(e), this.currentPath && this.startPoly();
            const r = e.alpha > 0;
            return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, {
                visible: r
            }, e)) : this._fillStyle.reset(), this
        }
        endFill() {
            return this.finishPoly(), this._fillStyle.reset(), this
        }
        drawRect(e, t, r, n) {
            return this.drawShape(new $e(e, t, r, n))
        }
        drawRoundedRect(e, t, r, n, i) {
            return this.drawShape(new q1(e, t, r, n, i))
        }
        drawCircle(e, t, r) {
            return this.drawShape(new Y1(e, t, r))
        }
        drawEllipse(e, t, r, n) {
            return this.drawShape(new K1(e, t, r, n))
        }
        drawPolygon(...e) {
            let t, r = !0;
            const n = e[0];
            n.points ? (r = n.closeStroke, t = n.points) : Array.isArray(e[0]) ? t = e[0] : t = e;
            const i = new Ba(t);
            return i.closeStroke = r, this.drawShape(i), this
        }
        drawShape(e) {
            return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
        }
        clear() {
            return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
        }
        isFastRect() {
            const e = this._geometry.graphicsData;
            return e.length === 1 && e[0].shape.type === tr.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width)
        }
        _render(e) {
            this.finishPoly();
            const t = this._geometry;
            t.updateBatches(), t.batchable ? (this.batchDirty !== t.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e))
        }
        _populateBatches() {
            const e = this._geometry,
                t = this.blendMode,
                r = e.batches.length;
            this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = r, this.vertexData = new Float32Array(e.points);
            for (let n = 0; n < r; n++) {
                const i = e.batches[n],
                    s = i.style.color,
                    o = new Float32Array(this.vertexData.buffer, i.attribStart * 4 * 2, i.attribSize * 2),
                    a = new Float32Array(e.uvsFloat32.buffer, i.attribStart * 4 * 2, i.attribSize * 2),
                    l = new Uint16Array(e.indicesUint16.buffer, i.start * 2, i.size),
                    c = {
                        vertexData: o,
                        blendMode: t,
                        indices: l,
                        uvs: a,
                        _batchRGB: ot.shared.setValue(s).toRgbArray(),
                        _tintRGB: s,
                        _texture: i.style.texture,
                        alpha: i.style.alpha,
                        worldAlpha: 1
                    };
                this.batches[n] = c
            }
        }
        _renderBatched(e) {
            if (this.batches.length) {
                e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
                for (let t = 0, r = this.batches.length; t < r; t++) {
                    const n = this.batches[t];
                    n.worldAlpha = this.worldAlpha * n.alpha, e.plugins[this.pluginName].render(n)
                }
            }
        }
        _renderDirect(e) {
            const t = this._resolveDirectShader(e),
                r = this._geometry,
                n = this.worldAlpha,
                i = t.uniforms,
                s = r.drawCalls;
            i.translationMatrix = this.transform.worldTransform, ot.shared.setValue(this._tintColor).premultiply(n).toArray(i.tint), e.shader.bind(t), e.geometry.bind(r, t), e.state.set(this.state);
            for (let o = 0, a = s.length; o < a; o++) this._renderDrawCallDirect(e, r.drawCalls[o])
        }
        _renderDrawCallDirect(e, t) {
            const {
                texArray: r,
                type: n,
                size: i,
                start: s
            } = t, o = r.count;
            for (let a = 0; a < o; a++) e.texture.bind(r.elements[a], a);
            e.geometry.draw(n, i, s)
        }
        _resolveDirectShader(e) {
            let t = this.shader;
            const r = this.pluginName;
            if (!t) {
                if (!qv[r]) {
                    const {
                        maxTextures: n
                    } = e.plugins[r], i = new Int32Array(n);
                    for (let a = 0; a < n; a++) i[a] = a;
                    const s = {
                            tint: new Float32Array([1, 1, 1, 1]),
                            translationMatrix: new mt,
                            default: In.from({
                                uSamplers: i
                            }, !0)
                        },
                        o = e.plugins[r]._shader.program;
                    qv[r] = new ni(o, s)
                }
                t = qv[r]
            }
            return t
        }
        _calculateBounds() {
            this.finishPoly();
            const e = this._geometry;
            if (!e.graphicsData.length) return;
            const {
                minX: t,
                minY: r,
                maxX: n,
                maxY: i
            } = e.bounds;
            this._bounds.addFrame(this.transform, t, r, n, i)
        }
        containsPoint(e) {
            return this.worldTransform.applyInverse(e, Pd._TEMP_POINT), this._geometry.containsPoint(Pd._TEMP_POINT)
        }
        calculateTints() {
            if (this.batchTint !== this.tint) {
                this.batchTint = this._tintColor.toNumber();
                for (let e = 0; e < this.batches.length; e++) {
                    const t = this.batches[e];
                    t._tintRGB = ot.shared.setValue(this._tintColor).multiply(t._batchRGB).toLittleEndianNumber()
                }
            }
        }
        calculateVertices() {
            const e = this.transform._worldID;
            if (this._transformID === e) return;
            this._transformID = e;
            const t = this.transform.worldTransform,
                r = t.a,
                n = t.b,
                i = t.c,
                s = t.d,
                o = t.tx,
                a = t.ty,
                l = this._geometry.points,
                c = this.vertexData;
            let u = 0;
            for (let h = 0; h < l.length; h += 2) {
                const d = l[h],
                    f = l[h + 1];
                c[u++] = r * d + i * f + o, c[u++] = s * f + n * d + a
            }
        }
        closePath() {
            const e = this.currentPath;
            return e && (e.closeStroke = !0, this.finishPoly()), this
        }
        setMatrix(e) {
            return this._matrix = e, this
        }
        beginHole() {
            return this.finishPoly(), this._holeMode = !0, this
        }
        endHole() {
            return this.finishPoly(), this._holeMode = !1, this
        }
        destroy(e) {
            this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(e)
        }
    };
let Um = Pd;
Um.curves = el;
Um._TEMP_POINT = new Se;
class GU {
    constructor(t, r) {
        this.uvBuffer = t, this.uvMatrix = r, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
    }
    update(t) {
        if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) return;
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        const r = this.uvBuffer.data;
        (!this.data || this.data.length !== r.length) && (this.data = new Float32Array(r.length)), this.uvMatrix.multiplyUvs(r, this.data), this._updateID++
    }
}
const Qv = new Se,
    CS = new Ba,
    Y$ = class extends jr {
        constructor(e, t, r, n = Zn.TRIANGLES) {
            super(), this.geometry = e, this.shader = t, this.state = r || ki.for2d(), this.drawMode = n, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = ce.ROUND_PIXELS, this.batchUvs = null
        }
        get geometry() {
            return this._geometry
        }
        set geometry(e) {
            this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1)
        }
        get uvBuffer() {
            return this.geometry.buffers[1]
        }
        get verticesBuffer() {
            return this.geometry.buffers[0]
        }
        set material(e) {
            this.shader = e
        }
        get material() {
            return this.shader
        }
        set blendMode(e) {
            this.state.blendMode = e
        }
        get blendMode() {
            return this.state.blendMode
        }
        set roundPixels(e) {
            this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e
        }
        get roundPixels() {
            return this._roundPixels
        }
        get tint() {
            return "tint" in this.shader ? this.shader.tint : null
        }
        set tint(e) {
            this.shader.tint = e
        }
        get tintValue() {
            return this.shader.tintValue
        }
        get texture() {
            return "texture" in this.shader ? this.shader.texture : null
        }
        set texture(e) {
            this.shader.texture = e
        }
        _render(e) {
            const t = this.geometry.buffers[0].data;
            this.shader.batchable && this.drawMode === Zn.TRIANGLES && t.length < Y$.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e)
        }
        _renderDefault(e) {
            const t = this.shader;
            t.alpha = this.worldAlpha, t.update && t.update(), e.batch.flush(), t.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(t), e.state.set(this.state), e.geometry.bind(this.geometry, t), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
        }
        _renderToBatch(e) {
            const t = this.geometry,
                r = this.shader;
            r.uvMatrix && (r.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = t.indexBuffer.data, this._tintRGB = r._tintRGB, this._texture = r.texture;
            const n = this.material.pluginName;
            e.batch.setObjectRenderer(e.plugins[n]), e.plugins[n].render(this)
        }
        calculateVertices() {
            const t = this.geometry.buffers[0],
                r = t.data,
                n = t._updateID;
            if (n === this.vertexDirty && this._transformID === this.transform._worldID) return;
            this._transformID = this.transform._worldID, this.vertexData.length !== r.length && (this.vertexData = new Float32Array(r.length));
            const i = this.transform.worldTransform,
                s = i.a,
                o = i.b,
                a = i.c,
                l = i.d,
                c = i.tx,
                u = i.ty,
                h = this.vertexData;
            for (let d = 0; d < h.length / 2; d++) {
                const f = r[d * 2],
                    p = r[d * 2 + 1];
                h[d * 2] = s * f + a * p + c, h[d * 2 + 1] = o * f + l * p + u
            }
            if (this._roundPixels) {
                const d = ce.RESOLUTION;
                for (let f = 0; f < h.length; ++f) h[f] = Math.round(h[f] * d) / d
            }
            this.vertexDirty = n
        }
        calculateUvs() {
            const e = this.geometry.buffers[1],
                t = this.shader;
            t.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new GU(e, t.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
        }
        _calculateBounds() {
            this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
        }
        containsPoint(e) {
            if (!this.getBounds().contains(e.x, e.y)) return !1;
            this.worldTransform.applyInverse(e, Qv);
            const t = this.geometry.getBuffer("aVertexPosition").data,
                r = CS.points,
                n = this.geometry.getIndex().data,
                i = n.length,
                s = this.drawMode === 4 ? 3 : 1;
            for (let o = 0; o + 2 < i; o += s) {
                const a = n[o] * 2,
                    l = n[o + 1] * 2,
                    c = n[o + 2] * 2;
                if (r[0] = t[a], r[1] = t[a + 1], r[2] = t[l], r[3] = t[l + 1], r[4] = t[c], r[5] = t[c + 1], CS.contains(Qv.x, Qv.y)) return !0
            }
            return !1
        }
        destroy(e) {
            super.destroy(e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
        }
    };
let n_ = Y$;
n_.BATCHABLE_SIZE = 100;
class VU extends Ps {
    constructor(t, r, n) {
        super();
        const i = new Ct(t),
            s = new Ct(r, !0),
            o = new Ct(n, !0, !0);
        this.addAttribute("aVertexPosition", i, 2, !1, be.FLOAT).addAttribute("aTextureCoord", s, 2, !1, be.FLOAT).addIndex(o), this._updateId = -1
    }
    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}
var WU = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`,
    XU = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
class TS extends ni {
    constructor(t, r) {
        const n = {
            uSampler: t,
            alpha: 1,
            uTextureMatrix: mt.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1])
        };
        r = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
        }, r), r.uniforms && Object.assign(n, r.uniforms), super(r.program || En.from(XU, WU), n), this._colorDirty = !1, this.uvMatrix = new _$(t), this.batchable = r.program === void 0, this.pluginName = r.pluginName, this._tintColor = new ot(r.tint), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0, this.alpha = r.alpha
    }
    get texture() {
        return this.uniforms.uSampler
    }
    set texture(t) {
        this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = t, this.uvMatrix.texture = t)
    }
    set alpha(t) {
        t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
    }
    get alpha() {
        return this._alpha
    }
    set tint(t) {
        t !== this.tint && (this._tintColor.setValue(t), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0)
    }
    get tint() {
        return this._tintColor.value
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    update() {
        if (this._colorDirty) {
            this._colorDirty = !1;
            const r = this.texture.baseTexture.alphaMode;
            ot.shared.setValue(this._tintColor).premultiply(this._alpha, r).toArray(this.uniforms.uColor)
        }
        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}
class OS {
    constructor(t, r, n) {
        this.geometry = new Ps, this.indexBuffer = null, this.size = n, this.dynamicProperties = [], this.staticProperties = [];
        for (let i = 0; i < t.length; ++i) {
            let s = t[i];
            s = {
                attributeName: s.attributeName,
                size: s.size,
                uploadFunction: s.uploadFunction,
                type: s.type || be.FLOAT,
                offset: s.offset
            }, r[i] ? this.dynamicProperties.push(s) : this.staticProperties.push(s)
        }
        this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
    }
    initBuffers() {
        const t = this.geometry;
        let r = 0;
        this.indexBuffer = new Ct(Z7(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            a.offset = r, r += a.size, this.dynamicStride += a.size
        }
        const n = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(n), this.dynamicDataUint32 = new Uint32Array(n), this.dynamicBuffer = new Ct(this.dynamicData, !1, !1);
        let i = 0;
        this.staticStride = 0;
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            a.offset = i, i += a.size, this.staticStride += a.size
        }
        const s = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(s), this.staticDataUint32 = new Uint32Array(s), this.staticBuffer = new Ct(this.staticData, !0, !1);
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            t.addAttribute(a.attributeName, this.dynamicBuffer, 0, a.type === be.UNSIGNED_BYTE, a.type, this.dynamicStride * 4, a.offset * 4)
        }
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            t.addAttribute(a.attributeName, this.staticBuffer, 0, a.type === be.UNSIGNED_BYTE, a.type, this.staticStride * 4, a.offset * 4)
        }
    }
    uploadDynamic(t, r, n) {
        for (let i = 0; i < this.dynamicProperties.length; i++) {
            const s = this.dynamicProperties[i];
            s.uploadFunction(t, r, n, s.type === be.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, s.offset)
        }
        this.dynamicBuffer._updateID++
    }
    uploadStatic(t, r, n) {
        for (let i = 0; i < this.staticProperties.length; i++) {
            const s = this.staticProperties[i];
            s.uploadFunction(t, r, n, s.type === be.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, s.offset)
        }
        this.staticBuffer._updateID++
    }
    destroy() {
        this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
    }
}
var YU = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`,
    KU = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
class K$ extends km {
    constructor(t) {
        super(t), this.shader = null, this.properties = null, this.tempMatrix = new mt, this.properties = [{
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
        }, {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
        }, {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
        }, {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
        }, {
            attributeName: "aColor",
            size: 1,
            type: be.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0
        }], this.shader = ni.from(KU, YU, {}), this.state = ki.for2d()
    }
    render(t) {
        const r = t.children,
            n = t._maxSize,
            i = t._batchSize,
            s = this.renderer;
        let o = r.length;
        if (o === 0) return;
        o > n && !t.autoResize && (o = n);
        let a = t._buffers;
        a || (a = t._buffers = this.generateBuffers(t));
        const l = r[0]._texture.baseTexture,
            c = l.alphaMode > 0;
        this.state.blendMode = JI(t.blendMode, c), s.state.set(this.state);
        const u = s.gl,
            h = t.worldTransform.copyTo(this.tempMatrix);
        h.prepend(s.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = h.toArray(!0), this.shader.uniforms.uColor = ot.shared.setValue(t.tintRgb).premultiply(t.worldAlpha, c).toArray(this.shader.uniforms.uColor), this.shader.uniforms.uSampler = l, this.renderer.shader.bind(this.shader);
        let d = !1;
        for (let f = 0, p = 0; f < o; f += i, p += 1) {
            let m = o - f;
            m > i && (m = i), p >= a.length && a.push(this._generateOneMoreBuffer(t));
            const w = a[p];
            w.uploadDynamic(r, f, m);
            const y = t._bufferUpdateIDs[p] || 0;
            d = d || w._updateID < y, d && (w._updateID = t._updateID, w.uploadStatic(r, f, m)), s.geometry.bind(w.geometry), u.drawElements(u.TRIANGLES, m * 6, u.UNSIGNED_SHORT, 0)
        }
    }
    generateBuffers(t) {
        const r = [],
            n = t._maxSize,
            i = t._batchSize,
            s = t._properties;
        for (let o = 0; o < n; o += i) r.push(new OS(this.properties, s, i));
        return r
    }
    _generateOneMoreBuffer(t) {
        const r = t._batchSize,
            n = t._properties;
        return new OS(this.properties, n, r)
    }
    uploadVertices(t, r, n, i, s, o) {
        let a = 0,
            l = 0,
            c = 0,
            u = 0;
        for (let h = 0; h < n; ++h) {
            const d = t[r + h],
                f = d._texture,
                p = d.scale.x,
                m = d.scale.y,
                w = f.trim,
                y = f.orig;
            w ? (l = w.x - d.anchor.x * y.width, a = l + w.width, u = w.y - d.anchor.y * y.height, c = u + w.height) : (a = y.width * (1 - d.anchor.x), l = y.width * -d.anchor.x, c = y.height * (1 - d.anchor.y), u = y.height * -d.anchor.y), i[o] = l * p, i[o + 1] = u * m, i[o + s] = a * p, i[o + s + 1] = u * m, i[o + s * 2] = a * p, i[o + s * 2 + 1] = c * m, i[o + s * 3] = l * p, i[o + s * 3 + 1] = c * m, o += s * 4
        }
    }
    uploadPosition(t, r, n, i, s, o) {
        for (let a = 0; a < n; a++) {
            const l = t[r + a].position;
            i[o] = l.x, i[o + 1] = l.y, i[o + s] = l.x, i[o + s + 1] = l.y, i[o + s * 2] = l.x, i[o + s * 2 + 1] = l.y, i[o + s * 3] = l.x, i[o + s * 3 + 1] = l.y, o += s * 4
        }
    }
    uploadRotation(t, r, n, i, s, o) {
        for (let a = 0; a < n; a++) {
            const l = t[r + a].rotation;
            i[o] = l, i[o + s] = l, i[o + s * 2] = l, i[o + s * 3] = l, o += s * 4
        }
    }
    uploadUvs(t, r, n, i, s, o) {
        for (let a = 0; a < n; ++a) {
            const l = t[r + a]._texture._uvs;
            l ? (i[o] = l.x0, i[o + 1] = l.y0, i[o + s] = l.x1, i[o + s + 1] = l.y1, i[o + s * 2] = l.x2, i[o + s * 2 + 1] = l.y2, i[o + s * 3] = l.x3, i[o + s * 3 + 1] = l.y3, o += s * 4) : (i[o] = 0, i[o + 1] = 0, i[o + s] = 0, i[o + s + 1] = 0, i[o + s * 2] = 0, i[o + s * 2 + 1] = 0, i[o + s * 3] = 0, i[o + s * 3 + 1] = 0, o += s * 4)
        }
    }
    uploadTint(t, r, n, i, s, o) {
        for (let a = 0; a < n; ++a) {
            const l = t[r + a],
                c = ot.shared.setValue(l._tintRGB).toPremultiplied(l.alpha, l.texture.baseTexture.alphaMode > 0);
            i[o] = c, i[o + s] = c, i[o + s * 2] = c, i[o + s * 3] = c, o += s * 4
        }
    }
    destroy() {
        super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
    }
}
K$.extension = {
    name: "particle",
    type: ue.RendererPlugin
};
ye.add(K$);
var Hm = (e => (e[e.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", e[e.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", e))(Hm || {});
const kh = {
        willReadFrequently: !0
    },
    me = class {
        static get experimentalLetterSpacingSupported() {
            let e = me._experimentalLetterSpacingSupported;
            if (e !== void 0) {
                const t = ce.ADAPTER.getCanvasRenderingContext2D().prototype;
                e = me._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t
            }
            return e
        }
        constructor(e, t, r, n, i, s, o, a, l) {
            this.text = e, this.style = t, this.width = r, this.height = n, this.lines = i, this.lineWidths = s, this.lineHeight = o, this.maxLineWidth = a, this.fontProperties = l
        }
        static measureText(e, t, r, n = me._canvas) {
            r = r??t.wordWrap;
            const i = t.toFontString(),
                s = me.measureFont(i);
            s.fontSize === 0 && (s.fontSize = t.fontSize, s.ascent = t.fontSize);
            const o = n.getContext("2d", kh);
            o.font = i;
            const l = (r ? me.wordWrap(e, t, n) : e).split(/(?:\r\n|\r|\n)/),
                c = new Array(l.length);
            let u = 0;
            for (let p = 0; p < l.length; p++) {
                const m = me._measureText(l[p], t.letterSpacing, o);
                c[p] = m, u = Math.max(u, m)
            }
            let h = u + t.strokeThickness;
            t.dropShadow && (h += t.dropShadowDistance);
            const d = t.lineHeight || s.fontSize + t.strokeThickness;
            let f = Math.max(d, s.fontSize + t.strokeThickness * 2) + (l.length - 1) * (d + t.leading);
            return t.dropShadow && (f += t.dropShadowDistance), new me(e, t, h, f, l, c, d + t.leading, u, s)
        }
        static _measureText(e, t, r) {
            let n = !1;
            me.experimentalLetterSpacingSupported && (me.experimentalLetterSpacing ? (r.letterSpacing = `${t}px`, r.textLetterSpacing = `${t}px`, n = !0) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
            let i = r.measureText(e).width;
            return i > 0 && (n ? i -= t : i += (me.graphemeSegmenter(e).length - 1) * t), i
        }
        static wordWrap(e, t, r = me._canvas) {
            const n = r.getContext("2d", kh);
            let i = 0,
                s = "",
                o = "";
            const a = Object.create(null),
                {
                    letterSpacing: l,
                    whiteSpace: c
                } = t,
                u = me.collapseSpaces(c),
                h = me.collapseNewlines(c);
            let d = !u;
            const f = t.wordWrapWidth + l,
                p = me.tokenize(e);
            for (let m = 0; m < p.length; m++) {
                let w = p[m];
                if (me.isNewline(w)) {
                    if (!h) {
                        o += me.addLine(s), d = !u, s = "", i = 0;
                        continue
                    }
                    w = " "
                }
                if (u) {
                    const v = me.isBreakingSpace(w),
                        _ = me.isBreakingSpace(s[s.length - 1]);
                    if (v && _) continue
                }
                const y = me.getFromCache(w, l, a, n);
                if (y > f)
                    if (s !== "" && (o += me.addLine(s), s = "", i = 0), me.canBreakWords(w, t.breakWords)) {
                        const v = me.wordWrapSplit(w);
                        for (let _ = 0; _ < v.length; _++) {
                            let E = v[_],
                                P = E,
                                C = 1;
                            for (; v[_ + C];) {
                                const O = v[_ + C];
                                if (!me.canBreakChars(P, O, w, _, t.breakWords)) E += O;
                                else break;
                                P = O, C++
                            }
                            _ += C - 1;
                            const T = me.getFromCache(E, l, a, n);
                            T + i > f && (o += me.addLine(s), d = !1, s = "", i = 0), s += E, i += T
                        }
                    } else {
                        s.length > 0 && (o += me.addLine(s), s = "", i = 0);
                        const v = m === p.length - 1;
                        o += me.addLine(w, !v), d = !1, s = "", i = 0
                    }
                else y + i > f && (d = !1, o += me.addLine(s), s = "", i = 0), (s.length > 0 || !me.isBreakingSpace(w) || d) && (s += w, i += y)
            }
            return o += me.addLine(s, !1), o
        }
        static addLine(e, t = !0) {
            return e = me.trimRight(e), e = t ? `${e}
` : e, e
        }
        static getFromCache(e, t, r, n) {
            let i = r[e];
            return typeof i != "number" && (i = me._measureText(e, t, n) + t, r[e] = i), i
        }
        static collapseSpaces(e) {
            return e === "normal" || e === "pre-line"
        }
        static collapseNewlines(e) {
            return e === "normal"
        }
        static trimRight(e) {
            if (typeof e != "string") return "";
            for (let t = e.length - 1; t >= 0; t--) {
                const r = e[t];
                if (!me.isBreakingSpace(r)) break;
                e = e.slice(0, -1)
            }
            return e
        }
        static isNewline(e) {
            return typeof e != "string" ? !1 : me._newlines.includes(e.charCodeAt(0))
        }
        static isBreakingSpace(e, t) {
            return typeof e != "string" ? !1 : me._breakingSpaces.includes(e.charCodeAt(0))
        }
        static tokenize(e) {
            const t = [];
            let r = "";
            if (typeof e != "string") return t;
            for (let n = 0; n < e.length; n++) {
                const i = e[n],
                    s = e[n + 1];
                if (me.isBreakingSpace(i, s) || me.isNewline(i)) {
                    r !== "" && (t.push(r), r = ""), t.push(i);
                    continue
                }
                r += i
            }
            return r !== "" && t.push(r), t
        }
        static canBreakWords(e, t) {
            return t
        }
        static canBreakChars(e, t, r, n, i) {
            return !0
        }
        static wordWrapSplit(e) {
            return me.graphemeSegmenter(e)
        }
        static measureFont(e) {
            if (me._fonts[e]) return me._fonts[e];
            const t = {
                    ascent: 0,
                    descent: 0,
                    fontSize: 0
                },
                r = me._canvas,
                n = me._context;
            n.font = e;
            const i = me.METRICS_STRING + me.BASELINE_SYMBOL,
                s = Math.ceil(n.measureText(i).width);
            let o = Math.ceil(n.measureText(me.BASELINE_SYMBOL).width);
            const a = Math.ceil(me.HEIGHT_MULTIPLIER * o);
            if (o = o * me.BASELINE_MULTIPLIER | 0, s === 0 || a === 0) return me._fonts[e] = t, t;
            r.width = s, r.height = a, n.fillStyle = "#f00", n.fillRect(0, 0, s, a), n.font = e, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText(i, 0, o);
            const l = n.getImageData(0, 0, s, a).data,
                c = l.length,
                u = s * 4;
            let h = 0,
                d = 0,
                f = !1;
            for (h = 0; h < o; ++h) {
                for (let p = 0; p < u; p += 4)
                    if (l[d + p] !== 255) {
                        f = !0;
                        break
                    }
                if (!f) d += u;
                else break
            }
            for (t.ascent = o - h, d = c - u, f = !1, h = a; h > o; --h) {
                for (let p = 0; p < u; p += 4)
                    if (l[d + p] !== 255) {
                        f = !0;
                        break
                    }
                if (!f) d -= u;
                else break
            }
            return t.descent = h - o, t.fontSize = t.ascent + t.descent, me._fonts[e] = t, t
        }
        static clearMetrics(e = "") {
            e ? delete me._fonts[e] : me._fonts = {}
        }
        static get _canvas() {
            if (!me.__canvas) {
                let e;
                try {
                    const t = new OffscreenCanvas(0, 0),
                        r = t.getContext("2d", kh);
                    if (r != null && r.measureText) return me.__canvas = t, t;
                    e = ce.ADAPTER.createCanvas()
                } catch {
                    e = ce.ADAPTER.createCanvas()
                }
                e.width = e.height = 10, me.__canvas = e
            }
            return me.__canvas
        }
        static get _context() {
            return me.__context || (me.__context = me._canvas.getContext("2d", kh)), me.__context
        }
    };
let er = me;
er.METRICS_STRING = "|ÉqÅ";
er.BASELINE_SYMBOL = "M";
er.BASELINE_MULTIPLIER = 1.4;
er.HEIGHT_MULTIPLIER = 2;
er.graphemeSegmenter = (() => {
    if (typeof(Intl == null ? void 0 : Intl.Segmenter) == "function") {
        const e = new Intl.Segmenter;
        return t => [...e.segment(t)].map(r => r.segment)
    }
    return e => [...e]
})();
er.experimentalLetterSpacing = !1;
er._fonts = {};
er._newlines = [10, 13];
er._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
const qU = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
    hc = class {
        constructor(e) {
            this.styleID = 0, this.reset(), Jv(this, e, e)
        }
        clone() {
            const e = {};
            return Jv(e, this, hc.defaultStyle), new hc(e)
        }
        reset() {
            Jv(this, hc.defaultStyle, hc.defaultStyle)
        }
        get align() {
            return this._align
        }
        set align(e) {
            this._align !== e && (this._align = e, this.styleID++)
        }
        get breakWords() {
            return this._breakWords
        }
        set breakWords(e) {
            this._breakWords !== e && (this._breakWords = e, this.styleID++)
        }
        get dropShadow() {
            return this._dropShadow
        }
        set dropShadow(e) {
            this._dropShadow !== e && (this._dropShadow = e, this.styleID++)
        }
        get dropShadowAlpha() {
            return this._dropShadowAlpha
        }
        set dropShadowAlpha(e) {
            this._dropShadowAlpha !== e && (this._dropShadowAlpha = e, this.styleID++)
        }
        get dropShadowAngle() {
            return this._dropShadowAngle
        }
        set dropShadowAngle(e) {
            this._dropShadowAngle !== e && (this._dropShadowAngle = e, this.styleID++)
        }
        get dropShadowBlur() {
            return this._dropShadowBlur
        }
        set dropShadowBlur(e) {
            this._dropShadowBlur !== e && (this._dropShadowBlur = e, this.styleID++)
        }
        get dropShadowColor() {
            return this._dropShadowColor
        }
        set dropShadowColor(e) {
            const t = Zv(e);
            this._dropShadowColor !== t && (this._dropShadowColor = t, this.styleID++)
        }
        get dropShadowDistance() {
            return this._dropShadowDistance
        }
        set dropShadowDistance(e) {
            this._dropShadowDistance !== e && (this._dropShadowDistance = e, this.styleID++)
        }
        get fill() {
            return this._fill
        }
        set fill(e) {
            const t = Zv(e);
            this._fill !== t && (this._fill = t, this.styleID++)
        }
        get fillGradientType() {
            return this._fillGradientType
        }
        set fillGradientType(e) {
            this._fillGradientType !== e && (this._fillGradientType = e, this.styleID++)
        }
        get fillGradientStops() {
            return this._fillGradientStops
        }
        set fillGradientStops(e) {
            QU(this._fillGradientStops, e) || (this._fillGradientStops = e, this.styleID++)
        }
        get fontFamily() {
            return this._fontFamily
        }
        set fontFamily(e) {
            this.fontFamily !== e && (this._fontFamily = e, this.styleID++)
        }
        get fontSize() {
            return this._fontSize
        }
        set fontSize(e) {
            this._fontSize !== e && (this._fontSize = e, this.styleID++)
        }
        get fontStyle() {
            return this._fontStyle
        }
        set fontStyle(e) {
            this._fontStyle !== e && (this._fontStyle = e, this.styleID++)
        }
        get fontVariant() {
            return this._fontVariant
        }
        set fontVariant(e) {
            this._fontVariant !== e && (this._fontVariant = e, this.styleID++)
        }
        get fontWeight() {
            return this._fontWeight
        }
        set fontWeight(e) {
            this._fontWeight !== e && (this._fontWeight = e, this.styleID++)
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(e) {
            this._letterSpacing !== e && (this._letterSpacing = e, this.styleID++)
        }
        get lineHeight() {
            return this._lineHeight
        }
        set lineHeight(e) {
            this._lineHeight !== e && (this._lineHeight = e, this.styleID++)
        }
        get leading() {
            return this._leading
        }
        set leading(e) {
            this._leading !== e && (this._leading = e, this.styleID++)
        }
        get lineJoin() {
            return this._lineJoin
        }
        set lineJoin(e) {
            this._lineJoin !== e && (this._lineJoin = e, this.styleID++)
        }
        get miterLimit() {
            return this._miterLimit
        }
        set miterLimit(e) {
            this._miterLimit !== e && (this._miterLimit = e, this.styleID++)
        }
        get padding() {
            return this._padding
        }
        set padding(e) {
            this._padding !== e && (this._padding = e, this.styleID++)
        }
        get stroke() {
            return this._stroke
        }
        set stroke(e) {
            const t = Zv(e);
            this._stroke !== t && (this._stroke = t, this.styleID++)
        }
        get strokeThickness() {
            return this._strokeThickness
        }
        set strokeThickness(e) {
            this._strokeThickness !== e && (this._strokeThickness = e, this.styleID++)
        }
        get textBaseline() {
            return this._textBaseline
        }
        set textBaseline(e) {
            this._textBaseline !== e && (this._textBaseline = e, this.styleID++)
        }
        get trim() {
            return this._trim
        }
        set trim(e) {
            this._trim !== e && (this._trim = e, this.styleID++)
        }
        get whiteSpace() {
            return this._whiteSpace
        }
        set whiteSpace(e) {
            this._whiteSpace !== e && (this._whiteSpace = e, this.styleID++)
        }
        get wordWrap() {
            return this._wordWrap
        }
        set wordWrap(e) {
            this._wordWrap !== e && (this._wordWrap = e, this.styleID++)
        }
        get wordWrapWidth() {
            return this._wordWrapWidth
        }
        set wordWrapWidth(e) {
            this._wordWrapWidth !== e && (this._wordWrapWidth = e, this.styleID++)
        }
        toFontString() {
            const e = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
            let t = this.fontFamily;
            Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
            for (let r = t.length - 1; r >= 0; r--) {
                let n = t[r].trim();
                !/([\"\'])[^\'\"]+\1/.test(n) && !qU.includes(n) && (n = `"${n}"`), t[r] = n
            }
            return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${e} ${t.join(",")}`
        }
    };
let $i = hc;
$i.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: Hm.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};

function Zv(e) {
    const t = ot.shared;
    return Array.isArray(e) ? e.map(r => t.setValue(r).toHex()) : t.setValue(e).toHex()
}

function QU(e, t) {
    if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length) return !1;
    for (let r = 0; r < e.length; ++r)
        if (e[r] !== t[r]) return !1;
    return !0
}

function Jv(e, t, r) {
    for (const n in r) Array.isArray(t[n]) ? e[n] = t[n].slice() : e[n] = t[n]
}
const ZU = {
        texture: !0,
        children: !1,
        baseTexture: !0
    },
    i_ = class extends pl {
        constructor(t, r, n) {
            let i = !1;
            n || (n = ce.ADAPTER.createCanvas(), i = !0), n.width = 3, n.height = 3;
            const s = ge.from(n);
            s.orig = new $e, s.trim = new $e, super(s), this._ownCanvas = i, this.canvas = n, this.context = n.getContext("2d", {
                willReadFrequently: !0
            }), this._resolution = i_.defaultResolution??ce.RESOLUTION, this._autoResolution = i_.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = t, this.style = r, this.localStyleID = -1
        }
        static get experimentalLetterSpacing() {
            return er.experimentalLetterSpacing
        }
        static set experimentalLetterSpacing(t) {
            ze("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"), er.experimentalLetterSpacing = t
        }
        updateText(t) {
            const r = this._style;
            if (this.localStyleID !== r.styleID && (this.dirty = !0, this.localStyleID = r.styleID), !this.dirty && t) return;
            this._font = this._style.toFontString();
            const n = this.context,
                i = er.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
                s = i.width,
                o = i.height,
                a = i.lines,
                l = i.lineHeight,
                c = i.lineWidths,
                u = i.maxLineWidth,
                h = i.fontProperties;
            this.canvas.width = Math.ceil(Math.ceil(Math.max(1, s) + r.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, o) + r.padding * 2) * this._resolution), n.scale(this._resolution, this._resolution), n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.font = this._font, n.lineWidth = r.strokeThickness, n.textBaseline = r.textBaseline, n.lineJoin = r.lineJoin, n.miterLimit = r.miterLimit;
            let d, f;
            const p = r.dropShadow ? 2 : 1;
            for (let m = 0; m < p; ++m) {
                const w = r.dropShadow && m === 0,
                    y = w ? Math.ceil(Math.max(1, o) + r.padding * 2) : 0,
                    v = y * this._resolution;
                if (w) {
                    n.fillStyle = "black", n.strokeStyle = "black";
                    const E = r.dropShadowColor,
                        P = r.dropShadowBlur * this._resolution,
                        C = r.dropShadowDistance * this._resolution;
                    n.shadowColor = ot.shared.setValue(E).setAlpha(r.dropShadowAlpha).toRgbaString(), n.shadowBlur = P, n.shadowOffsetX = Math.cos(r.dropShadowAngle) * C, n.shadowOffsetY = Math.sin(r.dropShadowAngle) * C + v
                } else n.fillStyle = this._generateFillStyle(r, a, i), n.strokeStyle = r.stroke, n.shadowColor = "black", n.shadowBlur = 0, n.shadowOffsetX = 0, n.shadowOffsetY = 0;
                let _ = (l - h.fontSize) / 2;
                l - h.fontSize < 0 && (_ = 0);
                for (let E = 0; E < a.length; E++) d = r.strokeThickness / 2, f = r.strokeThickness / 2 + E * l + h.ascent + _, r.align === "right" ? d += u - c[E] : r.align === "center" && (d += (u - c[E]) / 2), r.stroke && r.strokeThickness && this.drawLetterSpacing(a[E], d + r.padding, f + r.padding - y, !0), r.fill && this.drawLetterSpacing(a[E], d + r.padding, f + r.padding - y)
            }
            this.updateTexture()
        }
        drawLetterSpacing(t, r, n, i = !1) {
            const o = this._style.letterSpacing;
            let a = !1;
            if (er.experimentalLetterSpacingSupported && (er.experimentalLetterSpacing ? (this.context.letterSpacing = `${o}px`, this.context.textLetterSpacing = `${o}px`, a = !0) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), o === 0 || a) {
                i ? this.context.strokeText(t, r, n) : this.context.fillText(t, r, n);
                return
            }
            let l = r;
            const c = er.graphemeSegmenter(t);
            let u = this.context.measureText(t).width,
                h = 0;
            for (let d = 0; d < c.length; ++d) {
                const f = c[d];
                i ? this.context.strokeText(f, l, n) : this.context.fillText(f, l, n);
                let p = "";
                for (let m = d + 1; m < c.length; ++m) p += c[m];
                h = this.context.measureText(p).width, l += u - h + o, u = h
            }
        }
        updateTexture() {
            const t = this.canvas;
            if (this._style.trim) {
                const o = rz(t);
                o.data && (t.width = o.width, t.height = o.height, this.context.putImageData(o.data, 0, 0))
            }
            const r = this._texture,
                n = this._style,
                i = n.trim ? 0 : n.padding,
                s = r.baseTexture;
            r.trim.width = r._frame.width = t.width / this._resolution, r.trim.height = r._frame.height = t.height / this._resolution, r.trim.x = -i, r.trim.y = -i, r.orig.width = r._frame.width - i * 2, r.orig.height = r._frame.height - i * 2, this._onTextureUpdate(), s.setRealSize(t.width, t.height, this._resolution), r.updateUvs(), this.dirty = !1
        }
        _render(t) {
            this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0), this.updateText(!0), super._render(t)
        }
        updateTransform() {
            this.updateText(!0), super.updateTransform()
        }
        getBounds(t, r) {
            return this.updateText(!0), this._textureID === -1 && (t = !1), super.getBounds(t, r)
        }
        getLocalBounds(t) {
            return this.updateText(!0), super.getLocalBounds.call(this, t)
        }
        _calculateBounds() {
            this.calculateVertices(), this._bounds.addQuad(this.vertexData)
        }
        _generateFillStyle(t, r, n) {
            const i = t.fill;
            if (Array.isArray(i)) {
                if (i.length === 1) return i[0]
            } else return i;
            let s;
            const o = t.dropShadow ? t.dropShadowDistance : 0,
                a = t.padding || 0,
                l = this.canvas.width / this._resolution - o - a * 2,
                c = this.canvas.height / this._resolution - o - a * 2,
                u = i.slice(),
                h = t.fillGradientStops.slice();
            if (!h.length) {
                const d = u.length + 1;
                for (let f = 1; f < d; ++f) h.push(f / d)
            }
            if (u.unshift(i[0]), h.unshift(0), u.push(i[i.length - 1]), h.push(1), t.fillGradientType === Hm.LINEAR_VERTICAL) {
                s = this.context.createLinearGradient(l / 2, a, l / 2, c + a);
                const d = n.fontProperties.fontSize + t.strokeThickness;
                for (let f = 0; f < r.length; f++) {
                    const p = n.lineHeight * (f - 1) + d,
                        m = n.lineHeight * f;
                    let w = m;
                    f > 0 && p > m && (w = (m + p) / 2);
                    const y = m + d,
                        v = n.lineHeight * (f + 1);
                    let _ = y;
                    f + 1 < r.length && v < y && (_ = (y + v) / 2);
                    const E = (_ - w) / c;
                    for (let P = 0; P < u.length; P++) {
                        let C = 0;
                        typeof h[P] == "number" ? C = h[P] : C = P / u.length;
                        let T = Math.min(1, Math.max(0, w / c + C * E));
                        T = Number(T.toFixed(5)), s.addColorStop(T, u[P])
                    }
                }
            } else {
                s = this.context.createLinearGradient(a, c / 2, l + a, c / 2);
                const d = u.length + 1;
                let f = 1;
                for (let p = 0; p < u.length; p++) {
                    let m;
                    typeof h[p] == "number" ? m = h[p] : m = f / d, s.addColorStop(m, u[p]), f++
                }
            }
            return s
        }
        destroy(t) {
            typeof t == "boolean" && (t = {
                children: t
            }), t = Object.assign({}, ZU, t), super.destroy(t), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
        }
        get width() {
            return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
        }
        set width(t) {
            this.updateText(!0);
            const r = is(this.scale.x) || 1;
            this.scale.x = r * t / this._texture.orig.width, this._width = t
        }
        get height() {
            return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
        }
        set height(t) {
            this.updateText(!0);
            const r = is(this.scale.y) || 1;
            this.scale.y = r * t / this._texture.orig.height, this._height = t
        }
        get style() {
            return this._style
        }
        set style(t) {
            t = t || {}, t instanceof $i ? this._style = t : this._style = new $i(t), this.localStyleID = -1, this.dirty = !0
        }
        get text() {
            return this._text
        }
        set text(t) {
            t = String(t??""), this._text !== t && (this._text = t, this.dirty = !0)
        }
        get resolution() {
            return this._resolution
        }
        set resolution(t) {
            this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0)
        }
    };
let iw = i_;
iw.defaultAutoResolution = !0;
class JU {
    constructor(t) {
        this.maxItemsPerFrame = t, this.itemsLeft = 0
    }
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }
    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}

function eH(e, t) {
    var n;
    let r = !1;
    if ((n = e == null ? void 0 : e._textures) != null && n.length) {
        for (let i = 0; i < e._textures.length; i++)
            if (e._textures[i] instanceof ge) {
                const s = e._textures[i].baseTexture;
                t.includes(s) || (t.push(s), r = !0)
            }
    }
    return r
}

function tH(e, t) {
    if (e.baseTexture instanceof Oe) {
        const r = e.baseTexture;
        return t.includes(r) || t.push(r), !0
    }
    return !1
}

function rH(e, t) {
    if (e._texture && e._texture instanceof ge) {
        const r = e._texture.baseTexture;
        return t.includes(r) || t.push(r), !0
    }
    return !1
}

function nH(e, t) {
    return t instanceof iw ? (t.updateText(!0), !0) : !1
}

function iH(e, t) {
    if (t instanceof $i) {
        const r = t.toFontString();
        return er.measureFont(r), !0
    }
    return !1
}

function sH(e, t) {
    if (e instanceof iw) {
        t.includes(e.style) || t.push(e.style), t.includes(e) || t.push(e);
        const r = e._texture.baseTexture;
        return t.includes(r) || t.push(r), !0
    }
    return !1
}

function oH(e, t) {
    return e instanceof $i ? (t.includes(e) || t.push(e), !0) : !1
}
const q$ = class {
    constructor(e) {
        this.limiter = new JU(q$.uploadsPerFrame), this.renderer = e, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = () => {
            this.queue && this.prepareItems()
        }, this.registerFindHook(sH), this.registerFindHook(oH), this.registerFindHook(eH), this.registerFindHook(tH), this.registerFindHook(rH), this.registerUploadHook(nH), this.registerUploadHook(iH)
    }
    upload(e) {
        return new Promise(t => {
            e && this.add(e), this.queue.length ? (this.completes.push(t), this.ticking || (this.ticking = !0, Jt.system.addOnce(this.tick, this, _o.UTILITY))) : t()
        })
    }
    tick() {
        setTimeout(this.delayedTick, 0)
    }
    prepareItems() {
        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
            const e = this.queue[0];
            let t = !1;
            if (e && !e._destroyed) {
                for (let r = 0, n = this.uploadHooks.length; r < n; r++)
                    if (this.uploadHooks[r](this.uploadHookHelper, e)) {
                        this.queue.shift(), t = !0;
                        break
                    }
            }
            t || this.queue.shift()
        }
        if (this.queue.length) Jt.system.addOnce(this.tick, this, _o.UTILITY);
        else {
            this.ticking = !1;
            const e = this.completes.slice(0);
            this.completes.length = 0;
            for (let t = 0, r = e.length; t < r; t++) e[t]()
        }
    }
    registerFindHook(e) {
        return e && this.addHooks.push(e), this
    }
    registerUploadHook(e) {
        return e && this.uploadHooks.push(e), this
    }
    add(e) {
        for (let t = 0, r = this.addHooks.length; t < r && !this.addHooks[t](e, this.queue); t++);
        if (e instanceof jr)
            for (let t = e.children.length - 1; t >= 0; t--) this.add(e.children[t]);
        return this
    }
    destroy() {
        this.ticking && Jt.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
    }
};
let Cf = q$;
Cf.uploadsPerFrame = 4;
Object.defineProperties(ce, {
    UPLOADS_PER_FRAME: {
        get() {
            return Cf.uploadsPerFrame
        },
        set(e) {
            ze("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), Cf.uploadsPerFrame = e
        }
    }
});

function Q$(e, t) {
    return t instanceof Oe ? (t._glTextures[e.CONTEXT_UID] || e.texture.bind(t), !0) : !1
}

function aH(e, t) {
    if (!(t instanceof Um)) return !1;
    const {
        geometry: r
    } = t;
    t.finishPoly(), r.updateBatches();
    const {
        batches: n
    } = r;
    for (let i = 0; i < n.length; i++) {
        const {
            texture: s
        } = n[i].style;
        s && Q$(e, s.baseTexture)
    }
    return r.batchable || e.geometry.bind(r, t._resolveDirectShader(e)), !0
}

function lH(e, t) {
    return e instanceof Um ? (t.push(e), !0) : !1
}
class Z$ extends Cf {
    constructor(t) {
        super(t), this.uploadHookHelper = this.renderer, this.registerFindHook(lH), this.registerUploadHook(Q$), this.registerUploadHook(aH)
    }
}
Z$.extension = {
    name: "prepare",
    type: ue.RendererSystem
};
ye.add(Z$);
var cH = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`,
    uH = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
    hH = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`,
    AS = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
    dH = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const Mh = new mt;
class J$ extends km {
    constructor(t) {
        super(t), t.runners.contextChange.add(this), this.quad = new m$, this.state = ki.for2d()
    }
    contextChange() {
        const t = this.renderer,
            r = {
                globals: t.globalUniforms
            };
        this.simpleShader = ni.from(AS, dH, r), this.shader = t.context.webGLVersion > 1 ? ni.from(uH, cH, r) : ni.from(AS, hH, r)
    }
    render(t) {
        const r = this.renderer,
            n = this.quad;
        let i = n.vertices;
        i[0] = i[6] = t._width * -t.anchor.x, i[1] = i[3] = t._height * -t.anchor.y, i[2] = i[4] = t._width * (1 - t.anchor.x), i[5] = i[7] = t._height * (1 - t.anchor.y);
        const s = t.uvRespectAnchor ? t.anchor.x : 0,
            o = t.uvRespectAnchor ? t.anchor.y : 0;
        i = n.uvs, i[0] = i[6] = -s, i[1] = i[3] = -o, i[2] = i[4] = 1 - s, i[5] = i[7] = 1 - o, n.invalidate();
        const a = t._texture,
            l = a.baseTexture,
            c = l.alphaMode > 0,
            u = t.tileTransform.localTransform,
            h = t.uvMatrix;
        let d = l.isPowerOfTwo && a.frame.width === l.width && a.frame.height === l.height;
        d && (l._glTextures[r.CONTEXT_UID] ? d = l.wrapMode !== vs.CLAMP : l.wrapMode === vs.CLAMP && (l.wrapMode = vs.REPEAT));
        const f = d ? this.simpleShader : this.shader,
            p = a.width,
            m = a.height,
            w = t._width,
            y = t._height;
        Mh.set(u.a * p / w, u.b * p / y, u.c * m / w, u.d * m / y, u.tx / w, u.ty / y), Mh.invert(), d ? Mh.prepend(h.mapCoord) : (f.uniforms.uMapCoord = h.mapCoord.toArray(!0), f.uniforms.uClampFrame = h.uClampFrame, f.uniforms.uClampOffset = h.uClampOffset), f.uniforms.uTransform = Mh.toArray(!0), f.uniforms.uColor = ot.shared.setValue(t.tint).premultiply(t.worldAlpha, c).toArray(f.uniforms.uColor), f.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), f.uniforms.uSampler = a, r.shader.bind(f), r.geometry.bind(n), this.state.blendMode = JI(t.blendMode, c), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
    }
}
J$.extension = {
    name: "tilingSprite",
    type: ue.RendererPlugin
};
ye.add(J$);
const dc = class {
    constructor(e, t, r = null) {
        this.linkedSheets = [], this._texture = e instanceof ge ? e : null, this.baseTexture = e instanceof Oe ? e : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = t;
        const n = this.baseTexture.resource;
        this.resolution = this._updateResolution(r || (n ? n.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
    }
    _updateResolution(e = null) {
        const {
            scale: t
        } = this.data.meta;
        let r = Ss(e, null);
        return r === null && (r = parseFloat(t??"1")), r !== 1 && this.baseTexture.setResolution(r), r
    }
    parse() {
        return new Promise(e => {
            this._callback = e, this._batchIndex = 0, this._frameKeys.length <= dc.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
        })
    }
    _processFrames(e) {
        let t = e;
        const r = dc.BATCH_SIZE;
        for (; t - e < r && t < this._frameKeys.length;) {
            const n = this._frameKeys[t],
                i = this._frames[n],
                s = i.frame;
            if (s) {
                let o = null,
                    a = null;
                const l = i.trimmed !== !1 && i.sourceSize ? i.sourceSize : i.frame,
                    c = new $e(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);
                i.rotated ? o = new $e(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : o = new $e(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), i.trimmed !== !1 && i.spriteSourceSize && (a = new $e(Math.floor(i.spriteSourceSize.x) / this.resolution, Math.floor(i.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[n] = new ge(this.baseTexture, o, c, a, i.rotated ? 2 : 0, i.anchor, i.borders), ge.addToCache(this.textures[n], n)
            }
            t++
        }
    }
    _processAnimations() {
        const e = this.data.animations || {};
        for (const t in e) {
            this.animations[t] = [];
            for (let r = 0; r < e[t].length; r++) {
                const n = e[t][r];
                this.animations[t].push(this.textures[n])
            }
        }
    }
    _parseComplete() {
        const e = this._callback;
        this._callback = null, this._batchIndex = 0, e.call(this, this.textures)
    }
    _nextBatch() {
        this._processFrames(this._batchIndex * dc.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
            this._batchIndex * dc.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete())
        }, 0)
    }
    destroy(e = !1) {
        var t;
        for (const r in this.textures) this.textures[r].destroy();
        this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((t = this._texture) == null || t.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = []
    }
};
let s_ = dc;
s_.BATCH_SIZE = 1e3;
const fH = ["jpg", "png", "jpeg", "avif", "webp"];

function eR(e, t, r) {
    const n = {};
    if (e.forEach(i => {
            n[i] = t
        }), Object.keys(t.textures).forEach(i => {
            n[i] = t.textures[i]
        }), !r) {
        const i = hr.dirname(e[0]);
        t.linkedSheets.forEach((s, o) => {
            const a = eR([`${i}/${t.data.meta.related_multi_packs[o]}`], s, !0);
            Object.assign(n, a)
        })
    }
    return n
}
const pH = {
    extension: ue.Asset,
    cache: {
        test: e => e instanceof s_,
        getCacheableAssets: (e, t) => eR(e, t, !1)
    },
    resolver: {
        test: e => {
            const r = e.split("?")[0].split("."),
                n = r.pop(),
                i = r.pop();
            return n === "json" && fH.includes(i)
        },
        parse: e => {
            var r;
            const t = e.split(".");
            return {
                resolution: parseFloat(((r = ce.RETINA_PREFIX.exec(e)) == null ? void 0 : r[1])??"1"),
                format: t[t.length - 2],
                src: e
            }
        }
    },
    loader: {
        name: "spritesheetLoader",
        extension: {
            type: ue.LoadParser,
            priority: ai.Normal
        },
        async testParse(e, t) {
            return hr.extname(t.src).toLowerCase() === ".json" && !!e.frames
        },
        async parse(e, t, r) {
            var c, u;
            let n = hr.dirname(t.src);
            n && n.lastIndexOf("/") !== n.length - 1 && (n += "/");
            let i = n + e.meta.image;
            i = t_(i, t.src);
            const o = (await r.load([i]))[i],
                a = new s_(o.baseTexture, e, t.src);
            await a.parse();
            const l = (c = e == null ? void 0 : e.meta) == null ? void 0 : c.related_multi_packs;
            if (Array.isArray(l)) {
                const h = [];
                for (const f of l) {
                    if (typeof f != "string") continue;
                    let p = n + f;
                    (u = t.data) != null && u.ignoreMultiPack || (p = t_(p, t.src), h.push(r.load({
                        src: p,
                        data: {
                            ignoreMultiPack: !0
                        }
                    })))
                }
                const d = await Promise.all(h);
                a.linkedSheets = d, d.forEach(f => {
                    f.linkedSheets = [a].concat(a.linkedSheets.filter(p => p !== f))
                })
            }
            return a
        },
        unload(e) {
            e.destroy(!0)
        }
    }
};
ye.add(pH);
class Tf {
    constructor() {
        this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = []
    }
}
class Cd {
    static test(t) {
        return typeof t == "string" && t.startsWith("info face=")
    }
    static parse(t) {
        const r = t.match(/^[a-z]+\s+.+$/gm),
            n = {
                info: [],
                common: [],
                page: [],
                char: [],
                chars: [],
                kerning: [],
                kernings: [],
                distanceField: []
            };
        for (const s in r) {
            const o = r[s].match(/^[a-z]+/gm)[0],
                a = r[s].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                l = {};
            for (const c in a) {
                const u = a[c].split("="),
                    h = u[0],
                    d = u[1].replace(/"/gm, ""),
                    f = parseFloat(d),
                    p = isNaN(f) ? d : f;
                l[h] = p
            }
            n[o].push(l)
        }
        const i = new Tf;
        return n.info.forEach(s => i.info.push({
            face: s.face,
            size: parseInt(s.size, 10)
        })), n.common.forEach(s => i.common.push({
            lineHeight: parseInt(s.lineHeight, 10)
        })), n.page.forEach(s => i.page.push({
            id: parseInt(s.id, 10),
            file: s.file
        })), n.char.forEach(s => i.char.push({
            id: parseInt(s.id, 10),
            page: parseInt(s.page, 10),
            x: parseInt(s.x, 10),
            y: parseInt(s.y, 10),
            width: parseInt(s.width, 10),
            height: parseInt(s.height, 10),
            xoffset: parseInt(s.xoffset, 10),
            yoffset: parseInt(s.yoffset, 10),
            xadvance: parseInt(s.xadvance, 10)
        })), n.kerning.forEach(s => i.kerning.push({
            first: parseInt(s.first, 10),
            second: parseInt(s.second, 10),
            amount: parseInt(s.amount, 10)
        })), n.distanceField.forEach(s => i.distanceField.push({
            distanceRange: parseInt(s.distanceRange, 10),
            fieldType: s.fieldType
        })), i
    }
}
class o_ {
    static test(t) {
        const r = t;
        return "getElementsByTagName" in r && r.getElementsByTagName("page").length && r.getElementsByTagName("info")[0].getAttribute("face") !== null
    }
    static parse(t) {
        const r = new Tf,
            n = t.getElementsByTagName("info"),
            i = t.getElementsByTagName("common"),
            s = t.getElementsByTagName("page"),
            o = t.getElementsByTagName("char"),
            a = t.getElementsByTagName("kerning"),
            l = t.getElementsByTagName("distanceField");
        for (let c = 0; c < n.length; c++) r.info.push({
            face: n[c].getAttribute("face"),
            size: parseInt(n[c].getAttribute("size"), 10)
        });
        for (let c = 0; c < i.length; c++) r.common.push({
            lineHeight: parseInt(i[c].getAttribute("lineHeight"), 10)
        });
        for (let c = 0; c < s.length; c++) r.page.push({
            id: parseInt(s[c].getAttribute("id"), 10) || 0,
            file: s[c].getAttribute("file")
        });
        for (let c = 0; c < o.length; c++) {
            const u = o[c];
            r.char.push({
                id: parseInt(u.getAttribute("id"), 10),
                page: parseInt(u.getAttribute("page"), 10) || 0,
                x: parseInt(u.getAttribute("x"), 10),
                y: parseInt(u.getAttribute("y"), 10),
                width: parseInt(u.getAttribute("width"), 10),
                height: parseInt(u.getAttribute("height"), 10),
                xoffset: parseInt(u.getAttribute("xoffset"), 10),
                yoffset: parseInt(u.getAttribute("yoffset"), 10),
                xadvance: parseInt(u.getAttribute("xadvance"), 10)
            })
        }
        for (let c = 0; c < a.length; c++) r.kerning.push({
            first: parseInt(a[c].getAttribute("first"), 10),
            second: parseInt(a[c].getAttribute("second"), 10),
            amount: parseInt(a[c].getAttribute("amount"), 10)
        });
        for (let c = 0; c < l.length; c++) r.distanceField.push({
            fieldType: l[c].getAttribute("fieldType"),
            distanceRange: parseInt(l[c].getAttribute("distanceRange"), 10)
        });
        return r
    }
}
class a_ {
    static test(t) {
        return typeof t == "string" && t.includes("<font>") ? o_.test(ce.ADAPTER.parseXML(t)) : !1
    }
    static parse(t) {
        return o_.parse(ce.ADAPTER.parseXML(t))
    }
}
const e0 = [Cd, o_, a_];

function mH(e) {
    for (let t = 0; t < e0.length; t++)
        if (e0[t].test(e)) return e0[t];
    return null
}

function gH(e, t, r, n, i, s) {
    const o = r.fill;
    if (Array.isArray(o)) {
        if (o.length === 1) return o[0]
    } else return o;
    let a;
    const l = r.dropShadow ? r.dropShadowDistance : 0,
        c = r.padding || 0,
        u = e.width / n - l - c * 2,
        h = e.height / n - l - c * 2,
        d = o.slice(),
        f = r.fillGradientStops.slice();
    if (!f.length) {
        const p = d.length + 1;
        for (let m = 1; m < p; ++m) f.push(m / p)
    }
    if (d.unshift(o[0]), f.unshift(0), d.push(o[o.length - 1]), f.push(1), r.fillGradientType === Hm.LINEAR_VERTICAL) {
        a = t.createLinearGradient(u / 2, c, u / 2, h + c);
        let p = 0;
        const w = (s.fontProperties.fontSize + r.strokeThickness) / h;
        for (let y = 0; y < i.length; y++) {
            const v = s.lineHeight * y;
            for (let _ = 0; _ < d.length; _++) {
                let E = 0;
                typeof f[_] == "number" ? E = f[_] : E = _ / d.length;
                const P = v / h + E * w;
                let C = Math.max(p, P);
                C = Math.min(C, 1), a.addColorStop(C, d[_]), p = C
            }
        }
    } else {
        a = t.createLinearGradient(c, h / 2, u + c, h / 2);
        const p = d.length + 1;
        let m = 1;
        for (let w = 0; w < d.length; w++) {
            let y;
            typeof f[w] == "number" ? y = f[w] : y = m / p, a.addColorStop(y, d[w]), m++
        }
    }
    return a
}

function vH(e, t, r, n, i, s, o) {
    const a = r.text,
        l = r.fontProperties;
    t.translate(n, i), t.scale(s, s);
    const c = o.strokeThickness / 2,
        u = -(o.strokeThickness / 2);
    if (t.font = o.toFontString(), t.lineWidth = o.strokeThickness, t.textBaseline = o.textBaseline, t.lineJoin = o.lineJoin, t.miterLimit = o.miterLimit, t.fillStyle = gH(e, t, o, s, [a], r), t.strokeStyle = o.stroke, o.dropShadow) {
        const h = o.dropShadowColor,
            d = o.dropShadowBlur * s,
            f = o.dropShadowDistance * s;
        t.shadowColor = ot.shared.setValue(h).setAlpha(o.dropShadowAlpha).toRgbaString(), t.shadowBlur = d, t.shadowOffsetX = Math.cos(o.dropShadowAngle) * f, t.shadowOffsetY = Math.sin(o.dropShadowAngle) * f
    } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
    o.stroke && o.strokeThickness && t.strokeText(a, c, u + r.lineHeight - l.descent), o.fill && t.fillText(a, c, u + r.lineHeight - l.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)"
}

function Td(e) {
    return e.codePointAt ? e.codePointAt(0) : e.charCodeAt(0)
}

function tR(e) {
    return Array.from ? Array.from(e) : e.split("")
}

function yH(e) {
    typeof e == "string" && (e = [e]);
    const t = [];
    for (let r = 0, n = e.length; r < n; r++) {
        const i = e[r];
        if (Array.isArray(i)) {
            if (i.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);
            const s = i[0].charCodeAt(0),
                o = i[1].charCodeAt(0);
            if (o < s) throw new Error("[BitmapFont]: Invalid character range.");
            for (let a = s, l = o; a <= l; a++) t.push(String.fromCharCode(a))
        } else t.push(...tR(i))
    }
    if (t.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t
}
const mn = class {
    constructor(e, t, r) {
        var c;
        const [n] = e.info, [i] = e.common, [s] = e.page, [o] = e.distanceField, a = Ss(s.file), l = {};
        this._ownsTextures = r, this.font = n.face, this.size = n.size, this.lineHeight = i.lineHeight / a, this.chars = {}, this.pageTextures = l;
        for (let u = 0; u < e.page.length; u++) {
            const {
                id: h,
                file: d
            } = e.page[u];
            l[h] = t instanceof Array ? t[u] : t[d], o != null && o.fieldType && o.fieldType !== "none" && (l[h].baseTexture.alphaMode = Nn.NO_PREMULTIPLIED_ALPHA, l[h].baseTexture.mipmap = si.OFF)
        }
        for (let u = 0; u < e.char.length; u++) {
            const {
                id: h,
                page: d
            } = e.char[u];
            let {
                x: f,
                y: p,
                width: m,
                height: w,
                xoffset: y,
                yoffset: v,
                xadvance: _
            } = e.char[u];
            f /= a, p /= a, m /= a, w /= a, y /= a, v /= a, _ /= a;
            const E = new $e(f + l[d].frame.x / a, p + l[d].frame.y / a, m, w);
            this.chars[h] = {
                xOffset: y,
                yOffset: v,
                xAdvance: _,
                kerning: {},
                texture: new ge(l[d].baseTexture, E),
                page: d
            }
        }
        for (let u = 0; u < e.kerning.length; u++) {
            let {
                first: h,
                second: d,
                amount: f
            } = e.kerning[u];
            h /= a, d /= a, f /= a, this.chars[d] && (this.chars[d].kerning[h] = f)
        }
        this.distanceFieldRange = o == null ? void 0 : o.distanceRange, this.distanceFieldType = ((c = o == null ? void 0 : o.fieldType) == null ? void 0 : c.toLowerCase())??"none"
    }
    destroy() {
        for (const e in this.chars) this.chars[e].texture.destroy(), this.chars[e].texture = null;
        for (const e in this.pageTextures) this._ownsTextures && this.pageTextures[e].destroy(!0), this.pageTextures[e] = null;
        this.chars = null, this.pageTextures = null
    }
    static install(e, t, r) {
        let n;
        if (e instanceof Tf) n = e;
        else {
            const s = mH(e);
            if (!s) throw new Error("Unrecognized data format for font.");
            n = s.parse(e)
        }
        t instanceof ge && (t = [t]);
        const i = new mn(n, t, r);
        return mn.available[i.font] = i, i
    }
    static uninstall(e) {
        const t = mn.available[e];
        if (!t) throw new Error(`No font found named '${e}'`);
        t.destroy(), delete mn.available[e]
    }
    static from(e, t, r) {
        if (!e) throw new Error("[BitmapFont] Property `name` is required.");
        const {
            chars: n,
            padding: i,
            resolution: s,
            textureWidth: o,
            textureHeight: a,
            ...l
        } = Object.assign({}, mn.defaultOptions, r), c = yH(n), u = t instanceof $i ? t : new $i(t), h = o, d = new Tf;
        d.info[0] = {
            face: u.fontFamily,
            size: u.fontSize
        }, d.common[0] = {
            lineHeight: u.fontSize
        };
        let f = 0,
            p = 0,
            m, w, y, v = 0;
        const _ = [];
        for (let P = 0; P < c.length; P++) {
            m || (m = ce.ADAPTER.createCanvas(), m.width = o, m.height = a, w = m.getContext("2d"), y = new Oe(m, {
                resolution: s,
                ...l
            }), _.push(new ge(y)), d.page.push({
                id: _.length - 1,
                file: ""
            }));
            const C = c[P],
                T = er.measureText(C, u, !1, m),
                O = T.width,
                k = Math.ceil(T.height),
                D = Math.ceil((u.fontStyle === "italic" ? 2 : 1) * O);
            if (p >= a - k * s) {
                if (p === 0) throw new Error(`[BitmapFont] textureHeight ${a}px is too small (fontFamily: '${u.fontFamily}', fontSize: ${u.fontSize}px, char: '${C}')`);
                --P, m = null, w = null, y = null, p = 0, f = 0, v = 0;
                continue
            }
            if (v = Math.max(k + T.fontProperties.descent, v), D * s + f >= h) {
                if (f === 0) throw new Error(`[BitmapFont] textureWidth ${o}px is too small (fontFamily: '${u.fontFamily}', fontSize: ${u.fontSize}px, char: '${C}')`);
                --P, p += v * s, p = Math.ceil(p), f = 0, v = 0;
                continue
            }
            vH(m, w, T, f, p, s, u);
            const B = Td(T.text);
            d.char.push({
                id: B,
                page: _.length - 1,
                x: f / s,
                y: p / s,
                width: D,
                height: k,
                xoffset: 0,
                yoffset: 0,
                xadvance: O - (u.dropShadow ? u.dropShadowDistance : 0) - (u.stroke ? u.strokeThickness : 0)
            }), f += (D + 2 * i) * s, f = Math.ceil(f)
        }
        for (let P = 0, C = c.length; P < C; P++) {
            const T = c[P];
            for (let O = 0; O < C; O++) {
                const k = c[O],
                    D = w.measureText(T).width,
                    B = w.measureText(k).width,
                    L = w.measureText(T + k).width - (D + B);
                L && d.kerning.push({
                    first: Td(T),
                    second: Td(k),
                    amount: L
                })
            }
        }
        const E = new mn(d, _, !0);
        return mn.available[e] !== void 0 && mn.uninstall(e), mn.available[e] = E, E
    }
};
let br = mn;
br.ALPHA = [
    ["a", "z"],
    ["A", "Z"], " "
];
br.NUMERIC = [
    ["0", "9"]
];
br.ALPHANUMERIC = [
    ["a", "z"],
    ["A", "Z"],
    ["0", "9"], " "
];
br.ASCII = [
    [" ", "~"]
];
br.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: mn.ALPHANUMERIC
};
br.available = {};
var _H = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`,
    wH = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const IS = [],
    $S = [],
    RS = [],
    rR = class extends jr {
        constructor(e, t = {}) {
            super();
            const {
                align: r,
                tint: n,
                maxWidth: i,
                letterSpacing: s,
                fontName: o,
                fontSize: a
            } = Object.assign({}, rR.styleDefaults, t);
            if (!br.available[o]) throw new Error(`Missing BitmapFont "${o}"`);
            this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = r, this._tintColor = new ot(n), this._font = void 0, this._fontName = o, this._fontSize = a, this.text = e, this._maxWidth = i, this._maxLineHeight = 0, this._letterSpacing = s, this._anchor = new ss(() => {
                this.dirty = !0
            }, this, 0, 0), this._roundPixels = ce.ROUND_PIXELS, this.dirty = !0, this._resolution = ce.RESOLUTION, this._autoResolution = !0, this._textureCache = {}
        }
        updateText() {
            var D;
            const e = br.available[this._fontName],
                t = this.fontSize,
                r = t / e.size,
                n = new Se,
                i = [],
                s = [],
                o = [],
                a = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ",
                l = tR(a),
                c = this._maxWidth * e.size / t,
                u = e.distanceFieldType === "none" ? IS : $S;
            let h = null,
                d = 0,
                f = 0,
                p = 0,
                m = -1,
                w = 0,
                y = 0,
                v = 0,
                _ = 0;
            for (let B = 0; B < l.length; B++) {
                const j = l[B],
                    L = Td(j);
                if (/(?:\s)/.test(j) && (m = B, w = d, _++), j === "\r" || j === `
`) {
                    s.push(d), o.push(-1), f = Math.max(f, d), ++p, ++y, n.x = 0, n.y += e.lineHeight, h = null, _ = 0;
                    continue
                }
                const M = e.chars[L];
                if (!M) continue;
                h && M.kerning[h] && (n.x += M.kerning[h]);
                const W = RS.pop() || {
                    texture: ge.EMPTY,
                    line: 0,
                    charCode: 0,
                    prevSpaces: 0,
                    position: new Se
                };
                W.texture = M.texture, W.line = p, W.charCode = L, W.position.x = Math.round(n.x + M.xOffset + this._letterSpacing / 2), W.position.y = Math.round(n.y + M.yOffset), W.prevSpaces = _, i.push(W), d = W.position.x + Math.max(M.xAdvance - M.xOffset, M.texture.orig.width), n.x += M.xAdvance + this._letterSpacing, v = Math.max(v, M.yOffset + M.texture.height), h = L, m !== -1 && c > 0 && n.x > c && (++y, Fa(i, 1 + m - y, 1 + B - m), B = m, m = -1, s.push(w), o.push(i.length > 0 ? i[i.length - 1].prevSpaces : 0), f = Math.max(f, w), p++, n.x = 0, n.y += e.lineHeight, h = null, _ = 0)
            }
            const E = l[l.length - 1];
            E !== "\r" && E !== `
` && (/(?:\s)/.test(E) && (d = w), s.push(d), f = Math.max(f, d), o.push(-1));
            const P = [];
            for (let B = 0; B <= p; B++) {
                let j = 0;
                this._align === "right" ? j = f - s[B] : this._align === "center" ? j = (f - s[B]) / 2 : this._align === "justify" && (j = o[B] < 0 ? 0 : (f - s[B]) / o[B]), P.push(j)
            }
            const C = i.length,
                T = {},
                O = [],
                k = this._activePagesMeshData;
            u.push(...k);
            for (let B = 0; B < C; B++) {
                const j = i[B].texture,
                    L = j.baseTexture.uid;
                if (!T[L]) {
                    let M = u.pop();
                    if (!M) {
                        const Z = new VU;
                        let q, G;
                        e.distanceFieldType === "none" ? (q = new TS(ge.EMPTY), G = Ce.NORMAL) : (q = new TS(ge.EMPTY, {
                            program: En.from(wH, _H),
                            uniforms: {
                                uFWidth: 0
                            }
                        }), G = Ce.NORMAL_NPM);
                        const X = new n_(Z, q);
                        X.blendMode = G, M = {
                            index: 0,
                            indexCount: 0,
                            vertexCount: 0,
                            uvsCount: 0,
                            total: 0,
                            mesh: X,
                            vertices: null,
                            uvs: null,
                            indices: null
                        }
                    }
                    M.index = 0, M.indexCount = 0, M.vertexCount = 0, M.uvsCount = 0, M.total = 0;
                    const {
                        _textureCache: W
                    } = this;
                    W[L] = W[L] || new ge(j.baseTexture), M.mesh.texture = W[L], M.mesh.tint = this._tintColor.value, O.push(M), T[L] = M
                }
                T[L].total++
            }
            for (let B = 0; B < k.length; B++) O.includes(k[B]) || this.removeChild(k[B].mesh);
            for (let B = 0; B < O.length; B++) O[B].mesh.parent !== this && this.addChild(O[B].mesh);
            this._activePagesMeshData = O;
            for (const B in T) {
                const j = T[B],
                    L = j.total;
                if (!(((D = j.indices) == null ? void 0 : D.length) > 6 * L) || j.vertices.length < n_.BATCHABLE_SIZE * 2) j.vertices = new Float32Array(4 * 2 * L), j.uvs = new Float32Array(4 * 2 * L), j.indices = new Uint16Array(6 * L);
                else {
                    const M = j.total,
                        W = j.vertices;
                    for (let Z = M * 4 * 2; Z < W.length; Z++) W[Z] = 0
                }
                j.mesh.size = 6 * L
            }
            for (let B = 0; B < C; B++) {
                const j = i[B];
                let L = j.position.x + P[j.line] * (this._align === "justify" ? j.prevSpaces : 1);
                this._roundPixels && (L = Math.round(L));
                const M = L * r,
                    W = j.position.y * r,
                    Z = j.texture,
                    q = T[Z.baseTexture.uid],
                    G = Z.frame,
                    X = Z._uvs,
                    z = q.index++;
                q.indices[z * 6 + 0] = 0 + z * 4, q.indices[z * 6 + 1] = 1 + z * 4, q.indices[z * 6 + 2] = 2 + z * 4, q.indices[z * 6 + 3] = 0 + z * 4, q.indices[z * 6 + 4] = 2 + z * 4, q.indices[z * 6 + 5] = 3 + z * 4, q.vertices[z * 8 + 0] = M, q.vertices[z * 8 + 1] = W, q.vertices[z * 8 + 2] = M + G.width * r, q.vertices[z * 8 + 3] = W, q.vertices[z * 8 + 4] = M + G.width * r, q.vertices[z * 8 + 5] = W + G.height * r, q.vertices[z * 8 + 6] = M, q.vertices[z * 8 + 7] = W + G.height * r, q.uvs[z * 8 + 0] = X.x0, q.uvs[z * 8 + 1] = X.y0, q.uvs[z * 8 + 2] = X.x1, q.uvs[z * 8 + 3] = X.y1, q.uvs[z * 8 + 4] = X.x2, q.uvs[z * 8 + 5] = X.y2, q.uvs[z * 8 + 6] = X.x3, q.uvs[z * 8 + 7] = X.y3
            }
            this._textWidth = f * r, this._textHeight = (n.y + e.lineHeight) * r;
            for (const B in T) {
                const j = T[B];
                if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                    let Z = 0;
                    const q = this._textWidth * this.anchor.x,
                        G = this._textHeight * this.anchor.y;
                    for (let X = 0; X < j.total; X++) j.vertices[Z++] -= q, j.vertices[Z++] -= G, j.vertices[Z++] -= q, j.vertices[Z++] -= G, j.vertices[Z++] -= q, j.vertices[Z++] -= G, j.vertices[Z++] -= q, j.vertices[Z++] -= G
                }
                this._maxLineHeight = v * r;
                const L = j.mesh.geometry.getBuffer("aVertexPosition"),
                    M = j.mesh.geometry.getBuffer("aTextureCoord"),
                    W = j.mesh.geometry.getIndex();
                L.data = j.vertices, M.data = j.uvs, W.data = j.indices, L.update(), M.update(), W.update()
            }
            for (let B = 0; B < i.length; B++) RS.push(i[B]);
            this._font = e, this.dirty = !1
        }
        updateTransform() {
            this.validate(), this.containerUpdateTransform()
        }
        _render(e) {
            this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
            const {
                distanceFieldRange: t,
                distanceFieldType: r,
                size: n
            } = br.available[this._fontName];
            if (r !== "none") {
                const {
                    a: i,
                    b: s,
                    c: o,
                    d: a
                } = this.worldTransform, l = Math.sqrt(i * i + s * s), c = Math.sqrt(o * o + a * a), u = (Math.abs(l) + Math.abs(c)) / 2, h = this.fontSize / n, d = e._view.resolution;
                for (const f of this._activePagesMeshData) f.mesh.shader.uniforms.uFWidth = u * t * h * d
            }
            super._render(e)
        }
        getLocalBounds() {
            return this.validate(), super.getLocalBounds()
        }
        validate() {
            const e = br.available[this._fontName];
            if (!e) throw new Error(`Missing BitmapFont "${this._fontName}"`);
            this._font !== e && (this.dirty = !0), this.dirty && this.updateText()
        }
        get tint() {
            return this._tintColor.value
        }
        set tint(e) {
            if (this.tint !== e) {
                this._tintColor.setValue(e);
                for (let t = 0; t < this._activePagesMeshData.length; t++) this._activePagesMeshData[t].mesh.tint = e
            }
        }
        get align() {
            return this._align
        }
        set align(e) {
            this._align !== e && (this._align = e, this.dirty = !0)
        }
        get fontName() {
            return this._fontName
        }
        set fontName(e) {
            if (!br.available[e]) throw new Error(`Missing BitmapFont "${e}"`);
            this._fontName !== e && (this._fontName = e, this.dirty = !0)
        }
        get fontSize() {
            return this._fontSize??br.available[this._fontName].size
        }
        set fontSize(e) {
            this._fontSize !== e && (this._fontSize = e, this.dirty = !0)
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get text() {
            return this._text
        }
        set text(e) {
            e = String(e??""), this._text !== e && (this._text = e, this.dirty = !0)
        }
        get maxWidth() {
            return this._maxWidth
        }
        set maxWidth(e) {
            this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0)
        }
        get maxLineHeight() {
            return this.validate(), this._maxLineHeight
        }
        get textWidth() {
            return this.validate(), this._textWidth
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(e) {
            this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0)
        }
        get roundPixels() {
            return this._roundPixels
        }
        set roundPixels(e) {
            e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0)
        }
        get textHeight() {
            return this.validate(), this._textHeight
        }
        get resolution() {
            return this._resolution
        }
        set resolution(e) {
            this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
        }
        destroy(e) {
            const {
                _textureCache: t
            } = this, n = br.available[this._fontName].distanceFieldType === "none" ? IS : $S;
            n.push(...this._activePagesMeshData);
            for (const i of this._activePagesMeshData) this.removeChild(i.mesh);
            this._activePagesMeshData = [], n.filter(i => t[i.mesh.texture.baseTexture.uid]).forEach(i => {
                i.mesh.texture = ge.EMPTY
            });
            for (const i in t) t[i].destroy(), delete t[i];
            this._font = null, this._tintColor = null, this._textureCache = null, super.destroy(e)
        }
    };
let bH = rR;
bH.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
};
const xH = [".xml", ".fnt"],
    EH = {
        extension: {
            type: ue.LoadParser,
            priority: ai.Normal
        },
        name: "loadBitmapFont",
        test(e) {
            return xH.includes(hr.extname(e).toLowerCase())
        },
        async testParse(e) {
            return Cd.test(e) || a_.test(e)
        },
        async parse(e, t, r) {
            const n = Cd.test(e) ? Cd.parse(e) : a_.parse(e),
                {
                    src: i
                } = t,
                {
                    page: s
                } = n,
                o = [];
            for (let c = 0; c < s.length; ++c) {
                const u = s[c].file;
                let h = hr.join(hr.dirname(i), u);
                h = t_(h, i), o.push(h)
            }
            const a = await r.load(o),
                l = o.map(c => a[c]);
            return br.install(n, l, !0)
        },
        async load(e, t) {
            return (await ce.ADAPTER.fetch(e)).text()
        },
        unload(e) {
            e.destroy()
        }
    };
ye.add(EH);
const ca = class extends $i {
    constructor() {
        super(...arguments), this._fonts = [], this._overrides = [], this._stylesheet = "", this.fontsDirty = !1
    }
    static from(e) {
        return new ca(Object.keys(ca.defaultOptions).reduce((t, r) => ({ ...t,
            [r]: e[r]
        }), {}))
    }
    cleanFonts() {
        this._fonts.length > 0 && (this._fonts.forEach(e => {
            URL.revokeObjectURL(e.src), e.refs--, e.refs === 0 && (e.fontFace && document.fonts.delete(e.fontFace), delete ca.availableFonts[e.originalUrl])
        }), this.fontFamily = "Arial", this._fonts.length = 0, this.styleID++, this.fontsDirty = !0)
    }
    loadFont(e, t = {}) {
        const {
            availableFonts: r
        } = ca;
        if (r[e]) {
            const n = r[e];
            return this._fonts.push(n), n.refs++, this.styleID++, this.fontsDirty = !0, Promise.resolve()
        }
        return ce.ADAPTER.fetch(e).then(n => n.blob()).then(async n => new Promise((i, s) => {
            const o = URL.createObjectURL(n),
                a = new FileReader;
            a.onload = () => i([o, a.result]), a.onerror = s, a.readAsDataURL(n)
        })).then(async ([n, i]) => {
            const s = Object.assign({
                family: hr.basename(e, hr.extname(e)),
                weight: "normal",
                style: "normal",
                src: n,
                dataSrc: i,
                refs: 1,
                originalUrl: e,
                fontFace: null
            }, t);
            r[e] = s, this._fonts.push(s), this.styleID++;
            const o = new FontFace(s.family, `url(${s.src})`, {
                weight: s.weight,
                style: s.style
            });
            s.fontFace = o, await o.load(), document.fonts.add(o), await document.fonts.ready, this.styleID++, this.fontsDirty = !0
        })
    }
    addOverride(...e) {
        const t = e.filter(r => !this._overrides.includes(r));
        t.length > 0 && (this._overrides.push(...t), this.styleID++)
    }
    removeOverride(...e) {
        const t = e.filter(r => this._overrides.includes(r));
        t.length > 0 && (this._overrides = this._overrides.filter(r => !t.includes(r)), this.styleID++)
    }
    toCSS(e) {
        return [`transform: scale(${e})`, "transform-origin: top left", "display: inline-block", `color: ${this.normalizeColor(this.fill)}`, `font-size: ${this.fontSize}px`, `font-family: ${this.fontFamily}`, `font-weight: ${this.fontWeight}`, `font-style: ${this.fontStyle}`, `font-variant: ${this.fontVariant}`, `letter-spacing: ${this.letterSpacing}px`, `text-align: ${this.align}`, `padding: ${this.padding}px`, `white-space: ${this.whiteSpace}`, ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [], ...this.wordWrap ? [`word-wrap: ${this.breakWords?"break-all":"break-word"}`, `max-width: ${this.wordWrapWidth}px`] : [], ...this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : [], ...this.dropShadow ? [this.dropShadowToCSS()] : [], ...this._overrides].join(";")
    }
    toGlobalCSS() {
        return this._fonts.reduce((e, t) => `${e}
            @font-face {
                font-family: "${t.family}";
                src: url('${t.dataSrc}');
                font-weight: ${t.weight};
                font-style: ${t.style}; 
            }`, this._stylesheet)
    }
    get stylesheet() {
        return this._stylesheet
    }
    set stylesheet(e) {
        this._stylesheet !== e && (this._stylesheet = e, this.styleID++)
    }
    normalizeColor(e) {
        return Array.isArray(e) && (e = q7(e)), typeof e == "number" ? K7(e) : e
    }
    dropShadowToCSS() {
        let e = this.normalizeColor(this.dropShadowColor);
        const t = this.dropShadowAlpha,
            r = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance),
            n = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
        e.startsWith("#") && t < 1 && (e += (t * 255 | 0).toString(16).padStart(2, "0"));
        const i = `${r}px ${n}px`;
        return this.dropShadowBlur > 0 ? `text-shadow: ${i} ${this.dropShadowBlur}px ${e}` : `text-shadow: ${i} ${e}`
    }
    reset() {
        Object.assign(this, ca.defaultOptions)
    }
    onBeforeDraw() {
        const {
            fontsDirty: e
        } = this;
        return this.fontsDirty = !1, this.isSafari && this._fonts.length > 0 && e ? new Promise(t => setTimeout(t, 100)) : Promise.resolve()
    }
    get isSafari() {
        const {
            userAgent: e
        } = ce.ADAPTER.getNavigator();
        return /^((?!chrome|android).)*safari/i.test(e)
    }
    set fillGradientStops(e) {
        console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText")
    }
    get fillGradientStops() {
        return super.fillGradientStops
    }
    set fillGradientType(e) {
        console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText")
    }
    get fillGradientType() {
        return super.fillGradientType
    }
    set miterLimit(e) {
        console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText")
    }
    get miterLimit() {
        return super.miterLimit
    }
    set trim(e) {
        console.warn("[HTMLTextStyle] trim is not supported by HTMLText")
    }
    get trim() {
        return super.trim
    }
    set textBaseline(e) {
        console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText")
    }
    get textBaseline() {
        return super.textBaseline
    }
    set leading(e) {
        console.warn("[HTMLTextStyle] leading is not supported by HTMLText")
    }
    get leading() {
        return super.leading
    }
    set lineJoin(e) {
        console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText")
    }
    get lineJoin() {
        return super.lineJoin
    }
};
let Cc = ca;
Cc.availableFonts = {};
Cc.defaultOptions = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    whiteSpace: "normal",
    wordWrap: !1,
    wordWrapWidth: 100
};
const ua = class extends pl {
    constructor(e = "", t = {}) {
        super(ge.EMPTY), this._text = null, this._style = null, this._autoResolution = !0, this._loading = !1, this.localStyleID = -1, this.dirty = !1, this.ownsStyle = !1;
        const r = new Image,
            n = ge.from(r, {
                scaleMode: ce.SCALE_MODE,
                resourceOptions: {
                    autoLoad: !1
                }
            });
        n.orig = new $e, n.trim = new $e, this.texture = n;
        const i = "http://www.w3.org/2000/svg",
            s = "http://www.w3.org/1999/xhtml",
            o = document.createElementNS(i, "svg"),
            a = document.createElementNS(i, "foreignObject"),
            l = document.createElementNS(s, "div"),
            c = document.createElementNS(s, "style");
        a.setAttribute("width", "10000"), a.setAttribute("height", "10000"), a.style.overflow = "hidden", o.appendChild(a), this.maxWidth = ua.defaultMaxWidth, this.maxHeight = ua.defaultMaxHeight, this._domElement = l, this._styleElement = c, this._svgRoot = o, this._foreignObject = a, this._foreignObject.appendChild(c), this._foreignObject.appendChild(l), this._image = r, this._loadImage = new Image, this._autoResolution = ua.defaultAutoResolution, this._resolution = ua.defaultResolution??ce.RESOLUTION, this.text = e, this.style = t
    }
    measureText(e) {
        var a, l;
        const {
            text: t,
            style: r,
            resolution: n
        } = Object.assign({
            text: this._text,
            style: this._style,
            resolution: this._resolution
        }, e);
        Object.assign(this._domElement, {
            innerHTML: t,
            style: r.toCSS(n)
        }), this._styleElement.textContent = r.toGlobalCSS(), document.body.appendChild(this._svgRoot);
        const i = this._domElement.getBoundingClientRect();
        this._svgRoot.remove();
        const s = Math.min(this.maxWidth, Math.ceil(i.width)),
            o = Math.min(this.maxHeight, Math.ceil(i.height));
        return this._svgRoot.setAttribute("width", s.toString()), this._svgRoot.setAttribute("height", o.toString()), t !== this._text && (this._domElement.innerHTML = this._text), r !== this._style && (Object.assign(this._domElement, {
            style: (a = this._style) == null ? void 0 : a.toCSS(n)
        }), this._styleElement.textContent = (l = this._style) == null ? void 0 : l.toGlobalCSS()), {
            width: s + r.padding * 2,
            height: o + r.padding * 2
        }
    }
    async updateText(e = !0) {
        const {
            style: t,
            _image: r,
            _loadImage: n
        } = this;
        if (this.localStyleID !== t.styleID && (this.dirty = !0, this.localStyleID = t.styleID), !this.dirty && e) return;
        const {
            width: i,
            height: s
        } = this.measureText();
        r.width = n.width = Math.ceil(Math.max(1, i)), r.height = n.height = Math.ceil(Math.max(1, s)), this._loading || (this._loading = !0, await new Promise(o => {
            n.onload = async () => {
                await t.onBeforeDraw(), this._loading = !1, r.src = n.src, n.onload = null, n.src = "", this.updateTexture(), o()
            };
            const a = new XMLSerializer().serializeToString(this._svgRoot);
            n.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(a)}`
        }))
    }
    get source() {
        return this._image
    }
    updateTexture() {
        const {
            style: e,
            texture: t,
            _image: r,
            resolution: n
        } = this, {
            padding: i
        } = e, {
            baseTexture: s
        } = t;
        t.trim.width = t._frame.width = r.width / n, t.trim.height = t._frame.height = r.height / n, t.trim.x = -i, t.trim.y = -i, t.orig.width = t._frame.width - i * 2, t.orig.height = t._frame.height - i * 2, this._onTextureUpdate(), s.setRealSize(r.width, r.height, n), this.dirty = !1
    }
    _render(e) {
        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), super._render(e)
    }
    _renderCanvas(e) {
        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), super._renderCanvas(e)
    }
    getLocalBounds(e) {
        return this.updateText(!0), super.getLocalBounds(e)
    }
    _calculateBounds() {
        this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData)
    }
    _onStyleChange() {
        this.dirty = !0
    }
    destroy(e) {
        var r, n, i, s, o;
        typeof e == "boolean" && (e = {
            children: e
        }), e = Object.assign({}, ua.defaultDestroyOptions, e), super.destroy(e);
        const t = null;
        this.ownsStyle && ((r = this._style) == null || r.cleanFonts()), this._style = t, (n = this._svgRoot) == null || n.remove(), this._svgRoot = t, (i = this._domElement) == null || i.remove(), this._domElement = t, (s = this._foreignObject) == null || s.remove(), this._foreignObject = t, (o = this._styleElement) == null || o.remove(), this._styleElement = t, this._loadImage.src = "", this._loadImage.onload = null, this._loadImage = t, this._image.src = "", this._image = t
    }
    get width() {
        return this.updateText(!0), Math.abs(this.scale.x) * this._image.width / this.resolution
    }
    set width(e) {
        this.updateText(!0);
        const t = is(this.scale.x) || 1;
        this.scale.x = t * e / this._image.width / this.resolution, this._width = e
    }
    get height() {
        return this.updateText(!0), Math.abs(this.scale.y) * this._image.height / this.resolution
    }
    set height(e) {
        this.updateText(!0);
        const t = is(this.scale.y) || 1;
        this.scale.y = t * e / this._image.height / this.resolution, this._height = e
    }
    get style() {
        return this._style
    }
    set style(e) {
        this._style !== e && (e = e || {}, e instanceof Cc ? (this.ownsStyle = !1, this._style = e) : e instanceof $i ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"), this.ownsStyle = !0, this._style = Cc.from(e)) : (this.ownsStyle = !0, this._style = new Cc(e)), this.localStyleID = -1, this.dirty = !0)
    }
    get text() {
        return this._text
    }
    set text(e) {
        e = String(e === "" || e === null || e === void 0 ? " " : e), e = this.sanitiseText(e), this._text !== e && (this._text = e, this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
    }
    sanitiseText(e) {
        return e.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;")
    }
};
let Gm = ua;
Gm.defaultDestroyOptions = {
    texture: !0,
    children: !1,
    baseTexture: !0
};
Gm.defaultMaxWidth = 2024;
Gm.defaultMaxHeight = 2024;
Gm.defaultAutoResolution = !0;
const SH = {
        float(e, t, r, n) {
            r !== n && (r.v = n, e.uniform1f(t, n))
        },
        vec2(e, t, r, n) {
            (r[0] !== n[0] || r[1] !== n[1]) && (r[0] = n[0], r[1] = n[1], e.uniform2f(t, n[0], n[1]))
        },
        vec3(e, t, r, n) {
            (r[0] !== n[0] || r[1] !== n[1] || r[2] !== n[2]) && (r[0] = n[0], r[1] = n[1], r[2] = n[2], e.uniform3f(t, n[0], n[1], n[2]))
        },
        int(e, t, r, n) {
            e.uniform1i(t, n)
        },
        ivec2(e, t, r, n) {
            e.uniform2i(t, n[0], n[1])
        },
        ivec3(e, t, r, n) {
            e.uniform3i(t, n[0], n[1], n[2])
        },
        ivec4(e, t, r, n) {
            e.uniform4i(t, n[0], n[1], n[2], n[3])
        },
        uint(e, t, r, n) {
            e.uniform1ui(t, n)
        },
        uvec2(e, t, r, n) {
            e.uniform2ui(t, n[0], n[1])
        },
        uvec3(e, t, r, n) {
            e.uniform3ui(t, n[0], n[1], n[2])
        },
        uvec4(e, t, r, n) {
            e.uniform4ui(t, n[0], n[1], n[2], n[3])
        },
        bool(e, t, r, n) {
            r !== n && (r.v = n, e.uniform1i(t, Number(n)))
        },
        bvec2(e, t, r, n) {
            e.uniform2i(t, n[0], n[1])
        },
        bvec3(e, t, r, n) {
            e.uniform3i(t, n[0], n[1], n[2])
        },
        bvec4(e, t, r, n) {
            e.uniform4i(t, n[0], n[1], n[2], n[3])
        },
        mat2(e, t, r, n) {
            e.uniformMatrix2fv(t, !1, n)
        },
        mat3(e, t, r, n) {
            e.uniformMatrix3fv(t, !1, n)
        },
        mat4(e, t, r, n) {
            e.uniformMatrix4fv(t, !1, n)
        },
        sampler2D(e, t, r, n) {
            e.uniform1i(t, n)
        },
        samplerCube(e, t, r, n) {
            e.uniform1i(t, n)
        },
        sampler2DArray(e, t, r, n) {
            e.uniform1i(t, n)
        }
    },
    PH = {
        float(e, t, r, n) {
            e.uniform1fv(t, n)
        },
        vec2(e, t, r, n) {
            e.uniform2fv(t, n)
        },
        vec3(e, t, r, n) {
            e.uniform3fv(t, n)
        },
        vec4(e, t, r, n) {
            e.uniform4fv(t, n)
        },
        int(e, t, r, n) {
            e.uniform1iv(t, n)
        },
        ivec2(e, t, r, n) {
            e.uniform2iv(t, n)
        },
        ivec3(e, t, r, n) {
            e.uniform3iv(t, n)
        },
        ivec4(e, t, r, n) {
            e.uniform4iv(t, n)
        },
        uint(e, t, r, n) {
            e.uniform1uiv(t, n)
        },
        uvec2(e, t, r, n) {
            e.uniform2uiv(t, n)
        },
        uvec3(e, t, r, n) {
            e.uniform3uiv(t, n)
        },
        uvec4(e, t, r, n) {
            e.uniform4uiv(t, n)
        },
        bool(e, t, r, n) {
            e.uniform1iv(t, n)
        },
        bvec2(e, t, r, n) {
            e.uniform2iv(t, n)
        },
        bvec3(e, t, r, n) {
            e.uniform3iv(t, n)
        },
        bvec4(e, t, r, n) {
            e.uniform4iv(t, n)
        },
        sampler2D(e, t, r, n) {
            e.uniform1iv(t, n)
        },
        samplerCube(e, t, r, n) {
            e.uniform1iv(t, n)
        },
        sampler2DArray(e, t, r, n) {
            e.uniform1iv(t, n)
        }
    };

function CH(e, t, r, n, i) {
    let s = 0,
        o = null,
        a = null;
    const l = i.gl;
    for (const c in e.uniforms) {
        const u = t[c],
            h = n[c],
            d = r[c],
            f = e.uniforms[c];
        if (!u) {
            f.group && i.shader.syncUniformGroup(h);
            continue
        }
        u.type === "float" && u.size === 1 ? h !== d.value && (d.value = h, l.uniform1f(d.location, h)) : (u.type === "sampler2D" || u.type === "samplerCube" || u.type === "sampler2DArray") && u.size === 1 && !u.isArray ? (i.texture.bind(h, s), d.value !== s && (d.value = s, l.uniform1i(d.location, s)), s++) : u.type === "mat3" && u.size === 1 ? f.a !== void 0 ? l.uniformMatrix3fv(d.location, !1, h.toArray(!0)) : l.uniformMatrix3fv(d.location, !1, h) : u.type === "vec2" && u.size === 1 ? f.x !== void 0 ? (a = d.value, o = h, (a[0] !== o.x || a[1] !== o.y) && (a[0] = o.x, a[1] = o.y, l.uniform2f(d.location, o.x, o.y))) : (a = d.value, o = h, (a[0] !== o[0] || a[1] !== o[1]) && (a[0] = o[0], a[1] = o[1], l.uniform2f(d.location, o[0], o[1]))) : u.type === "vec4" && u.size === 1 ? f.width !== void 0 ? (a = d.value, o = h, (a[0] !== o.x || a[1] !== o.y || a[2] !== o.width || a[3] !== o.height) && (a[0] = o.x, a[1] = o.y, a[2] = o.width, a[3] = o.height, l.uniform4f(d.location, o.x, o.y, o.width, o.height))) : (a = d.value, o = h, (a[0] !== o[0] || a[1] !== o[1] || a[2] !== o[2] || a[3] !== o[3]) && (a[0] = o[0], a[1] = o[1], a[2] = o[2], a[3] = o[3], l.uniform4f(d.location, o[0], o[1], o[2], o[3]))) : (u.size === 1 ? SH : PH)[u.type].call(null, l, d.location, d.value, h)
    }
}

function TH() {
    Object.assign(Z1.prototype, {
        systemCheck() {},
        syncUniforms(e, t) {
            const {
                shader: r,
                renderer: n
            } = this;
            CH(e, r.program.uniformData, t.uniformData, e.uniforms, n)
        }
    })
}
TH();
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const nR = Symbol("Comlink.proxy"),
    OH = Symbol("Comlink.endpoint"),
    iR = Symbol("Comlink.releaseProxy"),
    t0 = Symbol("Comlink.finalizer"),
    Od = Symbol("Comlink.thrown"),
    sR = e => typeof e == "object" && e !== null || typeof e == "function",
    AH = {
        canHandle: e => sR(e) && e[nR],
        serialize(e) {
            const {
                port1: t,
                port2: r
            } = new MessageChannel;
            return aR(e, t), [r, [r]]
        },
        deserialize(e) {
            return e.start(), cR(e)
        }
    },
    IH = {
        canHandle: e => sR(e) && Od in e,
        serialize({
            value: e
        }) {
            let t;
            return e instanceof Error ? t = {
                isError: !0,
                value: {
                    message: e.message,
                    name: e.name,
                    stack: e.stack
                }
            } : t = {
                isError: !1,
                value: e
            }, [t, []]
        },
        deserialize(e) {
            throw e.isError ? Object.assign(new Error(e.value.message), e.value) : e.value
        }
    },
    oR = new Map([
        ["proxy", AH],
        ["throw", IH]
    ]);

function $H(e, t) {
    for (const r of e)
        if (t === r || r === "*" || r instanceof RegExp && r.test(t)) return !0;
    return !1
}

function aR(e, t = globalThis, r = ["*"]) {
    t.addEventListener("message", function n(i) {
        if (!i || !i.data) return;
        if (!$H(r, i.origin)) {
            console.warn(`Invalid origin '${i.origin}' for comlink proxy`);
            return
        }
        const {
            id: s,
            type: o,
            path: a
        } = Object.assign({
            path: []
        }, i.data), l = (i.data.argumentList || []).map(Ks);
        let c;
        try {
            const u = a.slice(0, -1).reduce((d, f) => d[f], e),
                h = a.reduce((d, f) => d[f], e);
            switch (o) {
                case "GET":
                    c = h;
                    break;
                case "SET":
                    u[a.slice(-1)[0]] = Ks(i.data.value), c = !0;
                    break;
                case "APPLY":
                    c = h.apply(u, l);
                    break;
                case "CONSTRUCT":
                    {
                        const d = new h(...l);c = fR(d)
                    }
                    break;
                case "ENDPOINT":
                    {
                        const {
                            port1: d,
                            port2: f
                        } = new MessageChannel;aR(e, f),
                        c = dR(d, [d])
                    }
                    break;
                case "RELEASE":
                    c = void 0;
                    break;
                default:
                    return
            }
        } catch (u) {
            c = {
                value: u,
                [Od]: 0
            }
        }
        Promise.resolve(c).catch(u => ({
            value: u,
            [Od]: 0
        })).then(u => {
            const [h, d] = If(u);
            t.postMessage(Object.assign(Object.assign({}, h), {
                id: s
            }), d), o === "RELEASE" && (t.removeEventListener("message", n), lR(t), t0 in e && typeof e[t0] == "function" && e[t0]())
        }).catch(u => {
            const [h, d] = If({
                value: new TypeError("Unserializable return value"),
                [Od]: 0
            });
            t.postMessage(Object.assign(Object.assign({}, h), {
                id: s
            }), d)
        })
    }), t.start && t.start()
}

function RH(e) {
    return e.constructor.name === "MessagePort"
}

function lR(e) {
    RH(e) && e.close()
}

function cR(e, t) {
    return l_(e, [], t)
}

function Dh(e) {
    if (e) throw new Error("Proxy has been released and is not useable")
}

function uR(e) {
    return ha(e, {
        type: "RELEASE"
    }).then(() => {
        lR(e)
    })
}
const Of = new WeakMap,
    Af = "FinalizationRegistry" in globalThis && new FinalizationRegistry(e => {
        const t = (Of.get(e) || 0) - 1;
        Of.set(e, t), t === 0 && uR(e)
    });

function kH(e, t) {
    const r = (Of.get(t) || 0) + 1;
    Of.set(t, r), Af && Af.register(e, t, e)
}

function MH(e) {
    Af && Af.unregister(e)
}

function l_(e, t = [], r = function() {}) {
    let n = !1;
    const i = new Proxy(r, {
        get(s, o) {
            if (Dh(n), o === iR) return () => {
                MH(i), uR(e), n = !0
            };
            if (o === "then") {
                if (t.length === 0) return {
                    then: () => i
                };
                const a = ha(e, {
                    type: "GET",
                    path: t.map(l => l.toString())
                }).then(Ks);
                return a.then.bind(a)
            }
            return l_(e, [...t, o])
        },
        set(s, o, a) {
            Dh(n);
            const [l, c] = If(a);
            return ha(e, {
                type: "SET",
                path: [...t, o].map(u => u.toString()),
                value: l
            }, c).then(Ks)
        },
        apply(s, o, a) {
            Dh(n);
            const l = t[t.length - 1];
            if (l === OH) return ha(e, {
                type: "ENDPOINT"
            }).then(Ks);
            if (l === "bind") return l_(e, t.slice(0, -1));
            const [c, u] = kS(a);
            return ha(e, {
                type: "APPLY",
                path: t.map(h => h.toString()),
                argumentList: c
            }, u).then(Ks)
        },
        construct(s, o) {
            Dh(n);
            const [a, l] = kS(o);
            return ha(e, {
                type: "CONSTRUCT",
                path: t.map(c => c.toString()),
                argumentList: a
            }, l).then(Ks)
        }
    });
    return kH(i, e), i
}

function DH(e) {
    return Array.prototype.concat.apply([], e)
}

function kS(e) {
    const t = e.map(If);
    return [t.map(r => r[0]), DH(t.map(r => r[1]))]
}
const hR = new WeakMap;

function dR(e, t) {
    return hR.set(e, t), e
}

function fR(e) {
    return Object.assign(e, {
        [nR]: !0
    })
}

function If(e) {
    for (const [t, r] of oR)
        if (r.canHandle(e)) {
            const [n, i] = r.serialize(e);
            return [{
                type: "HANDLER",
                name: t,
                value: n
            }, i]
        }
    return [{
        type: "RAW",
        value: e
    }, hR.get(e) || []]
}

function Ks(e) {
    switch (e.type) {
        case "HANDLER":
            return oR.get(e.name).deserialize(e.value);
        case "RAW":
            return e.value
    }
}

function ha(e, t, r) {
    return new Promise(n => {
        const i = NH();
        e.addEventListener("message", function s(o) {
            !o.data || !o.data.id || o.data.id !== i || (e.removeEventListener("message", s), n(o.data))
        }), e.start && e.start(), e.postMessage(Object.assign({
            id: i
        }, t), r)
    })
}

function NH() {
    return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-")
}

function LH() {
    return new Worker("" + new URL("gerber_app.js",
        import.meta.url).href, {
        type: "module"
    })
}
class FH {
    constructor(t) {
        oe(this, "element");
        oe(this, "canvas");
        oe(this, "resizeObserver");
        oe(this, "origin");
        oe(this, "virtualApplication");
        oe(this, "virtualViewport");
        oe(this, "renderer");
        oe(this, "pointer");
        const {
            element: r,
            ...n
        } = t;
        Object.assign(n, {
            width: r.clientWidth,
            height: r.clientHeight
        }), this.element = r, this.canvas = document.createElement("canvas"), this.element.appendChild(this.canvas), this.virtualApplication = new ew({
            width: r.clientWidth,
            height: r.clientHeight,
            autoDensity: !1
        }), this.virtualViewport = new Kj({
            worldWidth: 1e3,
            worldHeight: 1e3,
            screenWidth: r.clientWidth,
            screenHeight: r.clientHeight,
            canvasElement: this.canvas
        }).drag().wheel().pinch().decelerate(), this.virtualApplication.stage.addChild(this.virtualViewport);
        const i = this.canvas.transferControlToOffscreen(),
            s = cR(new LH);
        this.renderer = new s(dR(i, [i]), n), this.renderer.then(async o => {
            this.origin = await o.getOrigin()
        }), this.resizeObserver = new ResizeObserver(o => {
            const {
                width: a,
                height: l
            } = o[0].contentRect;
            this.virtualViewport.resize(a, l), this.virtualApplication.renderer.resize(a, l), this.renderer.then(c => {
                c.resizeViewport(a, l)
            })
        }), this.resizeObserver.observe(r), this.pointer = new EventTarget, this.virtualViewport.on("moved", () => {
            this.moveViewport()
        }), this.virtualViewport.on("pointertap", async o => {
            const l = await (await this.renderer).featuresAtPosition(o.screen.x, o.screen.y),
                {
                    x: c,
                    y: u
                } = this.getPosition(o);
            this.pointer.dispatchEvent(new CustomEvent("pointerdown", {
                detail: {
                    x: c,
                    y: u,
                    intersected: l
                }
            })), console.log(l)
        }), this.virtualViewport.on("clicked", async o => {
            const l = await (await this.renderer).featuresAtPosition(o.screen.x, o.screen.y),
                {
                    x: c,
                    y: u
                } = this.getPosition(o.event);
            this.pointer.dispatchEvent(new CustomEvent("pointerdown", {
                detail: {
                    x: c,
                    y: u
                }
            })), console.log(l)
        }), this.virtualViewport.on("pointermove", async o => {
            if (!this.origin) return;
            const {
                x: a,
                y: l
            } = this.getPosition(o);
            this.pointer.dispatchEvent(new CustomEvent("pointermove", {
                detail: {
                    x: a,
                    y: l
                }
            }))
        })
    }
    getPosition(t) {
        let r, n;
        if (t instanceof Wr) r = t.client.x, n = t.client.y;
        else if (t instanceof MouseEvent || t instanceof PointerEvent) r = t.clientX, n = t.clientY;
        else if (t instanceof TouchEvent) r = t.touches[0].clientX, n = t.touches[0].clientY;
        else throw new Error("Unknown event type");
        if (!this.origin) return {
            x: 0,
            y: 0
        };
        const i = this.virtualViewport.scale.x,
            s = this.virtualViewport.x,
            o = this.virtualViewport.y,
            a = ((r - s) / i - this.origin.x) * 10,
            l = -((n - o) / i - this.origin.y) * 10;
        return {
            x: a,
            y: l
        }
    }
    async moveViewport() {
        const t = this.virtualViewport.x,
            r = this.virtualViewport.y,
            n = this.virtualViewport.scale.x;
        await (await this.renderer).moveViewport(t, r, n)
    }
    async zoomHome() {
        const t = await this.renderer;
        await t.uncull();
        const r = await t.getRendererBounds(),
            n = await t.getViewportBounds();
        if (n.width === 0 || n.height === 0) return;
        const i = Math.min(r.width / n.width, r.height / n.height);
        this.virtualViewport.scale = {
            x: i,
            y: i
        }, this.virtualViewport.position = {
            x: r.width / 2 - (n.x + n.width / 2) * i,
            y: r.height / 2 - (n.y + n.height / 2) * i
        }, await this.moveViewport()
    }
    async zoom(t) {
        this.virtualViewport.zoom(t, !0), await this.moveViewport()
    }
    async destroy() {
        this.resizeObserver.disconnect(), this.element.removeChild(this.canvas), this.virtualApplication.destroy(!0), this.virtualViewport.removeAllListeners(), this.virtualViewport.destroy();
        const t = await this.renderer;
        t.destroy(!0), t[iR]()
    }
}
var c_ = {},
    BH = {
        get exports() {
            return c_
        },
        set exports(e) {
            c_ = e
        }
    };
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */
(function(e, t) {
    (function(r, n) {
        e.exports = n()
    })(cd, function() {
        for (var r = function(g, x, S) {
                return x === void 0 && (x = 0), S === void 0 && (S = 1), g < x ? x : g > S ? S : g
            }, n = r, i = function(g) {
                g._clipped = !1, g._unclipped = g.slice(0);
                for (var x = 0; x <= 3; x++) x < 3 ? ((g[x] < 0 || g[x] > 255) && (g._clipped = !0), g[x] = n(g[x], 0, 255)) : x === 3 && (g[x] = n(g[x], 0, 1));
                return g
            }, s = {}, o = 0, a = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]; o < a.length; o += 1) {
            var l = a[o];
            s["[object " + l + "]"] = l.toLowerCase()
        }
        var c = function(g) {
                return s[Object.prototype.toString.call(g)] || "object"
            },
            u = c,
            h = function(g, x) {
                return x === void 0 && (x = null), g.length >= 3 ? Array.prototype.slice.call(g) : u(g[0]) == "object" && x ? x.split("").filter(function(S) {
                    return g[0][S] !== void 0
                }).map(function(S) {
                    return g[0][S]
                }) : g[0]
            },
            d = c,
            f = function(g) {
                if (g.length < 2) return null;
                var x = g.length - 1;
                return d(g[x]) == "string" ? g[x].toLowerCase() : null
            },
            p = Math.PI,
            m = {
                clip_rgb: i,
                limit: r,
                type: c,
                unpack: h,
                last: f,
                PI: p,
                TWOPI: p * 2,
                PITHIRD: p / 3,
                DEG2RAD: p / 180,
                RAD2DEG: 180 / p
            },
            w = {
                format: {},
                autodetect: []
            },
            y = m.last,
            v = m.clip_rgb,
            _ = m.type,
            E = w,
            P = function() {
                for (var x = [], S = arguments.length; S--;) x[S] = arguments[S];
                var A = this;
                if (_(x[0]) === "object" && x[0].constructor && x[0].constructor === this.constructor) return x[0];
                var N = y(x),
                    F = !1;
                if (!N) {
                    F = !0, E.sorted || (E.autodetect = E.autodetect.sort(function(J, le) {
                        return le.p - J.p
                    }), E.sorted = !0);
                    for (var $ = 0, U = E.autodetect; $ < U.length; $ += 1) {
                        var H = U[$];
                        if (N = H.test.apply(H, x), N) break
                    }
                }
                if (E.format[N]) {
                    var Y = E.format[N].apply(null, F ? x : x.slice(0, -1));
                    A._rgb = v(Y)
                } else throw new Error("unknown format: " + x);
                A._rgb.length === 3 && A._rgb.push(1)
            };
        P.prototype.toString = function() {
            return _(this.hex) == "function" ? this.hex() : "[" + this._rgb.join(",") + "]"
        };
        var C = P,
            T = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                return new(Function.prototype.bind.apply(T.Color, [null].concat(g)))
            };
        T.Color = C, T.version = "2.4.2";
        var O = T,
            k = m.unpack,
            D = Math.max,
            B = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = k(g, "rgb"),
                    A = S[0],
                    N = S[1],
                    F = S[2];
                A = A / 255, N = N / 255, F = F / 255;
                var $ = 1 - D(A, D(N, F)),
                    U = $ < 1 ? 1 / (1 - $) : 0,
                    H = (1 - A - $) * U,
                    Y = (1 - N - $) * U,
                    J = (1 - F - $) * U;
                return [H, Y, J, $]
            },
            j = B,
            L = m.unpack,
            M = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                g = L(g, "cmyk");
                var S = g[0],
                    A = g[1],
                    N = g[2],
                    F = g[3],
                    $ = g.length > 4 ? g[4] : 1;
                return F === 1 ? [0, 0, 0, $] : [S >= 1 ? 0 : 255 * (1 - S) * (1 - F), A >= 1 ? 0 : 255 * (1 - A) * (1 - F), N >= 1 ? 0 : 255 * (1 - N) * (1 - F), $]
            },
            W = M,
            Z = O,
            q = C,
            G = w,
            X = m.unpack,
            z = m.type,
            Q = j;
        q.prototype.cmyk = function() {
            return Q(this._rgb)
        }, Z.cmyk = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(q, [null].concat(g, ["cmyk"])))
        }, G.format.cmyk = W, G.autodetect.push({
            p: 2,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = X(g, "cmyk"), z(g) === "array" && g.length === 4) return "cmyk"
            }
        });
        var ie = m.unpack,
            _e = m.last,
            we = function(g) {
                return Math.round(g * 100) / 100
            },
            De = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = ie(g, "hsla"),
                    A = _e(g) || "lsa";
                return S[0] = we(S[0] || 0), S[1] = we(S[1] * 100) + "%", S[2] = we(S[2] * 100) + "%", A === "hsla" || S.length > 3 && S[3] < 1 ? (S[3] = S.length > 3 ? S[3] : 1, A = "hsla") : S.length = 3, A + "(" + S.join(",") + ")"
            },
            Te = De,
            Ne = m.unpack,
            et = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                g = Ne(g, "rgba");
                var S = g[0],
                    A = g[1],
                    N = g[2];
                S /= 255, A /= 255, N /= 255;
                var F = Math.min(S, A, N),
                    $ = Math.max(S, A, N),
                    U = ($ + F) / 2,
                    H, Y;
                return $ === F ? (H = 0, Y = Number.NaN) : H = U < .5 ? ($ - F) / ($ + F) : ($ - F) / (2 - $ - F), S == $ ? Y = (A - N) / ($ - F) : A == $ ? Y = 2 + (N - S) / ($ - F) : N == $ && (Y = 4 + (S - A) / ($ - F)), Y *= 60, Y < 0 && (Y += 360), g.length > 3 && g[3] !== void 0 ? [Y, H, U, g[3]] : [Y, H, U]
            },
            Le = et,
            tt = m.unpack,
            Ue = m.last,
            Ve = Te,
            rt = Le,
            Dt = Math.round,
            zt = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = tt(g, "rgba"),
                    A = Ue(g) || "rgb";
                return A.substr(0, 3) == "hsl" ? Ve(rt(S), A) : (S[0] = Dt(S[0]), S[1] = Dt(S[1]), S[2] = Dt(S[2]), (A === "rgba" || S.length > 3 && S[3] < 1) && (S[3] = S.length > 3 ? S[3] : 1, A = "rgba"), A + "(" + S.slice(0, A === "rgb" ? 3 : 4).join(",") + ")")
            },
            Vr = zt,
            at = m.unpack,
            _r = Math.round,
            Ni = function() {
                for (var g, x = [], S = arguments.length; S--;) x[S] = arguments[S];
                x = at(x, "hsl");
                var A = x[0],
                    N = x[1],
                    F = x[2],
                    $, U, H;
                if (N === 0) $ = U = H = F * 255;
                else {
                    var Y = [0, 0, 0],
                        J = [0, 0, 0],
                        le = F < .5 ? F * (1 + N) : F + N - F * N,
                        ee = 2 * F - le,
                        pe = A / 360;
                    Y[0] = pe + 1 / 3, Y[1] = pe, Y[2] = pe - 1 / 3;
                    for (var de = 0; de < 3; de++) Y[de] < 0 && (Y[de] += 1), Y[de] > 1 && (Y[de] -= 1), 6 * Y[de] < 1 ? J[de] = ee + (le - ee) * 6 * Y[de] : 2 * Y[de] < 1 ? J[de] = le : 3 * Y[de] < 2 ? J[de] = ee + (le - ee) * (2 / 3 - Y[de]) * 6 : J[de] = ee;
                    g = [_r(J[0] * 255), _r(J[1] * 255), _r(J[2] * 255)], $ = g[0], U = g[1], H = g[2]
                }
                return x.length > 3 ? [$, U, H, x[3]] : [$, U, H, 1]
            },
            Ar = Ni,
            Bu = Ar,
            zu = w,
            ju = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/,
            ae = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/,
            xe = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/,
            gt = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/,
            At = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/,
            or = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/,
            Li = Math.round,
            li = function(g) {
                g = g.toLowerCase().trim();
                var x;
                if (zu.format.named) try {
                    return zu.format.named(g)
                } catch {}
                if (x = g.match(ju)) {
                    for (var S = x.slice(1, 4), A = 0; A < 3; A++) S[A] = +S[A];
                    return S[3] = 1, S
                }
                if (x = g.match(ae)) {
                    for (var N = x.slice(1, 5), F = 0; F < 4; F++) N[F] = +N[F];
                    return N
                }
                if (x = g.match(xe)) {
                    for (var $ = x.slice(1, 4), U = 0; U < 3; U++) $[U] = Li($[U] * 2.55);
                    return $[3] = 1, $
                }
                if (x = g.match(gt)) {
                    for (var H = x.slice(1, 5), Y = 0; Y < 3; Y++) H[Y] = Li(H[Y] * 2.55);
                    return H[3] = +H[3], H
                }
                if (x = g.match(At)) {
                    var J = x.slice(1, 4);
                    J[1] *= .01, J[2] *= .01;
                    var le = Bu(J);
                    return le[3] = 1, le
                }
                if (x = g.match(or)) {
                    var ee = x.slice(1, 4);
                    ee[1] *= .01, ee[2] *= .01;
                    var pe = Bu(ee);
                    return pe[3] = +x[4], pe
                }
            };
        li.test = function(g) {
            return ju.test(g) || ae.test(g) || xe.test(g) || gt.test(g) || At.test(g) || or.test(g)
        };
        var Pl = li,
            Cl = O,
            Mo = C,
            ks = w,
            Tl = m.type,
            Ol = Vr,
            Do = Pl;
        Mo.prototype.css = function(g) {
            return Ol(this._rgb, g)
        }, Cl.css = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(Mo, [null].concat(g, ["css"])))
        }, ks.format.css = Do, ks.autodetect.push({
            p: 5,
            test: function(g) {
                for (var x = [], S = arguments.length - 1; S-- > 0;) x[S] = arguments[S + 1];
                if (!x.length && Tl(g) === "string" && Do.test(g)) return "css"
            }
        });
        var No = C,
            Tg = O,
            PN = w,
            CN = m.unpack;
        PN.format.gl = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            var S = CN(g, "rgba");
            return S[0] *= 255, S[1] *= 255, S[2] *= 255, S
        }, Tg.gl = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(No, [null].concat(g, ["gl"])))
        }, No.prototype.gl = function() {
            var g = this._rgb;
            return [g[0] / 255, g[1] / 255, g[2] / 255, g[3]]
        };
        var TN = m.unpack,
            ON = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = TN(g, "rgb"),
                    A = S[0],
                    N = S[1],
                    F = S[2],
                    $ = Math.min(A, N, F),
                    U = Math.max(A, N, F),
                    H = U - $,
                    Y = H * 100 / 255,
                    J = $ / (255 - H) * 100,
                    le;
                return H === 0 ? le = Number.NaN : (A === U && (le = (N - F) / H), N === U && (le = 2 + (F - A) / H), F === U && (le = 4 + (A - N) / H), le *= 60, le < 0 && (le += 360)), [le, Y, J]
            },
            AN = ON,
            IN = m.unpack,
            $N = Math.floor,
            RN = function() {
                for (var g, x, S, A, N, F, $ = [], U = arguments.length; U--;) $[U] = arguments[U];
                $ = IN($, "hcg");
                var H = $[0],
                    Y = $[1],
                    J = $[2],
                    le, ee, pe;
                J = J * 255;
                var de = Y * 255;
                if (Y === 0) le = ee = pe = J;
                else {
                    H === 360 && (H = 0), H > 360 && (H -= 360), H < 0 && (H += 360), H /= 60;
                    var Re = $N(H),
                        Fe = H - Re,
                        We = J * (1 - Y),
                        Ke = We + de * (1 - Fe),
                        Yt = We + de * Fe,
                        Ut = We + de;
                    switch (Re) {
                        case 0:
                            g = [Ut, Yt, We], le = g[0], ee = g[1], pe = g[2];
                            break;
                        case 1:
                            x = [Ke, Ut, We], le = x[0], ee = x[1], pe = x[2];
                            break;
                        case 2:
                            S = [We, Ut, Yt], le = S[0], ee = S[1], pe = S[2];
                            break;
                        case 3:
                            A = [We, Ke, Ut], le = A[0], ee = A[1], pe = A[2];
                            break;
                        case 4:
                            N = [Yt, We, Ut], le = N[0], ee = N[1], pe = N[2];
                            break;
                        case 5:
                            F = [Ut, We, Ke], le = F[0], ee = F[1], pe = F[2];
                            break
                    }
                }
                return [le, ee, pe, $.length > 3 ? $[3] : 1]
            },
            kN = RN,
            MN = m.unpack,
            DN = m.type,
            NN = O,
            rb = C,
            nb = w,
            LN = AN;
        rb.prototype.hcg = function() {
            return LN(this._rgb)
        }, NN.hcg = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(rb, [null].concat(g, ["hcg"])))
        }, nb.format.hcg = kN, nb.autodetect.push({
            p: 1,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = MN(g, "hcg"), DN(g) === "array" && g.length === 3) return "hcg"
            }
        });
        var FN = m.unpack,
            BN = m.last,
            Uu = Math.round,
            zN = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = FN(g, "rgba"),
                    A = S[0],
                    N = S[1],
                    F = S[2],
                    $ = S[3],
                    U = BN(g) || "auto";
                $ === void 0 && ($ = 1), U === "auto" && (U = $ < 1 ? "rgba" : "rgb"), A = Uu(A), N = Uu(N), F = Uu(F);
                var H = A << 16 | N << 8 | F,
                    Y = "000000" + H.toString(16);
                Y = Y.substr(Y.length - 6);
                var J = "0" + Uu($ * 255).toString(16);
                switch (J = J.substr(J.length - 2), U.toLowerCase()) {
                    case "rgba":
                        return "#" + Y + J;
                    case "argb":
                        return "#" + J + Y;
                    default:
                        return "#" + Y
                }
            },
            ib = zN,
            jN = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
            UN = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/,
            HN = function(g) {
                if (g.match(jN)) {
                    (g.length === 4 || g.length === 7) && (g = g.substr(1)), g.length === 3 && (g = g.split(""), g = g[0] + g[0] + g[1] + g[1] + g[2] + g[2]);
                    var x = parseInt(g, 16),
                        S = x >> 16,
                        A = x >> 8 & 255,
                        N = x & 255;
                    return [S, A, N, 1]
                }
                if (g.match(UN)) {
                    (g.length === 5 || g.length === 9) && (g = g.substr(1)), g.length === 4 && (g = g.split(""), g = g[0] + g[0] + g[1] + g[1] + g[2] + g[2] + g[3] + g[3]);
                    var F = parseInt(g, 16),
                        $ = F >> 24 & 255,
                        U = F >> 16 & 255,
                        H = F >> 8 & 255,
                        Y = Math.round((F & 255) / 255 * 100) / 100;
                    return [$, U, H, Y]
                }
                throw new Error("unknown hex color: " + g)
            },
            sb = HN,
            GN = O,
            ob = C,
            VN = m.type,
            ab = w,
            WN = ib;
        ob.prototype.hex = function(g) {
            return WN(this._rgb, g)
        }, GN.hex = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(ob, [null].concat(g, ["hex"])))
        }, ab.format.hex = sb, ab.autodetect.push({
            p: 4,
            test: function(g) {
                for (var x = [], S = arguments.length - 1; S-- > 0;) x[S] = arguments[S + 1];
                if (!x.length && VN(g) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(g.length) >= 0) return "hex"
            }
        });
        var XN = m.unpack,
            lb = m.TWOPI,
            YN = Math.min,
            KN = Math.sqrt,
            qN = Math.acos,
            QN = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = XN(g, "rgb"),
                    A = S[0],
                    N = S[1],
                    F = S[2];
                A /= 255, N /= 255, F /= 255;
                var $, U = YN(A, N, F),
                    H = (A + N + F) / 3,
                    Y = H > 0 ? 1 - U / H : 0;
                return Y === 0 ? $ = NaN : ($ = (A - N + (A - F)) / 2, $ /= KN((A - N) * (A - N) + (A - F) * (N - F)), $ = qN($), F > N && ($ = lb - $), $ /= lb), [$ * 360, Y, H]
            },
            ZN = QN,
            JN = m.unpack,
            Og = m.limit,
            Lo = m.TWOPI,
            Ag = m.PITHIRD,
            Fo = Math.cos,
            e4 = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                g = JN(g, "hsi");
                var S = g[0],
                    A = g[1],
                    N = g[2],
                    F, $, U;
                return isNaN(S) && (S = 0), isNaN(A) && (A = 0), S > 360 && (S -= 360), S < 0 && (S += 360), S /= 360, S < 1 / 3 ? (U = (1 - A) / 3, F = (1 + A * Fo(Lo * S) / Fo(Ag - Lo * S)) / 3, $ = 1 - (U + F)) : S < 2 / 3 ? (S -= 1 / 3, F = (1 - A) / 3, $ = (1 + A * Fo(Lo * S) / Fo(Ag - Lo * S)) / 3, U = 1 - (F + $)) : (S -= 2 / 3, $ = (1 - A) / 3, U = (1 + A * Fo(Lo * S) / Fo(Ag - Lo * S)) / 3, F = 1 - ($ + U)), F = Og(N * F * 3), $ = Og(N * $ * 3), U = Og(N * U * 3), [F * 255, $ * 255, U * 255, g.length > 3 ? g[3] : 1]
            },
            t4 = e4,
            r4 = m.unpack,
            n4 = m.type,
            i4 = O,
            cb = C,
            ub = w,
            s4 = ZN;
        cb.prototype.hsi = function() {
            return s4(this._rgb)
        }, i4.hsi = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(cb, [null].concat(g, ["hsi"])))
        }, ub.format.hsi = t4, ub.autodetect.push({
            p: 2,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = r4(g, "hsi"), n4(g) === "array" && g.length === 3) return "hsi"
            }
        });
        var o4 = m.unpack,
            a4 = m.type,
            l4 = O,
            hb = C,
            db = w,
            c4 = Le;
        hb.prototype.hsl = function() {
            return c4(this._rgb)
        }, l4.hsl = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(hb, [null].concat(g, ["hsl"])))
        }, db.format.hsl = Ar, db.autodetect.push({
            p: 2,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = o4(g, "hsl"), a4(g) === "array" && g.length === 3) return "hsl"
            }
        });
        var u4 = m.unpack,
            h4 = Math.min,
            d4 = Math.max,
            f4 = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                g = u4(g, "rgb");
                var S = g[0],
                    A = g[1],
                    N = g[2],
                    F = h4(S, A, N),
                    $ = d4(S, A, N),
                    U = $ - F,
                    H, Y, J;
                return J = $ / 255, $ === 0 ? (H = Number.NaN, Y = 0) : (Y = U / $, S === $ && (H = (A - N) / U), A === $ && (H = 2 + (N - S) / U), N === $ && (H = 4 + (S - A) / U), H *= 60, H < 0 && (H += 360)), [H, Y, J]
            },
            p4 = f4,
            m4 = m.unpack,
            g4 = Math.floor,
            v4 = function() {
                for (var g, x, S, A, N, F, $ = [], U = arguments.length; U--;) $[U] = arguments[U];
                $ = m4($, "hsv");
                var H = $[0],
                    Y = $[1],
                    J = $[2],
                    le, ee, pe;
                if (J *= 255, Y === 0) le = ee = pe = J;
                else {
                    H === 360 && (H = 0), H > 360 && (H -= 360), H < 0 && (H += 360), H /= 60;
                    var de = g4(H),
                        Re = H - de,
                        Fe = J * (1 - Y),
                        We = J * (1 - Y * Re),
                        Ke = J * (1 - Y * (1 - Re));
                    switch (de) {
                        case 0:
                            g = [J, Ke, Fe], le = g[0], ee = g[1], pe = g[2];
                            break;
                        case 1:
                            x = [We, J, Fe], le = x[0], ee = x[1], pe = x[2];
                            break;
                        case 2:
                            S = [Fe, J, Ke], le = S[0], ee = S[1], pe = S[2];
                            break;
                        case 3:
                            A = [Fe, We, J], le = A[0], ee = A[1], pe = A[2];
                            break;
                        case 4:
                            N = [Ke, Fe, J], le = N[0], ee = N[1], pe = N[2];
                            break;
                        case 5:
                            F = [J, Fe, We], le = F[0], ee = F[1], pe = F[2];
                            break
                    }
                }
                return [le, ee, pe, $.length > 3 ? $[3] : 1]
            },
            y4 = v4,
            _4 = m.unpack,
            w4 = m.type,
            b4 = O,
            fb = C,
            pb = w,
            x4 = p4;
        fb.prototype.hsv = function() {
            return x4(this._rgb)
        }, b4.hsv = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(fb, [null].concat(g, ["hsv"])))
        }, pb.format.hsv = y4, pb.autodetect.push({
            p: 2,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = _4(g, "hsv"), w4(g) === "array" && g.length === 3) return "hsv"
            }
        });
        var Hu = {
                Kn: 18,
                Xn: .95047,
                Yn: 1,
                Zn: 1.08883,
                t0: .137931034,
                t1: .206896552,
                t2: .12841855,
                t3: .008856452
            },
            Bo = Hu,
            E4 = m.unpack,
            mb = Math.pow,
            S4 = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = E4(g, "rgb"),
                    A = S[0],
                    N = S[1],
                    F = S[2],
                    $ = P4(A, N, F),
                    U = $[0],
                    H = $[1],
                    Y = $[2],
                    J = 116 * H - 16;
                return [J < 0 ? 0 : J, 500 * (U - H), 200 * (H - Y)]
            },
            Ig = function(g) {
                return (g /= 255) <= .04045 ? g / 12.92 : mb((g + .055) / 1.055, 2.4)
            },
            $g = function(g) {
                return g > Bo.t3 ? mb(g, 1 / 3) : g / Bo.t2 + Bo.t0
            },
            P4 = function(g, x, S) {
                g = Ig(g), x = Ig(x), S = Ig(S);
                var A = $g((.4124564 * g + .3575761 * x + .1804375 * S) / Bo.Xn),
                    N = $g((.2126729 * g + .7151522 * x + .072175 * S) / Bo.Yn),
                    F = $g((.0193339 * g + .119192 * x + .9503041 * S) / Bo.Zn);
                return [A, N, F]
            },
            gb = S4,
            zo = Hu,
            C4 = m.unpack,
            T4 = Math.pow,
            O4 = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                g = C4(g, "lab");
                var S = g[0],
                    A = g[1],
                    N = g[2],
                    F, $, U, H, Y, J;
                return $ = (S + 16) / 116, F = isNaN(A) ? $ : $ + A / 500, U = isNaN(N) ? $ : $ - N / 200, $ = zo.Yn * kg($), F = zo.Xn * kg(F), U = zo.Zn * kg(U), H = Rg(3.2404542 * F - 1.5371385 * $ - .4985314 * U), Y = Rg(-.969266 * F + 1.8760108 * $ + .041556 * U), J = Rg(.0556434 * F - .2040259 * $ + 1.0572252 * U), [H, Y, J, g.length > 3 ? g[3] : 1]
            },
            Rg = function(g) {
                return 255 * (g <= .00304 ? 12.92 * g : 1.055 * T4(g, 1 / 2.4) - .055)
            },
            kg = function(g) {
                return g > zo.t1 ? g * g * g : zo.t2 * (g - zo.t0)
            },
            vb = O4,
            A4 = m.unpack,
            I4 = m.type,
            $4 = O,
            yb = C,
            _b = w,
            R4 = gb;
        yb.prototype.lab = function() {
            return R4(this._rgb)
        }, $4.lab = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(yb, [null].concat(g, ["lab"])))
        }, _b.format.lab = vb, _b.autodetect.push({
            p: 2,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = A4(g, "lab"), I4(g) === "array" && g.length === 3) return "lab"
            }
        });
        var k4 = m.unpack,
            M4 = m.RAD2DEG,
            D4 = Math.sqrt,
            N4 = Math.atan2,
            L4 = Math.round,
            F4 = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = k4(g, "lab"),
                    A = S[0],
                    N = S[1],
                    F = S[2],
                    $ = D4(N * N + F * F),
                    U = (N4(F, N) * M4 + 360) % 360;
                return L4($ * 1e4) === 0 && (U = Number.NaN), [A, $, U]
            },
            wb = F4,
            B4 = m.unpack,
            z4 = gb,
            j4 = wb,
            U4 = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = B4(g, "rgb"),
                    A = S[0],
                    N = S[1],
                    F = S[2],
                    $ = z4(A, N, F),
                    U = $[0],
                    H = $[1],
                    Y = $[2];
                return j4(U, H, Y)
            },
            H4 = U4,
            G4 = m.unpack,
            V4 = m.DEG2RAD,
            W4 = Math.sin,
            X4 = Math.cos,
            Y4 = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = G4(g, "lch"),
                    A = S[0],
                    N = S[1],
                    F = S[2];
                return isNaN(F) && (F = 0), F = F * V4, [A, X4(F) * N, W4(F) * N]
            },
            bb = Y4,
            K4 = m.unpack,
            q4 = bb,
            Q4 = vb,
            Z4 = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                g = K4(g, "lch");
                var S = g[0],
                    A = g[1],
                    N = g[2],
                    F = q4(S, A, N),
                    $ = F[0],
                    U = F[1],
                    H = F[2],
                    Y = Q4($, U, H),
                    J = Y[0],
                    le = Y[1],
                    ee = Y[2];
                return [J, le, ee, g.length > 3 ? g[3] : 1]
            },
            xb = Z4,
            J4 = m.unpack,
            eL = xb,
            tL = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = J4(g, "hcl").reverse();
                return eL.apply(void 0, S)
            },
            rL = tL,
            nL = m.unpack,
            iL = m.type,
            Eb = O,
            Gu = C,
            Mg = w,
            Sb = H4;
        Gu.prototype.lch = function() {
            return Sb(this._rgb)
        }, Gu.prototype.hcl = function() {
            return Sb(this._rgb).reverse()
        }, Eb.lch = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(Gu, [null].concat(g, ["lch"])))
        }, Eb.hcl = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(Gu, [null].concat(g, ["hcl"])))
        }, Mg.format.lch = xb, Mg.format.hcl = rL, ["lch", "hcl"].forEach(function(g) {
            return Mg.autodetect.push({
                p: 2,
                test: function() {
                    for (var x = [], S = arguments.length; S--;) x[S] = arguments[S];
                    if (x = nL(x, g), iL(x) === "array" && x.length === 3) return g
                }
            })
        });
        var sL = {
                aliceblue: "#f0f8ff",
                antiquewhite: "#faebd7",
                aqua: "#00ffff",
                aquamarine: "#7fffd4",
                azure: "#f0ffff",
                beige: "#f5f5dc",
                bisque: "#ffe4c4",
                black: "#000000",
                blanchedalmond: "#ffebcd",
                blue: "#0000ff",
                blueviolet: "#8a2be2",
                brown: "#a52a2a",
                burlywood: "#deb887",
                cadetblue: "#5f9ea0",
                chartreuse: "#7fff00",
                chocolate: "#d2691e",
                coral: "#ff7f50",
                cornflower: "#6495ed",
                cornflowerblue: "#6495ed",
                cornsilk: "#fff8dc",
                crimson: "#dc143c",
                cyan: "#00ffff",
                darkblue: "#00008b",
                darkcyan: "#008b8b",
                darkgoldenrod: "#b8860b",
                darkgray: "#a9a9a9",
                darkgreen: "#006400",
                darkgrey: "#a9a9a9",
                darkkhaki: "#bdb76b",
                darkmagenta: "#8b008b",
                darkolivegreen: "#556b2f",
                darkorange: "#ff8c00",
                darkorchid: "#9932cc",
                darkred: "#8b0000",
                darksalmon: "#e9967a",
                darkseagreen: "#8fbc8f",
                darkslateblue: "#483d8b",
                darkslategray: "#2f4f4f",
                darkslategrey: "#2f4f4f",
                darkturquoise: "#00ced1",
                darkviolet: "#9400d3",
                deeppink: "#ff1493",
                deepskyblue: "#00bfff",
                dimgray: "#696969",
                dimgrey: "#696969",
                dodgerblue: "#1e90ff",
                firebrick: "#b22222",
                floralwhite: "#fffaf0",
                forestgreen: "#228b22",
                fuchsia: "#ff00ff",
                gainsboro: "#dcdcdc",
                ghostwhite: "#f8f8ff",
                gold: "#ffd700",
                goldenrod: "#daa520",
                gray: "#808080",
                green: "#008000",
                greenyellow: "#adff2f",
                grey: "#808080",
                honeydew: "#f0fff0",
                hotpink: "#ff69b4",
                indianred: "#cd5c5c",
                indigo: "#4b0082",
                ivory: "#fffff0",
                khaki: "#f0e68c",
                laserlemon: "#ffff54",
                lavender: "#e6e6fa",
                lavenderblush: "#fff0f5",
                lawngreen: "#7cfc00",
                lemonchiffon: "#fffacd",
                lightblue: "#add8e6",
                lightcoral: "#f08080",
                lightcyan: "#e0ffff",
                lightgoldenrod: "#fafad2",
                lightgoldenrodyellow: "#fafad2",
                lightgray: "#d3d3d3",
                lightgreen: "#90ee90",
                lightgrey: "#d3d3d3",
                lightpink: "#ffb6c1",
                lightsalmon: "#ffa07a",
                lightseagreen: "#20b2aa",
                lightskyblue: "#87cefa",
                lightslategray: "#778899",
                lightslategrey: "#778899",
                lightsteelblue: "#b0c4de",
                lightyellow: "#ffffe0",
                lime: "#00ff00",
                limegreen: "#32cd32",
                linen: "#faf0e6",
                magenta: "#ff00ff",
                maroon: "#800000",
                maroon2: "#7f0000",
                maroon3: "#b03060",
                mediumaquamarine: "#66cdaa",
                mediumblue: "#0000cd",
                mediumorchid: "#ba55d3",
                mediumpurple: "#9370db",
                mediumseagreen: "#3cb371",
                mediumslateblue: "#7b68ee",
                mediumspringgreen: "#00fa9a",
                mediumturquoise: "#48d1cc",
                mediumvioletred: "#c71585",
                midnightblue: "#191970",
                mintcream: "#f5fffa",
                mistyrose: "#ffe4e1",
                moccasin: "#ffe4b5",
                navajowhite: "#ffdead",
                navy: "#000080",
                oldlace: "#fdf5e6",
                olive: "#808000",
                olivedrab: "#6b8e23",
                orange: "#ffa500",
                orangered: "#ff4500",
                orchid: "#da70d6",
                palegoldenrod: "#eee8aa",
                palegreen: "#98fb98",
                paleturquoise: "#afeeee",
                palevioletred: "#db7093",
                papayawhip: "#ffefd5",
                peachpuff: "#ffdab9",
                peru: "#cd853f",
                pink: "#ffc0cb",
                plum: "#dda0dd",
                powderblue: "#b0e0e6",
                purple: "#800080",
                purple2: "#7f007f",
                purple3: "#a020f0",
                rebeccapurple: "#663399",
                red: "#ff0000",
                rosybrown: "#bc8f8f",
                royalblue: "#4169e1",
                saddlebrown: "#8b4513",
                salmon: "#fa8072",
                sandybrown: "#f4a460",
                seagreen: "#2e8b57",
                seashell: "#fff5ee",
                sienna: "#a0522d",
                silver: "#c0c0c0",
                skyblue: "#87ceeb",
                slateblue: "#6a5acd",
                slategray: "#708090",
                slategrey: "#708090",
                snow: "#fffafa",
                springgreen: "#00ff7f",
                steelblue: "#4682b4",
                tan: "#d2b48c",
                teal: "#008080",
                thistle: "#d8bfd8",
                tomato: "#ff6347",
                turquoise: "#40e0d0",
                violet: "#ee82ee",
                wheat: "#f5deb3",
                white: "#ffffff",
                whitesmoke: "#f5f5f5",
                yellow: "#ffff00",
                yellowgreen: "#9acd32"
            },
            Pb = sL,
            oL = C,
            Cb = w,
            aL = m.type,
            Al = Pb,
            lL = sb,
            cL = ib;
        oL.prototype.name = function() {
            for (var g = cL(this._rgb, "rgb"), x = 0, S = Object.keys(Al); x < S.length; x += 1) {
                var A = S[x];
                if (Al[A] === g) return A.toLowerCase()
            }
            return g
        }, Cb.format.named = function(g) {
            if (g = g.toLowerCase(), Al[g]) return lL(Al[g]);
            throw new Error("unknown color name: " + g)
        }, Cb.autodetect.push({
            p: 5,
            test: function(g) {
                for (var x = [], S = arguments.length - 1; S-- > 0;) x[S] = arguments[S + 1];
                if (!x.length && aL(g) === "string" && Al[g.toLowerCase()]) return "named"
            }
        });
        var uL = m.unpack,
            hL = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = uL(g, "rgb"),
                    A = S[0],
                    N = S[1],
                    F = S[2];
                return (A << 16) + (N << 8) + F
            },
            dL = hL,
            fL = m.type,
            pL = function(g) {
                if (fL(g) == "number" && g >= 0 && g <= 16777215) {
                    var x = g >> 16,
                        S = g >> 8 & 255,
                        A = g & 255;
                    return [x, S, A, 1]
                }
                throw new Error("unknown num color: " + g)
            },
            mL = pL,
            gL = O,
            Tb = C,
            Ob = w,
            vL = m.type,
            yL = dL;
        Tb.prototype.num = function() {
            return yL(this._rgb)
        }, gL.num = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(Tb, [null].concat(g, ["num"])))
        }, Ob.format.num = mL, Ob.autodetect.push({
            p: 5,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g.length === 1 && vL(g[0]) === "number" && g[0] >= 0 && g[0] <= 16777215) return "num"
            }
        });
        var _L = O,
            Dg = C,
            Ab = w,
            Ib = m.unpack,
            $b = m.type,
            Rb = Math.round;
        Dg.prototype.rgb = function(g) {
            return g === void 0 && (g = !0), g === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(Rb)
        }, Dg.prototype.rgba = function(g) {
            return g === void 0 && (g = !0), this._rgb.slice(0, 4).map(function(x, S) {
                return S < 3 ? g === !1 ? x : Rb(x) : x
            })
        }, _L.rgb = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(Dg, [null].concat(g, ["rgb"])))
        }, Ab.format.rgb = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            var S = Ib(g, "rgba");
            return S[3] === void 0 && (S[3] = 1), S
        }, Ab.autodetect.push({
            p: 3,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = Ib(g, "rgba"), $b(g) === "array" && (g.length === 3 || g.length === 4 && $b(g[3]) == "number" && g[3] >= 0 && g[3] <= 1)) return "rgb"
            }
        });
        var Vu = Math.log,
            wL = function(g) {
                var x = g / 100,
                    S, A, N;
                return x < 66 ? (S = 255, A = x < 6 ? 0 : -155.25485562709179 - .44596950469579133 * (A = x - 2) + 104.49216199393888 * Vu(A), N = x < 20 ? 0 : -254.76935184120902 + .8274096064007395 * (N = x - 10) + 115.67994401066147 * Vu(N)) : (S = 351.97690566805693 + .114206453784165 * (S = x - 55) - 40.25366309332127 * Vu(S), A = 325.4494125711974 + .07943456536662342 * (A = x - 50) - 28.0852963507957 * Vu(A), N = 255), [S, A, N, 1]
            },
            kb = wL,
            bL = kb,
            xL = m.unpack,
            EL = Math.round,
            SL = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                for (var S = xL(g, "rgb"), A = S[0], N = S[2], F = 1e3, $ = 4e4, U = .4, H; $ - F > U;) {
                    H = ($ + F) * .5;
                    var Y = bL(H);
                    Y[2] / Y[0] >= N / A ? $ = H : F = H
                }
                return EL(H)
            },
            PL = SL,
            Ng = O,
            Wu = C,
            Lg = w,
            CL = PL;
        Wu.prototype.temp = Wu.prototype.kelvin = Wu.prototype.temperature = function() {
            return CL(this._rgb)
        }, Ng.temp = Ng.kelvin = Ng.temperature = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(Wu, [null].concat(g, ["temp"])))
        }, Lg.format.temp = Lg.format.kelvin = Lg.format.temperature = kb;
        var TL = m.unpack,
            Fg = Math.cbrt,
            OL = Math.pow,
            AL = Math.sign,
            IL = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = TL(g, "rgb"),
                    A = S[0],
                    N = S[1],
                    F = S[2],
                    $ = [Bg(A / 255), Bg(N / 255), Bg(F / 255)],
                    U = $[0],
                    H = $[1],
                    Y = $[2],
                    J = Fg(.4122214708 * U + .5363325363 * H + .0514459929 * Y),
                    le = Fg(.2119034982 * U + .6806995451 * H + .1073969566 * Y),
                    ee = Fg(.0883024619 * U + .2817188376 * H + .6299787005 * Y);
                return [.2104542553 * J + .793617785 * le - .0040720468 * ee, 1.9779984951 * J - 2.428592205 * le + .4505937099 * ee, .0259040371 * J + .7827717662 * le - .808675766 * ee]
            },
            Mb = IL;

        function Bg(g) {
            var x = Math.abs(g);
            return x < .04045 ? g / 12.92 : (AL(g) || 1) * OL((x + .055) / 1.055, 2.4)
        }
        var $L = m.unpack,
            Xu = Math.pow,
            RL = Math.sign,
            kL = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                g = $L(g, "lab");
                var S = g[0],
                    A = g[1],
                    N = g[2],
                    F = Xu(S + .3963377774 * A + .2158037573 * N, 3),
                    $ = Xu(S - .1055613458 * A - .0638541728 * N, 3),
                    U = Xu(S - .0894841775 * A - 1.291485548 * N, 3);
                return [255 * zg(4.0767416621 * F - 3.3077115913 * $ + .2309699292 * U), 255 * zg(-1.2684380046 * F + 2.6097574011 * $ - .3413193965 * U), 255 * zg(-.0041960863 * F - .7034186147 * $ + 1.707614701 * U), g.length > 3 ? g[3] : 1]
            },
            Db = kL;

        function zg(g) {
            var x = Math.abs(g);
            return x > .0031308 ? (RL(g) || 1) * (1.055 * Xu(x, 1 / 2.4) - .055) : g * 12.92
        }
        var ML = m.unpack,
            DL = m.type,
            NL = O,
            Nb = C,
            Lb = w,
            LL = Mb;
        Nb.prototype.oklab = function() {
            return LL(this._rgb)
        }, NL.oklab = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(Nb, [null].concat(g, ["oklab"])))
        }, Lb.format.oklab = Db, Lb.autodetect.push({
            p: 3,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = ML(g, "oklab"), DL(g) === "array" && g.length === 3) return "oklab"
            }
        });
        var FL = m.unpack,
            BL = Mb,
            zL = wb,
            jL = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                var S = FL(g, "rgb"),
                    A = S[0],
                    N = S[1],
                    F = S[2],
                    $ = BL(A, N, F),
                    U = $[0],
                    H = $[1],
                    Y = $[2];
                return zL(U, H, Y)
            },
            UL = jL,
            HL = m.unpack,
            GL = bb,
            VL = Db,
            WL = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                g = HL(g, "lch");
                var S = g[0],
                    A = g[1],
                    N = g[2],
                    F = GL(S, A, N),
                    $ = F[0],
                    U = F[1],
                    H = F[2],
                    Y = VL($, U, H),
                    J = Y[0],
                    le = Y[1],
                    ee = Y[2];
                return [J, le, ee, g.length > 3 ? g[3] : 1]
            },
            XL = WL,
            YL = m.unpack,
            KL = m.type,
            qL = O,
            Fb = C,
            Bb = w,
            QL = UL;
        Fb.prototype.oklch = function() {
            return QL(this._rgb)
        }, qL.oklch = function() {
            for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
            return new(Function.prototype.bind.apply(Fb, [null].concat(g, ["oklch"])))
        }, Bb.format.oklch = XL, Bb.autodetect.push({
            p: 3,
            test: function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                if (g = YL(g, "oklch"), KL(g) === "array" && g.length === 3) return "oklch"
            }
        });
        var zb = C,
            ZL = m.type;
        zb.prototype.alpha = function(g, x) {
            return x === void 0 && (x = !1), g !== void 0 && ZL(g) === "number" ? x ? (this._rgb[3] = g, this) : new zb([this._rgb[0], this._rgb[1], this._rgb[2], g], "rgb") : this._rgb[3]
        };
        var JL = C;
        JL.prototype.clipped = function() {
            return this._rgb._clipped || !1
        };
        var Ms = C,
            e6 = Hu;
        Ms.prototype.darken = function(g) {
            g === void 0 && (g = 1);
            var x = this,
                S = x.lab();
            return S[0] -= e6.Kn * g, new Ms(S, "lab").alpha(x.alpha(), !0)
        }, Ms.prototype.brighten = function(g) {
            return g === void 0 && (g = 1), this.darken(-g)
        }, Ms.prototype.darker = Ms.prototype.darken, Ms.prototype.brighter = Ms.prototype.brighten;
        var t6 = C;
        t6.prototype.get = function(g) {
            var x = g.split("."),
                S = x[0],
                A = x[1],
                N = this[S]();
            if (A) {
                var F = S.indexOf(A) - (S.substr(0, 2) === "ok" ? 2 : 0);
                if (F > -1) return N[F];
                throw new Error("unknown channel " + A + " in mode " + S)
            } else return N
        };
        var jo = C,
            r6 = m.type,
            n6 = Math.pow,
            i6 = 1e-7,
            s6 = 20;
        jo.prototype.luminance = function(g) {
            if (g !== void 0 && r6(g) === "number") {
                if (g === 0) return new jo([0, 0, 0, this._rgb[3]], "rgb");
                if (g === 1) return new jo([255, 255, 255, this._rgb[3]], "rgb");
                var x = this.luminance(),
                    S = "rgb",
                    A = s6,
                    N = function($, U) {
                        var H = $.interpolate(U, .5, S),
                            Y = H.luminance();
                        return Math.abs(g - Y) < i6 || !A-- ? H : Y > g ? N($, H) : N(H, U)
                    },
                    F = (x > g ? N(new jo([0, 0, 0]), this) : N(this, new jo([255, 255, 255]))).rgb();
                return new jo(F.concat([this._rgb[3]]))
            }
            return o6.apply(void 0, this._rgb.slice(0, 3))
        };
        var o6 = function(g, x, S) {
                return g = jg(g), x = jg(x), S = jg(S), .2126 * g + .7152 * x + .0722 * S
            },
            jg = function(g) {
                return g /= 255, g <= .03928 ? g / 12.92 : n6((g + .055) / 1.055, 2.4)
            },
            Ir = {},
            jb = C,
            Ub = m.type,
            Yu = Ir,
            Hb = function(g, x, S) {
                S === void 0 && (S = .5);
                for (var A = [], N = arguments.length - 3; N-- > 0;) A[N] = arguments[N + 3];
                var F = A[0] || "lrgb";
                if (!Yu[F] && !A.length && (F = Object.keys(Yu)[0]), !Yu[F]) throw new Error("interpolation mode " + F + " is not defined");
                return Ub(g) !== "object" && (g = new jb(g)), Ub(x) !== "object" && (x = new jb(x)), Yu[F](g, x, S).alpha(g.alpha() + S * (x.alpha() - g.alpha()))
            },
            Gb = C,
            a6 = Hb;
        Gb.prototype.mix = Gb.prototype.interpolate = function(g, x) {
            x === void 0 && (x = .5);
            for (var S = [], A = arguments.length - 2; A-- > 0;) S[A] = arguments[A + 2];
            return a6.apply(void 0, [this, g, x].concat(S))
        };
        var Vb = C;
        Vb.prototype.premultiply = function(g) {
            g === void 0 && (g = !1);
            var x = this._rgb,
                S = x[3];
            return g ? (this._rgb = [x[0] * S, x[1] * S, x[2] * S, S], this) : new Vb([x[0] * S, x[1] * S, x[2] * S, S], "rgb")
        };
        var Ug = C,
            l6 = Hu;
        Ug.prototype.saturate = function(g) {
            g === void 0 && (g = 1);
            var x = this,
                S = x.lch();
            return S[1] += l6.Kn * g, S[1] < 0 && (S[1] = 0), new Ug(S, "lch").alpha(x.alpha(), !0)
        }, Ug.prototype.desaturate = function(g) {
            return g === void 0 && (g = 1), this.saturate(-g)
        };
        var Wb = C,
            Xb = m.type;
        Wb.prototype.set = function(g, x, S) {
            S === void 0 && (S = !1);
            var A = g.split("."),
                N = A[0],
                F = A[1],
                $ = this[N]();
            if (F) {
                var U = N.indexOf(F) - (N.substr(0, 2) === "ok" ? 2 : 0);
                if (U > -1) {
                    if (Xb(x) == "string") switch (x.charAt(0)) {
                            case "+":
                                $[U] += +x;
                                break;
                            case "-":
                                $[U] += +x;
                                break;
                            case "*":
                                $[U] *= +x.substr(1);
                                break;
                            case "/":
                                $[U] /= +x.substr(1);
                                break;
                            default:
                                $[U] = +x
                        } else if (Xb(x) === "number") $[U] = x;
                        else throw new Error("unsupported value for Color.set");
                    var H = new Wb($, N);
                    return S ? (this._rgb = H._rgb, this) : H
                }
                throw new Error("unknown channel " + F + " in mode " + N)
            } else return $
        };
        var c6 = C,
            u6 = function(g, x, S) {
                var A = g._rgb,
                    N = x._rgb;
                return new c6(A[0] + S * (N[0] - A[0]), A[1] + S * (N[1] - A[1]), A[2] + S * (N[2] - A[2]), "rgb")
            };
        Ir.rgb = u6;
        var h6 = C,
            Hg = Math.sqrt,
            Uo = Math.pow,
            d6 = function(g, x, S) {
                var A = g._rgb,
                    N = A[0],
                    F = A[1],
                    $ = A[2],
                    U = x._rgb,
                    H = U[0],
                    Y = U[1],
                    J = U[2];
                return new h6(Hg(Uo(N, 2) * (1 - S) + Uo(H, 2) * S), Hg(Uo(F, 2) * (1 - S) + Uo(Y, 2) * S), Hg(Uo($, 2) * (1 - S) + Uo(J, 2) * S), "rgb")
            };
        Ir.lrgb = d6;
        var f6 = C,
            p6 = function(g, x, S) {
                var A = g.lab(),
                    N = x.lab();
                return new f6(A[0] + S * (N[0] - A[0]), A[1] + S * (N[1] - A[1]), A[2] + S * (N[2] - A[2]), "lab")
            };
        Ir.lab = p6;
        var Yb = C,
            Ho = function(g, x, S, A) {
                var N, F, $, U;
                A === "hsl" ? ($ = g.hsl(), U = x.hsl()) : A === "hsv" ? ($ = g.hsv(), U = x.hsv()) : A === "hcg" ? ($ = g.hcg(), U = x.hcg()) : A === "hsi" ? ($ = g.hsi(), U = x.hsi()) : A === "lch" || A === "hcl" ? (A = "hcl", $ = g.hcl(), U = x.hcl()) : A === "oklch" && ($ = g.oklch().reverse(), U = x.oklch().reverse());
                var H, Y, J, le, ee, pe;
                (A.substr(0, 1) === "h" || A === "oklch") && (N = $, H = N[0], J = N[1], ee = N[2], F = U, Y = F[0], le = F[1], pe = F[2]);
                var de, Re, Fe, We;
                return !isNaN(H) && !isNaN(Y) ? (Y > H && Y - H > 180 ? We = Y - (H + 360) : Y < H && H - Y > 180 ? We = Y + 360 - H : We = Y - H, Re = H + S * We) : isNaN(H) ? isNaN(Y) ? Re = Number.NaN : (Re = Y, (ee == 1 || ee == 0) && A != "hsv" && (de = le)) : (Re = H, (pe == 1 || pe == 0) && A != "hsv" && (de = J)), de === void 0 && (de = J + S * (le - J)), Fe = ee + S * (pe - ee), A === "oklch" ? new Yb([Fe, de, Re], A) : new Yb([Re, de, Fe], A)
            },
            m6 = Ho,
            Kb = function(g, x, S) {
                return m6(g, x, S, "lch")
            };
        Ir.lch = Kb, Ir.hcl = Kb;
        var g6 = C,
            v6 = function(g, x, S) {
                var A = g.num(),
                    N = x.num();
                return new g6(A + S * (N - A), "num")
            };
        Ir.num = v6;
        var y6 = Ho,
            _6 = function(g, x, S) {
                return y6(g, x, S, "hcg")
            };
        Ir.hcg = _6;
        var w6 = Ho,
            b6 = function(g, x, S) {
                return w6(g, x, S, "hsi")
            };
        Ir.hsi = b6;
        var x6 = Ho,
            E6 = function(g, x, S) {
                return x6(g, x, S, "hsl")
            };
        Ir.hsl = E6;
        var S6 = Ho,
            P6 = function(g, x, S) {
                return S6(g, x, S, "hsv")
            };
        Ir.hsv = P6;
        var C6 = C,
            T6 = function(g, x, S) {
                var A = g.oklab(),
                    N = x.oklab();
                return new C6(A[0] + S * (N[0] - A[0]), A[1] + S * (N[1] - A[1]), A[2] + S * (N[2] - A[2]), "oklab")
            };
        Ir.oklab = T6;
        var O6 = Ho,
            A6 = function(g, x, S) {
                return O6(g, x, S, "oklch")
            };
        Ir.oklch = A6;
        var Gg = C,
            I6 = m.clip_rgb,
            Vg = Math.pow,
            Wg = Math.sqrt,
            Xg = Math.PI,
            qb = Math.cos,
            Qb = Math.sin,
            $6 = Math.atan2,
            R6 = function(g, x, S) {
                x === void 0 && (x = "lrgb"), S === void 0 && (S = null);
                var A = g.length;
                S || (S = Array.from(new Array(A)).map(function() {
                    return 1
                }));
                var N = A / S.reduce(function(Re, Fe) {
                    return Re + Fe
                });
                if (S.forEach(function(Re, Fe) {
                        S[Fe] *= N
                    }), g = g.map(function(Re) {
                        return new Gg(Re)
                    }), x === "lrgb") return k6(g, S);
                for (var F = g.shift(), $ = F.get(x), U = [], H = 0, Y = 0, J = 0; J < $.length; J++)
                    if ($[J] = ($[J] || 0) * S[0], U.push(isNaN($[J]) ? 0 : S[0]), x.charAt(J) === "h" && !isNaN($[J])) {
                        var le = $[J] / 180 * Xg;
                        H += qb(le) * S[0], Y += Qb(le) * S[0]
                    }
                var ee = F.alpha() * S[0];
                g.forEach(function(Re, Fe) {
                    var We = Re.get(x);
                    ee += Re.alpha() * S[Fe + 1];
                    for (var Ke = 0; Ke < $.length; Ke++)
                        if (!isNaN(We[Ke]))
                            if (U[Ke] += S[Fe + 1], x.charAt(Ke) === "h") {
                                var Yt = We[Ke] / 180 * Xg;
                                H += qb(Yt) * S[Fe + 1], Y += Qb(Yt) * S[Fe + 1]
                            } else $[Ke] += We[Ke] * S[Fe + 1]
                });
                for (var pe = 0; pe < $.length; pe++)
                    if (x.charAt(pe) === "h") {
                        for (var de = $6(Y / U[pe], H / U[pe]) / Xg * 180; de < 0;) de += 360;
                        for (; de >= 360;) de -= 360;
                        $[pe] = de
                    } else $[pe] = $[pe] / U[pe];
                return ee /= A, new Gg($, x).alpha(ee > .99999 ? 1 : ee, !0)
            },
            k6 = function(g, x) {
                for (var S = g.length, A = [0, 0, 0, 0], N = 0; N < g.length; N++) {
                    var F = g[N],
                        $ = x[N] / S,
                        U = F._rgb;
                    A[0] += Vg(U[0], 2) * $, A[1] += Vg(U[1], 2) * $, A[2] += Vg(U[2], 2) * $, A[3] += U[3] * $
                }
                return A[0] = Wg(A[0]), A[1] = Wg(A[1]), A[2] = Wg(A[2]), A[3] > .9999999 && (A[3] = 1), new Gg(I6(A))
            },
            ln = O,
            Go = m.type,
            M6 = Math.pow,
            Yg = function(g) {
                var x = "rgb",
                    S = ln("#ccc"),
                    A = 0,
                    N = [0, 1],
                    F = [],
                    $ = [0, 0],
                    U = !1,
                    H = [],
                    Y = !1,
                    J = 0,
                    le = 1,
                    ee = !1,
                    pe = {},
                    de = !0,
                    Re = 1,
                    Fe = function(te) {
                        if (te = te || ["#fff", "#000"], te && Go(te) === "string" && ln.brewer && ln.brewer[te.toLowerCase()] && (te = ln.brewer[te.toLowerCase()]), Go(te) === "array") {
                            te.length === 1 && (te = [te[0], te[0]]), te = te.slice(0);
                            for (var Ee = 0; Ee < te.length; Ee++) te[Ee] = ln(te[Ee]);
                            F.length = 0;
                            for (var Me = 0; Me < te.length; Me++) F.push(Me / (te.length - 1))
                        }
                        return wr(), H = te
                    },
                    We = function(te) {
                        if (U != null) {
                            for (var Ee = U.length - 1, Me = 0; Me < Ee && te >= U[Me];) Me++;
                            return Me - 1
                        }
                        return 0
                    },
                    Ke = function(te) {
                        return te
                    },
                    Yt = function(te) {
                        return te
                    },
                    Ut = function(te, Ee) {
                        var Me, ke;
                        if (Ee == null && (Ee = !1), isNaN(te) || te === null) return S;
                        if (Ee) ke = te;
                        else if (U && U.length > 2) {
                            var Kt = We(te);
                            ke = Kt / (U.length - 2)
                        } else le !== J ? ke = (te - J) / (le - J) : ke = 1;
                        ke = Yt(ke), Ee || (ke = Ke(ke)), Re !== 1 && (ke = M6(ke, Re)), ke = $[0] + ke * (1 - $[0] - $[1]), ke = Math.min(1, Math.max(0, ke));
                        var lt = Math.floor(ke * 1e4);
                        if (de && pe[lt]) Me = pe[lt];
                        else {
                            if (Go(H) === "array")
                                for (var Xe = 0; Xe < F.length; Xe++) {
                                    var Ze = F[Xe];
                                    if (ke <= Ze) {
                                        Me = H[Xe];
                                        break
                                    }
                                    if (ke >= Ze && Xe === F.length - 1) {
                                        Me = H[Xe];
                                        break
                                    }
                                    if (ke > Ze && ke < F[Xe + 1]) {
                                        ke = (ke - Ze) / (F[Xe + 1] - Ze), Me = ln.interpolate(H[Xe], H[Xe + 1], ke, x);
                                        break
                                    }
                                } else Go(H) === "function" && (Me = H(ke));
                            de && (pe[lt] = Me)
                        }
                        return Me
                    },
                    wr = function() {
                        return pe = {}
                    };
                Fe(g);
                var He = function(te) {
                    var Ee = ln(Ut(te));
                    return Y && Ee[Y] ? Ee[Y]() : Ee
                };
                return He.classes = function(te) {
                    if (te != null) {
                        if (Go(te) === "array") U = te, N = [te[0], te[te.length - 1]];
                        else {
                            var Ee = ln.analyze(N);
                            te === 0 ? U = [Ee.min, Ee.max] : U = ln.limits(Ee, "e", te)
                        }
                        return He
                    }
                    return U
                }, He.domain = function(te) {
                    if (!arguments.length) return N;
                    J = te[0], le = te[te.length - 1], F = [];
                    var Ee = H.length;
                    if (te.length === Ee && J !== le)
                        for (var Me = 0, ke = Array.from(te); Me < ke.length; Me += 1) {
                            var Kt = ke[Me];
                            F.push((Kt - J) / (le - J))
                        } else {
                            for (var lt = 0; lt < Ee; lt++) F.push(lt / (Ee - 1));
                            if (te.length > 2) {
                                var Xe = te.map(function(Je, nt) {
                                        return nt / (te.length - 1)
                                    }),
                                    Ze = te.map(function(Je) {
                                        return (Je - J) / (le - J)
                                    });
                                Ze.every(function(Je, nt) {
                                    return Xe[nt] === Je
                                }) || (Yt = function(Je) {
                                    if (Je <= 0 || Je >= 1) return Je;
                                    for (var nt = 0; Je >= Ze[nt + 1];) nt++;
                                    var un = (Je - Ze[nt]) / (Ze[nt + 1] - Ze[nt]),
                                        zi = Xe[nt] + un * (Xe[nt + 1] - Xe[nt]);
                                    return zi
                                })
                            }
                        }
                    return N = [J, le], He
                }, He.mode = function(te) {
                    return arguments.length ? (x = te, wr(), He) : x
                }, He.range = function(te, Ee) {
                    return Fe(te), He
                }, He.out = function(te) {
                    return Y = te, He
                }, He.spread = function(te) {
                    return arguments.length ? (A = te, He) : A
                }, He.correctLightness = function(te) {
                    return te == null && (te = !0), ee = te, wr(), ee ? Ke = function(Ee) {
                        for (var Me = Ut(0, !0).lab()[0], ke = Ut(1, !0).lab()[0], Kt = Me > ke, lt = Ut(Ee, !0).lab()[0], Xe = Me + (ke - Me) * Ee, Ze = lt - Xe, Je = 0, nt = 1, un = 20; Math.abs(Ze) > .01 && un-- > 0;)(function() {
                            return Kt && (Ze *= -1), Ze < 0 ? (Je = Ee, Ee += (nt - Ee) * .5) : (nt = Ee, Ee += (Je - Ee) * .5), lt = Ut(Ee, !0).lab()[0], Ze = lt - Xe
                        })();
                        return Ee
                    } : Ke = function(Ee) {
                        return Ee
                    }, He
                }, He.padding = function(te) {
                    return te != null ? (Go(te) === "number" && (te = [te, te]), $ = te, He) : $
                }, He.colors = function(te, Ee) {
                    arguments.length < 2 && (Ee = "hex");
                    var Me = [];
                    if (arguments.length === 0) Me = H.slice(0);
                    else if (te === 1) Me = [He(.5)];
                    else if (te > 1) {
                        var ke = N[0],
                            Kt = N[1] - ke;
                        Me = D6(0, te, !1).map(function(nt) {
                            return He(ke + nt / (te - 1) * Kt)
                        })
                    } else {
                        g = [];
                        var lt = [];
                        if (U && U.length > 2)
                            for (var Xe = 1, Ze = U.length, Je = 1 <= Ze; Je ? Xe < Ze : Xe > Ze; Je ? Xe++ : Xe--) lt.push((U[Xe - 1] + U[Xe]) * .5);
                        else lt = N;
                        Me = lt.map(function(nt) {
                            return He(nt)
                        })
                    }
                    return ln[Ee] && (Me = Me.map(function(nt) {
                        return nt[Ee]()
                    })), Me
                }, He.cache = function(te) {
                    return te != null ? (de = te, He) : de
                }, He.gamma = function(te) {
                    return te != null ? (Re = te, He) : Re
                }, He.nodata = function(te) {
                    return te != null ? (S = ln(te), He) : S
                }, He
            };

        function D6(g, x, S) {
            for (var A = [], N = g < x, F = S ? N ? x + 1 : x - 1 : x, $ = g; N ? $ < F : $ > F; N ? $++ : $--) A.push($);
            return A
        }
        var Il = C,
            N6 = Yg,
            L6 = function(g) {
                for (var x = [1, 1], S = 1; S < g; S++) {
                    for (var A = [1], N = 1; N <= x.length; N++) A[N] = (x[N] || 0) + x[N - 1];
                    x = A
                }
                return x
            },
            F6 = function(g) {
                var x, S, A, N, F, $, U;
                if (g = g.map(function(ee) {
                        return new Il(ee)
                    }), g.length === 2) x = g.map(function(ee) {
                    return ee.lab()
                }), F = x[0], $ = x[1], N = function(ee) {
                    var pe = [0, 1, 2].map(function(de) {
                        return F[de] + ee * ($[de] - F[de])
                    });
                    return new Il(pe, "lab")
                };
                else if (g.length === 3) S = g.map(function(ee) {
                    return ee.lab()
                }), F = S[0], $ = S[1], U = S[2], N = function(ee) {
                    var pe = [0, 1, 2].map(function(de) {
                        return (1 - ee) * (1 - ee) * F[de] + 2 * (1 - ee) * ee * $[de] + ee * ee * U[de]
                    });
                    return new Il(pe, "lab")
                };
                else if (g.length === 4) {
                    var H;
                    A = g.map(function(ee) {
                        return ee.lab()
                    }), F = A[0], $ = A[1], U = A[2], H = A[3], N = function(ee) {
                        var pe = [0, 1, 2].map(function(de) {
                            return (1 - ee) * (1 - ee) * (1 - ee) * F[de] + 3 * (1 - ee) * (1 - ee) * ee * $[de] + 3 * (1 - ee) * ee * ee * U[de] + ee * ee * ee * H[de]
                        });
                        return new Il(pe, "lab")
                    }
                } else if (g.length >= 5) {
                    var Y, J, le;
                    Y = g.map(function(ee) {
                        return ee.lab()
                    }), le = g.length - 1, J = L6(le), N = function(ee) {
                        var pe = 1 - ee,
                            de = [0, 1, 2].map(function(Re) {
                                return Y.reduce(function(Fe, We, Ke) {
                                    return Fe + J[Ke] * Math.pow(pe, le - Ke) * Math.pow(ee, Ke) * We[Re]
                                }, 0)
                            });
                        return new Il(de, "lab")
                    }
                } else throw new RangeError("No point in running bezier with only one color.");
                return N
            },
            B6 = function(g) {
                var x = F6(g);
                return x.scale = function() {
                    return N6(x)
                }, x
            },
            Kg = O,
            cn = function(g, x, S) {
                if (!cn[S]) throw new Error("unknown blend mode " + S);
                return cn[S](g, x)
            },
            Fi = function(g) {
                return function(x, S) {
                    var A = Kg(S).rgb(),
                        N = Kg(x).rgb();
                    return Kg.rgb(g(A, N))
                }
            },
            Bi = function(g) {
                return function(x, S) {
                    var A = [];
                    return A[0] = g(x[0], S[0]), A[1] = g(x[1], S[1]), A[2] = g(x[2], S[2]), A
                }
            },
            z6 = function(g) {
                return g
            },
            j6 = function(g, x) {
                return g * x / 255
            },
            U6 = function(g, x) {
                return g > x ? x : g
            },
            H6 = function(g, x) {
                return g > x ? g : x
            },
            G6 = function(g, x) {
                return 255 * (1 - (1 - g / 255) * (1 - x / 255))
            },
            V6 = function(g, x) {
                return x < 128 ? 2 * g * x / 255 : 255 * (1 - 2 * (1 - g / 255) * (1 - x / 255))
            },
            W6 = function(g, x) {
                return 255 * (1 - (1 - x / 255) / (g / 255))
            },
            X6 = function(g, x) {
                return g === 255 ? 255 : (g = 255 * (x / 255) / (1 - g / 255), g > 255 ? 255 : g)
            };
        cn.normal = Fi(Bi(z6)), cn.multiply = Fi(Bi(j6)), cn.screen = Fi(Bi(G6)), cn.overlay = Fi(Bi(V6)), cn.darken = Fi(Bi(U6)), cn.lighten = Fi(Bi(H6)), cn.dodge = Fi(Bi(X6)), cn.burn = Fi(Bi(W6));
        for (var Y6 = cn, qg = m.type, K6 = m.clip_rgb, q6 = m.TWOPI, Q6 = Math.pow, Z6 = Math.sin, J6 = Math.cos, Zb = O, eF = function(g, x, S, A, N) {
                g === void 0 && (g = 300), x === void 0 && (x = -1.5), S === void 0 && (S = 1), A === void 0 && (A = 1), N === void 0 && (N = [0, 1]);
                var F = 0,
                    $;
                qg(N) === "array" ? $ = N[1] - N[0] : ($ = 0, N = [N, N]);
                var U = function(H) {
                    var Y = q6 * ((g + 120) / 360 + x * H),
                        J = Q6(N[0] + $ * H, A),
                        le = F !== 0 ? S[0] + H * F : S,
                        ee = le * J * (1 - J) / 2,
                        pe = J6(Y),
                        de = Z6(Y),
                        Re = J + ee * (-.14861 * pe + 1.78277 * de),
                        Fe = J + ee * (-.29227 * pe - .90649 * de),
                        We = J + ee * (1.97294 * pe);
                    return Zb(K6([Re * 255, Fe * 255, We * 255, 1]))
                };
                return U.start = function(H) {
                    return H == null ? g : (g = H, U)
                }, U.rotations = function(H) {
                    return H == null ? x : (x = H, U)
                }, U.gamma = function(H) {
                    return H == null ? A : (A = H, U)
                }, U.hue = function(H) {
                    return H == null ? S : (S = H, qg(S) === "array" ? (F = S[1] - S[0], F === 0 && (S = S[1])) : F = 0, U)
                }, U.lightness = function(H) {
                    return H == null ? N : (qg(H) === "array" ? (N = H, $ = H[1] - H[0]) : (N = [H, H], $ = 0), U)
                }, U.scale = function() {
                    return Zb.scale(U)
                }, U.hue(S), U
            }, tF = C, rF = "0123456789abcdef", nF = Math.floor, iF = Math.random, sF = function() {
                for (var g = "#", x = 0; x < 6; x++) g += rF.charAt(nF(iF() * 16));
                return new tF(g, "hex")
            }, Qg = c, Jb = Math.log, oF = Math.pow, aF = Math.floor, lF = Math.abs, ex = function(g, x) {
                x === void 0 && (x = null);
                var S = {
                    min: Number.MAX_VALUE,
                    max: Number.MAX_VALUE * -1,
                    sum: 0,
                    values: [],
                    count: 0
                };
                return Qg(g) === "object" && (g = Object.values(g)), g.forEach(function(A) {
                    x && Qg(A) === "object" && (A = A[x]), A != null && !isNaN(A) && (S.values.push(A), S.sum += A, A < S.min && (S.min = A), A > S.max && (S.max = A), S.count += 1)
                }), S.domain = [S.min, S.max], S.limits = function(A, N) {
                    return tx(S, A, N)
                }, S
            }, tx = function(g, x, S) {
                x === void 0 && (x = "equal"), S === void 0 && (S = 7), Qg(g) == "array" && (g = ex(g));
                var A = g.min,
                    N = g.max,
                    F = g.values.sort(function(Jg, ev) {
                        return Jg - ev
                    });
                if (S === 1) return [A, N];
                var $ = [];
                if (x.substr(0, 1) === "c" && ($.push(A), $.push(N)), x.substr(0, 1) === "e") {
                    $.push(A);
                    for (var U = 1; U < S; U++) $.push(A + U / S * (N - A));
                    $.push(N)
                } else if (x.substr(0, 1) === "l") {
                    if (A <= 0) throw new Error("Logarithmic scales are only possible for values > 0");
                    var H = Math.LOG10E * Jb(A),
                        Y = Math.LOG10E * Jb(N);
                    $.push(A);
                    for (var J = 1; J < S; J++) $.push(oF(10, H + J / S * (Y - H)));
                    $.push(N)
                } else if (x.substr(0, 1) === "q") {
                    $.push(A);
                    for (var le = 1; le < S; le++) {
                        var ee = (F.length - 1) * le / S,
                            pe = aF(ee);
                        if (pe === ee) $.push(F[pe]);
                        else {
                            var de = ee - pe;
                            $.push(F[pe] * (1 - de) + F[pe + 1] * de)
                        }
                    }
                    $.push(N)
                } else if (x.substr(0, 1) === "k") {
                    var Re, Fe = F.length,
                        We = new Array(Fe),
                        Ke = new Array(S),
                        Yt = !0,
                        Ut = 0,
                        wr = null;
                    wr = [], wr.push(A);
                    for (var He = 1; He < S; He++) wr.push(A + He / S * (N - A));
                    for (wr.push(N); Yt;) {
                        for (var te = 0; te < S; te++) Ke[te] = 0;
                        for (var Ee = 0; Ee < Fe; Ee++)
                            for (var Me = F[Ee], ke = Number.MAX_VALUE, Kt = void 0, lt = 0; lt < S; lt++) {
                                var Xe = lF(wr[lt] - Me);
                                Xe < ke && (ke = Xe, Kt = lt), Ke[Kt]++, We[Ee] = Kt
                            }
                        for (var Ze = new Array(S), Je = 0; Je < S; Je++) Ze[Je] = null;
                        for (var nt = 0; nt < Fe; nt++) Re = We[nt], Ze[Re] === null ? Ze[Re] = F[nt] : Ze[Re] += F[nt];
                        for (var un = 0; un < S; un++) Ze[un] *= 1 / Ke[un];
                        Yt = !1;
                        for (var zi = 0; zi < S; zi++)
                            if (Ze[zi] !== wr[zi]) {
                                Yt = !0;
                                break
                            }
                        wr = Ze, Ut++, Ut > 200 && (Yt = !1)
                    }
                    for (var ji = {}, Vo = 0; Vo < S; Vo++) ji[Vo] = [];
                    for (var Wo = 0; Wo < Fe; Wo++) Re = We[Wo], ji[Re].push(F[Wo]);
                    for (var ui = [], Ds = 0; Ds < S; Ds++) ui.push(ji[Ds][0]), ui.push(ji[Ds][ji[Ds].length - 1]);
                    ui = ui.sort(function(Jg, ev) {
                        return Jg - ev
                    }), $.push(ui[0]);
                    for (var $l = 1; $l < ui.length; $l += 2) {
                        var Ns = ui[$l];
                        !isNaN(Ns) && $.indexOf(Ns) === -1 && $.push(Ns)
                    }
                }
                return $
            }, rx = {
                analyze: ex,
                limits: tx
            }, nx = C, cF = function(g, x) {
                g = new nx(g), x = new nx(x);
                var S = g.luminance(),
                    A = x.luminance();
                return S > A ? (S + .05) / (A + .05) : (A + .05) / (S + .05)
            }, ix = C, ci = Math.sqrt, It = Math.pow, uF = Math.min, hF = Math.max, sx = Math.atan2, ox = Math.abs, Ku = Math.cos, ax = Math.sin, dF = Math.exp, lx = Math.PI, fF = function(g, x, S, A, N) {
                S === void 0 && (S = 1), A === void 0 && (A = 1), N === void 0 && (N = 1);
                var F = function(Ns) {
                        return 360 * Ns / (2 * lx)
                    },
                    $ = function(Ns) {
                        return 2 * lx * Ns / 360
                    };
                g = new ix(g), x = new ix(x);
                var U = Array.from(g.lab()),
                    H = U[0],
                    Y = U[1],
                    J = U[2],
                    le = Array.from(x.lab()),
                    ee = le[0],
                    pe = le[1],
                    de = le[2],
                    Re = (H + ee) / 2,
                    Fe = ci(It(Y, 2) + It(J, 2)),
                    We = ci(It(pe, 2) + It(de, 2)),
                    Ke = (Fe + We) / 2,
                    Yt = .5 * (1 - ci(It(Ke, 7) / (It(Ke, 7) + It(25, 7)))),
                    Ut = Y * (1 + Yt),
                    wr = pe * (1 + Yt),
                    He = ci(It(Ut, 2) + It(J, 2)),
                    te = ci(It(wr, 2) + It(de, 2)),
                    Ee = (He + te) / 2,
                    Me = F(sx(J, Ut)),
                    ke = F(sx(de, wr)),
                    Kt = Me >= 0 ? Me : Me + 360,
                    lt = ke >= 0 ? ke : ke + 360,
                    Xe = ox(Kt - lt) > 180 ? (Kt + lt + 360) / 2 : (Kt + lt) / 2,
                    Ze = 1 - .17 * Ku($(Xe - 30)) + .24 * Ku($(2 * Xe)) + .32 * Ku($(3 * Xe + 6)) - .2 * Ku($(4 * Xe - 63)),
                    Je = lt - Kt;
                Je = ox(Je) <= 180 ? Je : lt <= Kt ? Je + 360 : Je - 360, Je = 2 * ci(He * te) * ax($(Je) / 2);
                var nt = ee - H,
                    un = te - He,
                    zi = 1 + .015 * It(Re - 50, 2) / ci(20 + It(Re - 50, 2)),
                    ji = 1 + .045 * Ee,
                    Vo = 1 + .015 * Ee * Ze,
                    Wo = 30 * dF(-It((Xe - 275) / 25, 2)),
                    ui = 2 * ci(It(Ee, 7) / (It(Ee, 7) + It(25, 7))),
                    Ds = -ui * ax(2 * $(Wo)),
                    $l = ci(It(nt / (S * zi), 2) + It(un / (A * ji), 2) + It(Je / (N * Vo), 2) + Ds * (un / (A * ji)) * (Je / (N * Vo)));
                return hF(0, uF(100, $l))
            }, cx = C, pF = function(g, x, S) {
                S === void 0 && (S = "lab"), g = new cx(g), x = new cx(x);
                var A = g.get(S),
                    N = x.get(S),
                    F = 0;
                for (var $ in A) {
                    var U = (A[$] || 0) - (N[$] || 0);
                    F += U * U
                }
                return Math.sqrt(F)
            }, mF = C, gF = function() {
                for (var g = [], x = arguments.length; x--;) g[x] = arguments[x];
                try {
                    return new(Function.prototype.bind.apply(mF, [null].concat(g))), !0
                } catch {
                    return !1
                }
            }, ux = O, hx = Yg, vF = {
                cool: function() {
                    return hx([ux.hsl(180, 1, .9), ux.hsl(250, .7, .4)])
                },
                hot: function() {
                    return hx(["#000", "#f00", "#ff0", "#fff"]).mode("rgb")
                }
            }, qu = {
                OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
                PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
                BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
                Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
                BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
                YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
                YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
                Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
                RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
                Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
                YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
                Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
                GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
                Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
                YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
                PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
                Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
                PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
                Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
                Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
                RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
                RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
                PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
                PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
                RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
                BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
                RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
                PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
                Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
                Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
                Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
                Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
                Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
                Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
                Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
                Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
            }, Zg = 0, dx = Object.keys(qu); Zg < dx.length; Zg += 1) {
            var fx = dx[Zg];
            qu[fx.toLowerCase()] = qu[fx]
        }
        var yF = qu,
            jt = O;
        jt.average = R6, jt.bezier = B6, jt.blend = Y6, jt.cubehelix = eF, jt.mix = jt.interpolate = Hb, jt.random = sF, jt.scale = Yg, jt.analyze = rx.analyze, jt.contrast = cF, jt.deltaE = fF, jt.distance = pF, jt.limits = rx.limits, jt.valid = gF, jt.scales = vF, jt.colors = Pb, jt.brewer = yF;
        var _F = jt;
        return _F
    })
})(BH);
const ao = c_;
var ts = function() {
    return ts = Object.assign || function(t) {
        for (var r, n = 1, i = arguments.length; n < i; n++) {
            r = arguments[n];
            for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        return t
    }, ts.apply(this, arguments)
};

function zH(e, t) {
    var r = {};
    for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++) t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
    return r
}

function jH(e, t, r) {
    if (r || arguments.length === 2)
        for (var n = 0, i = t.length, s; n < i; n++)(s || !(n in t)) && (s || (s = Array.prototype.slice.call(t, 0, n)), s[n] = t[n]);
    return e.concat(s || Array.prototype.slice.call(t))
}
var Ad = "right-scroll-bar-position",
    Id = "width-before-scroll-bar",
    UH = "with-scroll-bars-hidden",
    HH = "--removed-body-scroll-bar-size";

function GH(e, t) {
    return typeof e == "function" ? e(t) : e && (e.current = t), e
}

function VH(e, t) {
    var r = b.useState(function() {
        return {
            value: e,
            callback: t,
            facade: {
                get current() {
                    return r.value
                },
                set current(n) {
                    var i = r.value;
                    i !== n && (r.value = n, r.callback(n, i))
                }
            }
        }
    })[0];
    return r.callback = t, r.facade
}

function WH(e, t) {
    return VH(t || null, function(r) {
        return e.forEach(function(n) {
            return GH(n, r)
        })
    })
}
var $f = function() {
    return $f = Object.assign || function(t) {
        for (var r, n = 1, i = arguments.length; n < i; n++) {
            r = arguments[n];
            for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s])
        }
        return t
    }, $f.apply(this, arguments)
};

function XH(e, t) {
    var r = {};
    for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++) t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
    return r
}

function YH(e) {
    return e
}

function KH(e, t) {
    t === void 0 && (t = YH);
    var r = [],
        n = !1,
        i = {
            read: function() {
                if (n) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
                return r.length ? r[r.length - 1] : e
            },
            useMedium: function(s) {
                var o = t(s, n);
                return r.push(o),
                    function() {
                        r = r.filter(function(a) {
                            return a !== o
                        })
                    }
            },
            assignSyncMedium: function(s) {
                for (n = !0; r.length;) {
                    var o = r;
                    r = [], o.forEach(s)
                }
                r = {
                    push: function(a) {
                        return s(a)
                    },
                    filter: function() {
                        return r
                    }
                }
            },
            assignMedium: function(s) {
                n = !0;
                var o = [];
                if (r.length) {
                    var a = r;
                    r = [], a.forEach(s), o = r
                }
                var l = function() {
                        var u = o;
                        o = [], u.forEach(s)
                    },
                    c = function() {
                        return Promise.resolve().then(l)
                    };
                c(), r = {
                    push: function(u) {
                        o.push(u), c()
                    },
                    filter: function(u) {
                        return o = o.filter(u), r
                    }
                }
            }
        };
    return i
}

function qH(e) {
    e === void 0 && (e = {});
    var t = KH(null);
    return t.options = $f({
        async: !0,
        ssr: !1
    }, e), t
}
var pR = function(e) {
    var t = e.sideCar,
        r = XH(e, ["sideCar"]);
    if (!t) throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var n = t.read();
    if (!n) throw new Error("Sidecar medium not found");
    return b.createElement(n, $f({}, r))
};
pR.isSideCarExport = !0;

function QH(e, t) {
    return e.useMedium(t), pR
}
var mR = qH(),
    r0 = function() {},
    Vm = b.forwardRef(function(e, t) {
        var r = b.useRef(null),
            n = b.useState({
                onScrollCapture: r0,
                onWheelCapture: r0,
                onTouchMoveCapture: r0
            }),
            i = n[0],
            s = n[1],
            o = e.forwardProps,
            a = e.children,
            l = e.className,
            c = e.removeScrollBar,
            u = e.enabled,
            h = e.shards,
            d = e.sideCar,
            f = e.noIsolation,
            p = e.inert,
            m = e.allowPinchZoom,
            w = e.as,
            y = w === void 0 ? "div" : w,
            v = e.gapMode,
            _ = zH(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]),
            E = d,
            P = WH([r, t]),
            C = ts(ts({}, _), i);
        return b.createElement(b.Fragment, null, u && b.createElement(E, {
            sideCar: mR,
            removeScrollBar: c,
            shards: h,
            noIsolation: f,
            inert: p,
            setCallbacks: s,
            allowPinchZoom: !!m,
            lockRef: r,
            gapMode: v
        }), o ? b.cloneElement(b.Children.only(a), ts(ts({}, C), {
            ref: P
        })) : b.createElement(y, ts({}, C, {
            className: l,
            ref: P
        }), a))
    });
Vm.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
Vm.classNames = {
    fullWidth: Id,
    zeroRight: Ad
};
var MS, ZH = function() {
    if (MS) return MS;
    if (typeof __webpack_nonce__ < "u") return __webpack_nonce__
};

function JH() {
    if (!document) return null;
    var e = document.createElement("style");
    e.type = "text/css";
    var t = ZH();
    return t && e.setAttribute("nonce", t), e
}

function eG(e, t) {
    e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t))
}

function tG(e) {
    var t = document.head || document.getElementsByTagName("head")[0];
    t.appendChild(e)
}
var rG = function() {
        var e = 0,
            t = null;
        return {
            add: function(r) {
                e == 0 && (t = JH()) && (eG(t, r), tG(t)), e++
            },
            remove: function() {
                e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null)
            }
        }
    },
    nG = function() {
        var e = rG();
        return function(t, r) {
            b.useEffect(function() {
                return e.add(t),
                    function() {
                        e.remove()
                    }
            }, [t && r])
        }
    },
    gR = function() {
        var e = nG(),
            t = function(r) {
                var n = r.styles,
                    i = r.dynamic;
                return e(n, i), null
            };
        return t
    },
    iG = {
        left: 0,
        top: 0,
        right: 0,
        gap: 0
    },
    n0 = function(e) {
        return parseInt(e || "", 10) || 0
    },
    sG = function(e) {
        var t = window.getComputedStyle(document.body),
            r = t[e === "padding" ? "paddingLeft" : "marginLeft"],
            n = t[e === "padding" ? "paddingTop" : "marginTop"],
            i = t[e === "padding" ? "paddingRight" : "marginRight"];
        return [n0(r), n0(n), n0(i)]
    },
    oG = function(e) {
        if (e === void 0 && (e = "margin"), typeof window > "u") return iG;
        var t = sG(e),
            r = document.documentElement.clientWidth,
            n = window.innerWidth;
        return {
            left: t[0],
            top: t[1],
            right: t[2],
            gap: Math.max(0, n - r + t[2] - t[0])
        }
    },
    aG = gR(),
    lG = function(e, t, r, n) {
        var i = e.left,
            s = e.top,
            o = e.right,
            a = e.gap;
        return r === void 0 && (r = "margin"), `
  .`.concat(UH, ` {
   overflow: hidden `).concat(n, `;
   padding-right: `).concat(a, "px ").concat(n, `;
  }
  body {
    overflow: hidden `).concat(n, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(n, ";"), r === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(n, `;
    `), r === "padding" && "padding-right: ".concat(a, "px ").concat(n, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Ad, ` {
    right: `).concat(a, "px ").concat(n, `;
  }
  
  .`).concat(Id, ` {
    margin-right: `).concat(a, "px ").concat(n, `;
  }
  
  .`).concat(Ad, " .").concat(Ad, ` {
    right: 0 `).concat(n, `;
  }
  
  .`).concat(Id, " .").concat(Id, ` {
    margin-right: 0 `).concat(n, `;
  }
  
  body {
    `).concat(HH, ": ").concat(a, `px;
  }
`)
    },
    cG = function(e) {
        var t = e.noRelative,
            r = e.noImportant,
            n = e.gapMode,
            i = n === void 0 ? "margin" : n,
            s = b.useMemo(function() {
                return oG(i)
            }, [i]);
        return b.createElement(aG, {
            styles: lG(s, !t, i, r ? "" : "!important")
        })
    },
    u_ = !1;
if (typeof window < "u") try {
    var Nh = Object.defineProperty({}, "passive", {
        get: function() {
            return u_ = !0, !0
        }
    });
    window.addEventListener("test", Nh, Nh), window.removeEventListener("test", Nh, Nh)
} catch {
    u_ = !1
}
var Qo = u_ ? {
        passive: !1
    } : !1,
    uG = function(e) {
        return e.tagName === "TEXTAREA"
    },
    vR = function(e, t) {
        var r = window.getComputedStyle(e);
        return r[t] !== "hidden" && !(r.overflowY === r.overflowX && !uG(e) && r[t] === "visible")
    },
    hG = function(e) {
        return vR(e, "overflowY")
    },
    dG = function(e) {
        return vR(e, "overflowX")
    },
    DS = function(e, t) {
        var r = t.ownerDocument,
            n = t;
        do {
            typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
            var i = yR(e, n);
            if (i) {
                var s = _R(e, n),
                    o = s[1],
                    a = s[2];
                if (o > a) return !0
            }
            n = n.parentNode
        } while (n && n !== r.body);
        return !1
    },
    fG = function(e) {
        var t = e.scrollTop,
            r = e.scrollHeight,
            n = e.clientHeight;
        return [t, r, n]
    },
    pG = function(e) {
        var t = e.scrollLeft,
            r = e.scrollWidth,
            n = e.clientWidth;
        return [t, r, n]
    },
    yR = function(e, t) {
        return e === "v" ? hG(t) : dG(t)
    },
    _R = function(e, t) {
        return e === "v" ? fG(t) : pG(t)
    },
    mG = function(e, t) {
        return e === "h" && t === "rtl" ? -1 : 1
    },
    gG = function(e, t, r, n, i) {
        var s = mG(e, window.getComputedStyle(t).direction),
            o = s * n,
            a = r.target,
            l = t.contains(a),
            c = !1,
            u = o > 0,
            h = 0,
            d = 0;
        do {
            var f = _R(e, a),
                p = f[0],
                m = f[1],
                w = f[2],
                y = m - w - s * p;
            (p || y) && yR(e, a) && (h += y, d += p), a = a.parentNode
        } while (!l && a !== document.body || l && (t.contains(a) || t === a));
        return (u && (i && h === 0 || !i && o > h) || !u && (i && d === 0 || !i && -o > d)) && (c = !0), c
    },
    Lh = function(e) {
        return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0]
    },
    NS = function(e) {
        return [e.deltaX, e.deltaY]
    },
    LS = function(e) {
        return e && "current" in e ? e.current : e
    },
    vG = function(e, t) {
        return e[0] === t[0] && e[1] === t[1]
    },
    yG = function(e) {
        return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
    },
    _G = 0,
    Zo = [];

function wG(e) {
    var t = b.useRef([]),
        r = b.useRef([0, 0]),
        n = b.useRef(),
        i = b.useState(_G++)[0],
        s = b.useState(gR)[0],
        o = b.useRef(e);
    b.useEffect(function() {
        o.current = e
    }, [e]), b.useEffect(function() {
        if (e.inert) {
            document.body.classList.add("block-interactivity-".concat(i));
            var m = jH([e.lockRef.current], (e.shards || []).map(LS), !0).filter(Boolean);
            return m.forEach(function(w) {
                    return w.classList.add("allow-interactivity-".concat(i))
                }),
                function() {
                    document.body.classList.remove("block-interactivity-".concat(i)), m.forEach(function(w) {
                        return w.classList.remove("allow-interactivity-".concat(i))
                    })
                }
        }
    }, [e.inert, e.lockRef.current, e.shards]);
    var a = b.useCallback(function(m, w) {
            if ("touches" in m && m.touches.length === 2) return !o.current.allowPinchZoom;
            var y = Lh(m),
                v = r.current,
                _ = "deltaX" in m ? m.deltaX : v[0] - y[0],
                E = "deltaY" in m ? m.deltaY : v[1] - y[1],
                P, C = m.target,
                T = Math.abs(_) > Math.abs(E) ? "h" : "v";
            if ("touches" in m && T === "h" && C.type === "range") return !1;
            var O = DS(T, C);
            if (!O) return !0;
            if (O ? P = T : (P = T === "v" ? "h" : "v", O = DS(T, C)), !O) return !1;
            if (!n.current && "changedTouches" in m && (_ || E) && (n.current = P), !P) return !0;
            var k = n.current || P;
            return gG(k, w, m, k === "h" ? _ : E, !0)
        }, []),
        l = b.useCallback(function(m) {
            var w = m;
            if (!(!Zo.length || Zo[Zo.length - 1] !== s)) {
                var y = "deltaY" in w ? NS(w) : Lh(w),
                    v = t.current.filter(function(P) {
                        return P.name === w.type && P.target === w.target && vG(P.delta, y)
                    })[0];
                if (v && v.should) {
                    w.cancelable && w.preventDefault();
                    return
                }
                if (!v) {
                    var _ = (o.current.shards || []).map(LS).filter(Boolean).filter(function(P) {
                            return P.contains(w.target)
                        }),
                        E = _.length > 0 ? a(w, _[0]) : !o.current.noIsolation;
                    E && w.cancelable && w.preventDefault()
                }
            }
        }, []),
        c = b.useCallback(function(m, w, y, v) {
            var _ = {
                name: m,
                delta: w,
                target: y,
                should: v
            };
            t.current.push(_), setTimeout(function() {
                t.current = t.current.filter(function(E) {
                    return E !== _
                })
            }, 1)
        }, []),
        u = b.useCallback(function(m) {
            r.current = Lh(m), n.current = void 0
        }, []),
        h = b.useCallback(function(m) {
            c(m.type, NS(m), m.target, a(m, e.lockRef.current))
        }, []),
        d = b.useCallback(function(m) {
            c(m.type, Lh(m), m.target, a(m, e.lockRef.current))
        }, []);
    b.useEffect(function() {
        return Zo.push(s), e.setCallbacks({
                onScrollCapture: h,
                onWheelCapture: h,
                onTouchMoveCapture: d
            }), document.addEventListener("wheel", l, Qo), document.addEventListener("touchmove", l, Qo), document.addEventListener("touchstart", u, Qo),
            function() {
                Zo = Zo.filter(function(m) {
                    return m !== s
                }), document.removeEventListener("wheel", l, Qo), document.removeEventListener("touchmove", l, Qo), document.removeEventListener("touchstart", u, Qo)
            }
    }, []);
    var f = e.removeScrollBar,
        p = e.inert;
    return b.createElement(b.Fragment, null, p ? b.createElement(s, {
        styles: yG(i)
    }) : null, f ? b.createElement(cG, {
        gapMode: e.gapMode
    }) : null)
}
const bG = QH(mR, wG);
var wR = b.forwardRef(function(e, t) {
    return b.createElement(Vm, ts({}, e, {
        ref: t,
        sideCar: bG
    }))
});
wR.classNames = Vm.classNames;
const xG = wR;

function h_(e, t) {
    let r = e;
    for (;
        (r = r.parentElement) && !r.matches(t););
    return r
}

function EG(e, t, r) {
    for (let n = e - 1; n >= 0; n -= 1)
        if (!t[n].disabled) return n;
    if (r) {
        for (let n = t.length - 1; n > -1; n -= 1)
            if (!t[n].disabled) return n
    }
    return e
}

function SG(e, t, r) {
    for (let n = e + 1; n < t.length; n += 1)
        if (!t[n].disabled) return n;
    if (r) {
        for (let n = 0; n < t.length; n += 1)
            if (!t[n].disabled) return n
    }
    return e
}

function PG(e, t, r) {
    return h_(e, r) === h_(t, r)
}

function CG({
    parentSelector: e,
    siblingSelector: t,
    onKeyDown: r,
    loop: n = !0,
    activateOnFocus: i = !1,
    dir: s = "rtl",
    orientation: o
}) {
    return a => {
        var l;
        r == null || r(a);
        const c = Array.from(((l = h_(a.currentTarget, e)) == null ? void 0 : l.querySelectorAll(t)) || []).filter(m => PG(a.currentTarget, m, e)),
            u = c.findIndex(m => a.currentTarget === m),
            h = SG(u, c, n),
            d = EG(u, c, n),
            f = s === "rtl" ? d : h,
            p = s === "rtl" ? h : d;
        switch (a.key) {
            case "ArrowRight":
                {
                    o === "horizontal" && (a.stopPropagation(), a.preventDefault(), c[f].focus(), i && c[f].click());
                    break
                }
            case "ArrowLeft":
                {
                    o === "horizontal" && (a.stopPropagation(), a.preventDefault(), c[p].focus(), i && c[p].click());
                    break
                }
            case "ArrowUp":
                {
                    o === "vertical" && (a.stopPropagation(), a.preventDefault(), c[d].focus(), i && c[d].click());
                    break
                }
            case "ArrowDown":
                {
                    o === "vertical" && (a.stopPropagation(), a.preventDefault(), c[h].focus(), i && c[h].click());
                    break
                }
            case "Home":
                {
                    a.stopPropagation(),
                    a.preventDefault(),
                    !c[0].disabled && c[0].focus();
                    break
                }
            case "End":
                {
                    a.stopPropagation(),
                    a.preventDefault();
                    const m = c.length - 1;!c[m].disabled && c[m].focus();
                    break
                }
        }
    }
}

function ml(e) {
    const t = b.createContext(null);
    return [({
        children: i,
        value: s
    }) => I.createElement(t.Provider, {
        value: s
    }, i), () => {
        const i = b.useContext(t);
        if (i === null) throw new Error(e);
        return i
    }]
}

function Wm(e) {
    return Array.isArray(e) ? e : [e]
}

function FS(e, t) {
    return r => {
        if (typeof r != "string" || r.trim().length === 0) throw new Error(t);
        return `${e}-${r}`
    }
}
const TG = () => {};

function OG(e, t = {
    active: !0
}) {
    return typeof e != "function" || !t.active ? t.onKeyDown || TG : r => {
        var n;
        r.key === "Escape" && (e(r), (n = t.onTrigger) == null || n.call(t))
    }
}

function AG(e, t) {
    window.dispatchEvent(new CustomEvent(e, {
        detail: t
    }))
}
const IG = typeof window < "u" ? b.useLayoutEffect : b.useEffect;

function $G(e) {
    function t(n) {
        const i = Object.keys(n).reduce((s, o) => (s[`${e}:${o}`] = a => n[o](a.detail), s), {});
        IG(() => (Object.keys(i).forEach(s => {
            window.removeEventListener(s, i[s]), window.addEventListener(s, i[s])
        }), () => Object.keys(i).forEach(s => {
            window.removeEventListener(s, i[s])
        })), [i])
    }

    function r(n) {
        return (...i) => AG(`${e}:${String(n)}`, i[0])
    }
    return [t, r]
}

function Pu(e) {
    return Array.isArray(e) || e === null ? !1 : typeof e == "object" ? e.type !== I.Fragment : !1
}

function bR(e) {
    var t, r, n = "";
    if (typeof e == "string" || typeof e == "number") n += e;
    else if (typeof e == "object")
        if (Array.isArray(e))
            for (t = 0; t < e.length; t++) e[t] && (r = bR(e[t])) && (n && (n += " "), n += r);
        else
            for (t in e) e[t] && (n && (n += " "), n += t);
    return n
}

function xR() {
    for (var e = 0, t, r, n = ""; e < arguments.length;)(t = arguments[e++]) && (r = bR(t)) && (n && (n += " "), n += r);
    return n
}
const RG = {
    dark: ["#C1C2C5", "#A6A7AB", "#909296", "#5c5f66", "#373A40", "#2C2E33", "#25262b", "#1A1B1E", "#141517", "#101113"],
    gray: ["#f8f9fa", "#f1f3f5", "#e9ecef", "#dee2e6", "#ced4da", "#adb5bd", "#868e96", "#495057", "#343a40", "#212529"],
    red: ["#fff5f5", "#ffe3e3", "#ffc9c9", "#ffa8a8", "#ff8787", "#ff6b6b", "#fa5252", "#f03e3e", "#e03131", "#c92a2a"],
    pink: ["#fff0f6", "#ffdeeb", "#fcc2d7", "#faa2c1", "#f783ac", "#f06595", "#e64980", "#d6336c", "#c2255c", "#a61e4d"],
    grape: ["#f8f0fc", "#f3d9fa", "#eebefa", "#e599f7", "#da77f2", "#cc5de8", "#be4bdb", "#ae3ec9", "#9c36b5", "#862e9c"],
    violet: ["#f3f0ff", "#e5dbff", "#d0bfff", "#b197fc", "#9775fa", "#845ef7", "#7950f2", "#7048e8", "#6741d9", "#5f3dc4"],
    indigo: ["#edf2ff", "#dbe4ff", "#bac8ff", "#91a7ff", "#748ffc", "#5c7cfa", "#4c6ef5", "#4263eb", "#3b5bdb", "#364fc7"],
    blue: ["#e7f5ff", "#d0ebff", "#a5d8ff", "#74c0fc", "#4dabf7", "#339af0", "#228be6", "#1c7ed6", "#1971c2", "#1864ab"],
    cyan: ["#e3fafc", "#c5f6fa", "#99e9f2", "#66d9e8", "#3bc9db", "#22b8cf", "#15aabf", "#1098ad", "#0c8599", "#0b7285"],
    teal: ["#e6fcf5", "#c3fae8", "#96f2d7", "#63e6be", "#38d9a9", "#20c997", "#12b886", "#0ca678", "#099268", "#087f5b"],
    green: ["#ebfbee", "#d3f9d8", "#b2f2bb", "#8ce99a", "#69db7c", "#51cf66", "#40c057", "#37b24d", "#2f9e44", "#2b8a3e"],
    lime: ["#f4fce3", "#e9fac8", "#d8f5a2", "#c0eb75", "#a9e34b", "#94d82d", "#82c91e", "#74b816", "#66a80f", "#5c940d"],
    yellow: ["#fff9db", "#fff3bf", "#ffec99", "#ffe066", "#ffd43b", "#fcc419", "#fab005", "#f59f00", "#f08c00", "#e67700"],
    orange: ["#fff4e6", "#ffe8cc", "#ffd8a8", "#ffc078", "#ffa94d", "#ff922b", "#fd7e14", "#f76707", "#e8590c", "#d9480f"]
};

function kG(e) {
    return () => ({
        fontFamily: e.fontFamily || "sans-serif"
    })
}
var MG = Object.defineProperty,
    BS = Object.getOwnPropertySymbols,
    DG = Object.prototype.hasOwnProperty,
    NG = Object.prototype.propertyIsEnumerable,
    zS = (e, t, r) => t in e ? MG(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    jS = (e, t) => {
        for (var r in t || (t = {})) DG.call(t, r) && zS(e, r, t[r]);
        if (BS)
            for (var r of BS(t)) NG.call(t, r) && zS(e, r, t[r]);
        return e
    };

function LG(e) {
    return t => ({
        WebkitTapHighlightColor: "transparent",
        [t || "&:focus"]: jS({}, e.focusRing === "always" || e.focusRing === "auto" ? e.focusRingStyles.styles(e) : e.focusRingStyles.resetStyles(e)),
        [t ? t.replace(":focus", ":focus:not(:focus-visible)") : "&:focus:not(:focus-visible)"]: jS({}, e.focusRing === "auto" || e.focusRing === "never" ? e.focusRingStyles.resetStyles(e) : null)
    })
}

function Cu(e) {
    return t => typeof e.primaryShade == "number" ? e.primaryShade : e.primaryShade[t || e.colorScheme]
}

function sw(e) {
    const t = Cu(e);
    return (r, n, i = !0, s = !0) => {
        if (typeof r == "string" && r.includes(".")) {
            const [a, l] = r.split("."), c = parseInt(l, 10);
            if (a in e.colors && c >= 0 && c < 10) return e.colors[a][typeof n == "number" && !s ? n : c]
        }
        const o = typeof n == "number" ? n : t();
        return r in e.colors ? e.colors[r][o] : i ? e.colors[e.primaryColor][o] : r
    }
}

function ER(e) {
    let t = "";
    for (let r = 1; r < e.length - 1; r += 1) t += `${e[r]} ${r/(e.length-1)*100}%, `;
    return `${e[0]} 0%, ${t}${e[e.length-1]} 100%`
}

function FG(e, ...t) {
    return `linear-gradient(${e}deg, ${ER(t)})`
}

function BG(...e) {
    return `radial-gradient(circle, ${ER(e)})`
}

function SR(e) {
    const t = sw(e),
        r = Cu(e);
    return n => {
        const i = {
            from: (n == null ? void 0 : n.from) || e.defaultGradient.from,
            to: (n == null ? void 0 : n.to) || e.defaultGradient.to,
            deg: (n == null ? void 0 : n.deg) || e.defaultGradient.deg
        };
        return `linear-gradient(${i.deg}deg, ${t(i.from,r(),!1)} 0%, ${t(i.to,r(),!1)} 100%)`
    }
}

function PR(e) {
    return t => {
        if (typeof t == "number") return `${t/16}${e}`;
        if (typeof t == "string") {
            const r = t.replace("px", "");
            if (!Number.isNaN(Number(r))) return `${Number(r)/16}${e}`
        }
        return t
    }
}
const R = PR("rem"),
    Xm = PR("em");

function he({
    size: e,
    sizes: t,
    units: r
}) {
    return e in t ? t[e] : typeof e == "number" ? r === "em" ? Xm(e) : R(e) : e || t.md
}

function tl(e) {
    return typeof e == "number" ? e : typeof e == "string" && e.includes("rem") ? Number(e.replace("rem", "")) * 16 : typeof e == "string" && e.includes("em") ? Number(e.replace("em", "")) * 16 : Number(e)
}

function zG(e) {
    return t => `@media (min-width: ${Xm(tl(he({size:t,sizes:e.breakpoints})))})`
}

function jG(e) {
    return t => `@media (max-width: ${Xm(tl(he({size:t,sizes:e.breakpoints}))-1)})`
}

function UG(e) {
    return /^#?([0-9A-F]{3}){1,2}$/i.test(e)
}

function HG(e) {
    let t = e.replace("#", "");
    if (t.length === 3) {
        const o = t.split("");
        t = [o[0], o[0], o[1], o[1], o[2], o[2]].join("")
    }
    const r = parseInt(t, 16),
        n = r >> 16 & 255,
        i = r >> 8 & 255,
        s = r & 255;
    return {
        r: n,
        g: i,
        b: s,
        a: 1
    }
}

function GG(e) {
    const [t, r, n, i] = e.replace(/[^0-9,.]/g, "").split(",").map(Number);
    return {
        r: t,
        g: r,
        b: n,
        a: i || 1
    }
}

function ow(e) {
    return UG(e) ? HG(e) : e.startsWith("rgb") ? GG(e) : {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    }
}

function da(e, t) {
    if (typeof e != "string" || t > 1 || t < 0) return "rgba(0, 0, 0, 1)";
    if (e.startsWith("var(--")) return e;
    const {
        r,
        g: n,
        b: i
    } = ow(e);
    return `rgba(${r}, ${n}, ${i}, ${t})`
}

function VG(e = 0) {
    return {
        position: "absolute",
        top: R(e),
        right: R(e),
        left: R(e),
        bottom: R(e)
    }
}

function WG(e, t) {
    if (typeof e == "string" && e.startsWith("var(--")) return e;
    const {
        r,
        g: n,
        b: i,
        a: s
    } = ow(e), o = 1 - t, a = l => Math.round(l * o);
    return `rgba(${a(r)}, ${a(n)}, ${a(i)}, ${s})`
}

function XG(e, t) {
    if (typeof e == "string" && e.startsWith("var(--")) return e;
    const {
        r,
        g: n,
        b: i,
        a: s
    } = ow(e), o = a => Math.round(a + (255 - a) * t);
    return `rgba(${o(r)}, ${o(n)}, ${o(i)}, ${s})`
}

function YG(e) {
    return t => {
        if (typeof t == "number") return R(t);
        const r = typeof e.defaultRadius == "number" ? e.defaultRadius : e.radius[e.defaultRadius] || e.defaultRadius;
        return e.radius[t] || t || r
    }
}

function KG(e, t) {
    if (typeof e == "string" && e.includes(".")) {
        const [r, n] = e.split("."), i = parseInt(n, 10);
        if (r in t.colors && i >= 0 && i < 10) return {
            isSplittedColor: !0,
            key: r,
            shade: i
        }
    }
    return {
        isSplittedColor: !1
    }
}

function qG(e) {
    const t = sw(e),
        r = Cu(e),
        n = SR(e);
    return ({
        variant: i,
        color: s,
        gradient: o,
        primaryFallback: a
    }) => {
        const l = KG(s, e);
        switch (i) {
            case "light":
                return {
                    border: "transparent",
                    background: da(t(s, e.colorScheme === "dark" ? 8 : 0, a, !1), e.colorScheme === "dark" ? .2 : 1),
                    color: s === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(s, e.colorScheme === "dark" ? 2 : r("light")),
                    hover: da(t(s, e.colorScheme === "dark" ? 7 : 1, a, !1), e.colorScheme === "dark" ? .25 : .65)
                };
            case "subtle":
                return {
                    border: "transparent",
                    background: "transparent",
                    color: s === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(s, e.colorScheme === "dark" ? 2 : r("light")),
                    hover: da(t(s, e.colorScheme === "dark" ? 8 : 0, a, !1), e.colorScheme === "dark" ? .2 : 1)
                };
            case "outline":
                return {
                    border: t(s, e.colorScheme === "dark" ? 5 : r("light")),
                    background: "transparent",
                    color: t(s, e.colorScheme === "dark" ? 5 : r("light")),
                    hover: e.colorScheme === "dark" ? da(t(s, 5, a, !1), .05) : da(t(s, 0, a, !1), .35)
                };
            case "default":
                return {
                    border: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4],
                    background: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
                    color: e.colorScheme === "dark" ? e.white : e.black,
                    hover: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[0]
                };
            case "white":
                return {
                    border: "transparent",
                    background: e.white,
                    color: t(s, r()),
                    hover: null
                };
            case "transparent":
                return {
                    border: "transparent",
                    color: s === "dark" ? e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.dark[9] : t(s, e.colorScheme === "dark" ? 2 : r("light")),
                    background: "transparent",
                    hover: null
                };
            case "gradient":
                return {
                    background: n(o),
                    color: e.white,
                    border: "transparent",
                    hover: null
                };
            default:
                {
                    const c = r(),
                        u = l.isSplittedColor ? l.shade : c,
                        h = l.isSplittedColor ? l.key : s;
                    return {
                        border: "transparent",
                        background: t(h, u, a),
                        color: e.white,
                        hover: t(h, u === 9 ? 8 : u + 1)
                    }
                }
        }
    }
}

function QG(e) {
    return t => {
        const r = Cu(e)(t);
        return e.colors[e.primaryColor][r]
    }
}

function ZG(e) {
    return {
        "@media (hover: hover)": {
            "&:hover": e
        },
        "@media (hover: none)": {
            "&:active": e
        }
    }
}

function JG(e) {
    return () => ({
        userSelect: "none",
        color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
    })
}

function eV(e) {
    return () => e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6]
}
const Nt = {
    fontStyles: kG,
    themeColor: sw,
    focusStyles: LG,
    linearGradient: FG,
    radialGradient: BG,
    smallerThan: jG,
    largerThan: zG,
    rgba: da,
    cover: VG,
    darken: WG,
    lighten: XG,
    radius: YG,
    variant: qG,
    primaryShade: Cu,
    hover: ZG,
    gradient: SR,
    primaryColor: QG,
    placeholderStyles: JG,
    dimmed: eV
};
var tV = Object.defineProperty,
    rV = Object.defineProperties,
    nV = Object.getOwnPropertyDescriptors,
    US = Object.getOwnPropertySymbols,
    iV = Object.prototype.hasOwnProperty,
    sV = Object.prototype.propertyIsEnumerable,
    HS = (e, t, r) => t in e ? tV(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    oV = (e, t) => {
        for (var r in t || (t = {})) iV.call(t, r) && HS(e, r, t[r]);
        if (US)
            for (var r of US(t)) sV.call(t, r) && HS(e, r, t[r]);
        return e
    },
    aV = (e, t) => rV(e, nV(t));

function CR(e) {
    return aV(oV({}, e), {
        fn: {
            fontStyles: Nt.fontStyles(e),
            themeColor: Nt.themeColor(e),
            focusStyles: Nt.focusStyles(e),
            largerThan: Nt.largerThan(e),
            smallerThan: Nt.smallerThan(e),
            radialGradient: Nt.radialGradient,
            linearGradient: Nt.linearGradient,
            gradient: Nt.gradient(e),
            rgba: Nt.rgba,
            cover: Nt.cover,
            lighten: Nt.lighten,
            darken: Nt.darken,
            primaryShade: Nt.primaryShade(e),
            radius: Nt.radius(e),
            variant: Nt.variant(e),
            hover: Nt.hover,
            primaryColor: Nt.primaryColor(e),
            placeholderStyles: Nt.placeholderStyles(e),
            dimmed: Nt.dimmed(e)
        }
    })
}
const lV = {
        dir: "ltr",
        primaryShade: {
            light: 6,
            dark: 8
        },
        focusRing: "auto",
        loader: "oval",
        colorScheme: "light",
        white: "#fff",
        black: "#000",
        defaultRadius: "sm",
        transitionTimingFunction: "ease",
        colors: RG,
        lineHeight: 1.55,
        fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
        fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
        primaryColor: "blue",
        respectReducedMotion: !0,
        cursorType: "default",
        defaultGradient: {
            from: "indigo",
            to: "cyan",
            deg: 45
        },
        shadows: {
            xs: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), 0 0.0625rem 0.125rem rgba(0, 0, 0, 0.1)",
            sm: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 0.625rem 0.9375rem -0.3125rem, rgba(0, 0, 0, 0.04) 0 0.4375rem 0.4375rem -0.3125rem",
            md: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 1.25rem 1.5625rem -0.3125rem, rgba(0, 0, 0, 0.04) 0 0.625rem 0.625rem -0.3125rem",
            lg: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 1.75rem 1.4375rem -0.4375rem, rgba(0, 0, 0, 0.04) 0 0.75rem 0.75rem -0.4375rem",
            xl: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 2.25rem 1.75rem -0.4375rem, rgba(0, 0, 0, 0.04) 0 1.0625rem 1.0625rem -0.4375rem"
        },
        fontSizes: {
            xs: "0.75rem",
            sm: "0.875rem",
            md: "1rem",
            lg: "1.125rem",
            xl: "1.25rem"
        },
        radius: {
            xs: "0.125rem",
            sm: "0.25rem",
            md: "0.5rem",
            lg: "1rem",
            xl: "2rem"
        },
        spacing: {
            xs: "0.625rem",
            sm: "0.75rem",
            md: "1rem",
            lg: "1.25rem",
            xl: "1.5rem"
        },
        breakpoints: {
            xs: "36em",
            sm: "48em",
            md: "62em",
            lg: "75em",
            xl: "88em"
        },
        headings: {
            fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
            fontWeight: 700,
            sizes: {
                h1: {
                    fontSize: "2.125rem",
                    lineHeight: 1.3,
                    fontWeight: void 0
                },
                h2: {
                    fontSize: "1.625rem",
                    lineHeight: 1.35,
                    fontWeight: void 0
                },
                h3: {
                    fontSize: "1.375rem",
                    lineHeight: 1.4,
                    fontWeight: void 0
                },
                h4: {
                    fontSize: "1.125rem",
                    lineHeight: 1.45,
                    fontWeight: void 0
                },
                h5: {
                    fontSize: "1rem",
                    lineHeight: 1.5,
                    fontWeight: void 0
                },
                h6: {
                    fontSize: "0.875rem",
                    lineHeight: 1.5,
                    fontWeight: void 0
                }
            }
        },
        other: {},
        components: {},
        activeStyles: {
            transform: "translateY(0.0625rem)"
        },
        datesLocale: "en",
        globalStyles: void 0,
        focusRingStyles: {
            styles: e => ({
                outlineOffset: "0.125rem",
                outline: `0.125rem solid ${e.colors[e.primaryColor][e.colorScheme==="dark"?7:5]}`
            }),
            resetStyles: () => ({
                outline: "none"
            }),
            inputStyles: e => ({
                outline: "none",
                borderColor: e.colors[e.primaryColor][typeof e.primaryShade == "object" ? e.primaryShade[e.colorScheme] : e.primaryShade]
            })
        }
    },
    aw = CR(lV);

function cV(e) {
    if (e.sheet) return e.sheet;
    for (var t = 0; t < document.styleSheets.length; t++)
        if (document.styleSheets[t].ownerNode === e) return document.styleSheets[t]
}

function uV(e) {
    var t = document.createElement("style");
    return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t
}
var hV = function() {
        function e(r) {
            var n = this;
            this._insertTag = function(i) {
                var s;
                n.tags.length === 0 ? n.insertionPoint ? s = n.insertionPoint.nextSibling : n.prepend ? s = n.container.firstChild : s = n.before : s = n.tags[n.tags.length - 1].nextSibling, n.container.insertBefore(i, s), n.tags.push(i)
            }, this.isSpeedy = r.speedy === void 0 ? !0 : r.speedy, this.tags = [], this.ctr = 0, this.nonce = r.nonce, this.key = r.key, this.container = r.container, this.prepend = r.prepend, this.insertionPoint = r.insertionPoint, this.before = null
        }
        var t = e.prototype;
        return t.hydrate = function(n) {
            n.forEach(this._insertTag)
        }, t.insert = function(n) {
            this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(uV(this));
            var i = this.tags[this.tags.length - 1];
            if (this.isSpeedy) {
                var s = cV(i);
                try {
                    s.insertRule(n, s.cssRules.length)
                } catch {}
            } else i.appendChild(document.createTextNode(n));
            this.ctr++
        }, t.flush = function() {
            this.tags.forEach(function(n) {
                return n.parentNode && n.parentNode.removeChild(n)
            }), this.tags = [], this.ctr = 0
        }, e
    }(),
    cr = "-ms-",
    Rf = "-moz-",
    qe = "-webkit-",
    TR = "comm",
    lw = "rule",
    cw = "decl",
    dV = "@import",
    OR = "@keyframes",
    fV = "@layer",
    pV = Math.abs,
    Ym = String.fromCharCode,
    mV = Object.assign;

function gV(e, t) {
    return Zt(e, 0) ^ 45 ? (((t << 2 ^ Zt(e, 0)) << 2 ^ Zt(e, 1)) << 2 ^ Zt(e, 2)) << 2 ^ Zt(e, 3) : 0
}

function AR(e) {
    return e.trim()
}

function vV(e, t) {
    return (e = t.exec(e)) ? e[0] : e
}

function Qe(e, t, r) {
    return e.replace(t, r)
}

function d_(e, t) {
    return e.indexOf(t)
}

function Zt(e, t) {
    return e.charCodeAt(t) | 0
}

function nu(e, t, r) {
    return e.slice(t, r)
}

function Xn(e) {
    return e.length
}

function uw(e) {
    return e.length
}

function Fh(e, t) {
    return t.push(e), e
}

function yV(e, t) {
    return e.map(t).join("")
}
var Km = 1,
    rl = 1,
    IR = 0,
    Or = 0,
    kt = 0,
    gl = "";

function qm(e, t, r, n, i, s, o) {
    return {
        value: e,
        root: t,
        parent: r,
        type: n,
        props: i,
        children: s,
        line: Km,
        column: rl,
        length: o,
        return: ""
    }
}

function Xl(e, t) {
    return mV(qm("", null, null, "", null, null, 0), e, {
        length: -e.length
    }, t)
}

function _V() {
    return kt
}

function wV() {
    return kt = Or > 0 ? Zt(gl, --Or) : 0, rl--, kt === 10 && (rl = 1, Km--), kt
}

function Br() {
    return kt = Or < IR ? Zt(gl, Or++) : 0, rl++, kt === 10 && (rl = 1, Km++), kt
}

function ii() {
    return Zt(gl, Or)
}

function $d() {
    return Or
}

function Tu(e, t) {
    return nu(gl, e, t)
}

function iu(e) {
    switch (e) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1
    }
    return 0
}

function $R(e) {
    return Km = rl = 1, IR = Xn(gl = e), Or = 0, []
}

function RR(e) {
    return gl = "", e
}

function Rd(e) {
    return AR(Tu(Or - 1, f_(e === 91 ? e + 2 : e === 40 ? e + 1 : e)))
}

function bV(e) {
    for (;
        (kt = ii()) && kt < 33;) Br();
    return iu(e) > 2 || iu(kt) > 3 ? "" : " "
}

function xV(e, t) {
    for (; --t && Br() && !(kt < 48 || kt > 102 || kt > 57 && kt < 65 || kt > 70 && kt < 97););
    return Tu(e, $d() + (t < 6 && ii() == 32 && Br() == 32))
}

function f_(e) {
    for (; Br();) switch (kt) {
        case e:
            return Or;
        case 34:
        case 39:
            e !== 34 && e !== 39 && f_(kt);
            break;
        case 40:
            e === 41 && f_(e);
            break;
        case 92:
            Br();
            break
    }
    return Or
}

function EV(e, t) {
    for (; Br() && e + kt !== 47 + 10;)
        if (e + kt === 42 + 42 && ii() === 47) break;
    return "/*" + Tu(t, Or - 1) + "*" + Ym(e === 47 ? e : Br())
}

function SV(e) {
    for (; !iu(ii());) Br();
    return Tu(e, Or)
}

function PV(e) {
    return RR(kd("", null, null, null, [""], e = $R(e), 0, [0], e))
}

function kd(e, t, r, n, i, s, o, a, l) {
    for (var c = 0, u = 0, h = o, d = 0, f = 0, p = 0, m = 1, w = 1, y = 1, v = 0, _ = "", E = i, P = s, C = n, T = _; w;) switch (p = v, v = Br()) {
        case 40:
            if (p != 108 && Zt(T, h - 1) == 58) {
                d_(T += Qe(Rd(v), "&", "&\f"), "&\f") != -1 && (y = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            T += Rd(v);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            T += bV(p);
            break;
        case 92:
            T += xV($d() - 1, 7);
            continue;
        case 47:
            switch (ii()) {
                case 42:
                case 47:
                    Fh(CV(EV(Br(), $d()), t, r), l);
                    break;
                default:
                    T += "/"
            }
            break;
        case 123 * m:
            a[c++] = Xn(T) * y;
        case 125 * m:
        case 59:
        case 0:
            switch (v) {
                case 0:
                case 125:
                    w = 0;
                case 59 + u:
                    y == -1 && (T = Qe(T, /\f/g, "")), f > 0 && Xn(T) - h && Fh(f > 32 ? VS(T + ";", n, r, h - 1) : VS(Qe(T, " ", "") + ";", n, r, h - 2), l);
                    break;
                case 59:
                    T += ";";
                default:
                    if (Fh(C = GS(T, t, r, c, u, i, a, _, E = [], P = [], h), s), v === 123)
                        if (u === 0) kd(T, t, C, C, E, s, h, a, P);
                        else switch (d === 99 && Zt(T, 3) === 110 ? 100 : d) {
                            case 100:
                            case 108:
                            case 109:
                            case 115:
                                kd(e, C, C, n && Fh(GS(e, C, C, 0, 0, i, a, _, i, E = [], h), P), i, P, h, a, n ? E : P);
                                break;
                            default:
                                kd(T, C, C, C, [""], P, 0, a, P)
                        }
            }
            c = u = f = 0, m = y = 1, _ = T = "", h = o;
            break;
        case 58:
            h = 1 + Xn(T), f = p;
        default:
            if (m < 1) {
                if (v == 123) --m;
                else if (v == 125 && m++ == 0 && wV() == 125) continue
            }
            switch (T += Ym(v), v * m) {
                case 38:
                    y = u > 0 ? 1 : (T += "\f", -1);
                    break;
                case 44:
                    a[c++] = (Xn(T) - 1) * y, y = 1;
                    break;
                case 64:
                    ii() === 45 && (T += Rd(Br())), d = ii(), u = h = Xn(_ = T += SV($d())), v++;
                    break;
                case 45:
                    p === 45 && Xn(T) == 2 && (m = 0)
            }
    }
    return s
}

function GS(e, t, r, n, i, s, o, a, l, c, u) {
    for (var h = i - 1, d = i === 0 ? s : [""], f = uw(d), p = 0, m = 0, w = 0; p < n; ++p)
        for (var y = 0, v = nu(e, h + 1, h = pV(m = o[p])), _ = e; y < f; ++y)(_ = AR(m > 0 ? d[y] + " " + v : Qe(v, /&\f/g, d[y]))) && (l[w++] = _);
    return qm(e, t, r, i === 0 ? lw : a, l, c, u)
}

function CV(e, t, r) {
    return qm(e, t, r, TR, Ym(_V()), nu(e, 2, -2), 0)
}

function VS(e, t, r, n) {
    return qm(e, t, r, cw, nu(e, 0, n), nu(e, n + 1, -1), n)
}

function ja(e, t) {
    for (var r = "", n = uw(e), i = 0; i < n; i++) r += t(e[i], i, e, t) || "";
    return r
}

function TV(e, t, r, n) {
    switch (e.type) {
        case fV:
            if (e.children.length) break;
        case dV:
        case cw:
            return e.return = e.return || e.value;
        case TR:
            return "";
        case OR:
            return e.return = e.value + "{" + ja(e.children, n) + "}";
        case lw:
            e.value = e.props.join(",")
    }
    return Xn(r = ja(e.children, n)) ? e.return = e.value + "{" + r + "}" : ""
}

function OV(e) {
    var t = uw(e);
    return function(r, n, i, s) {
        for (var o = "", a = 0; a < t; a++) o += e[a](r, n, i, s) || "";
        return o
    }
}

function AV(e) {
    return function(t) {
        t.root || (t = t.return) && e(t)
    }
}
var WS = function(t) {
    var r = new WeakMap;
    return function(n) {
        if (r.has(n)) return r.get(n);
        var i = t(n);
        return r.set(n, i), i
    }
};

function IV(e) {
    var t = Object.create(null);
    return function(r) {
        return t[r] === void 0 && (t[r] = e(r)), t[r]
    }
}
var $V = function(t, r, n) {
        for (var i = 0, s = 0; i = s, s = ii(), i === 38 && s === 12 && (r[n] = 1), !iu(s);) Br();
        return Tu(t, Or)
    },
    RV = function(t, r) {
        var n = -1,
            i = 44;
        do switch (iu(i)) {
            case 0:
                i === 38 && ii() === 12 && (r[n] = 1), t[n] += $V(Or - 1, r, n);
                break;
            case 2:
                t[n] += Rd(i);
                break;
            case 4:
                if (i === 44) {
                    t[++n] = ii() === 58 ? "&\f" : "", r[n] = t[n].length;
                    break
                }
            default:
                t[n] += Ym(i)
        }
        while (i = Br());
        return t
    },
    kV = function(t, r) {
        return RR(RV($R(t), r))
    },
    XS = new WeakMap,
    MV = function(t) {
        if (!(t.type !== "rule" || !t.parent || t.length < 1)) {
            for (var r = t.value, n = t.parent, i = t.column === n.column && t.line === n.line; n.type !== "rule";)
                if (n = n.parent, !n) return;
            if (!(t.props.length === 1 && r.charCodeAt(0) !== 58 && !XS.get(n)) && !i) {
                XS.set(t, !0);
                for (var s = [], o = kV(r, s), a = n.props, l = 0, c = 0; l < o.length; l++)
                    for (var u = 0; u < a.length; u++, c++) t.props[c] = s[l] ? o[l].replace(/&\f/g, a[u]) : a[u] + " " + o[l]
            }
        }
    },
    DV = function(t) {
        if (t.type === "decl") {
            var r = t.value;
            r.charCodeAt(0) === 108 && r.charCodeAt(2) === 98 && (t.return = "", t.value = "")
        }
    };

function kR(e, t) {
    switch (gV(e, t)) {
        case 5103:
            return qe + "print-" + e + e;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return qe + e + e;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return qe + e + Rf + e + cr + e + e;
        case 6828:
        case 4268:
            return qe + e + cr + e + e;
        case 6165:
            return qe + e + cr + "flex-" + e + e;
        case 5187:
            return qe + e + Qe(e, /(\w+).+(:[^]+)/, qe + "box-$1$2" + cr + "flex-$1$2") + e;
        case 5443:
            return qe + e + cr + "flex-item-" + Qe(e, /flex-|-self/, "") + e;
        case 4675:
            return qe + e + cr + "flex-line-pack" + Qe(e, /align-content|flex-|-self/, "") + e;
        case 5548:
            return qe + e + cr + Qe(e, "shrink", "negative") + e;
        case 5292:
            return qe + e + cr + Qe(e, "basis", "preferred-size") + e;
        case 6060:
            return qe + "box-" + Qe(e, "-grow", "") + qe + e + cr + Qe(e, "grow", "positive") + e;
        case 4554:
            return qe + Qe(e, /([^-])(transform)/g, "$1" + qe + "$2") + e;
        case 6187:
            return Qe(Qe(Qe(e, /(zoom-|grab)/, qe + "$1"), /(image-set)/, qe + "$1"), e, "") + e;
        case 5495:
        case 3959:
            return Qe(e, /(image-set\([^]*)/, qe + "$1$`$1");
        case 4968:
            return Qe(Qe(e, /(.+:)(flex-)?(.*)/, qe + "box-pack:$3" + cr + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + qe + e + e;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return Qe(e, /(.+)-inline(.+)/, qe + "$1$2") + e;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (Xn(e) - 1 - t > 6) switch (Zt(e, t + 1)) {
                case 109:
                    if (Zt(e, t + 4) !== 45) break;
                case 102:
                    return Qe(e, /(.+:)(.+)-([^]+)/, "$1" + qe + "$2-$3$1" + Rf + (Zt(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
                case 115:
                    return ~d_(e, "stretch") ? kR(Qe(e, "stretch", "fill-available"), t) + e : e
            }
            break;
        case 4949:
            if (Zt(e, t + 1) !== 115) break;
        case 6444:
            switch (Zt(e, Xn(e) - 3 - (~d_(e, "!important") && 10))) {
                case 107:
                    return Qe(e, ":", ":" + qe) + e;
                case 101:
                    return Qe(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + qe + (Zt(e, 14) === 45 ? "inline-" : "") + "box$3$1" + qe + "$2$3$1" + cr + "$2box$3") + e
            }
            break;
        case 5936:
            switch (Zt(e, t + 11)) {
                case 114:
                    return qe + e + cr + Qe(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
                case 108:
                    return qe + e + cr + Qe(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
                case 45:
                    return qe + e + cr + Qe(e, /[svh]\w+-[tblr]{2}/, "lr") + e
            }
            return qe + e + cr + e + e
    }
    return e
}
var NV = function(t, r, n, i) {
        if (t.length > -1 && !t.return) switch (t.type) {
            case cw:
                t.return = kR(t.value, t.length);
                break;
            case OR:
                return ja([Xl(t, {
                    value: Qe(t.value, "@", "@" + qe)
                })], i);
            case lw:
                if (t.length) return yV(t.props, function(s) {
                    switch (vV(s, /(::plac\w+|:read-\w+)/)) {
                        case ":read-only":
                        case ":read-write":
                            return ja([Xl(t, {
                                props: [Qe(s, /:(read-\w+)/, ":" + Rf + "$1")]
                            })], i);
                        case "::placeholder":
                            return ja([Xl(t, {
                                props: [Qe(s, /:(plac\w+)/, ":" + qe + "input-$1")]
                            }), Xl(t, {
                                props: [Qe(s, /:(plac\w+)/, ":" + Rf + "$1")]
                            }), Xl(t, {
                                props: [Qe(s, /:(plac\w+)/, cr + "input-$1")]
                            })], i)
                    }
                    return ""
                })
        }
    },
    LV = [NV],
    MR = function(t) {
        var r = t.key;
        if (r === "css") {
            var n = document.querySelectorAll("style[data-emotion]:not([data-s])");
            Array.prototype.forEach.call(n, function(m) {
                var w = m.getAttribute("data-emotion");
                w.indexOf(" ") !== -1 && (document.head.appendChild(m), m.setAttribute("data-s", ""))
            })
        }
        var i = t.stylisPlugins || LV,
            s = {},
            o, a = [];
        o = t.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + r + ' "]'), function(m) {
            for (var w = m.getAttribute("data-emotion").split(" "), y = 1; y < w.length; y++) s[w[y]] = !0;
            a.push(m)
        });
        var l, c = [MV, DV]; {
            var u, h = [TV, AV(function(m) {
                    u.insert(m)
                })],
                d = OV(c.concat(i, h)),
                f = function(w) {
                    return ja(PV(w), d)
                };
            l = function(w, y, v, _) {
                u = v, f(w ? w + "{" + y.styles + "}" : y.styles), _ && (p.inserted[y.name] = !0)
            }
        }
        var p = {
            key: r,
            sheet: new hV({
                key: r,
                container: o,
                nonce: t.nonce,
                speedy: t.speedy,
                prepend: t.prepend,
                insertionPoint: t.insertionPoint
            }),
            nonce: t.nonce,
            inserted: s,
            registered: {},
            insert: l
        };
        return p.sheet.hydrate(a), p
    };

function dt() {
    return dt = Object.assign ? Object.assign.bind() : function(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = arguments[t];
            for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
        }
        return e
    }, dt.apply(this, arguments)
}
var p_ = {},
    FV = {
        get exports() {
            return p_
        },
        set exports(e) {
            p_ = e
        }
    },
    st = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wt = typeof Symbol == "function" && Symbol.for,
    hw = Wt ? Symbol.for("react.element") : 60103,
    dw = Wt ? Symbol.for("react.portal") : 60106,
    Qm = Wt ? Symbol.for("react.fragment") : 60107,
    Zm = Wt ? Symbol.for("react.strict_mode") : 60108,
    Jm = Wt ? Symbol.for("react.profiler") : 60114,
    eg = Wt ? Symbol.for("react.provider") : 60109,
    tg = Wt ? Symbol.for("react.context") : 60110,
    fw = Wt ? Symbol.for("react.async_mode") : 60111,
    rg = Wt ? Symbol.for("react.concurrent_mode") : 60111,
    ng = Wt ? Symbol.for("react.forward_ref") : 60112,
    ig = Wt ? Symbol.for("react.suspense") : 60113,
    BV = Wt ? Symbol.for("react.suspense_list") : 60120,
    sg = Wt ? Symbol.for("react.memo") : 60115,
    og = Wt ? Symbol.for("react.lazy") : 60116,
    zV = Wt ? Symbol.for("react.block") : 60121,
    jV = Wt ? Symbol.for("react.fundamental") : 60117,
    UV = Wt ? Symbol.for("react.responder") : 60118,
    HV = Wt ? Symbol.for("react.scope") : 60119;

function Gr(e) {
    if (typeof e == "object" && e !== null) {
        var t = e.$$typeof;
        switch (t) {
            case hw:
                switch (e = e.type, e) {
                    case fw:
                    case rg:
                    case Qm:
                    case Jm:
                    case Zm:
                    case ig:
                        return e;
                    default:
                        switch (e = e && e.$$typeof, e) {
                            case tg:
                            case ng:
                            case og:
                            case sg:
                            case eg:
                                return e;
                            default:
                                return t
                        }
                }
            case dw:
                return t
        }
    }
}

function DR(e) {
    return Gr(e) === rg
}
st.AsyncMode = fw;
st.ConcurrentMode = rg;
st.ContextConsumer = tg;
st.ContextProvider = eg;
st.Element = hw;
st.ForwardRef = ng;
st.Fragment = Qm;
st.Lazy = og;
st.Memo = sg;
st.Portal = dw;
st.Profiler = Jm;
st.StrictMode = Zm;
st.Suspense = ig;
st.isAsyncMode = function(e) {
    return DR(e) || Gr(e) === fw
};
st.isConcurrentMode = DR;
st.isContextConsumer = function(e) {
    return Gr(e) === tg
};
st.isContextProvider = function(e) {
    return Gr(e) === eg
};
st.isElement = function(e) {
    return typeof e == "object" && e !== null && e.$$typeof === hw
};
st.isForwardRef = function(e) {
    return Gr(e) === ng
};
st.isFragment = function(e) {
    return Gr(e) === Qm
};
st.isLazy = function(e) {
    return Gr(e) === og
};
st.isMemo = function(e) {
    return Gr(e) === sg
};
st.isPortal = function(e) {
    return Gr(e) === dw
};
st.isProfiler = function(e) {
    return Gr(e) === Jm
};
st.isStrictMode = function(e) {
    return Gr(e) === Zm
};
st.isSuspense = function(e) {
    return Gr(e) === ig
};
st.isValidElementType = function(e) {
    return typeof e == "string" || typeof e == "function" || e === Qm || e === rg || e === Jm || e === Zm || e === ig || e === BV || typeof e == "object" && e !== null && (e.$$typeof === og || e.$$typeof === sg || e.$$typeof === eg || e.$$typeof === tg || e.$$typeof === ng || e.$$typeof === jV || e.$$typeof === UV || e.$$typeof === HV || e.$$typeof === zV)
};
st.typeOf = Gr;
(function(e) {
    e.exports = st
})(FV);
var NR = p_,
    GV = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0
    },
    VV = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0
    },
    LR = {};
LR[NR.ForwardRef] = GV;
LR[NR.Memo] = VV;
var WV = !0;

function XV(e, t, r) {
    var n = "";
    return r.split(" ").forEach(function(i) {
        e[i] !== void 0 ? t.push(e[i] + ";") : n += i + " "
    }), n
}
var YV = function(t, r, n) {
        var i = t.key + "-" + r.name;
        (n === !1 || WV === !1) && t.registered[i] === void 0 && (t.registered[i] = r.styles)
    },
    FR = function(t, r, n) {
        YV(t, r, n);
        var i = t.key + "-" + r.name;
        if (t.inserted[r.name] === void 0) {
            var s = r;
            do t.insert(r === s ? "." + i : "", s, t.sheet, !0), s = s.next; while (s !== void 0)
        }
    };

function KV(e) {
    for (var t = 0, r, n = 0, i = e.length; i >= 4; ++n, i -= 4) r = e.charCodeAt(n) & 255 | (e.charCodeAt(++n) & 255) << 8 | (e.charCodeAt(++n) & 255) << 16 | (e.charCodeAt(++n) & 255) << 24, r = (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= r >>> 24, t = (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (i) {
        case 3:
            t ^= (e.charCodeAt(n + 2) & 255) << 16;
        case 2:
            t ^= (e.charCodeAt(n + 1) & 255) << 8;
        case 1:
            t ^= e.charCodeAt(n) & 255, t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16)
    }
    return t ^= t >>> 13, t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36)
}
var qV = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
    },
    QV = /[A-Z]|^ms/g,
    ZV = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
    BR = function(t) {
        return t.charCodeAt(1) === 45
    },
    YS = function(t) {
        return t != null && typeof t != "boolean"
    },
    i0 = IV(function(e) {
        return BR(e) ? e : e.replace(QV, "-$&").toLowerCase()
    }),
    KS = function(t, r) {
        switch (t) {
            case "animation":
            case "animationName":
                if (typeof r == "string") return r.replace(ZV, function(n, i, s) {
                    return Yn = {
                        name: i,
                        styles: s,
                        next: Yn
                    }, i
                })
        }
        return qV[t] !== 1 && !BR(t) && typeof r == "number" && r !== 0 ? r + "px" : r
    };

function su(e, t, r) {
    if (r == null) return "";
    if (r.__emotion_styles !== void 0) return r;
    switch (typeof r) {
        case "boolean":
            return "";
        case "object":
            {
                if (r.anim === 1) return Yn = {
                    name: r.name,
                    styles: r.styles,
                    next: Yn
                }, r.name;
                if (r.styles !== void 0) {
                    var n = r.next;
                    if (n !== void 0)
                        for (; n !== void 0;) Yn = {
                            name: n.name,
                            styles: n.styles,
                            next: Yn
                        }, n = n.next;
                    var i = r.styles + ";";
                    return i
                }
                return JV(e, t, r)
            }
        case "function":
            {
                if (e !== void 0) {
                    var s = Yn,
                        o = r(e);
                    return Yn = s, su(e, t, o)
                }
                break
            }
    }
    if (t == null) return r;
    var a = t[r];
    return a !== void 0 ? a : r
}

function JV(e, t, r) {
    var n = "";
    if (Array.isArray(r))
        for (var i = 0; i < r.length; i++) n += su(e, t, r[i]) + ";";
    else
        for (var s in r) {
            var o = r[s];
            if (typeof o != "object") t != null && t[o] !== void 0 ? n += s + "{" + t[o] + "}" : YS(o) && (n += i0(s) + ":" + KS(s, o) + ";");
            else if (Array.isArray(o) && typeof o[0] == "string" && (t == null || t[o[0]] === void 0))
                for (var a = 0; a < o.length; a++) YS(o[a]) && (n += i0(s) + ":" + KS(s, o[a]) + ";");
            else {
                var l = su(e, t, o);
                switch (s) {
                    case "animation":
                    case "animationName":
                        {
                            n += i0(s) + ":" + l + ";";
                            break
                        }
                    default:
                        n += s + "{" + l + "}"
                }
            }
        }
    return n
}
var qS = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
    Yn, zR = function(t, r, n) {
        if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0) return t[0];
        var i = !0,
            s = "";
        Yn = void 0;
        var o = t[0];
        o == null || o.raw === void 0 ? (i = !1, s += su(n, r, o)) : s += o[0];
        for (var a = 1; a < t.length; a++) s += su(n, r, t[a]), i && (s += o[a]);
        qS.lastIndex = 0;
        for (var l = "", c;
            (c = qS.exec(s)) !== null;) l += "-" + c[1];
        var u = KV(s) + l;
        return {
            name: u,
            styles: s,
            next: Yn
        }
    },
    eW = Hd["useInsertionEffect"] ? Hd["useInsertionEffect"] : !1,
    QS = eW || b.useLayoutEffect,
    jR = b.createContext(typeof HTMLElement < "u" ? MR({
        key: "css"
    }) : null);
jR.Provider;
var tW = function(t) {
        return b.forwardRef(function(r, n) {
            var i = b.useContext(jR);
            return t(r, i, n)
        })
    },
    m_ = b.createContext({}),
    rW = function(t, r) {
        if (typeof r == "function") {
            var n = r(t);
            return n
        }
        return dt({}, t, r)
    },
    nW = WS(function(e) {
        return WS(function(t) {
            return rW(e, t)
        })
    }),
    iW = function(t) {
        var r = b.useContext(m_);
        return t.theme !== r && (r = nW(r)(t.theme)), b.createElement(m_.Provider, {
            value: r
        }, t.children)
    },
    ag = tW(function(e, t) {
        var r = e.styles,
            n = zR([r], void 0, b.useContext(m_)),
            i = b.useRef();
        return QS(function() {
            var s = t.key + "-global",
                o = new t.sheet.constructor({
                    key: s,
                    nonce: t.sheet.nonce,
                    container: t.sheet.container,
                    speedy: t.sheet.isSpeedy
                }),
                a = !1,
                l = document.querySelector('style[data-emotion="' + s + " " + n.name + '"]');
            return t.sheet.tags.length && (o.before = t.sheet.tags[0]), l !== null && (a = !0, l.setAttribute("data-emotion", s), o.hydrate([l])), i.current = [o, a],
                function() {
                    o.flush()
                }
        }, [t]), QS(function() {
            var s = i.current,
                o = s[0],
                a = s[1];
            if (a) {
                s[1] = !1;
                return
            }
            if (n.next !== void 0 && FR(t, n.next, !0), o.tags.length) {
                var l = o.tags[o.tags.length - 1].nextElementSibling;
                o.before = l, o.flush()
            }
            t.insert("", n, o, !1)
        }, [t, n.name]), null
    }),
    sW = Object.defineProperty,
    oW = Object.defineProperties,
    aW = Object.getOwnPropertyDescriptors,
    ZS = Object.getOwnPropertySymbols,
    lW = Object.prototype.hasOwnProperty,
    cW = Object.prototype.propertyIsEnumerable,
    JS = (e, t, r) => t in e ? sW(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    uW = (e, t) => {
        for (var r in t || (t = {})) lW.call(t, r) && JS(e, r, t[r]);
        if (ZS)
            for (var r of ZS(t)) cW.call(t, r) && JS(e, r, t[r]);
        return e
    },
    hW = (e, t) => oW(e, aW(t));

function dW({
    theme: e
}) {
    return I.createElement(ag, {
        styles: {
            "*, *::before, *::after": {
                boxSizing: "border-box"
            },
            html: {
                colorScheme: e.colorScheme === "dark" ? "dark" : "light"
            },
            body: hW(uW({}, e.fn.fontStyles()), {
                backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
                color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
                lineHeight: e.lineHeight,
                fontSize: e.fontSizes.md,
                WebkitFontSmoothing: "antialiased",
                MozOsxFontSmoothing: "grayscale"
            })
        }
    })
}

function Yl(e, t, r, n = R) {
    Object.keys(t).forEach(i => {
        e[`--mantine-${r}-${i}`] = n(t[i])
    })
}

function fW({
    theme: e
}) {
    const t = {
        "--mantine-color-white": e.white,
        "--mantine-color-black": e.black,
        "--mantine-transition-timing-function": e.transitionTimingFunction,
        "--mantine-line-height": `${e.lineHeight}`,
        "--mantine-font-family": e.fontFamily,
        "--mantine-font-family-monospace": e.fontFamilyMonospace,
        "--mantine-font-family-headings": e.headings.fontFamily,
        "--mantine-heading-font-weight": `${e.headings.fontWeight}`
    };
    Yl(t, e.shadows, "shadow"), Yl(t, e.fontSizes, "font-size"), Yl(t, e.radius, "radius"), Yl(t, e.spacing, "spacing"), Yl(t, e.breakpoints, "breakpoints", Xm), Object.keys(e.colors).forEach(n => {
        e.colors[n].forEach((i, s) => {
            t[`--mantine-color-${n}-${s}`] = i
        })
    });
    const r = e.headings.sizes;
    return Object.keys(r).forEach(n => {
        t[`--mantine-${n}-font-size`] = r[n].fontSize, t[`--mantine-${n}-line-height`] = `${r[n].lineHeight}`
    }), I.createElement(ag, {
        styles: {
            ":root": t
        }
    })
}
var pW = Object.defineProperty,
    mW = Object.defineProperties,
    gW = Object.getOwnPropertyDescriptors,
    eP = Object.getOwnPropertySymbols,
    vW = Object.prototype.hasOwnProperty,
    yW = Object.prototype.propertyIsEnumerable,
    tP = (e, t, r) => t in e ? pW(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Bn = (e, t) => {
        for (var r in t || (t = {})) vW.call(t, r) && tP(e, r, t[r]);
        if (eP)
            for (var r of eP(t)) yW.call(t, r) && tP(e, r, t[r]);
        return e
    },
    s0 = (e, t) => mW(e, gW(t));

function _W(e, t) {
    var r;
    if (!t) return e;
    const n = Object.keys(e).reduce((i, s) => {
        if (s === "headings" && t.headings) {
            const o = t.headings.sizes ? Object.keys(e.headings.sizes).reduce((a, l) => (a[l] = Bn(Bn({}, e.headings.sizes[l]), t.headings.sizes[l]), a), {}) : e.headings.sizes;
            return s0(Bn({}, i), {
                headings: s0(Bn(Bn({}, e.headings), t.headings), {
                    sizes: o
                })
            })
        }
        if (s === "breakpoints" && t.breakpoints) {
            const o = Bn(Bn({}, e.breakpoints), t.breakpoints);
            return s0(Bn({}, i), {
                breakpoints: Object.fromEntries(Object.entries(o).sort((a, l) => tl(a[1]) - tl(l[1])))
            })
        }
        return i[s] = typeof t[s] == "object" ? Bn(Bn({}, e[s]), t[s]) : typeof t[s] == "number" || typeof t[s] == "boolean" || typeof t[s] == "function" ? t[s] : t[s] || e[s], i
    }, {});
    if (t != null && t.fontFamily && !((r = t == null ? void 0 : t.headings) != null && r.fontFamily) && (n.headings.fontFamily = t.fontFamily), !(n.primaryColor in n.colors)) throw new Error("MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more – https://mantine.dev/theming/colors/#primary-color");
    return n
}

function wW(e, t) {
    return CR(_W(e, t))
}

function UR(e) {
    return Object.keys(e).reduce((t, r) => (e[r] !== void 0 && (t[r] = e[r]), t), {})
}
const bW = {
    html: {
        fontFamily: "sans-serif",
        lineHeight: "1.15",
        textSizeAdjust: "100%"
    },
    body: {
        margin: 0
    },
    "article, aside, footer, header, nav, section, figcaption, figure, main": {
        display: "block"
    },
    h1: {
        fontSize: "2em"
    },
    hr: {
        boxSizing: "content-box",
        height: 0,
        overflow: "visible"
    },
    pre: {
        fontFamily: "monospace, monospace",
        fontSize: "1em"
    },
    a: {
        background: "transparent",
        textDecorationSkip: "objects"
    },
    "a:active, a:hover": {
        outlineWidth: 0
    },
    "abbr[title]": {
        borderBottom: "none",
        textDecoration: "underline"
    },
    "b, strong": {
        fontWeight: "bolder"
    },
    "code, kbp, samp": {
        fontFamily: "monospace, monospace",
        fontSize: "1em"
    },
    dfn: {
        fontStyle: "italic"
    },
    mark: {
        backgroundColor: "#ff0",
        color: "#000"
    },
    small: {
        fontSize: "80%"
    },
    "sub, sup": {
        fontSize: "75%",
        lineHeight: 0,
        position: "relative",
        verticalAlign: "baseline"
    },
    sup: {
        top: "-0.5em"
    },
    sub: {
        bottom: "-0.25em"
    },
    "audio, video": {
        display: "inline-block"
    },
    "audio:not([controls])": {
        display: "none",
        height: 0
    },
    img: {
        borderStyle: "none",
        verticalAlign: "middle"
    },
    "svg:not(:root)": {
        overflow: "hidden"
    },
    "button, input, optgroup, select, textarea": {
        fontFamily: "sans-serif",
        fontSize: "100%",
        lineHeight: "1.15",
        margin: 0
    },
    "button, input": {
        overflow: "visible"
    },
    "button, select": {
        textTransform: "none"
    },
    "button, [type=reset], [type=submit]": {
        WebkitAppearance: "button"
    },
    "button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner": {
        borderStyle: "none",
        padding: 0
    },
    "button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring": {
        outline: `${R(1)} dotted ButtonText`
    },
    legend: {
        boxSizing: "border-box",
        color: "inherit",
        display: "table",
        maxWidth: "100%",
        padding: 0,
        whiteSpace: "normal"
    },
    progress: {
        display: "inline-block",
        verticalAlign: "baseline"
    },
    textarea: {
        overflow: "auto"
    },
    "[type=checkbox], [type=radio]": {
        boxSizing: "border-box",
        padding: 0
    },
    "[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button": {
        height: "auto"
    },
    "[type=search]": {
        appearance: "none"
    },
    "[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration": {
        appearance: "none"
    },
    "::-webkit-file-upload-button": {
        appearance: "button",
        font: "inherit"
    },
    "details, menu": {
        display: "block"
    },
    summary: {
        display: "list-item"
    },
    canvas: {
        display: "inline-block"
    },
    template: {
        display: "none"
    }
};

function xW() {
    return I.createElement(ag, {
        styles: bW
    })
}
var EW = Object.defineProperty,
    rP = Object.getOwnPropertySymbols,
    SW = Object.prototype.hasOwnProperty,
    PW = Object.prototype.propertyIsEnumerable,
    nP = (e, t, r) => t in e ? EW(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Tc = (e, t) => {
        for (var r in t || (t = {})) SW.call(t, r) && nP(e, r, t[r]);
        if (rP)
            for (var r of rP(t)) PW.call(t, r) && nP(e, r, t[r]);
        return e
    };
const kf = b.createContext({
    theme: aw
});

function yr() {
    var e;
    return ((e = b.useContext(kf)) == null ? void 0 : e.theme) || aw
}

function CW(e) {
    const t = yr(),
        r = n => {
            var i, s, o, a;
            return {
                styles: ((i = t.components[n]) == null ? void 0 : i.styles) || {},
                classNames: ((s = t.components[n]) == null ? void 0 : s.classNames) || {},
                variants: (o = t.components[n]) == null ? void 0 : o.variants,
                sizes: (a = t.components[n]) == null ? void 0 : a.sizes
            }
        };
    return Array.isArray(e) ? e.map(r) : [r(e)]
}

function HR() {
    var e;
    return (e = b.useContext(kf)) == null ? void 0 : e.emotionCache
}

function ve(e, t, r) {
    var n;
    const i = yr(),
        s = (n = i.components[e]) == null ? void 0 : n.defaultProps,
        o = typeof s == "function" ? s(i) : s;
    return Tc(Tc(Tc({}, t), o), UR(r))
}

function GR({
    theme: e,
    emotionCache: t,
    withNormalizeCSS: r = !1,
    withGlobalStyles: n = !1,
    withCSSVariables: i = !1,
    inherit: s = !1,
    children: o
}) {
    const a = b.useContext(kf),
        l = wW(aw, s ? Tc(Tc({}, a.theme), e) : e);
    return I.createElement(iW, {
        theme: l
    }, I.createElement(kf.Provider, {
        value: {
            theme: l,
            emotionCache: t
        }
    }, r && I.createElement(xW, null), n && I.createElement(dW, {
        theme: l
    }), i && I.createElement(fW, {
        theme: l
    }), typeof l.globalStyles == "function" && I.createElement(ag, {
        styles: l.globalStyles(l)
    }), o))
}
GR.displayName = "@mantine/core/MantineProvider";
const TW = {
    app: 100,
    modal: 200,
    popover: 300,
    overlay: 400,
    max: 9999
};

function $s(e) {
    return TW[e]
}

function VR(e) {
    return typeof e == "number" ? e : typeof e == "string" ? e.includes("px") ? Number(e.replace("px", "")) : e.includes("rem") ? Number(e.replace("rem", "")) * 16 : Number(e) : NaN
}

function OW(e, t) {
    const r = b.useRef();
    return (!r.current || t.length !== r.current.prevDeps.length || r.current.prevDeps.map((n, i) => n === t[i]).indexOf(!1) >= 0) && (r.current = {
        v: e(),
        prevDeps: [...t]
    }), r.current.v
}
const AW = MR({
    key: "mantine",
    prepend: !0
});

function IW() {
    return HR() || AW
}
var $W = Object.defineProperty,
    iP = Object.getOwnPropertySymbols,
    RW = Object.prototype.hasOwnProperty,
    kW = Object.prototype.propertyIsEnumerable,
    sP = (e, t, r) => t in e ? $W(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    MW = (e, t) => {
        for (var r in t || (t = {})) RW.call(t, r) && sP(e, r, t[r]);
        if (iP)
            for (var r of iP(t)) kW.call(t, r) && sP(e, r, t[r]);
        return e
    };
const o0 = "ref";

function DW(e) {
    let t;
    if (e.length !== 1) return {
        args: e,
        ref: t
    };
    const [r] = e;
    if (!(r instanceof Object)) return {
        args: e,
        ref: t
    };
    if (!(o0 in r)) return {
        args: e,
        ref: t
    };
    t = r[o0];
    const n = MW({}, r);
    return delete n[o0], {
        args: [n],
        ref: t
    }
}
const {
    cssFactory: NW
} = (() => {
    function e(r, n, i) {
        const s = [],
            o = XV(r, s, i);
        return s.length < 2 ? i : o + n(s)
    }

    function t(r) {
        const {
            cache: n
        } = r, i = (...o) => {
            const {
                ref: a,
                args: l
            } = DW(o), c = zR(l, n.registered);
            return FR(n, c, !1), `${n.key}-${c.name}${a===void 0?"":` ${a}`}`
        };
        return {
            css: i,
            cx: (...o) => e(n.registered, i, xR(o))
        }
    }
    return {
        cssFactory: t
    }
})();

function WR() {
    const e = IW();
    return OW(() => NW({
        cache: e
    }), [e])
}

function LW({
    cx: e,
    classes: t,
    context: r,
    classNames: n,
    name: i,
    cache: s
}) {
    const o = r.reduce((a, l) => (Object.keys(l.classNames).forEach(c => {
        typeof a[c] != "string" ? a[c] = `${l.classNames[c]}` : a[c] = `${a[c]} ${l.classNames[c]}`
    }), a), {});
    return Object.keys(t).reduce((a, l) => (a[l] = e(t[l], o[l], n != null && n[l], Array.isArray(i) ? i.filter(Boolean).map(c => `${(s==null?void 0:s.key)||"mantine"}-${c}-${l}`).join(" ") : i ? `${(s==null?void 0:s.key)||"mantine"}-${i}-${l}` : null), a), {})
}
var FW = Object.defineProperty,
    oP = Object.getOwnPropertySymbols,
    BW = Object.prototype.hasOwnProperty,
    zW = Object.prototype.propertyIsEnumerable,
    aP = (e, t, r) => t in e ? FW(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    a0 = (e, t) => {
        for (var r in t || (t = {})) BW.call(t, r) && aP(e, r, t[r]);
        if (oP)
            for (var r of oP(t)) zW.call(t, r) && aP(e, r, t[r]);
        return e
    };

function g_(e, t) {
    return t && Object.keys(t).forEach(r => {
        e[r] ? e[r] = a0(a0({}, e[r]), t[r]) : e[r] = a0({}, t[r])
    }), e
}

function lP(e, t, r, n) {
    const i = s => typeof s == "function" ? s(t, r || {}, n) : s || {};
    return Array.isArray(e) ? e.map(s => i(s.styles)).reduce((s, o) => g_(s, o), {}) : i(e)
}

function jW({
    ctx: e,
    theme: t,
    params: r,
    variant: n,
    size: i
}) {
    return e.reduce((s, o) => (o.variants && n in o.variants && g_(s, o.variants[n](t, r, {
        variant: n,
        size: i
    })), o.sizes && i in o.sizes && g_(s, o.sizes[i](t, r, {
        variant: n,
        size: i
    })), s), {})
}

function Pe(e) {
    const t = typeof e == "function" ? e : () => e;

    function r(n, i) {
        const s = yr(),
            o = CW(i == null ? void 0 : i.name),
            a = HR(),
            l = {
                variant: i == null ? void 0 : i.variant,
                size: i == null ? void 0 : i.size
            },
            {
                css: c,
                cx: u
            } = WR(),
            h = t(s, n, l),
            d = lP(i == null ? void 0 : i.styles, s, n, l),
            f = lP(o, s, n, l),
            p = jW({
                ctx: o,
                theme: s,
                params: n,
                variant: i == null ? void 0 : i.variant,
                size: i == null ? void 0 : i.size
            }),
            m = Object.fromEntries(Object.keys(h).map(w => {
                const y = u({
                    [c(h[w])]: !(i != null && i.unstyled)
                }, c(p[w]), c(f[w]), c(d[w]));
                return [w, y]
            }));
        return {
            classes: LW({
                cx: u,
                classes: m,
                context: o,
                classNames: i == null ? void 0 : i.classNames,
                name: i == null ? void 0 : i.name,
                cache: a
            }),
            cx: u,
            theme: s
        }
    }
    return r
}

function ys(e) {
    return `___ref-${e||""}`
}
var UW = Object.defineProperty,
    HW = Object.defineProperties,
    GW = Object.getOwnPropertyDescriptors,
    cP = Object.getOwnPropertySymbols,
    VW = Object.prototype.hasOwnProperty,
    WW = Object.prototype.propertyIsEnumerable,
    uP = (e, t, r) => t in e ? UW(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Kl = (e, t) => {
        for (var r in t || (t = {})) VW.call(t, r) && uP(e, r, t[r]);
        if (cP)
            for (var r of cP(t)) WW.call(t, r) && uP(e, r, t[r]);
        return e
    },
    ql = (e, t) => HW(e, GW(t));
const Ql = { in: {
            opacity: 1,
            transform: "scale(1)"
        },
        out: {
            opacity: 0,
            transform: `scale(.9) translateY(${R(10)})`
        },
        transitionProperty: "transform, opacity"
    },
    Bh = {
        fade: { in: {
                opacity: 1
            },
            out: {
                opacity: 0
            },
            transitionProperty: "opacity"
        },
        scale: { in: {
                opacity: 1,
                transform: "scale(1)"
            },
            out: {
                opacity: 0,
                transform: "scale(0)"
            },
            common: {
                transformOrigin: "top"
            },
            transitionProperty: "transform, opacity"
        },
        "scale-y": { in: {
                opacity: 1,
                transform: "scaleY(1)"
            },
            out: {
                opacity: 0,
                transform: "scaleY(0)"
            },
            common: {
                transformOrigin: "top"
            },
            transitionProperty: "transform, opacity"
        },
        "scale-x": { in: {
                opacity: 1,
                transform: "scaleX(1)"
            },
            out: {
                opacity: 0,
                transform: "scaleX(0)"
            },
            common: {
                transformOrigin: "left"
            },
            transitionProperty: "transform, opacity"
        },
        "skew-up": { in: {
                opacity: 1,
                transform: "translateY(0) skew(0deg, 0deg)"
            },
            out: {
                opacity: 0,
                transform: `translateY(-${R(20)}) skew(-10deg, -5deg)`
            },
            common: {
                transformOrigin: "top"
            },
            transitionProperty: "transform, opacity"
        },
        "skew-down": { in: {
                opacity: 1,
                transform: "translateY(0) skew(0deg, 0deg)"
            },
            out: {
                opacity: 0,
                transform: `translateY(${R(20)}) skew(-10deg, -5deg)`
            },
            common: {
                transformOrigin: "bottom"
            },
            transitionProperty: "transform, opacity"
        },
        "rotate-left": { in: {
                opacity: 1,
                transform: "translateY(0) rotate(0deg)"
            },
            out: {
                opacity: 0,
                transform: `translateY(${R(20)}) rotate(-5deg)`
            },
            common: {
                transformOrigin: "bottom"
            },
            transitionProperty: "transform, opacity"
        },
        "rotate-right": { in: {
                opacity: 1,
                transform: "translateY(0) rotate(0deg)"
            },
            out: {
                opacity: 0,
                transform: `translateY(${R(20)}) rotate(5deg)`
            },
            common: {
                transformOrigin: "top"
            },
            transitionProperty: "transform, opacity"
        },
        "slide-down": { in: {
                opacity: 1,
                transform: "translateY(0)"
            },
            out: {
                opacity: 0,
                transform: "translateY(-100%)"
            },
            common: {
                transformOrigin: "top"
            },
            transitionProperty: "transform, opacity"
        },
        "slide-up": { in: {
                opacity: 1,
                transform: "translateY(0)"
            },
            out: {
                opacity: 0,
                transform: "translateY(100%)"
            },
            common: {
                transformOrigin: "bottom"
            },
            transitionProperty: "transform, opacity"
        },
        "slide-left": { in: {
                opacity: 1,
                transform: "translateX(0)"
            },
            out: {
                opacity: 0,
                transform: "translateX(100%)"
            },
            common: {
                transformOrigin: "left"
            },
            transitionProperty: "transform, opacity"
        },
        "slide-right": { in: {
                opacity: 1,
                transform: "translateX(0)"
            },
            out: {
                opacity: 0,
                transform: "translateX(-100%)"
            },
            common: {
                transformOrigin: "right"
            },
            transitionProperty: "transform, opacity"
        },
        pop: ql(Kl({}, Ql), {
            common: {
                transformOrigin: "center center"
            }
        }),
        "pop-bottom-left": ql(Kl({}, Ql), {
            common: {
                transformOrigin: "bottom left"
            }
        }),
        "pop-bottom-right": ql(Kl({}, Ql), {
            common: {
                transformOrigin: "bottom right"
            }
        }),
        "pop-top-left": ql(Kl({}, Ql), {
            common: {
                transformOrigin: "top left"
            }
        }),
        "pop-top-right": ql(Kl({}, Ql), {
            common: {
                transformOrigin: "top right"
            }
        })
    },
    hP = ["mousedown", "touchstart"];

function XR(e, t, r) {
    const n = b.useRef();
    return b.useEffect(() => {
        const i = s => {
            const {
                target: o
            } = s??{};
            if (Array.isArray(r)) {
                const a = (o == null ? void 0 : o.hasAttribute("data-ignore-outside-clicks")) || !document.body.contains(o) && o.tagName !== "HTML";
                r.every(c => !!c && !s.composedPath().includes(c)) && !a && e()
            } else n.current && !n.current.contains(o) && e()
        };
        return (t || hP).forEach(s => document.addEventListener(s, i)), () => {
            (t || hP).forEach(s => document.removeEventListener(s, i))
        }
    }, [n, e, r]), n
}

function XW(e, t) {
    try {
        return e.addEventListener("change", t), () => e.removeEventListener("change", t)
    } catch {
        return e.addListener(t), () => e.removeListener(t)
    }
}

function YW(e, t) {
    return typeof t == "boolean" ? t : typeof window < "u" && "matchMedia" in window ? window.matchMedia(e).matches : !1
}

function KW(e, t, {
    getInitialValueInEffect: r
} = {
    getInitialValueInEffect: !0
}) {
    const [n, i] = b.useState(r ? t : YW(e, t)), s = b.useRef();
    return b.useEffect(() => {
        if ("matchMedia" in window) return s.current = window.matchMedia(e), i(s.current.matches), XW(s.current, o => i(o.matches))
    }, [e]), n
}

function Mf(e, t, r) {
    return Math.min(Math.max(e, t), r)
}
const YR = typeof document < "u" ? b.useLayoutEffect : b.useEffect;

function sn(e, t) {
    const r = b.useRef(!1);
    b.useEffect(() => () => {
        r.current = !1
    }, []), b.useEffect(() => {
        if (r.current) return e();
        r.current = !0
    }, t)
}

function KR({
    opened: e,
    shouldReturnFocus: t = !0
}) {
    const r = b.useRef(),
        n = () => {
            var i;
            r.current && "focus" in r.current && typeof r.current.focus == "function" && ((i = r.current) == null || i.focus({
                preventScroll: !0
            }))
        };
    return sn(() => {
        let i = -1;
        const s = o => {
            o.key === "Tab" && window.clearTimeout(i)
        };
        return document.addEventListener("keydown", s), e ? r.current = document.activeElement : t && (i = window.setTimeout(n, 10)), () => {
            window.clearTimeout(i), document.removeEventListener("keydown", s)
        }
    }, [e, t]), n
}
const qW = /input|select|textarea|button|object/,
    qR = "a, input, select, textarea, button, object, [tabindex]";

function QW(e) {
    return e.style.display === "none"
}

function ZW(e) {
    if (e.getAttribute("aria-hidden") || e.getAttribute("hidden") || e.getAttribute("type") === "hidden") return !1;
    let r = e;
    for (; r && !(r === document.body || r.nodeType === 11);) {
        if (QW(r)) return !1;
        r = r.parentNode
    }
    return !0
}

function QR(e) {
    let t = e.getAttribute("tabindex");
    return t === null && (t = void 0), parseInt(t, 10)
}

function v_(e) {
    const t = e.nodeName.toLowerCase(),
        r = !Number.isNaN(QR(e));
    return (qW.test(t) && !e.disabled || e instanceof HTMLAnchorElement && e.href || r) && ZW(e)
}

function ZR(e) {
    const t = QR(e);
    return (Number.isNaN(t) || t >= 0) && v_(e)
}

function JW(e) {
    return Array.from(e.querySelectorAll(qR)).filter(ZR)
}

function eX(e, t) {
    const r = JW(e);
    if (!r.length) {
        t.preventDefault();
        return
    }
    const n = r[t.shiftKey ? 0 : r.length - 1],
        i = e.getRootNode();
    if (!(n === i.activeElement || e === i.activeElement)) return;
    t.preventDefault();
    const o = r[t.shiftKey ? r.length - 1 : 0];
    o && o.focus()
}

function pw() {
    return `mantine-${Math.random().toString(36).slice(2,11)}`
}

function tX(e, t = "body > :not(script)") {
    const r = pw(),
        n = Array.from(document.querySelectorAll(t)).map(i => {
            var s;
            if ((s = i == null ? void 0 : i.shadowRoot) != null && s.contains(e) || i.contains(e)) return;
            const o = i.getAttribute("aria-hidden"),
                a = i.getAttribute("data-hidden"),
                l = i.getAttribute("data-focus-id");
            return i.setAttribute("data-focus-id", r), o === null || o === "false" ? i.setAttribute("aria-hidden", "true") : !a && !l && i.setAttribute("data-hidden", o), {
                node: i,
                ariaHidden: a || null
            }
        });
    return () => {
        n.forEach(i => {
            !i || r !== i.node.getAttribute("data-focus-id") || (i.ariaHidden === null ? i.node.removeAttribute("aria-hidden") : i.node.setAttribute("aria-hidden", i.ariaHidden), i.node.removeAttribute("data-focus-id"), i.node.removeAttribute("data-hidden"))
        })
    }
}

function rX(e = !0) {
    const t = b.useRef(),
        r = b.useRef(null),
        n = s => {
            let o = s.querySelector("[data-autofocus]");
            if (!o) {
                const a = Array.from(s.querySelectorAll(qR));
                o = a.find(ZR) || a.find(v_) || null, !o && v_(s) && (o = s)
            }
            o && o.focus({
                preventScroll: !0
            })
        },
        i = b.useCallback(s => {
            if (e) {
                if (s === null) {
                    r.current && (r.current(), r.current = null);
                    return
                }
                r.current = tX(s), t.current !== s && (s ? (setTimeout(() => {
                    s.getRootNode() && n(s)
                }), t.current = s) : t.current = null)
            }
        }, [e]);
    return b.useEffect(() => {
        if (!e) return;
        t.current && setTimeout(() => n(t.current));
        const s = o => {
            o.key === "Tab" && t.current && eX(t.current, o)
        };
        return document.addEventListener("keydown", s), () => {
            document.removeEventListener("keydown", s), r.current && r.current()
        }
    }, [e]), i
}
const nX = e => (e + 1) % 1e6;

function iX() {
    const [, e] = b.useReducer(nX, 0);
    return e
}
const sX = I["useId".toString()] || (() => {});

function oX() {
    const e = sX();
    return e ? `mantine-${e.replace(/:/g,"")}` : ""
}

function Ou(e) {
    const t = oX(),
        [r, n] = b.useState(t);
    return YR(() => {
        n(pw())
    }, []), typeof e == "string" ? e : typeof window > "u" ? t : r
}

function ou(e, t, r) {
    b.useEffect(() => (window.addEventListener(e, t, r), () => window.removeEventListener(e, t, r)), [e, t])
}

function aX(e, t) {
    try {
        return JSON.stringify(e)
    } catch {
        throw new Error(`@mantine/hooks ${t}: Failed to serialize the value`)
    }
}

function lX(e) {
    try {
        return JSON.parse(e)
    } catch {
        return e
    }
}

function cX(e, t) {
    const r = e === "localStorage" ? "mantine-local-storage" : "mantine-session-storage";
    return function({
        key: i,
        defaultValue: s = void 0,
        getInitialValueInEffect: o = !0,
        deserialize: a = lX,
        serialize: l = c => aX(c, t)
    }) {
        const c = b.useCallback(p => {
                if (typeof window > "u" || !(e in window) || window[e] === null || p) return s;
                const m = window[e].getItem(i);
                return m !== null ? a(m) : s
            }, [i, s]),
            [u, h] = b.useState(c(o)),
            d = b.useCallback(p => {
                p instanceof Function ? h(m => {
                    const w = p(m);
                    return window[e].setItem(i, l(w)), window.dispatchEvent(new CustomEvent(r, {
                        detail: {
                            key: i,
                            value: p(m)
                        }
                    })), w
                }) : (window[e].setItem(i, l(p)), window.dispatchEvent(new CustomEvent(r, {
                    detail: {
                        key: i,
                        value: p
                    }
                })), h(p))
            }, [i]),
            f = b.useCallback(() => {
                window[e].removeItem(i), window.dispatchEvent(new CustomEvent(r, {
                    detail: {
                        key: i,
                        value: s
                    }
                }))
            }, []);
        return ou("storage", p => {
            var m;
            p.storageArea === window[e] && p.key === i && h(a((m = p.newValue) != null ? m : void 0))
        }), ou(r, p => {
            p.detail.key === i && h(p.detail.value)
        }), b.useEffect(() => {
            s !== void 0 && u === void 0 && d(s)
        }, [s, u, d]), b.useEffect(() => {
            o && h(c())
        }, [i]), [u === void 0 ? s : u, d, f]
    }
}

function dP(e) {
    return cX("localStorage", "use-local-storage")(e)
}

function mw(e, t) {
    typeof e == "function" ? e(t) : typeof e == "object" && e !== null && "current" in e && (e.current = t)
}

function JR(...e) {
    return t => {
        e.forEach(r => mw(r, t))
    }
}

function Oo(...e) {
    return b.useCallback(JR(...e), e)
}
const ek = e => ({
    x: Mf(e.x, 0, 1),
    y: Mf(e.y, 0, 1)
});

function tk(e, t, r = "ltr") {
    const n = b.useRef(),
        i = b.useRef(!1),
        s = b.useRef(!1),
        o = b.useRef(0),
        [a, l] = b.useState(!1);
    return b.useEffect(() => {
        i.current = !0
    }, []), b.useEffect(() => {
        const c = ({
                x: v,
                y: _
            }) => {
                cancelAnimationFrame(o.current), o.current = requestAnimationFrame(() => {
                    if (i.current && n.current) {
                        n.current.style.userSelect = "none";
                        const E = n.current.getBoundingClientRect();
                        if (E.width && E.height) {
                            const P = Mf((v - E.left) / E.width, 0, 1);
                            e({
                                x: r === "ltr" ? P : 1 - P,
                                y: Mf((_ - E.top) / E.height, 0, 1)
                            })
                        }
                    }
                })
            },
            u = () => {
                document.addEventListener("mousemove", m), document.addEventListener("mouseup", f), document.addEventListener("touchmove", y), document.addEventListener("touchend", f)
            },
            h = () => {
                document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", f), document.removeEventListener("touchmove", y), document.removeEventListener("touchend", f)
            },
            d = () => {
                !s.current && i.current && (s.current = !0, typeof(t == null ? void 0 : t.onScrubStart) == "function" && t.onScrubStart(), l(!0), u())
            },
            f = () => {
                s.current && i.current && (s.current = !1, l(!1), h(), setTimeout(() => {
                    typeof(t == null ? void 0 : t.onScrubEnd) == "function" && t.onScrubEnd()
                }, 0))
            },
            p = v => {
                d(), v.preventDefault(), m(v)
            },
            m = v => c({
                x: v.clientX,
                y: v.clientY
            }),
            w = v => {
                v.cancelable && v.preventDefault(), d(), y(v)
            },
            y = v => {
                v.cancelable && v.preventDefault(), c({
                    x: v.changedTouches[0].clientX,
                    y: v.changedTouches[0].clientY
                })
            };
        return n.current.addEventListener("mousedown", p), n.current.addEventListener("touchstart", w, {
            passive: !1
        }), () => {
            n.current && (n.current.removeEventListener("mousedown", p), n.current.removeEventListener("touchstart", w))
        }
    }, [r, e]), {
        ref: n,
        active: a
    }
}

function Au({
    value: e,
    defaultValue: t,
    finalValue: r,
    onChange: n = () => {}
}) {
    const [i, s] = b.useState(t !== void 0 ? t : r), o = a => {
        s(a), n == null || n(a)
    };
    return e !== void 0 ? [e, n, !0] : [i, o, !1]
}

function uX({
    initialValues: e = [],
    limit: t
}) {
    const [{
        state: r,
        queue: n
    }, i] = b.useState({
        state: e.slice(0, t),
        queue: e.slice(t)
    });
    return {
        state: r,
        queue: n,
        add: (...l) => i(c => {
            const u = [...c.state, ...c.queue, ...l];
            return {
                state: u.slice(0, t),
                queue: u.slice(t)
            }
        }),
        update: l => i(c => {
            const u = l([...c.state, ...c.queue]);
            return {
                state: u.slice(0, t),
                queue: u.slice(t)
            }
        }),
        cleanQueue: () => i(l => ({
            state: l.state,
            queue: []
        }))
    }
}

function lg(e, t) {
    return KW("(prefers-reduced-motion: reduce)", e, t)
}
const hX = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
};

function dX() {
    const e = b.useRef(0),
        t = b.useRef(null),
        [r, n] = b.useState(hX),
        i = b.useMemo(() => typeof window < "u" ? new ResizeObserver(s => {
            const o = s[0];
            o && (cancelAnimationFrame(e.current), e.current = requestAnimationFrame(() => {
                t.current && n(o.contentRect)
            }))
        }) : null, []);
    return b.useEffect(() => (t.current && i.observe(t.current), () => {
        i.disconnect(), e.current && cancelAnimationFrame(e.current)
    }), [t.current]), [t, r]
}

function fX() {
    const [e, {
        width: t,
        height: r
    }] = dX();
    return {
        ref: e,
        width: t,
        height: r
    }
}

function cg(e = !1, t) {
    const {
        onOpen: r,
        onClose: n
    } = t || {}, [i, s] = b.useState(e), o = b.useCallback(() => {
        s(c => c || (r == null || r(), !0))
    }, [r]), a = b.useCallback(() => {
        s(c => c && (n == null || n(), !1))
    }, [n]), l = b.useCallback(() => {
        i ? a() : o()
    }, [a, o, i]);
    return [i, {
        open: o,
        close: a,
        toggle: l
    }]
}

function fP(e) {
    return typeof e != "string" ? "" : e.charAt(0).toUpperCase() + e.slice(1)
}
const Df = {
        context: "Accordion component was not found in the tree",
        itemContext: "Accordion.Item component was not found in the tree",
        value: "Accordion.Item component was rendered with invalid value or without value"
    },
    [pX, Nf] = ml(Df.context);

function mX({
    children: e,
    multiple: t,
    value: r,
    defaultValue: n,
    onChange: i,
    id: s,
    loop: o,
    transitionDuration: a,
    disableChevronRotation: l,
    chevronPosition: c,
    chevronSize: u,
    order: h,
    chevron: d,
    variant: f,
    radius: p,
    classNames: m,
    styles: w,
    unstyled: y
}) {
    const v = Ou(s),
        [_, E] = Au({
            value: r,
            defaultValue: n,
            finalValue: t ? [] : null,
            onChange: i
        }),
        P = T => Array.isArray(_) ? _.includes(T) : T === _,
        C = T => {
            const O = Array.isArray(_) ? _.includes(T) ? _.filter(k => k !== T) : [..._, T] : T === _ ? null : T;
            E(O)
        };
    return I.createElement(pX, {
        value: {
            isItemActive: P,
            onChange: C,
            getControlId: FS(`${v}-control`, Df.value),
            getRegionId: FS(`${v}-panel`, Df.value),
            transitionDuration: a,
            disableChevronRotation: l,
            chevronPosition: c,
            chevronSize: u,
            order: h,
            chevron: d,
            loop: o,
            variant: f,
            radius: p,
            classNames: m,
            styles: w,
            unstyled: y
        }
    }, e)
}
const [gX, rk] = ml(Df.itemContext);

function vX(e, t, {
    radius: r
}) {
    const n = e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3],
        i = e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0],
        s = e.fn.radius(r);
    return t === "default" ? {
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
        borderBottom: `${R(1)} solid ${n}`
    } : t === "contained" ? {
        border: `${R(1)} solid ${n}`,
        transition: "background-color 150ms ease",
        "&[data-active]": {
            backgroundColor: i
        },
        "&:first-of-type": {
            borderTopRightRadius: s,
            borderTopLeftRadius: s,
            "& > [data-accordion-control]": {
                borderTopRightRadius: s,
                borderTopLeftRadius: s
            }
        },
        "&:last-of-type": {
            borderBottomRightRadius: s,
            borderBottomLeftRadius: s,
            "& > [data-accordion-control]": {
                borderBottomRightRadius: s,
                borderBottomLeftRadius: s
            }
        },
        "& + &": {
            borderTop: 0
        }
    } : t === "filled" ? {
        borderRadius: s,
        "&[data-active]": {
            backgroundColor: i
        }
    } : t === "separated" ? {
        borderRadius: s,
        backgroundColor: i,
        border: `${R(1)} solid transparent`,
        transition: "background-color 150ms ease",
        "& + &": {
            marginTop: e.spacing.md
        },
        "&[data-active]": {
            backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
            borderColor: n
        }
    } : {}
}
var yX = Pe((e, t, {
    variant: r
}) => ({
    item: vX(e, r, t)
}));
const _X = yX;
var pP = Object.getOwnPropertySymbols,
    wX = Object.prototype.hasOwnProperty,
    bX = Object.prototype.propertyIsEnumerable,
    xX = (e, t) => {
        var r = {};
        for (var n in e) wX.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && pP)
            for (var n of pP(e)) t.indexOf(n) < 0 && bX.call(e, n) && (r[n] = e[n]);
        return r
    };

function ug(e) {
    const t = e,
        {
            m: r,
            mx: n,
            my: i,
            mt: s,
            mb: o,
            ml: a,
            mr: l,
            p: c,
            px: u,
            py: h,
            pt: d,
            pb: f,
            pl: p,
            pr: m,
            bg: w,
            c: y,
            opacity: v,
            ff: _,
            fz: E,
            fw: P,
            lts: C,
            ta: T,
            lh: O,
            fs: k,
            tt: D,
            td: B,
            w: j,
            miw: L,
            maw: M,
            h: W,
            mih: Z,
            mah: q,
            bgsz: G,
            bgp: X,
            bgr: z,
            bga: Q,
            pos: ie,
            top: _e,
            left: we,
            bottom: De,
            right: Te,
            inset: Ne,
            display: et
        } = t,
        Le = xX(t, ["m", "mx", "my", "mt", "mb", "ml", "mr", "p", "px", "py", "pt", "pb", "pl", "pr", "bg", "c", "opacity", "ff", "fz", "fw", "lts", "ta", "lh", "fs", "tt", "td", "w", "miw", "maw", "h", "mih", "mah", "bgsz", "bgp", "bgr", "bga", "pos", "top", "left", "bottom", "right", "inset", "display"]);
    return {
        systemStyles: UR({
            m: r,
            mx: n,
            my: i,
            mt: s,
            mb: o,
            ml: a,
            mr: l,
            p: c,
            px: u,
            py: h,
            pt: d,
            pb: f,
            pl: p,
            pr: m,
            bg: w,
            c: y,
            opacity: v,
            ff: _,
            fz: E,
            fw: P,
            lts: C,
            ta: T,
            lh: O,
            fs: k,
            tt: D,
            td: B,
            w: j,
            miw: L,
            maw: M,
            h: W,
            mih: Z,
            mah: q,
            bgsz: G,
            bgp: X,
            bgr: z,
            bga: Q,
            pos: ie,
            top: _e,
            left: we,
            bottom: De,
            right: Te,
            inset: Ne,
            display: et
        }),
        rest: Le
    }
}

function EX(e, t) {
    const r = Object.keys(e).filter(n => n !== "base").sort((n, i) => tl(he({
        size: n,
        sizes: t.breakpoints
    })) - tl(he({
        size: i,
        sizes: t.breakpoints
    })));
    return "base" in e ? ["base", ...r] : r
}

function SX({
    value: e,
    theme: t,
    getValue: r,
    property: n
}) {
    if (e == null) return;
    if (typeof e == "object") return EX(e, t).reduce((o, a) => {
        if (a === "base" && e.base !== void 0) {
            const c = r(e.base, t);
            return Array.isArray(n) ? (n.forEach(u => {
                o[u] = c
            }), o) : (o[n] = c, o)
        }
        const l = r(e[a], t);
        return Array.isArray(n) ? (o[t.fn.largerThan(a)] = {}, n.forEach(c => {
            o[t.fn.largerThan(a)][c] = l
        }), o) : (o[t.fn.largerThan(a)] = {
            [n]: l
        }, o)
    }, {});
    const i = r(e, t);
    return Array.isArray(n) ? n.reduce((s, o) => (s[o] = i, s), {}) : {
        [n]: i
    }
}

function PX(e, t) {
    return e === "dimmed" ? t.colorScheme === "dark" ? t.colors.dark[2] : t.colors.gray[6] : t.fn.variant({
        variant: "filled",
        color: e,
        primaryFallback: !1
    }).background
}

function CX(e) {
    return R(e)
}

function TX(e) {
    return e
}

function OX(e, t) {
    return he({
        size: e,
        sizes: t.fontSizes
    })
}
const AX = ["-xs", "-sm", "-md", "-lg", "-xl"];

function IX(e, t) {
    return AX.includes(e) ? `calc(${he({size:e.replace("-",""),sizes:t.spacing})} * -1)` : he({
        size: e,
        sizes: t.spacing
    })
}
const $X = {
        identity: TX,
        color: PX,
        size: CX,
        fontSize: OX,
        spacing: IX
    },
    RX = {
        m: {
            type: "spacing",
            property: "margin"
        },
        mt: {
            type: "spacing",
            property: "marginTop"
        },
        mb: {
            type: "spacing",
            property: "marginBottom"
        },
        ml: {
            type: "spacing",
            property: "marginLeft"
        },
        mr: {
            type: "spacing",
            property: "marginRight"
        },
        mx: {
            type: "spacing",
            property: ["marginRight", "marginLeft"]
        },
        my: {
            type: "spacing",
            property: ["marginTop", "marginBottom"]
        },
        p: {
            type: "spacing",
            property: "padding"
        },
        pt: {
            type: "spacing",
            property: "paddingTop"
        },
        pb: {
            type: "spacing",
            property: "paddingBottom"
        },
        pl: {
            type: "spacing",
            property: "paddingLeft"
        },
        pr: {
            type: "spacing",
            property: "paddingRight"
        },
        px: {
            type: "spacing",
            property: ["paddingRight", "paddingLeft"]
        },
        py: {
            type: "spacing",
            property: ["paddingTop", "paddingBottom"]
        },
        bg: {
            type: "color",
            property: "background"
        },
        c: {
            type: "color",
            property: "color"
        },
        opacity: {
            type: "identity",
            property: "opacity"
        },
        ff: {
            type: "identity",
            property: "fontFamily"
        },
        fz: {
            type: "fontSize",
            property: "fontSize"
        },
        fw: {
            type: "identity",
            property: "fontWeight"
        },
        lts: {
            type: "size",
            property: "letterSpacing"
        },
        ta: {
            type: "identity",
            property: "textAlign"
        },
        lh: {
            type: "identity",
            property: "lineHeight"
        },
        fs: {
            type: "identity",
            property: "fontStyle"
        },
        tt: {
            type: "identity",
            property: "textTransform"
        },
        td: {
            type: "identity",
            property: "textDecoration"
        },
        w: {
            type: "spacing",
            property: "width"
        },
        miw: {
            type: "spacing",
            property: "minWidth"
        },
        maw: {
            type: "spacing",
            property: "maxWidth"
        },
        h: {
            type: "spacing",
            property: "height"
        },
        mih: {
            type: "spacing",
            property: "minHeight"
        },
        mah: {
            type: "spacing",
            property: "maxHeight"
        },
        bgsz: {
            type: "size",
            property: "backgroundSize"
        },
        bgp: {
            type: "identity",
            property: "backgroundPosition"
        },
        bgr: {
            type: "identity",
            property: "backgroundRepeat"
        },
        bga: {
            type: "identity",
            property: "backgroundAttachment"
        },
        pos: {
            type: "identity",
            property: "position"
        },
        top: {
            type: "identity",
            property: "top"
        },
        left: {
            type: "size",
            property: "left"
        },
        bottom: {
            type: "size",
            property: "bottom"
        },
        right: {
            type: "size",
            property: "right"
        },
        inset: {
            type: "size",
            property: "inset"
        },
        display: {
            type: "identity",
            property: "display"
        }
    };
var kX = Object.defineProperty,
    mP = Object.getOwnPropertySymbols,
    MX = Object.prototype.hasOwnProperty,
    DX = Object.prototype.propertyIsEnumerable,
    gP = (e, t, r) => t in e ? kX(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    vP = (e, t) => {
        for (var r in t || (t = {})) MX.call(t, r) && gP(e, r, t[r]);
        if (mP)
            for (var r of mP(t)) DX.call(t, r) && gP(e, r, t[r]);
        return e
    };

function y_(e, t, r = RX) {
    return Object.keys(r).reduce((i, s) => (s in e && e[s] !== void 0 && i.push(SX({
        value: e[s],
        getValue: $X[r[s].type],
        property: r[s].property,
        theme: t
    })), i), []).reduce((i, s) => (Object.keys(s).forEach(o => {
        typeof s[o] == "object" && s[o] !== null && o in i ? i[o] = vP(vP({}, i[o]), s[o]) : i[o] = s[o]
    }), i), {})
}

function yP(e, t) {
    return typeof e == "function" ? e(t) : e
}

function NX(e, t, r) {
    const n = yr(),
        {
            css: i,
            cx: s
        } = WR();
    return Array.isArray(e) ? s(r, i(y_(t, n)), e.map(o => i(yP(o, n)))) : s(r, i(yP(e, n)), i(y_(t, n)))
}
var LX = Object.defineProperty,
    Lf = Object.getOwnPropertySymbols,
    nk = Object.prototype.hasOwnProperty,
    ik = Object.prototype.propertyIsEnumerable,
    _P = (e, t, r) => t in e ? LX(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    FX = (e, t) => {
        for (var r in t || (t = {})) nk.call(t, r) && _P(e, r, t[r]);
        if (Lf)
            for (var r of Lf(t)) ik.call(t, r) && _P(e, r, t[r]);
        return e
    },
    BX = (e, t) => {
        var r = {};
        for (var n in e) nk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Lf)
            for (var n of Lf(e)) t.indexOf(n) < 0 && ik.call(e, n) && (r[n] = e[n]);
        return r
    };
const sk = b.forwardRef((e, t) => {
    var r = e,
        {
            className: n,
            component: i,
            style: s,
            sx: o
        } = r,
        a = BX(r, ["className", "component", "style", "sx"]);
    const {
        systemStyles: l,
        rest: c
    } = ug(a), u = i || "div";
    return I.createElement(u, FX({
        ref: t,
        className: NX(o, l, n),
        style: s
    }, c))
});
sk.displayName = "@mantine/core/Box";
const Ie = sk;
var zX = Object.defineProperty,
    Ff = Object.getOwnPropertySymbols,
    ok = Object.prototype.hasOwnProperty,
    ak = Object.prototype.propertyIsEnumerable,
    wP = (e, t, r) => t in e ? zX(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    jX = (e, t) => {
        for (var r in t || (t = {})) ok.call(t, r) && wP(e, r, t[r]);
        if (Ff)
            for (var r of Ff(t)) ak.call(t, r) && wP(e, r, t[r]);
        return e
    },
    UX = (e, t) => {
        var r = {};
        for (var n in e) ok.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Ff)
            for (var n of Ff(e)) t.indexOf(n) < 0 && ak.call(e, n) && (r[n] = e[n]);
        return r
    };
const HX = {},
    lk = b.forwardRef((e, t) => {
        const r = ve("AccordionItem", HX, e),
            {
                children: n,
                className: i,
                value: s
            } = r,
            o = UX(r, ["children", "className", "value"]),
            a = Nf(),
            {
                classes: l,
                cx: c
            } = _X({
                radius: a.radius
            }, {
                name: "Accordion",
                classNames: a.classNames,
                styles: a.styles,
                unstyled: a.unstyled,
                variant: a.variant
            });
        return I.createElement(gX, {
            value: {
                value: s
            }
        }, I.createElement(Ie, jX({
            ref: t,
            className: c(l.item, i),
            "data-active": a.isItemActive(s) || void 0
        }, o), n))
    });
lk.displayName = "@mantine/core/AccordionItem";
var GX = Object.defineProperty,
    VX = Object.defineProperties,
    WX = Object.getOwnPropertyDescriptors,
    bP = Object.getOwnPropertySymbols,
    XX = Object.prototype.hasOwnProperty,
    YX = Object.prototype.propertyIsEnumerable,
    xP = (e, t, r) => t in e ? GX(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    zh = (e, t) => {
        for (var r in t || (t = {})) XX.call(t, r) && xP(e, r, t[r]);
        if (bP)
            for (var r of bP(t)) YX.call(t, r) && xP(e, r, t[r]);
        return e
    },
    KX = (e, t) => VX(e, WX(t));

function qX(e, t) {
    return t === "default" || t === "contained" ? e.fn.hover({
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0]
    }) : {}
}
var QX = Pe((e, {
    transitionDuration: t,
    chevronPosition: r,
    chevronSize: n
}, {
    variant: i
}) => ({
    icon: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        marginRight: r === "left" ? 0 : e.spacing.sm,
        marginLeft: r === "left" ? e.spacing.lg : 0
    },
    chevron: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: `transform ${t}ms ease`,
        marginRight: r === "right" ? 0 : e.spacing.sm,
        marginLeft: r === "right" ? e.spacing.lg : 0,
        width: R(n),
        minWidth: R(n),
        "&[data-rotate]": {
            transform: "rotate(180deg)"
        }
    },
    label: {
        color: "inherit",
        fontWeight: 400,
        flex: 1,
        overflow: "hidden",
        textOverflow: "ellipsis",
        paddingTop: e.spacing.md,
        paddingBottom: e.spacing.md
    },
    itemTitle: {
        margin: 0,
        padding: 0
    },
    control: KX(zh(zh(zh({}, e.fn.focusStyles()), e.fn.fontStyles()), qX(e, i)), {
        width: "100%",
        display: "flex",
        alignItems: "center",
        flexDirection: r === "right" ? "row-reverse" : "row",
        paddingRight: e.spacing.md,
        paddingLeft: r === "right" ? `calc(${e.spacing.md} + ${R(4)})` : e.spacing.xs,
        textAlign: "left",
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
        "&:disabled": zh({
            opacity: .4,
            cursor: "not-allowed"
        }, e.fn.hover({
            backgroundColor: "transparent"
        }))
    })
}));
const ZX = QX;
var JX = Object.defineProperty,
    eY = Object.defineProperties,
    tY = Object.getOwnPropertyDescriptors,
    EP = Object.getOwnPropertySymbols,
    rY = Object.prototype.hasOwnProperty,
    nY = Object.prototype.propertyIsEnumerable,
    SP = (e, t, r) => t in e ? JX(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    PP = (e, t) => {
        for (var r in t || (t = {})) rY.call(t, r) && SP(e, r, t[r]);
        if (EP)
            for (var r of EP(t)) nY.call(t, r) && SP(e, r, t[r]);
        return e
    },
    iY = (e, t) => eY(e, tY(t)),
    sY = Pe(e => ({
        root: iY(PP(PP({}, e.fn.focusStyles()), e.fn.fontStyles()), {
            cursor: "pointer",
            border: 0,
            padding: 0,
            appearance: "none",
            fontSize: e.fontSizes.md,
            backgroundColor: "transparent",
            textAlign: "left",
            color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
            textDecoration: "none",
            boxSizing: "border-box"
        })
    }));
const oY = sY;
var aY = Object.defineProperty,
    Bf = Object.getOwnPropertySymbols,
    ck = Object.prototype.hasOwnProperty,
    uk = Object.prototype.propertyIsEnumerable,
    CP = (e, t, r) => t in e ? aY(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    lY = (e, t) => {
        for (var r in t || (t = {})) ck.call(t, r) && CP(e, r, t[r]);
        if (Bf)
            for (var r of Bf(t)) uk.call(t, r) && CP(e, r, t[r]);
        return e
    },
    cY = (e, t) => {
        var r = {};
        for (var n in e) ck.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Bf)
            for (var n of Bf(e)) t.indexOf(n) < 0 && uk.call(e, n) && (r[n] = e[n]);
        return r
    };
const hk = b.forwardRef((e, t) => {
    const r = ve("UnstyledButton", {}, e),
        {
            className: n,
            component: i = "button",
            unstyled: s,
            variant: o
        } = r,
        a = cY(r, ["className", "component", "unstyled", "variant"]),
        {
            classes: l,
            cx: c
        } = oY(null, {
            name: "UnstyledButton",
            unstyled: s,
            variant: o
        });
    return I.createElement(Ie, lY({
        component: i,
        ref: t,
        className: c(l.root, n),
        type: i === "button" ? "button" : void 0
    }, a))
});
hk.displayName = "@mantine/core/UnstyledButton";
const hg = hk;
var uY = Object.defineProperty,
    hY = Object.defineProperties,
    dY = Object.getOwnPropertyDescriptors,
    zf = Object.getOwnPropertySymbols,
    dk = Object.prototype.hasOwnProperty,
    fk = Object.prototype.propertyIsEnumerable,
    TP = (e, t, r) => t in e ? uY(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    fY = (e, t) => {
        for (var r in t || (t = {})) dk.call(t, r) && TP(e, r, t[r]);
        if (zf)
            for (var r of zf(t)) fk.call(t, r) && TP(e, r, t[r]);
        return e
    },
    pY = (e, t) => hY(e, dY(t)),
    mY = (e, t) => {
        var r = {};
        for (var n in e) dk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && zf)
            for (var n of zf(e)) t.indexOf(n) < 0 && fk.call(e, n) && (r[n] = e[n]);
        return r
    };
const gY = {},
    pk = b.forwardRef((e, t) => {
        const r = ve("AccordionControl", gY, e),
            {
                disabled: n,
                onKeyDown: i,
                onClick: s,
                chevron: o,
                children: a,
                className: l,
                icon: c
            } = r,
            u = mY(r, ["disabled", "onKeyDown", "onClick", "chevron", "children", "className", "icon"]),
            h = Nf(),
            {
                value: d
            } = rk(),
            {
                classes: f,
                cx: p
            } = ZX({
                transitionDuration: h.transitionDuration,
                chevronPosition: h.chevronPosition,
                chevronSize: h.chevronSize,
                radius: h.radius
            }, {
                name: "Accordion",
                classNames: h.classNames,
                styles: h.styles,
                unstyled: h.unstyled,
                variant: h.variant
            }),
            m = h.isItemActive(d),
            w = typeof h.order == "number",
            y = `h${h.order}`,
            v = I.createElement(hg, pY(fY({}, u), {
                ref: t,
                "data-accordion-control": !0,
                disabled: n,
                className: p(f.control, l),
                onClick: _ => {
                    s == null || s(_), h.onChange(d)
                },
                type: "button",
                "data-active": m || void 0,
                "aria-expanded": m,
                "aria-controls": h.getRegionId(d),
                id: h.getControlId(d),
                unstyled: h.unstyled,
                onKeyDown: CG({
                    siblingSelector: "[data-accordion-control]",
                    parentSelector: "[data-accordion]",
                    activateOnFocus: !1,
                    loop: h.loop,
                    orientation: "vertical",
                    onKeyDown: i
                })
            }), I.createElement("span", {
                className: f.chevron,
                "data-rotate": !h.disableChevronRotation && m || void 0
            }, o || h.chevron), I.createElement("span", {
                className: f.label
            }, a), c && I.createElement("span", {
                className: f.icon
            }, c));
        return w ? I.createElement(y, {
            className: f.itemTitle
        }, v) : v
    });
pk.displayName = "@mantine/core/AccordionControl";
var vY = Object.defineProperty,
    yY = Object.defineProperties,
    _Y = Object.getOwnPropertyDescriptors,
    OP = Object.getOwnPropertySymbols,
    wY = Object.prototype.hasOwnProperty,
    bY = Object.prototype.propertyIsEnumerable,
    AP = (e, t, r) => t in e ? vY(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    xY = (e, t) => {
        for (var r in t || (t = {})) wY.call(t, r) && AP(e, r, t[r]);
        if (OP)
            for (var r of OP(t)) bY.call(t, r) && AP(e, r, t[r]);
        return e
    },
    EY = (e, t) => yY(e, _Y(t)),
    SY = Pe((e, t) => ({
        panel: EY(xY({}, e.fn.fontStyles()), {
            wordBreak: "break-word",
            lineHeight: e.lineHeight
        }),
        content: {
            padding: e.spacing.md,
            paddingTop: `calc(${e.spacing.xs} / 2)`
        }
    }));
const PY = SY;
var CY = Object.defineProperty,
    TY = Object.defineProperties,
    OY = Object.getOwnPropertyDescriptors,
    jf = Object.getOwnPropertySymbols,
    mk = Object.prototype.hasOwnProperty,
    gk = Object.prototype.propertyIsEnumerable,
    IP = (e, t, r) => t in e ? CY(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Bs = (e, t) => {
        for (var r in t || (t = {})) mk.call(t, r) && IP(e, r, t[r]);
        if (jf)
            for (var r of jf(t)) gk.call(t, r) && IP(e, r, t[r]);
        return e
    },
    l0 = (e, t) => TY(e, OY(t)),
    AY = (e, t) => {
        var r = {};
        for (var n in e) mk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && jf)
            for (var n of jf(e)) t.indexOf(n) < 0 && gk.call(e, n) && (r[n] = e[n]);
        return r
    };

function IY(e) {
    if (!e || typeof e == "string") return 0;
    const t = e / 36;
    return Math.round((4 + 15 * t ** .25 + t / 5) * 10)
}

function c0(e) {
    return e != null && e.current ? e.current.scrollHeight : "auto"
}
const jh = typeof window < "u" && window.requestAnimationFrame;

function $Y({
    transitionDuration: e,
    transitionTimingFunction: t = "ease",
    onTransitionEnd: r = () => {},
    opened: n
}) {
    const i = b.useRef(null),
        s = 0,
        o = {
            display: "none",
            height: 0,
            overflow: "hidden"
        },
        [a, l] = b.useState(n ? {} : o),
        c = p => {
            Ci.flushSync(() => l(p))
        },
        u = p => {
            c(m => Bs(Bs({}, m), p))
        };

    function h(p) {
        return {
            transition: `height ${e||IY(p)}ms ${t}`
        }
    }
    sn(() => {
        jh(n ? () => {
            u({
                willChange: "height",
                display: "block",
                overflow: "hidden"
            }), jh(() => {
                const p = c0(i);
                u(l0(Bs({}, h(p)), {
                    height: p
                }))
            })
        } : () => {
            const p = c0(i);
            u(l0(Bs({}, h(p)), {
                willChange: "height",
                height: p
            })), jh(() => u({
                height: s,
                overflow: "hidden"
            }))
        })
    }, [n]);
    const d = p => {
        if (!(p.target !== i.current || p.propertyName !== "height"))
            if (n) {
                const m = c0(i);
                m === a.height ? c({}) : u({
                    height: m
                }), r()
            } else a.height === s && (c(o), r())
    };

    function f(p = {}) {
        var m = p,
            {
                style: w = {},
                refKey: y = "ref"
            } = m,
            v = AY(m, ["style", "refKey"]);
        const _ = v[y];
        return l0(Bs({
            "aria-hidden": !n
        }, v), {
            [y]: JR(i, _),
            onTransitionEnd: d,
            style: Bs(Bs({
                boxSizing: "border-box"
            }, w), a)
        })
    }
    return f
}
var RY = Object.defineProperty,
    Uf = Object.getOwnPropertySymbols,
    vk = Object.prototype.hasOwnProperty,
    yk = Object.prototype.propertyIsEnumerable,
    $P = (e, t, r) => t in e ? RY(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Uh = (e, t) => {
        for (var r in t || (t = {})) vk.call(t, r) && $P(e, r, t[r]);
        if (Uf)
            for (var r of Uf(t)) yk.call(t, r) && $P(e, r, t[r]);
        return e
    },
    kY = (e, t) => {
        var r = {};
        for (var n in e) vk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Uf)
            for (var n of Uf(e)) t.indexOf(n) < 0 && yk.call(e, n) && (r[n] = e[n]);
        return r
    };
const MY = {
        transitionDuration: 200,
        transitionTimingFunction: "ease",
        animateOpacity: !0
    },
    _k = b.forwardRef((e, t) => {
        const r = ve("Collapse", MY, e),
            {
                children: n,
                in: i,
                transitionDuration: s,
                transitionTimingFunction: o,
                style: a,
                onTransitionEnd: l,
                animateOpacity: c
            } = r,
            u = kY(r, ["children", "in", "transitionDuration", "transitionTimingFunction", "style", "onTransitionEnd", "animateOpacity"]),
            h = yr(),
            d = lg(),
            p = (h.respectReducedMotion ? d : !1) ? 0 : s,
            {
                systemStyles: m,
                rest: w
            } = ug(u),
            y = $Y({
                opened: i,
                transitionDuration: p,
                transitionTimingFunction: o,
                onTransitionEnd: l
            });
        return p === 0 ? i ? I.createElement(Ie, Uh({}, w), n) : null : I.createElement(Ie, Uh({}, y(Uh(Uh({
            style: a,
            ref: t
        }, w), m))), I.createElement("div", {
            style: {
                opacity: i || !c ? 1 : 0,
                transition: c ? `opacity ${p}ms ${o}` : "none"
            }
        }, n))
    });
_k.displayName = "@mantine/core/Collapse";
var DY = Object.defineProperty,
    NY = Object.defineProperties,
    LY = Object.getOwnPropertyDescriptors,
    Hf = Object.getOwnPropertySymbols,
    wk = Object.prototype.hasOwnProperty,
    bk = Object.prototype.propertyIsEnumerable,
    RP = (e, t, r) => t in e ? DY(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    FY = (e, t) => {
        for (var r in t || (t = {})) wk.call(t, r) && RP(e, r, t[r]);
        if (Hf)
            for (var r of Hf(t)) bk.call(t, r) && RP(e, r, t[r]);
        return e
    },
    BY = (e, t) => NY(e, LY(t)),
    zY = (e, t) => {
        var r = {};
        for (var n in e) wk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Hf)
            for (var n of Hf(e)) t.indexOf(n) < 0 && bk.call(e, n) && (r[n] = e[n]);
        return r
    };
const jY = {};

function xk(e) {
    const t = ve("AccordionPanel", jY, e),
        {
            children: r,
            className: n
        } = t,
        i = zY(t, ["children", "className"]),
        s = Nf(),
        {
            value: o
        } = rk(),
        {
            classNames: a,
            styles: l,
            unstyled: c
        } = Nf(),
        {
            classes: u,
            cx: h
        } = PY({
            radius: s.radius
        }, {
            name: "Accordion",
            classNames: a,
            styles: l,
            unstyled: c,
            variant: s.variant
        });
    return I.createElement(_k, BY(FY({}, i), {
        className: h(u.panel, n),
        in: s.isItemActive(o),
        transitionDuration: s.transitionDuration,
        role: "region",
        id: s.getRegionId(o),
        "aria-labelledby": s.getControlId(o)
    }), I.createElement("div", {
        className: u.content
    }, r))
}
xk.displayName = "@mantine/core/AccordionPanel";
var UY = Object.defineProperty,
    kP = Object.getOwnPropertySymbols,
    HY = Object.prototype.hasOwnProperty,
    GY = Object.prototype.propertyIsEnumerable,
    MP = (e, t, r) => t in e ? UY(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    VY = (e, t) => {
        for (var r in t || (t = {})) HY.call(t, r) && MP(e, r, t[r]);
        if (kP)
            for (var r of kP(t)) GY.call(t, r) && MP(e, r, t[r]);
        return e
    };

function WY(e) {
    return I.createElement("svg", VY({
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1rem",
        height: "1rem"
    }, e), I.createElement("path", {
        d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
        fill: "currentColor",
        fillRule: "evenodd",
        clipRule: "evenodd"
    }))
}
var XY = Object.defineProperty,
    YY = Object.defineProperties,
    KY = Object.getOwnPropertyDescriptors,
    Gf = Object.getOwnPropertySymbols,
    Ek = Object.prototype.hasOwnProperty,
    Sk = Object.prototype.propertyIsEnumerable,
    DP = (e, t, r) => t in e ? XY(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    qY = (e, t) => {
        for (var r in t || (t = {})) Ek.call(t, r) && DP(e, r, t[r]);
        if (Gf)
            for (var r of Gf(t)) Sk.call(t, r) && DP(e, r, t[r]);
        return e
    },
    QY = (e, t) => YY(e, KY(t)),
    ZY = (e, t) => {
        var r = {};
        for (var n in e) Ek.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Gf)
            for (var n of Gf(e)) t.indexOf(n) < 0 && Sk.call(e, n) && (r[n] = e[n]);
        return r
    };
const JY = {
    multiple: !1,
    disableChevronRotation: !1,
    transitionDuration: 200,
    chevronPosition: "right",
    variant: "default",
    chevronSize: 24,
    chevron: I.createElement(WY, null)
};

function qt(e) {
    const t = ve("Accordion", JY, e),
        {
            id: r,
            loop: n,
            children: i,
            multiple: s,
            value: o,
            defaultValue: a,
            onChange: l,
            transitionDuration: c,
            disableChevronRotation: u,
            chevronPosition: h,
            chevronSize: d,
            order: f,
            chevron: p,
            classNames: m,
            styles: w,
            unstyled: y,
            variant: v,
            radius: _
        } = t,
        E = ZY(t, ["id", "loop", "children", "multiple", "value", "defaultValue", "onChange", "transitionDuration", "disableChevronRotation", "chevronPosition", "chevronSize", "order", "chevron", "classNames", "styles", "unstyled", "variant", "radius"]);
    return I.createElement(mX, {
        id: r,
        multiple: s,
        value: o,
        defaultValue: a,
        onChange: l,
        loop: n,
        transitionDuration: c,
        disableChevronRotation: u,
        chevronPosition: h,
        chevronSize: d,
        order: f,
        chevron: p,
        variant: v,
        radius: _,
        classNames: m,
        styles: w,
        unstyled: y
    }, I.createElement(Ie, QY(qY({}, E), {
        "data-accordion": !0
    }), i))
}
qt.Item = lk;
qt.Control = pk;
qt.Panel = xk;
qt.displayName = "@mantine/core/Accordion";
var eK = Object.defineProperty,
    tK = Object.defineProperties,
    rK = Object.getOwnPropertyDescriptors,
    NP = Object.getOwnPropertySymbols,
    nK = Object.prototype.hasOwnProperty,
    iK = Object.prototype.propertyIsEnumerable,
    LP = (e, t, r) => t in e ? eK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    __ = (e, t) => {
        for (var r in t || (t = {})) nK.call(t, r) && LP(e, r, t[r]);
        if (NP)
            for (var r of NP(t)) iK.call(t, r) && LP(e, r, t[r]);
        return e
    },
    FP = (e, t) => tK(e, rK(t));
const sK = ["subtle", "filled", "outline", "light", "default", "transparent", "gradient"],
    Hh = {
        xs: R(18),
        sm: R(22),
        md: R(28),
        lg: R(34),
        xl: R(44)
    };

function oK({
    variant: e,
    theme: t,
    color: r,
    gradient: n
}) {
    const i = t.fn.variant({
        color: r,
        variant: e,
        gradient: n
    });
    return e === "gradient" ? {
        border: 0,
        backgroundImage: i.background,
        color: i.color,
        "&:hover": t.fn.hover({
            backgroundSize: "200%"
        })
    } : sK.includes(e) ? __({
        border: `${R(1)} solid ${i.border}`,
        backgroundColor: i.background,
        color: i.color
    }, t.fn.hover({
        backgroundColor: i.hover
    })) : null
}
var aK = Pe((e, {
    radius: t,
    color: r,
    gradient: n
}, {
    variant: i,
    size: s
}) => ({
    root: FP(__({
        position: "relative",
        borderRadius: e.fn.radius(t),
        padding: 0,
        lineHeight: 1,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        height: he({
            size: s,
            sizes: Hh
        }),
        minHeight: he({
            size: s,
            sizes: Hh
        }),
        width: he({
            size: s,
            sizes: Hh
        }),
        minWidth: he({
            size: s,
            sizes: Hh
        })
    }, oK({
        variant: i,
        theme: e,
        color: r,
        gradient: n
    })), {
        "&:active": e.activeStyles,
        "& [data-action-icon-loader]": {
            maxWidth: "70%"
        },
        "&:disabled, &[data-disabled]": {
            color: e.colors.gray[e.colorScheme === "dark" ? 6 : 4],
            cursor: "not-allowed",
            backgroundColor: i === "transparent" ? void 0 : e.fn.themeColor("gray", e.colorScheme === "dark" ? 8 : 1),
            borderColor: i === "transparent" ? void 0 : e.fn.themeColor("gray", e.colorScheme === "dark" ? 8 : 1),
            backgroundImage: "none",
            pointerEvents: "none",
            "&:active": {
                transform: "none"
            }
        },
        "&[data-loading]": {
            pointerEvents: "none",
            "&::before": FP(__({
                content: '""'
            }, e.fn.cover(R(-1))), {
                backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.colors.dark[7], .5) : "rgba(255, 255, 255, .5)",
                borderRadius: e.fn.radius(t),
                cursor: "not-allowed"
            })
        }
    })
}));
const lK = aK;
var cK = Object.defineProperty,
    Vf = Object.getOwnPropertySymbols,
    Pk = Object.prototype.hasOwnProperty,
    Ck = Object.prototype.propertyIsEnumerable,
    BP = (e, t, r) => t in e ? cK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    uK = (e, t) => {
        for (var r in t || (t = {})) Pk.call(t, r) && BP(e, r, t[r]);
        if (Vf)
            for (var r of Vf(t)) Ck.call(t, r) && BP(e, r, t[r]);
        return e
    },
    hK = (e, t) => {
        var r = {};
        for (var n in e) Pk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Vf)
            for (var n of Vf(e)) t.indexOf(n) < 0 && Ck.call(e, n) && (r[n] = e[n]);
        return r
    };

function dK(e) {
    var t = e,
        {
            size: r,
            color: n
        } = t,
        i = hK(t, ["size", "color"]);
    return I.createElement("svg", uK({
        viewBox: "0 0 135 140",
        xmlns: "http://www.w3.org/2000/svg",
        fill: n,
        width: r
    }, i), I.createElement("rect", {
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
    }, I.createElement("animate", {
        attributeName: "height",
        begin: "0.5s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), I.createElement("animate", {
        attributeName: "y",
        begin: "0.5s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), I.createElement("rect", {
        x: "30",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
    }, I.createElement("animate", {
        attributeName: "height",
        begin: "0.25s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), I.createElement("animate", {
        attributeName: "y",
        begin: "0.25s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), I.createElement("rect", {
        x: "60",
        width: "15",
        height: "140",
        rx: "6"
    }, I.createElement("animate", {
        attributeName: "height",
        begin: "0s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), I.createElement("animate", {
        attributeName: "y",
        begin: "0s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), I.createElement("rect", {
        x: "90",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
    }, I.createElement("animate", {
        attributeName: "height",
        begin: "0.25s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), I.createElement("animate", {
        attributeName: "y",
        begin: "0.25s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), I.createElement("rect", {
        x: "120",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
    }, I.createElement("animate", {
        attributeName: "height",
        begin: "0.5s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), I.createElement("animate", {
        attributeName: "y",
        begin: "0.5s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })))
}
var fK = Object.defineProperty,
    Wf = Object.getOwnPropertySymbols,
    Tk = Object.prototype.hasOwnProperty,
    Ok = Object.prototype.propertyIsEnumerable,
    zP = (e, t, r) => t in e ? fK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    pK = (e, t) => {
        for (var r in t || (t = {})) Tk.call(t, r) && zP(e, r, t[r]);
        if (Wf)
            for (var r of Wf(t)) Ok.call(t, r) && zP(e, r, t[r]);
        return e
    },
    mK = (e, t) => {
        var r = {};
        for (var n in e) Tk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Wf)
            for (var n of Wf(e)) t.indexOf(n) < 0 && Ok.call(e, n) && (r[n] = e[n]);
        return r
    };

function gK(e) {
    var t = e,
        {
            size: r,
            color: n
        } = t,
        i = mK(t, ["size", "color"]);
    return I.createElement("svg", pK({
        width: r,
        height: r,
        viewBox: "0 0 38 38",
        xmlns: "http://www.w3.org/2000/svg",
        stroke: n
    }, i), I.createElement("g", {
        fill: "none",
        fillRule: "evenodd"
    }, I.createElement("g", {
        transform: "translate(2.5 2.5)",
        strokeWidth: "5"
    }, I.createElement("circle", {
        strokeOpacity: ".5",
        cx: "16",
        cy: "16",
        r: "16"
    }), I.createElement("path", {
        d: "M32 16c0-9.94-8.06-16-16-16"
    }, I.createElement("animateTransform", {
        attributeName: "transform",
        type: "rotate",
        from: "0 16 16",
        to: "360 16 16",
        dur: "1s",
        repeatCount: "indefinite"
    })))))
}
var vK = Object.defineProperty,
    Xf = Object.getOwnPropertySymbols,
    Ak = Object.prototype.hasOwnProperty,
    Ik = Object.prototype.propertyIsEnumerable,
    jP = (e, t, r) => t in e ? vK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    yK = (e, t) => {
        for (var r in t || (t = {})) Ak.call(t, r) && jP(e, r, t[r]);
        if (Xf)
            for (var r of Xf(t)) Ik.call(t, r) && jP(e, r, t[r]);
        return e
    },
    _K = (e, t) => {
        var r = {};
        for (var n in e) Ak.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Xf)
            for (var n of Xf(e)) t.indexOf(n) < 0 && Ik.call(e, n) && (r[n] = e[n]);
        return r
    };

function wK(e) {
    var t = e,
        {
            size: r,
            color: n
        } = t,
        i = _K(t, ["size", "color"]);
    return I.createElement("svg", yK({
        width: r,
        viewBox: "0 0 120 30",
        xmlns: "http://www.w3.org/2000/svg",
        fill: n
    }, i), I.createElement("circle", {
        cx: "15",
        cy: "15",
        r: "15"
    }, I.createElement("animate", {
        attributeName: "r",
        from: "15",
        to: "15",
        begin: "0s",
        dur: "0.8s",
        values: "15;9;15",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), I.createElement("animate", {
        attributeName: "fill-opacity",
        from: "1",
        to: "1",
        begin: "0s",
        dur: "0.8s",
        values: "1;.5;1",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), I.createElement("circle", {
        cx: "60",
        cy: "15",
        r: "9",
        fillOpacity: "0.3"
    }, I.createElement("animate", {
        attributeName: "r",
        from: "9",
        to: "9",
        begin: "0s",
        dur: "0.8s",
        values: "9;15;9",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), I.createElement("animate", {
        attributeName: "fill-opacity",
        from: "0.5",
        to: "0.5",
        begin: "0s",
        dur: "0.8s",
        values: ".5;1;.5",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), I.createElement("circle", {
        cx: "105",
        cy: "15",
        r: "15"
    }, I.createElement("animate", {
        attributeName: "r",
        from: "15",
        to: "15",
        begin: "0s",
        dur: "0.8s",
        values: "15;9;15",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), I.createElement("animate", {
        attributeName: "fill-opacity",
        from: "1",
        to: "1",
        begin: "0s",
        dur: "0.8s",
        values: "1;.5;1",
        calcMode: "linear",
        repeatCount: "indefinite"
    })))
}
var bK = Object.defineProperty,
    Yf = Object.getOwnPropertySymbols,
    $k = Object.prototype.hasOwnProperty,
    Rk = Object.prototype.propertyIsEnumerable,
    UP = (e, t, r) => t in e ? bK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    xK = (e, t) => {
        for (var r in t || (t = {})) $k.call(t, r) && UP(e, r, t[r]);
        if (Yf)
            for (var r of Yf(t)) Rk.call(t, r) && UP(e, r, t[r]);
        return e
    },
    EK = (e, t) => {
        var r = {};
        for (var n in e) $k.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Yf)
            for (var n of Yf(e)) t.indexOf(n) < 0 && Rk.call(e, n) && (r[n] = e[n]);
        return r
    };
const u0 = {
        bars: dK,
        oval: gK,
        dots: wK
    },
    SK = {
        xs: R(18),
        sm: R(22),
        md: R(36),
        lg: R(44),
        xl: R(58)
    },
    PK = {
        size: "md"
    };

function Ao(e) {
    const t = ve("Loader", PK, e),
        {
            size: r,
            color: n,
            variant: i
        } = t,
        s = EK(t, ["size", "color", "variant"]),
        o = yr(),
        a = i in u0 ? i : o.loader;
    return I.createElement(Ie, xK({
        role: "presentation",
        component: u0[a] || u0.bars,
        size: he({
            size: r,
            sizes: SK
        }),
        color: o.fn.variant({
            variant: "filled",
            primaryFallback: !1,
            color: n || o.primaryColor
        }).background
    }, s))
}
Ao.displayName = "@mantine/core/Loader";
var CK = Object.defineProperty,
    Kf = Object.getOwnPropertySymbols,
    kk = Object.prototype.hasOwnProperty,
    Mk = Object.prototype.propertyIsEnumerable,
    HP = (e, t, r) => t in e ? CK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    GP = (e, t) => {
        for (var r in t || (t = {})) kk.call(t, r) && HP(e, r, t[r]);
        if (Kf)
            for (var r of Kf(t)) Mk.call(t, r) && HP(e, r, t[r]);
        return e
    },
    TK = (e, t) => {
        var r = {};
        for (var n in e) kk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Kf)
            for (var n of Kf(e)) t.indexOf(n) < 0 && Mk.call(e, n) && (r[n] = e[n]);
        return r
    };
const OK = {
        color: "gray",
        size: "md",
        variant: "subtle"
    },
    Dk = b.forwardRef((e, t) => {
        const r = ve("ActionIcon", OK, e),
            {
                className: n,
                color: i,
                children: s,
                radius: o,
                size: a,
                variant: l,
                gradient: c,
                disabled: u,
                loaderProps: h,
                loading: d,
                unstyled: f,
                __staticSelector: p
            } = r,
            m = TK(r, ["className", "color", "children", "radius", "size", "variant", "gradient", "disabled", "loaderProps", "loading", "unstyled", "__staticSelector"]),
            {
                classes: w,
                cx: y,
                theme: v
            } = lK({
                radius: o,
                color: i,
                gradient: c
            }, {
                name: ["ActionIcon", p],
                unstyled: f,
                size: a,
                variant: l
            }),
            _ = I.createElement(Ao, GP({
                color: v.fn.variant({
                    color: i,
                    variant: l
                }).color,
                size: "100%",
                "data-action-icon-loader": !0
            }, h));
        return I.createElement(hg, GP({
            className: y(w.root, n),
            ref: t,
            disabled: u,
            "data-disabled": u || void 0,
            "data-loading": d || void 0,
            unstyled: f
        }, m), d ? _ : s)
    });
Dk.displayName = "@mantine/core/ActionIcon";
const mi = Dk;
var AK = Object.defineProperty,
    IK = Object.defineProperties,
    $K = Object.getOwnPropertyDescriptors,
    qf = Object.getOwnPropertySymbols,
    Nk = Object.prototype.hasOwnProperty,
    Lk = Object.prototype.propertyIsEnumerable,
    VP = (e, t, r) => t in e ? AK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    RK = (e, t) => {
        for (var r in t || (t = {})) Nk.call(t, r) && VP(e, r, t[r]);
        if (qf)
            for (var r of qf(t)) Lk.call(t, r) && VP(e, r, t[r]);
        return e
    },
    kK = (e, t) => IK(e, $K(t)),
    MK = (e, t) => {
        var r = {};
        for (var n in e) Nk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && qf)
            for (var n of qf(e)) t.indexOf(n) < 0 && Lk.call(e, n) && (r[n] = e[n]);
        return r
    };

function gw(e) {
    const t = ve("Portal", {}, e),
        {
            children: r,
            target: n,
            className: i,
            innerRef: s
        } = t,
        o = MK(t, ["children", "target", "className", "innerRef"]),
        a = yr(),
        [l, c] = b.useState(!1),
        u = b.useRef();
    return YR(() => (c(!0), u.current = n ? typeof n == "string" ? document.querySelector(n) : n : document.createElement("div"), n || document.body.appendChild(u.current), () => {
        !n && document.body.removeChild(u.current)
    }), [n]), l ? Ci.createPortal(I.createElement("div", kK(RK({
        className: i,
        dir: a.dir
    }, o), {
        ref: s
    }), r), u.current) : null
}
gw.displayName = "@mantine/core/Portal";
var DK = Object.defineProperty,
    Qf = Object.getOwnPropertySymbols,
    Fk = Object.prototype.hasOwnProperty,
    Bk = Object.prototype.propertyIsEnumerable,
    WP = (e, t, r) => t in e ? DK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    NK = (e, t) => {
        for (var r in t || (t = {})) Fk.call(t, r) && WP(e, r, t[r]);
        if (Qf)
            for (var r of Qf(t)) Bk.call(t, r) && WP(e, r, t[r]);
        return e
    },
    LK = (e, t) => {
        var r = {};
        for (var n in e) Fk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Qf)
            for (var n of Qf(e)) t.indexOf(n) < 0 && Bk.call(e, n) && (r[n] = e[n]);
        return r
    };

function vl(e) {
    var t = e,
        {
            withinPortal: r = !0,
            children: n
        } = t,
        i = LK(t, ["withinPortal", "children"]);
    return r ? I.createElement(gw, NK({}, i), n) : I.createElement(I.Fragment, null, n)
}
vl.displayName = "@mantine/core/OptionalPortal";
var FK = Object.defineProperty,
    XP = Object.getOwnPropertySymbols,
    BK = Object.prototype.hasOwnProperty,
    zK = Object.prototype.propertyIsEnumerable,
    YP = (e, t, r) => t in e ? FK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    jK = (e, t) => {
        for (var r in t || (t = {})) BK.call(t, r) && YP(e, r, t[r]);
        if (XP)
            for (var r of XP(t)) zK.call(t, r) && YP(e, r, t[r]);
        return e
    };

function zk(e) {
    return I.createElement("svg", jK({
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, e), I.createElement("path", {
        d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
        fill: "currentColor",
        fillRule: "evenodd",
        clipRule: "evenodd"
    }))
}
zk.displayName = "@mantine/core/CloseIcon";
var UK = Object.defineProperty,
    Zf = Object.getOwnPropertySymbols,
    jk = Object.prototype.hasOwnProperty,
    Uk = Object.prototype.propertyIsEnumerable,
    KP = (e, t, r) => t in e ? UK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    HK = (e, t) => {
        for (var r in t || (t = {})) jk.call(t, r) && KP(e, r, t[r]);
        if (Zf)
            for (var r of Zf(t)) Uk.call(t, r) && KP(e, r, t[r]);
        return e
    },
    GK = (e, t) => {
        var r = {};
        for (var n in e) jk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Zf)
            for (var n of Zf(e)) t.indexOf(n) < 0 && Uk.call(e, n) && (r[n] = e[n]);
        return r
    };
const VK = {
        xs: R(12),
        sm: R(16),
        md: R(20),
        lg: R(28),
        xl: R(34)
    },
    WK = {
        size: "sm"
    },
    Hk = b.forwardRef((e, t) => {
        const r = ve("CloseButton", WK, e),
            {
                iconSize: n,
                size: i,
                children: s
            } = r,
            o = GK(r, ["iconSize", "size", "children"]),
            a = R(n || VK[i]);
        return I.createElement(mi, HK({
            ref: t,
            __staticSelector: "CloseButton",
            size: i
        }, o), s || I.createElement(zk, {
            width: a,
            height: a
        }))
    });
Hk.displayName = "@mantine/core/CloseButton";
const Gk = Hk;
var XK = Object.defineProperty,
    YK = Object.defineProperties,
    KK = Object.getOwnPropertyDescriptors,
    qP = Object.getOwnPropertySymbols,
    qK = Object.prototype.hasOwnProperty,
    QK = Object.prototype.propertyIsEnumerable,
    QP = (e, t, r) => t in e ? XK(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Gh = (e, t) => {
        for (var r in t || (t = {})) qK.call(t, r) && QP(e, r, t[r]);
        if (qP)
            for (var r of qP(t)) QK.call(t, r) && QP(e, r, t[r]);
        return e
    },
    ZK = (e, t) => YK(e, KK(t));

function JK({
    underline: e,
    strikethrough: t
}) {
    const r = [];
    return e && r.push("underline"), t && r.push("line-through"), r.length > 0 ? r.join(" ") : "none"
}

function eq({
    theme: e,
    color: t
}) {
    return t === "dimmed" ? e.fn.dimmed() : typeof t == "string" && (t in e.colors || t.split(".")[0] in e.colors) ? e.fn.variant({
        variant: "filled",
        color: t
    }).background : t || "inherit"
}

function tq(e) {
    return typeof e == "number" ? {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitLineClamp: e,
        WebkitBoxOrient: "vertical"
    } : null
}

function rq({
    theme: e,
    truncate: t
}) {
    return t === "start" ? {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        direction: e.dir === "ltr" ? "rtl" : "ltr",
        textAlign: e.dir === "ltr" ? "right" : "left"
    } : t ? {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
    } : null
}
var nq = Pe((e, {
    color: t,
    lineClamp: r,
    truncate: n,
    inline: i,
    inherit: s,
    underline: o,
    gradient: a,
    weight: l,
    transform: c,
    align: u,
    strikethrough: h,
    italic: d
}, {
    size: f
}) => {
    const p = e.fn.variant({
        variant: "gradient",
        gradient: a
    });
    return {
        root: ZK(Gh(Gh(Gh(Gh({}, e.fn.fontStyles()), e.fn.focusStyles()), tq(r)), rq({
            theme: e,
            truncate: n
        })), {
            color: eq({
                color: t,
                theme: e
            }),
            fontFamily: s ? "inherit" : e.fontFamily,
            fontSize: s || f === void 0 ? "inherit" : he({
                size: f,
                sizes: e.fontSizes
            }),
            lineHeight: s ? "inherit" : i ? 1 : e.lineHeight,
            textDecoration: JK({
                underline: o,
                strikethrough: h
            }),
            WebkitTapHighlightColor: "transparent",
            fontWeight: s ? "inherit" : l,
            textTransform: c,
            textAlign: u,
            fontStyle: d ? "italic" : void 0
        }),
        gradient: {
            backgroundImage: p.background,
            WebkitBackgroundClip: "text",
            WebkitTextFillColor: "transparent"
        }
    }
});
const iq = nq;
var sq = Object.defineProperty,
    Jf = Object.getOwnPropertySymbols,
    Vk = Object.prototype.hasOwnProperty,
    Wk = Object.prototype.propertyIsEnumerable,
    ZP = (e, t, r) => t in e ? sq(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    oq = (e, t) => {
        for (var r in t || (t = {})) Vk.call(t, r) && ZP(e, r, t[r]);
        if (Jf)
            for (var r of Jf(t)) Wk.call(t, r) && ZP(e, r, t[r]);
        return e
    },
    aq = (e, t) => {
        var r = {};
        for (var n in e) Vk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Jf)
            for (var n of Jf(e)) t.indexOf(n) < 0 && Wk.call(e, n) && (r[n] = e[n]);
        return r
    };
const lq = {
        variant: "text"
    },
    Xk = b.forwardRef((e, t) => {
        const r = ve("Text", lq, e),
            {
                className: n,
                size: i,
                weight: s,
                transform: o,
                color: a,
                align: l,
                variant: c,
                lineClamp: u,
                truncate: h,
                gradient: d,
                inline: f,
                inherit: p,
                underline: m,
                strikethrough: w,
                italic: y,
                classNames: v,
                styles: _,
                unstyled: E,
                span: P,
                __staticSelector: C
            } = r,
            T = aq(r, ["className", "size", "weight", "transform", "color", "align", "variant", "lineClamp", "truncate", "gradient", "inline", "inherit", "underline", "strikethrough", "italic", "classNames", "styles", "unstyled", "span", "__staticSelector"]),
            {
                classes: O,
                cx: k
            } = iq({
                color: a,
                lineClamp: u,
                truncate: h,
                inline: f,
                inherit: p,
                underline: m,
                strikethrough: w,
                italic: y,
                weight: s,
                transform: o,
                align: l,
                gradient: d
            }, {
                unstyled: E,
                name: C || "Text",
                variant: c,
                size: i
            });
        return I.createElement(Ie, oq({
            ref: t,
            className: k(O.root, {
                [O.gradient]: c === "gradient"
            }, n),
            component: P ? "span" : "div"
        }, T))
    });
Xk.displayName = "@mantine/core/Text";
const ir = Xk;
var cq = Object.defineProperty,
    JP = Object.getOwnPropertySymbols,
    uq = Object.prototype.hasOwnProperty,
    hq = Object.prototype.propertyIsEnumerable,
    e2 = (e, t, r) => t in e ? cq(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    dq = (e, t) => {
        for (var r in t || (t = {})) uq.call(t, r) && e2(e, r, t[r]);
        if (JP)
            for (var r of JP(t)) hq.call(t, r) && e2(e, r, t[r]);
        return e
    };

function fq({
    theme: e,
    color: t
}) {
    return t === "dimmed" ? e.fn.dimmed() : e.fn.themeColor(t || e.primaryColor, e.colorScheme === "dark" ? 4 : 7, !1, !0)
}
var pq = Pe((e, {
    color: t,
    underline: r
}) => ({
    root: dq({
        backgroundColor: "transparent",
        cursor: "pointer",
        padding: 0,
        border: 0,
        color: fq({
            theme: e,
            color: t
        })
    }, e.fn.hover({
        textDecoration: r ? "underline" : "none"
    }))
}));
const mq = pq;
var gq = Object.defineProperty,
    ep = Object.getOwnPropertySymbols,
    Yk = Object.prototype.hasOwnProperty,
    Kk = Object.prototype.propertyIsEnumerable,
    t2 = (e, t, r) => t in e ? gq(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    r2 = (e, t) => {
        for (var r in t || (t = {})) Yk.call(t, r) && t2(e, r, t[r]);
        if (ep)
            for (var r of ep(t)) Kk.call(t, r) && t2(e, r, t[r]);
        return e
    },
    vq = (e, t) => {
        var r = {};
        for (var n in e) Yk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && ep)
            for (var n of ep(e)) t.indexOf(n) < 0 && Kk.call(e, n) && (r[n] = e[n]);
        return r
    };
const yq = {
        underline: !0
    },
    qk = b.forwardRef((e, t) => {
        const r = ve("Anchor", yq, e),
            {
                component: n,
                className: i,
                unstyled: s,
                variant: o,
                size: a,
                color: l,
                underline: c
            } = r,
            u = vq(r, ["component", "className", "unstyled", "variant", "size", "color", "underline"]),
            {
                classes: h,
                cx: d
            } = mq({
                color: l,
                underline: c
            }, {
                name: "Anchor",
                unstyled: s,
                variant: o,
                size: a
            }),
            f = n === "button" ? {
                type: "button"
            } : null;
        return I.createElement(ir, r2(r2({
            component: n || "a",
            ref: t,
            className: d(h.root, i),
            size: a
        }, f), u))
    });
qk.displayName = "@mantine/core/Anchor";
const Vi = qk,
    Vh = {
        xs: R(1),
        sm: R(2),
        md: R(3),
        lg: R(4),
        xl: R(5)
    };

function Wh(e, t) {
    const r = e.fn.variant({
        variant: "outline",
        color: t
    }).border;
    return typeof t == "string" && (t in e.colors || t.split(".")[0] in e.colors) ? r : t === void 0 ? e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[4] : t
}
var _q = Pe((e, {
    color: t
}, {
    size: r,
    variant: n
}) => ({
    root: {},
    withLabel: {
        borderTop: "0 !important"
    },
    left: {
        "&::before": {
            display: "none"
        }
    },
    right: {
        "&::after": {
            display: "none"
        }
    },
    label: {
        display: "flex",
        alignItems: "center",
        "&::before": {
            content: '""',
            flex: 1,
            height: R(1),
            borderTop: `${he({size:r,sizes:Vh})} ${n} ${Wh(e,t)}`,
            marginRight: e.spacing.xs
        },
        "&::after": {
            content: '""',
            flex: 1,
            borderTop: `${he({size:r,sizes:Vh})} ${n} ${Wh(e,t)}`,
            marginLeft: e.spacing.xs
        }
    },
    labelDefaultStyles: {
        color: t === "dark" ? e.colors.dark[1] : e.fn.themeColor(t, e.colorScheme === "dark" ? 5 : e.fn.primaryShade(), !1)
    },
    horizontal: {
        border: 0,
        borderTopWidth: R(he({
            size: r,
            sizes: Vh
        })),
        borderTopColor: Wh(e, t),
        borderTopStyle: n,
        margin: 0
    },
    vertical: {
        border: 0,
        alignSelf: "stretch",
        height: "auto",
        borderLeftWidth: R(he({
            size: r,
            sizes: Vh
        })),
        borderLeftColor: Wh(e, t),
        borderLeftStyle: n
    }
}));
const wq = _q;
var bq = Object.defineProperty,
    xq = Object.defineProperties,
    Eq = Object.getOwnPropertyDescriptors,
    tp = Object.getOwnPropertySymbols,
    Qk = Object.prototype.hasOwnProperty,
    Zk = Object.prototype.propertyIsEnumerable,
    n2 = (e, t, r) => t in e ? bq(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    i2 = (e, t) => {
        for (var r in t || (t = {})) Qk.call(t, r) && n2(e, r, t[r]);
        if (tp)
            for (var r of tp(t)) Zk.call(t, r) && n2(e, r, t[r]);
        return e
    },
    Sq = (e, t) => xq(e, Eq(t)),
    Pq = (e, t) => {
        var r = {};
        for (var n in e) Qk.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && tp)
            for (var n of tp(e)) t.indexOf(n) < 0 && Zk.call(e, n) && (r[n] = e[n]);
        return r
    };
const Cq = {
        orientation: "horizontal",
        size: "xs",
        labelPosition: "left",
        variant: "solid"
    },
    fa = b.forwardRef((e, t) => {
        const r = ve("Divider", Cq, e),
            {
                className: n,
                color: i,
                orientation: s,
                size: o,
                label: a,
                labelPosition: l,
                labelProps: c,
                variant: u,
                styles: h,
                classNames: d,
                unstyled: f
            } = r,
            p = Pq(r, ["className", "color", "orientation", "size", "label", "labelPosition", "labelProps", "variant", "styles", "classNames", "unstyled"]),
            {
                classes: m,
                cx: w
            } = wq({
                color: i
            }, {
                classNames: d,
                styles: h,
                unstyled: f,
                name: "Divider",
                variant: u,
                size: o
            }),
            y = s === "vertical",
            v = s === "horizontal",
            _ = !!a && v,
            E = !(c != null && c.color);
        return I.createElement(Ie, i2({
            ref: t,
            className: w(m.root, {
                [m.vertical]: y,
                [m.horizontal]: v,
                [m.withLabel]: _
            }, n),
            role: "separator"
        }, p), _ && I.createElement(ir, Sq(i2({}, c), {
            size: (c == null ? void 0 : c.size) || "xs",
            mt: R(2),
            className: w(m.label, m[l], {
                [m.labelDefaultStyles]: E
            })
        }), a))
    });
fa.displayName = "@mantine/core/Divider";

function Tq(e, t) {
    typeof e == "function" ? e(t) : e != null && (e.current = t)
}

function Jk(...e) {
    return t => e.forEach(r => Tq(r, t))
}

function Io(...e) {
    return b.useCallback(Jk(...e), e)
}
const e3 = b.forwardRef((e, t) => {
    const {
        children: r,
        ...n
    } = e, i = b.Children.toArray(r), s = i.find(Aq);
    if (s) {
        const o = s.props.children,
            a = i.map(l => l === s ? b.Children.count(o) > 1 ? b.Children.only(null) : b.isValidElement(o) ? o.props.children : null : l);
        return b.createElement(w_, dt({}, n, {
            ref: t
        }), b.isValidElement(o) ? b.cloneElement(o, void 0, a) : null)
    }
    return b.createElement(w_, dt({}, n, {
        ref: t
    }), r)
});
e3.displayName = "Slot";
const w_ = b.forwardRef((e, t) => {
    const {
        children: r,
        ...n
    } = e;
    return b.isValidElement(r) ? b.cloneElement(r, { ...Iq(n, r.props),
        ref: Jk(t, r.ref)
    }) : b.Children.count(r) > 1 ? b.Children.only(null) : null
});
w_.displayName = "SlotClone";
const Oq = ({
    children: e
}) => b.createElement(b.Fragment, null, e);

function Aq(e) {
    return b.isValidElement(e) && e.type === Oq
}

function Iq(e, t) {
    const r = { ...t
    };
    for (const n in t) {
        const i = e[n],
            s = t[n];
        /^on[A-Z]/.test(n) ? i && s ? r[n] = (...a) => {
            s(...a), i(...a)
        } : i && (r[n] = i) : n === "style" ? r[n] = { ...i,
            ...s
        } : n === "className" && (r[n] = [i, s].filter(Boolean).join(" "))
    }
    return { ...e,
        ...r
    }
}
const $q = ["a", "button", "div", "h2", "h3", "img", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
    Iu = $q.reduce((e, t) => {
        const r = b.forwardRef((n, i) => {
            const {
                asChild: s,
                ...o
            } = n, a = s ? e3 : t;
            return b.useEffect(() => {
                window[Symbol.for("radix-ui")] = !0
            }, []), b.createElement(a, dt({}, o, {
                ref: i
            }))
        });
        return r.displayName = `Primitive.${t}`, { ...e,
            [t]: r
        }
    }, {}),
    b_ = globalThis != null && globalThis.document ? b.useLayoutEffect : () => {};

function Rq(e, t) {
    return b.useReducer((r, n) => {
        const i = t[r][n];
        return i??r
    }, e)
}
const $u = e => {
    const {
        present: t,
        children: r
    } = e, n = kq(t), i = typeof r == "function" ? r({
        present: n.isPresent
    }) : b.Children.only(r), s = Io(n.ref, i.ref);
    return typeof r == "function" || n.isPresent ? b.cloneElement(i, {
        ref: s
    }) : null
};
$u.displayName = "Presence";

function kq(e) {
    const [t, r] = b.useState(), n = b.useRef({}), i = b.useRef(e), s = b.useRef("none"), o = e ? "mounted" : "unmounted", [a, l] = Rq(o, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return b.useEffect(() => {
        const c = Xh(n.current);
        s.current = a === "mounted" ? c : "none"
    }, [a]), b_(() => {
        const c = n.current,
            u = i.current;
        if (u !== e) {
            const d = s.current,
                f = Xh(c);
            e ? l("MOUNT") : f === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && d !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e
        }
    }, [e, l]), b_(() => {
        if (t) {
            const c = h => {
                    const f = Xh(n.current).includes(h.animationName);
                    h.target === t && f && Ci.flushSync(() => l("ANIMATION_END"))
                },
                u = h => {
                    h.target === t && (s.current = Xh(n.current))
                };
            return t.addEventListener("animationstart", u), t.addEventListener("animationcancel", c), t.addEventListener("animationend", c), () => {
                t.removeEventListener("animationstart", u), t.removeEventListener("animationcancel", c), t.removeEventListener("animationend", c)
            }
        } else l("ANIMATION_END")
    }, [t, l]), {
        isPresent: ["mounted", "unmountSuspended"].includes(a),
        ref: b.useCallback(c => {
            c && (n.current = getComputedStyle(c)), r(c)
        }, [])
    }
}

function Xh(e) {
    return (e == null ? void 0 : e.animationName) || "none"
}

function Mq(e, t = []) {
    let r = [];

    function n(s, o) {
        const a = b.createContext(o),
            l = r.length;
        r = [...r, o];

        function c(h) {
            const {
                scope: d,
                children: f,
                ...p
            } = h, m = (d == null ? void 0 : d[e][l]) || a, w = b.useMemo(() => p, Object.values(p));
            return b.createElement(m.Provider, {
                value: w
            }, f)
        }

        function u(h, d) {
            const f = (d == null ? void 0 : d[e][l]) || a,
                p = b.useContext(f);
            if (p) return p;
            if (o !== void 0) return o;
            throw new Error(`\`${h}\` must be used within \`${s}\``)
        }
        return c.displayName = s + "Provider", [c, u]
    }
    const i = () => {
        const s = r.map(o => b.createContext(o));
        return function(a) {
            const l = (a == null ? void 0 : a[e]) || s;
            return b.useMemo(() => ({
                [`__scope${e}`]: { ...a,
                    [e]: l
                }
            }), [a, l])
        }
    };
    return i.scopeName = e, [n, Dq(i, ...t)]
}

function Dq(...e) {
    const t = e[0];
    if (e.length === 1) return t;
    const r = () => {
        const n = e.map(i => ({
            useScope: i(),
            scopeName: i.scopeName
        }));
        return function(s) {
            const o = n.reduce((a, {
                useScope: l,
                scopeName: c
            }) => {
                const h = l(s)[`__scope${c}`];
                return { ...a,
                    ...h
                }
            }, {});
            return b.useMemo(() => ({
                [`__scope${t.scopeName}`]: o
            }), [o])
        }
    };
    return r.scopeName = t.scopeName, r
}

function qs(e) {
    const t = b.useRef(e);
    return b.useEffect(() => {
        t.current = e
    }), b.useMemo(() => (...r) => {
        var n;
        return (n = t.current) === null || n === void 0 ? void 0 : n.call(t, ...r)
    }, [])
}
const Nq = b.createContext(void 0);

function Lq(e) {
    const t = b.useContext(Nq);
    return e || t || "ltr"
}

function Fq(e, [t, r]) {
    return Math.min(r, Math.max(t, e))
}

function lo(e, t, {
    checkForDefaultPrevented: r = !0
} = {}) {
    return function(i) {
        if (e == null || e(i), r === !1 || !i.defaultPrevented) return t == null ? void 0 : t(i)
    }
}

function Bq(e, t) {
    return b.useReducer((r, n) => {
        const i = t[r][n];
        return i??r
    }, e)
}
const t3 = "ScrollArea",
    [r3, ide] = Mq(t3),
    [zq, an] = r3(t3),
    jq = b.forwardRef((e, t) => {
        const {
            __scopeScrollArea: r,
            type: n = "hover",
            dir: i,
            scrollHideDelay: s = 600,
            ...o
        } = e, [a, l] = b.useState(null), [c, u] = b.useState(null), [h, d] = b.useState(null), [f, p] = b.useState(null), [m, w] = b.useState(null), [y, v] = b.useState(0), [_, E] = b.useState(0), [P, C] = b.useState(!1), [T, O] = b.useState(!1), k = Io(t, B => l(B)), D = Lq(i);
        return b.createElement(zq, {
            scope: r,
            type: n,
            dir: D,
            scrollHideDelay: s,
            scrollArea: a,
            viewport: c,
            onViewportChange: u,
            content: h,
            onContentChange: d,
            scrollbarX: f,
            onScrollbarXChange: p,
            scrollbarXEnabled: P,
            onScrollbarXEnabledChange: C,
            scrollbarY: m,
            onScrollbarYChange: w,
            scrollbarYEnabled: T,
            onScrollbarYEnabledChange: O,
            onCornerWidthChange: v,
            onCornerHeightChange: E
        }, b.createElement(Iu.div, dt({
            dir: D
        }, o, {
            ref: k,
            style: {
                position: "relative",
                ["--radix-scroll-area-corner-width"]: y + "px",
                ["--radix-scroll-area-corner-height"]: _ + "px",
                ...e.style
            }
        })))
    }),
    Uq = "ScrollAreaViewport",
    Hq = b.forwardRef((e, t) => {
        const {
            __scopeScrollArea: r,
            children: n,
            ...i
        } = e, s = an(Uq, r), o = b.useRef(null), a = Io(t, o, s.onViewportChange);
        return b.createElement(b.Fragment, null, b.createElement("style", {
            dangerouslySetInnerHTML: {
                __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
            }
        }), b.createElement(Iu.div, dt({
            "data-radix-scroll-area-viewport": ""
        }, i, {
            ref: a,
            style: {
                overflowX: s.scrollbarXEnabled ? "scroll" : "hidden",
                overflowY: s.scrollbarYEnabled ? "scroll" : "hidden",
                ...e.style
            }
        }), b.createElement("div", {
            ref: s.onContentChange,
            style: {
                minWidth: "100%",
                display: "table"
            }
        }, n)))
    }),
    Mi = "ScrollAreaScrollbar",
    Gq = b.forwardRef((e, t) => {
        const {
            forceMount: r,
            ...n
        } = e, i = an(Mi, e.__scopeScrollArea), {
            onScrollbarXEnabledChange: s,
            onScrollbarYEnabledChange: o
        } = i, a = e.orientation === "horizontal";
        return b.useEffect(() => (a ? s(!0) : o(!0), () => {
            a ? s(!1) : o(!1)
        }), [a, s, o]), i.type === "hover" ? b.createElement(Vq, dt({}, n, {
            ref: t,
            forceMount: r
        })) : i.type === "scroll" ? b.createElement(Wq, dt({}, n, {
            ref: t,
            forceMount: r
        })) : i.type === "auto" ? b.createElement(n3, dt({}, n, {
            ref: t,
            forceMount: r
        })) : i.type === "always" ? b.createElement(vw, dt({}, n, {
            ref: t
        })) : null
    }),
    Vq = b.forwardRef((e, t) => {
        const {
            forceMount: r,
            ...n
        } = e, i = an(Mi, e.__scopeScrollArea), [s, o] = b.useState(!1);
        return b.useEffect(() => {
            const a = i.scrollArea;
            let l = 0;
            if (a) {
                const c = () => {
                        window.clearTimeout(l), o(!0)
                    },
                    u = () => {
                        l = window.setTimeout(() => o(!1), i.scrollHideDelay)
                    };
                return a.addEventListener("pointerenter", c), a.addEventListener("pointerleave", u), () => {
                    window.clearTimeout(l), a.removeEventListener("pointerenter", c), a.removeEventListener("pointerleave", u)
                }
            }
        }, [i.scrollArea, i.scrollHideDelay]), b.createElement($u, {
            present: r || s
        }, b.createElement(n3, dt({
            "data-state": s ? "visible" : "hidden"
        }, n, {
            ref: t
        })))
    }),
    Wq = b.forwardRef((e, t) => {
        const {
            forceMount: r,
            ...n
        } = e, i = an(Mi, e.__scopeScrollArea), s = e.orientation === "horizontal", o = fg(() => l("SCROLL_END"), 100), [a, l] = Bq("hidden", {
            hidden: {
                SCROLL: "scrolling"
            },
            scrolling: {
                SCROLL_END: "idle",
                POINTER_ENTER: "interacting"
            },
            interacting: {
                SCROLL: "interacting",
                POINTER_LEAVE: "idle"
            },
            idle: {
                HIDE: "hidden",
                SCROLL: "scrolling",
                POINTER_ENTER: "interacting"
            }
        });
        return b.useEffect(() => {
            if (a === "idle") {
                const c = window.setTimeout(() => l("HIDE"), i.scrollHideDelay);
                return () => window.clearTimeout(c)
            }
        }, [a, i.scrollHideDelay, l]), b.useEffect(() => {
            const c = i.viewport,
                u = s ? "scrollLeft" : "scrollTop";
            if (c) {
                let h = c[u];
                const d = () => {
                    const f = c[u];
                    h !== f && (l("SCROLL"), o()), h = f
                };
                return c.addEventListener("scroll", d), () => c.removeEventListener("scroll", d)
            }
        }, [i.viewport, s, l, o]), b.createElement($u, {
            present: r || a !== "hidden"
        }, b.createElement(vw, dt({
            "data-state": a === "hidden" ? "hidden" : "visible"
        }, n, {
            ref: t,
            onPointerEnter: lo(e.onPointerEnter, () => l("POINTER_ENTER")),
            onPointerLeave: lo(e.onPointerLeave, () => l("POINTER_LEAVE"))
        })))
    }),
    n3 = b.forwardRef((e, t) => {
        const r = an(Mi, e.__scopeScrollArea),
            {
                forceMount: n,
                ...i
            } = e,
            [s, o] = b.useState(!1),
            a = e.orientation === "horizontal",
            l = fg(() => {
                if (r.viewport) {
                    const c = r.viewport.offsetWidth < r.viewport.scrollWidth,
                        u = r.viewport.offsetHeight < r.viewport.scrollHeight;
                    o(a ? c : u)
                }
            }, 10);
        return nl(r.viewport, l), nl(r.content, l), b.createElement($u, {
            present: n || s
        }, b.createElement(vw, dt({
            "data-state": s ? "visible" : "hidden"
        }, i, {
            ref: t
        })))
    }),
    vw = b.forwardRef((e, t) => {
        const {
            orientation: r = "vertical",
            ...n
        } = e, i = an(Mi, e.__scopeScrollArea), s = b.useRef(null), o = b.useRef(0), [a, l] = b.useState({
            content: 0,
            viewport: 0,
            scrollbar: {
                size: 0,
                paddingStart: 0,
                paddingEnd: 0
            }
        }), c = a3(a.viewport, a.content), u = { ...n,
            sizes: a,
            onSizesChange: l,
            hasThumb: c > 0 && c < 1,
            onThumbChange: d => s.current = d,
            onThumbPointerUp: () => o.current = 0,
            onThumbPointerDown: d => o.current = d
        };

        function h(d, f) {
            return eQ(d, o.current, a, f)
        }
        return r === "horizontal" ? b.createElement(Xq, dt({}, u, {
            ref: t,
            onThumbPositionChange: () => {
                if (i.viewport && s.current) {
                    const d = i.viewport.scrollLeft,
                        f = s2(d, a, i.dir);
                    s.current.style.transform = `translate3d(${f}px, 0, 0)`
                }
            },
            onWheelScroll: d => {
                i.viewport && (i.viewport.scrollLeft = d)
            },
            onDragScroll: d => {
                i.viewport && (i.viewport.scrollLeft = h(d, i.dir))
            }
        })) : r === "vertical" ? b.createElement(Yq, dt({}, u, {
            ref: t,
            onThumbPositionChange: () => {
                if (i.viewport && s.current) {
                    const d = i.viewport.scrollTop,
                        f = s2(d, a);
                    s.current.style.transform = `translate3d(0, ${f}px, 0)`
                }
            },
            onWheelScroll: d => {
                i.viewport && (i.viewport.scrollTop = d)
            },
            onDragScroll: d => {
                i.viewport && (i.viewport.scrollTop = h(d))
            }
        })) : null
    }),
    Xq = b.forwardRef((e, t) => {
        const {
            sizes: r,
            onSizesChange: n,
            ...i
        } = e, s = an(Mi, e.__scopeScrollArea), [o, a] = b.useState(), l = b.useRef(null), c = Io(t, l, s.onScrollbarXChange);
        return b.useEffect(() => {
            l.current && a(getComputedStyle(l.current))
        }, [l]), b.createElement(s3, dt({
            "data-orientation": "horizontal"
        }, i, {
            ref: c,
            sizes: r,
            style: {
                bottom: 0,
                left: s.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
                right: s.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
                ["--radix-scroll-area-thumb-width"]: dg(r) + "px",
                ...e.style
            },
            onThumbPointerDown: u => e.onThumbPointerDown(u.x),
            onDragScroll: u => e.onDragScroll(u.x),
            onWheelScroll: (u, h) => {
                if (s.viewport) {
                    const d = s.viewport.scrollLeft + u.deltaX;
                    e.onWheelScroll(d), c3(d, h) && u.preventDefault()
                }
            },
            onResize: () => {
                l.current && s.viewport && o && n({
                    content: s.viewport.scrollWidth,
                    viewport: s.viewport.offsetWidth,
                    scrollbar: {
                        size: l.current.clientWidth,
                        paddingStart: rp(o.paddingLeft),
                        paddingEnd: rp(o.paddingRight)
                    }
                })
            }
        }))
    }),
    Yq = b.forwardRef((e, t) => {
        const {
            sizes: r,
            onSizesChange: n,
            ...i
        } = e, s = an(Mi, e.__scopeScrollArea), [o, a] = b.useState(), l = b.useRef(null), c = Io(t, l, s.onScrollbarYChange);
        return b.useEffect(() => {
            l.current && a(getComputedStyle(l.current))
        }, [l]), b.createElement(s3, dt({
            "data-orientation": "vertical"
        }, i, {
            ref: c,
            sizes: r,
            style: {
                top: 0,
                right: s.dir === "ltr" ? 0 : void 0,
                left: s.dir === "rtl" ? 0 : void 0,
                bottom: "var(--radix-scroll-area-corner-height)",
                ["--radix-scroll-area-thumb-height"]: dg(r) + "px",
                ...e.style
            },
            onThumbPointerDown: u => e.onThumbPointerDown(u.y),
            onDragScroll: u => e.onDragScroll(u.y),
            onWheelScroll: (u, h) => {
                if (s.viewport) {
                    const d = s.viewport.scrollTop + u.deltaY;
                    e.onWheelScroll(d), c3(d, h) && u.preventDefault()
                }
            },
            onResize: () => {
                l.current && s.viewport && o && n({
                    content: s.viewport.scrollHeight,
                    viewport: s.viewport.offsetHeight,
                    scrollbar: {
                        size: l.current.clientHeight,
                        paddingStart: rp(o.paddingTop),
                        paddingEnd: rp(o.paddingBottom)
                    }
                })
            }
        }))
    }),
    [Kq, i3] = r3(Mi),
    s3 = b.forwardRef((e, t) => {
        const {
            __scopeScrollArea: r,
            sizes: n,
            hasThumb: i,
            onThumbChange: s,
            onThumbPointerUp: o,
            onThumbPointerDown: a,
            onThumbPositionChange: l,
            onDragScroll: c,
            onWheelScroll: u,
            onResize: h,
            ...d
        } = e, f = an(Mi, r), [p, m] = b.useState(null), w = Io(t, k => m(k)), y = b.useRef(null), v = b.useRef(""), _ = f.viewport, E = n.content - n.viewport, P = qs(u), C = qs(l), T = fg(h, 10);

        function O(k) {
            if (y.current) {
                const D = k.clientX - y.current.left,
                    B = k.clientY - y.current.top;
                c({
                    x: D,
                    y: B
                })
            }
        }
        return b.useEffect(() => {
            const k = D => {
                const B = D.target;
                (p == null ? void 0 : p.contains(B)) && P(D, E)
            };
            return document.addEventListener("wheel", k, {
                passive: !1
            }), () => document.removeEventListener("wheel", k, {
                passive: !1
            })
        }, [_, p, E, P]), b.useEffect(C, [n, C]), nl(p, T), nl(f.content, T), b.createElement(Kq, {
            scope: r,
            scrollbar: p,
            hasThumb: i,
            onThumbChange: qs(s),
            onThumbPointerUp: qs(o),
            onThumbPositionChange: C,
            onThumbPointerDown: qs(a)
        }, b.createElement(Iu.div, dt({}, d, {
            ref: w,
            style: {
                position: "absolute",
                ...d.style
            },
            onPointerDown: lo(e.onPointerDown, k => {
                k.button === 0 && (k.target.setPointerCapture(k.pointerId), y.current = p.getBoundingClientRect(), v.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", O(k))
            }),
            onPointerMove: lo(e.onPointerMove, O),
            onPointerUp: lo(e.onPointerUp, k => {
                const D = k.target;
                D.hasPointerCapture(k.pointerId) && D.releasePointerCapture(k.pointerId), document.body.style.webkitUserSelect = v.current, y.current = null
            })
        })))
    }),
    x_ = "ScrollAreaThumb",
    qq = b.forwardRef((e, t) => {
        const {
            forceMount: r,
            ...n
        } = e, i = i3(x_, e.__scopeScrollArea);
        return b.createElement($u, {
            present: r || i.hasThumb
        }, b.createElement(Qq, dt({
            ref: t
        }, n)))
    }),
    Qq = b.forwardRef((e, t) => {
        const {
            __scopeScrollArea: r,
            style: n,
            ...i
        } = e, s = an(x_, r), o = i3(x_, r), {
            onThumbPositionChange: a
        } = o, l = Io(t, h => o.onThumbChange(h)), c = b.useRef(), u = fg(() => {
            c.current && (c.current(), c.current = void 0)
        }, 100);
        return b.useEffect(() => {
            const h = s.viewport;
            if (h) {
                const d = () => {
                    if (u(), !c.current) {
                        const f = tQ(h, a);
                        c.current = f, a()
                    }
                };
                return a(), h.addEventListener("scroll", d), () => h.removeEventListener("scroll", d)
            }
        }, [s.viewport, u, a]), b.createElement(Iu.div, dt({
            "data-state": o.hasThumb ? "visible" : "hidden"
        }, i, {
            ref: l,
            style: {
                width: "var(--radix-scroll-area-thumb-width)",
                height: "var(--radix-scroll-area-thumb-height)",
                ...n
            },
            onPointerDownCapture: lo(e.onPointerDownCapture, h => {
                const f = h.target.getBoundingClientRect(),
                    p = h.clientX - f.left,
                    m = h.clientY - f.top;
                o.onThumbPointerDown({
                    x: p,
                    y: m
                })
            }),
            onPointerUp: lo(e.onPointerUp, o.onThumbPointerUp)
        }))
    }),
    o3 = "ScrollAreaCorner",
    Zq = b.forwardRef((e, t) => {
        const r = an(o3, e.__scopeScrollArea),
            n = !!(r.scrollbarX && r.scrollbarY);
        return r.type !== "scroll" && n ? b.createElement(Jq, dt({}, e, {
            ref: t
        })) : null
    }),
    Jq = b.forwardRef((e, t) => {
        const {
            __scopeScrollArea: r,
            ...n
        } = e, i = an(o3, r), [s, o] = b.useState(0), [a, l] = b.useState(0), c = !!(s && a);
        return nl(i.scrollbarX, () => {
            var u;
            const h = ((u = i.scrollbarX) === null || u === void 0 ? void 0 : u.offsetHeight) || 0;
            i.onCornerHeightChange(h), l(h)
        }), nl(i.scrollbarY, () => {
            var u;
            const h = ((u = i.scrollbarY) === null || u === void 0 ? void 0 : u.offsetWidth) || 0;
            i.onCornerWidthChange(h), o(h)
        }), c ? b.createElement(Iu.div, dt({}, n, {
            ref: t,
            style: {
                width: s,
                height: a,
                position: "absolute",
                right: i.dir === "ltr" ? 0 : void 0,
                left: i.dir === "rtl" ? 0 : void 0,
                bottom: 0,
                ...e.style
            }
        })) : null
    });

function rp(e) {
    return e ? parseInt(e, 10) : 0
}

function a3(e, t) {
    const r = e / t;
    return isNaN(r) ? 0 : r
}

function dg(e) {
    const t = a3(e.viewport, e.content),
        r = e.scrollbar.paddingStart + e.scrollbar.paddingEnd,
        n = (e.scrollbar.size - r) * t;
    return Math.max(n, 18)
}

function eQ(e, t, r, n = "ltr") {
    const i = dg(r),
        s = i / 2,
        o = t || s,
        a = i - o,
        l = r.scrollbar.paddingStart + o,
        c = r.scrollbar.size - r.scrollbar.paddingEnd - a,
        u = r.content - r.viewport,
        h = n === "ltr" ? [0, u] : [u * -1, 0];
    return l3([l, c], h)(e)
}

function s2(e, t, r = "ltr") {
    const n = dg(t),
        i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd,
        s = t.scrollbar.size - i,
        o = t.content - t.viewport,
        a = s - n,
        l = r === "ltr" ? [0, o] : [o * -1, 0],
        c = Fq(e, l);
    return l3([0, o], [0, a])(c)
}

function l3(e, t) {
    return r => {
        if (e[0] === e[1] || t[0] === t[1]) return t[0];
        const n = (t[1] - t[0]) / (e[1] - e[0]);
        return t[0] + n * (r - e[0])
    }
}

function c3(e, t) {
    return e > 0 && e < t
}
const tQ = (e, t = () => {}) => {
    let r = {
            left: e.scrollLeft,
            top: e.scrollTop
        },
        n = 0;
    return function i() {
        const s = {
                left: e.scrollLeft,
                top: e.scrollTop
            },
            o = r.left !== s.left,
            a = r.top !== s.top;
        (o || a) && t(), r = s, n = window.requestAnimationFrame(i)
    }(), () => window.cancelAnimationFrame(n)
};

function fg(e, t) {
    const r = qs(e),
        n = b.useRef(0);
    return b.useEffect(() => () => window.clearTimeout(n.current), []), b.useCallback(() => {
        window.clearTimeout(n.current), n.current = window.setTimeout(r, t)
    }, [r, t])
}

function nl(e, t) {
    const r = qs(t);
    b_(() => {
        let n = 0;
        if (e) {
            const i = new ResizeObserver(() => {
                cancelAnimationFrame(n), n = window.requestAnimationFrame(r)
            });
            return i.observe(e), () => {
                window.cancelAnimationFrame(n), i.unobserve(e)
            }
        }
    }, [e, r])
}
const rQ = jq,
    nQ = Hq,
    o2 = Gq,
    a2 = qq,
    iQ = Zq;
var sQ = Pe((e, {
    scrollbarSize: t,
    offsetScrollbars: r,
    scrollbarHovered: n,
    hidden: i
}) => ({
    root: {
        overflow: "hidden"
    },
    viewport: {
        width: "100%",
        height: "100%",
        paddingRight: r ? R(t) : void 0,
        paddingBottom: r ? R(t) : void 0
    },
    scrollbar: {
        display: i ? "none" : "flex",
        userSelect: "none",
        touchAction: "none",
        boxSizing: "border-box",
        padding: `calc(${R(t)}  / 5)`,
        transition: "background-color 150ms ease, opacity 150ms ease",
        "&:hover": {
            backgroundColor: e.colorScheme === "dark" ? e.colors.dark[8] : e.colors.gray[0],
            [`& .${ys("thumb")}`]: {
                backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.white, .5) : e.fn.rgba(e.black, .5)
            }
        },
        '&[data-orientation="vertical"]': {
            width: R(t)
        },
        '&[data-orientation="horizontal"]': {
            flexDirection: "column",
            height: R(t)
        },
        '&[data-state="hidden"]': {
            display: "none",
            opacity: 0
        }
    },
    thumb: {
        ref: ys("thumb"),
        flex: 1,
        backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.white, .4) : e.fn.rgba(e.black, .4),
        borderRadius: R(t),
        position: "relative",
        transition: "background-color 150ms ease",
        display: i ? "none" : void 0,
        overflow: "hidden",
        "&::before": {
            content: '""',
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: "100%",
            height: "100%",
            minWidth: R(44),
            minHeight: R(44)
        }
    },
    corner: {
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0],
        transition: "opacity 150ms ease",
        opacity: n ? 1 : 0,
        display: i ? "none" : void 0
    }
}));
const oQ = sQ;
var aQ = Object.defineProperty,
    lQ = Object.defineProperties,
    cQ = Object.getOwnPropertyDescriptors,
    np = Object.getOwnPropertySymbols,
    u3 = Object.prototype.hasOwnProperty,
    h3 = Object.prototype.propertyIsEnumerable,
    l2 = (e, t, r) => t in e ? aQ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    E_ = (e, t) => {
        for (var r in t || (t = {})) u3.call(t, r) && l2(e, r, t[r]);
        if (np)
            for (var r of np(t)) h3.call(t, r) && l2(e, r, t[r]);
        return e
    },
    d3 = (e, t) => lQ(e, cQ(t)),
    f3 = (e, t) => {
        var r = {};
        for (var n in e) u3.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && np)
            for (var n of np(e)) t.indexOf(n) < 0 && h3.call(e, n) && (r[n] = e[n]);
        return r
    };
const p3 = {
        scrollbarSize: 12,
        scrollHideDelay: 1e3,
        type: "hover",
        offsetScrollbars: !1
    },
    pg = b.forwardRef((e, t) => {
        const r = ve("ScrollArea", p3, e),
            {
                children: n,
                className: i,
                classNames: s,
                styles: o,
                scrollbarSize: a,
                scrollHideDelay: l,
                type: c,
                dir: u,
                offsetScrollbars: h,
                viewportRef: d,
                onScrollPositionChange: f,
                unstyled: p,
                variant: m,
                viewportProps: w
            } = r,
            y = f3(r, ["children", "className", "classNames", "styles", "scrollbarSize", "scrollHideDelay", "type", "dir", "offsetScrollbars", "viewportRef", "onScrollPositionChange", "unstyled", "variant", "viewportProps"]),
            [v, _] = b.useState(!1),
            E = yr(),
            {
                classes: P,
                cx: C
            } = oQ({
                scrollbarSize: a,
                offsetScrollbars: h,
                scrollbarHovered: v,
                hidden: c === "never"
            }, {
                name: "ScrollArea",
                classNames: s,
                styles: o,
                unstyled: p,
                variant: m
            });
        return I.createElement(rQ, {
            type: c === "never" ? "always" : c,
            scrollHideDelay: l,
            dir: u || E.dir,
            ref: t,
            asChild: !0
        }, I.createElement(Ie, E_({
            className: C(P.root, i)
        }, y), I.createElement(nQ, d3(E_({}, w), {
            className: P.viewport,
            ref: d,
            onScroll: typeof f == "function" ? ({
                currentTarget: T
            }) => f({
                x: T.scrollLeft,
                y: T.scrollTop
            }) : void 0
        }), n), I.createElement(o2, {
            orientation: "horizontal",
            className: P.scrollbar,
            forceMount: !0,
            onMouseEnter: () => _(!0),
            onMouseLeave: () => _(!1)
        }, I.createElement(a2, {
            className: P.thumb
        })), I.createElement(o2, {
            orientation: "vertical",
            className: P.scrollbar,
            forceMount: !0,
            onMouseEnter: () => _(!0),
            onMouseLeave: () => _(!1)
        }, I.createElement(a2, {
            className: P.thumb
        })), I.createElement(iQ, {
            className: P.corner
        })))
    }),
    m3 = b.forwardRef((e, t) => {
        const r = ve("ScrollAreaAutosize", p3, e),
            {
                children: n,
                classNames: i,
                styles: s,
                scrollbarSize: o,
                scrollHideDelay: a,
                type: l,
                dir: c,
                offsetScrollbars: u,
                viewportRef: h,
                onScrollPositionChange: d,
                unstyled: f,
                sx: p,
                variant: m,
                viewportProps: w
            } = r,
            y = f3(r, ["children", "classNames", "styles", "scrollbarSize", "scrollHideDelay", "type", "dir", "offsetScrollbars", "viewportRef", "onScrollPositionChange", "unstyled", "sx", "variant", "viewportProps"]);
        return I.createElement(Ie, d3(E_({}, y), {
            ref: t,
            sx: [{
                display: "flex"
            }, ...Wm(p)]
        }), I.createElement(Ie, {
            sx: {
                display: "flex",
                flexDirection: "column",
                flex: 1
            }
        }, I.createElement(pg, {
            classNames: i,
            styles: s,
            scrollHideDelay: a,
            scrollbarSize: o,
            type: l,
            dir: c,
            offsetScrollbars: u,
            viewportRef: h,
            onScrollPositionChange: d,
            unstyled: f,
            variant: m,
            viewportProps: w
        }, n)))
    });
m3.displayName = "@mantine/core/ScrollAreaAutosize";
pg.displayName = "@mantine/core/ScrollArea";
pg.Autosize = m3;
const uQ = pg;

function yl(e) {
    return e.split("-")[1]
}

function yw(e) {
    return e === "y" ? "height" : "width"
}

function $n(e) {
    return e.split("-")[0]
}

function Rs(e) {
    return ["top", "bottom"].includes($n(e)) ? "x" : "y"
}

function c2(e, t, r) {
    let {
        reference: n,
        floating: i
    } = e;
    const s = n.x + n.width / 2 - i.width / 2,
        o = n.y + n.height / 2 - i.height / 2,
        a = Rs(t),
        l = yw(a),
        c = n[l] / 2 - i[l] / 2,
        u = a === "x";
    let h;
    switch ($n(t)) {
        case "top":
            h = {
                x: s,
                y: n.y - i.height
            };
            break;
        case "bottom":
            h = {
                x: s,
                y: n.y + n.height
            };
            break;
        case "right":
            h = {
                x: n.x + n.width,
                y: o
            };
            break;
        case "left":
            h = {
                x: n.x - i.width,
                y: o
            };
            break;
        default:
            h = {
                x: n.x,
                y: n.y
            }
    }
    switch (yl(t)) {
        case "start":
            h[a] -= c * (r && u ? -1 : 1);
            break;
        case "end":
            h[a] += c * (r && u ? -1 : 1)
    }
    return h
}
const hQ = async (e, t, r) => {
    const {
        placement: n = "bottom",
        strategy: i = "absolute",
        middleware: s = [],
        platform: o
    } = r, a = s.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
    let c = await o.getElementRects({
            reference: e,
            floating: t,
            strategy: i
        }),
        {
            x: u,
            y: h
        } = c2(c, n, l),
        d = n,
        f = {},
        p = 0;
    for (let m = 0; m < a.length; m++) {
        const {
            name: w,
            fn: y
        } = a[m], {
            x: v,
            y: _,
            data: E,
            reset: P
        } = await y({
            x: u,
            y: h,
            initialPlacement: n,
            placement: d,
            strategy: i,
            middlewareData: f,
            rects: c,
            platform: o,
            elements: {
                reference: e,
                floating: t
            }
        });
        u = v??u, h = _??h, f = { ...f,
            [w]: { ...f[w],
                ...E
            }
        }, P && p <= 50 && (p++, typeof P == "object" && (P.placement && (d = P.placement), P.rects && (c = P.rects === !0 ? await o.getElementRects({
            reference: e,
            floating: t,
            strategy: i
        }) : P.rects), {
            x: u,
            y: h
        } = c2(c, d, l)), m = -1)
    }
    return {
        x: u,
        y: h,
        placement: d,
        strategy: i,
        middlewareData: f
    }
};

function _w(e) {
    return typeof e != "number" ? function(t) {
        return {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            ...t
        }
    }(e) : {
        top: e,
        right: e,
        bottom: e,
        left: e
    }
}

function il(e) {
    return { ...e,
        top: e.y,
        left: e.x,
        right: e.x + e.width,
        bottom: e.y + e.height
    }
}
async function ww(e, t) {
    var r;
    t === void 0 && (t = {});
    const {
        x: n,
        y: i,
        platform: s,
        rects: o,
        elements: a,
        strategy: l
    } = e, {
        boundary: c = "clippingAncestors",
        rootBoundary: u = "viewport",
        elementContext: h = "floating",
        altBoundary: d = !1,
        padding: f = 0
    } = t, p = _w(f), m = a[d ? h === "floating" ? "reference" : "floating" : h], w = il(await s.getClippingRect({
        element: (r = await (s.isElement == null ? void 0 : s.isElement(m))) == null || r ? m : m.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
        boundary: c,
        rootBoundary: u,
        strategy: l
    })), y = h === "floating" ? { ...o.floating,
        x: n,
        y: i
    } : o.reference, v = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), _ = await (s.isElement == null ? void 0 : s.isElement(v)) && await (s.getScale == null ? void 0 : s.getScale(v)) || {
        x: 1,
        y: 1
    }, E = il(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: y,
        offsetParent: v,
        strategy: l
    }) : y);
    return {
        top: (w.top - E.top + p.top) / _.y,
        bottom: (E.bottom - w.bottom + p.bottom) / _.y,
        left: (w.left - E.left + p.left) / _.x,
        right: (E.right - w.right + p.right) / _.x
    }
}
const sl = Math.min,
    Kn = Math.max;

function S_(e, t, r) {
    return Kn(e, sl(t, r))
}
const u2 = e => ({
        name: "arrow",
        options: e,
        async fn(t) {
            const {
                element: r,
                padding: n = 0
            } = e || {}, {
                x: i,
                y: s,
                placement: o,
                rects: a,
                platform: l,
                elements: c
            } = t;
            if (r == null) return {};
            const u = _w(n),
                h = {
                    x: i,
                    y: s
                },
                d = Rs(o),
                f = yw(d),
                p = await l.getDimensions(r),
                m = d === "y",
                w = m ? "top" : "left",
                y = m ? "bottom" : "right",
                v = m ? "clientHeight" : "clientWidth",
                _ = a.reference[f] + a.reference[d] - h[d] - a.floating[f],
                E = h[d] - a.reference[d],
                P = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(r));
            let C = P ? P[v] : 0;
            C && await (l.isElement == null ? void 0 : l.isElement(P)) || (C = c.floating[v] || a.floating[f]);
            const T = _ / 2 - E / 2,
                O = u[w],
                k = C - p[f] - u[y],
                D = C / 2 - p[f] / 2 + T,
                B = S_(O, D, k),
                j = yl(o) != null && D != B && a.reference[f] / 2 - (D < O ? u[w] : u[y]) - p[f] / 2 < 0;
            return {
                [d]: h[d] - (j ? D < O ? O - D : k - D : 0),
                data: {
                    [d]: B,
                    centerOffset: D - B
                }
            }
        }
    }),
    dQ = ["top", "right", "bottom", "left"];
dQ.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
const fQ = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};

function ip(e) {
    return e.replace(/left|right|bottom|top/g, t => fQ[t])
}

function pQ(e, t, r) {
    r === void 0 && (r = !1);
    const n = yl(e),
        i = Rs(e),
        s = yw(i);
    let o = i === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
    return t.reference[s] > t.floating[s] && (o = ip(o)), {
        main: o,
        cross: ip(o)
    }
}
const mQ = {
    start: "end",
    end: "start"
};

function h0(e) {
    return e.replace(/start|end/g, t => mQ[t])
}
const g3 = function(e) {
    return e === void 0 && (e = {}), {
        name: "flip",
        options: e,
        async fn(t) {
            var r;
            const {
                placement: n,
                middlewareData: i,
                rects: s,
                initialPlacement: o,
                platform: a,
                elements: l
            } = t, {
                mainAxis: c = !0,
                crossAxis: u = !0,
                fallbackPlacements: h,
                fallbackStrategy: d = "bestFit",
                fallbackAxisSideDirection: f = "none",
                flipAlignment: p = !0,
                ...m
            } = e, w = $n(n), y = $n(o) === o, v = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), _ = h || (y || !p ? [ip(o)] : function(B) {
                const j = ip(B);
                return [h0(B), j, h0(j)]
            }(o));
            h || f === "none" || _.push(... function(B, j, L, M) {
                const W = yl(B);
                let Z = function(q, G, X) {
                    const z = ["left", "right"],
                        Q = ["right", "left"],
                        ie = ["top", "bottom"],
                        _e = ["bottom", "top"];
                    switch (q) {
                        case "top":
                        case "bottom":
                            return X ? G ? Q : z : G ? z : Q;
                        case "left":
                        case "right":
                            return G ? ie : _e;
                        default:
                            return []
                    }
                }($n(B), L === "start", M);
                return W && (Z = Z.map(q => q + "-" + W), j && (Z = Z.concat(Z.map(h0)))), Z
            }(o, p, f, v));
            const E = [o, ..._],
                P = await ww(t, m),
                C = [];
            let T = ((r = i.flip) == null ? void 0 : r.overflows) || [];
            if (c && C.push(P[w]), u) {
                const {
                    main: B,
                    cross: j
                } = pQ(n, s, v);
                C.push(P[B], P[j])
            }
            if (T = [...T, {
                    placement: n,
                    overflows: C
                }], !C.every(B => B <= 0)) {
                var O, k;
                const B = (((O = i.flip) == null ? void 0 : O.index) || 0) + 1,
                    j = E[B];
                if (j) return {
                    data: {
                        index: B,
                        overflows: T
                    },
                    reset: {
                        placement: j
                    }
                };
                let L = (k = T.filter(M => M.overflows[0] <= 0).sort((M, W) => M.overflows[1] - W.overflows[1])[0]) == null ? void 0 : k.placement;
                if (!L) switch (d) {
                    case "bestFit":
                        {
                            var D;
                            const M = (D = T.map(W => [W.placement, W.overflows.filter(Z => Z > 0).reduce((Z, q) => Z + q, 0)]).sort((W, Z) => W[1] - Z[1])[0]) == null ? void 0 : D[0];M && (L = M);
                            break
                        }
                    case "initialPlacement":
                        L = o
                }
                if (n !== L) return {
                    reset: {
                        placement: L
                    }
                }
            }
            return {}
        }
    }
};

function h2(e) {
    const t = sl(...e.map(n => n.left)),
        r = sl(...e.map(n => n.top));
    return {
        x: t,
        y: r,
        width: Kn(...e.map(n => n.right)) - t,
        height: Kn(...e.map(n => n.bottom)) - r
    }
}
const v3 = function(e) {
        return e === void 0 && (e = {}), {
            name: "inline",
            options: e,
            async fn(t) {
                const {
                    placement: r,
                    elements: n,
                    rects: i,
                    platform: s,
                    strategy: o
                } = t, {
                    padding: a = 2,
                    x: l,
                    y: c
                } = e, u = Array.from(await (s.getClientRects == null ? void 0 : s.getClientRects(n.reference)) || []), h = function(m) {
                    const w = m.slice().sort((_, E) => _.y - E.y),
                        y = [];
                    let v = null;
                    for (let _ = 0; _ < w.length; _++) {
                        const E = w[_];
                        !v || E.y - v.y > v.height / 2 ? y.push([E]) : y[y.length - 1].push(E), v = E
                    }
                    return y.map(_ => il(h2(_)))
                }(u), d = il(h2(u)), f = _w(a), p = await s.getElementRects({
                    reference: {
                        getBoundingClientRect: function() {
                            if (h.length === 2 && h[0].left > h[1].right && l != null && c != null) return h.find(m => l > m.left - f.left && l < m.right + f.right && c > m.top - f.top && c < m.bottom + f.bottom) || d;
                            if (h.length >= 2) {
                                if (Rs(r) === "x") {
                                    const P = h[0],
                                        C = h[h.length - 1],
                                        T = $n(r) === "top",
                                        O = P.top,
                                        k = C.bottom,
                                        D = T ? P.left : C.left,
                                        B = T ? P.right : C.right;
                                    return {
                                        top: O,
                                        bottom: k,
                                        left: D,
                                        right: B,
                                        width: B - D,
                                        height: k - O,
                                        x: D,
                                        y: O
                                    }
                                }
                                const m = $n(r) === "left",
                                    w = Kn(...h.map(P => P.right)),
                                    y = sl(...h.map(P => P.left)),
                                    v = h.filter(P => m ? P.left === y : P.right === w),
                                    _ = v[0].top,
                                    E = v[v.length - 1].bottom;
                                return {
                                    top: _,
                                    bottom: E,
                                    left: y,
                                    right: w,
                                    width: w - y,
                                    height: E - _,
                                    x: y,
                                    y: _
                                }
                            }
                            return d
                        }
                    },
                    floating: n.floating,
                    strategy: o
                });
                return i.reference.x !== p.reference.x || i.reference.y !== p.reference.y || i.reference.width !== p.reference.width || i.reference.height !== p.reference.height ? {
                    reset: {
                        rects: p
                    }
                } : {}
            }
        }
    },
    y3 = function(e) {
        return e === void 0 && (e = 0), {
            name: "offset",
            options: e,
            async fn(t) {
                const {
                    x: r,
                    y: n
                } = t, i = await async function(s, o) {
                    const {
                        placement: a,
                        platform: l,
                        elements: c
                    } = s, u = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), h = $n(a), d = yl(a), f = Rs(a) === "x", p = ["left", "top"].includes(h) ? -1 : 1, m = u && f ? -1 : 1, w = typeof o == "function" ? o(s) : o;
                    let {
                        mainAxis: y,
                        crossAxis: v,
                        alignmentAxis: _
                    } = typeof w == "number" ? {
                        mainAxis: w,
                        crossAxis: 0,
                        alignmentAxis: null
                    } : {
                        mainAxis: 0,
                        crossAxis: 0,
                        alignmentAxis: null,
                        ...w
                    };
                    return d && typeof _ == "number" && (v = d === "end" ? -1 * _ : _), f ? {
                        x: v * m,
                        y: y * p
                    } : {
                        x: y * p,
                        y: v * m
                    }
                }(t, e);
                return {
                    x: r + i.x,
                    y: n + i.y,
                    data: i
                }
            }
        }
    };

function _3(e) {
    return e === "x" ? "y" : "x"
}
const bw = function(e) {
        return e === void 0 && (e = {}), {
            name: "shift",
            options: e,
            async fn(t) {
                const {
                    x: r,
                    y: n,
                    placement: i
                } = t, {
                    mainAxis: s = !0,
                    crossAxis: o = !1,
                    limiter: a = {
                        fn: w => {
                            let {
                                x: y,
                                y: v
                            } = w;
                            return {
                                x: y,
                                y: v
                            }
                        }
                    },
                    ...l
                } = e, c = {
                    x: r,
                    y: n
                }, u = await ww(t, l), h = Rs($n(i)), d = _3(h);
                let f = c[h],
                    p = c[d];
                if (s) {
                    const w = h === "y" ? "bottom" : "right";
                    f = S_(f + u[h === "y" ? "top" : "left"], f, f - u[w])
                }
                if (o) {
                    const w = d === "y" ? "bottom" : "right";
                    p = S_(p + u[d === "y" ? "top" : "left"], p, p - u[w])
                }
                const m = a.fn({ ...t,
                    [h]: f,
                    [d]: p
                });
                return { ...m,
                    data: {
                        x: m.x - r,
                        y: m.y - n
                    }
                }
            }
        }
    },
    gQ = function(e) {
        return e === void 0 && (e = {}), {
            options: e,
            fn(t) {
                const {
                    x: r,
                    y: n,
                    placement: i,
                    rects: s,
                    middlewareData: o
                } = t, {
                    offset: a = 0,
                    mainAxis: l = !0,
                    crossAxis: c = !0
                } = e, u = {
                    x: r,
                    y: n
                }, h = Rs(i), d = _3(h);
                let f = u[h],
                    p = u[d];
                const m = typeof a == "function" ? a(t) : a,
                    w = typeof m == "number" ? {
                        mainAxis: m,
                        crossAxis: 0
                    } : {
                        mainAxis: 0,
                        crossAxis: 0,
                        ...m
                    };
                if (l) {
                    const _ = h === "y" ? "height" : "width",
                        E = s.reference[h] - s.floating[_] + w.mainAxis,
                        P = s.reference[h] + s.reference[_] - w.mainAxis;
                    f < E ? f = E : f > P && (f = P)
                }
                if (c) {
                    var y, v;
                    const _ = h === "y" ? "width" : "height",
                        E = ["top", "left"].includes($n(i)),
                        P = s.reference[d] - s.floating[_] + (E && ((y = o.offset) == null ? void 0 : y[d]) || 0) + (E ? 0 : w.crossAxis),
                        C = s.reference[d] + s.reference[_] + (E ? 0 : ((v = o.offset) == null ? void 0 : v[d]) || 0) - (E ? w.crossAxis : 0);
                    p < P ? p = P : p > C && (p = C)
                }
                return {
                    [h]: f,
                    [d]: p
                }
            }
        }
    },
    vQ = function(e) {
        return e === void 0 && (e = {}), {
            name: "size",
            options: e,
            async fn(t) {
                const {
                    placement: r,
                    rects: n,
                    platform: i,
                    elements: s
                } = t, {
                    apply: o = () => {},
                    ...a
                } = e, l = await ww(t, a), c = $n(r), u = yl(r), h = Rs(r) === "x", {
                    width: d,
                    height: f
                } = n.floating;
                let p, m;
                c === "top" || c === "bottom" ? (p = c, m = u === (await (i.isRTL == null ? void 0 : i.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (m = c, p = u === "end" ? "top" : "bottom");
                const w = f - l[p],
                    y = d - l[m],
                    v = !t.middlewareData.shift;
                let _ = w,
                    E = y;
                if (h) {
                    const C = d - l.left - l.right;
                    E = u || v ? sl(y, C) : C
                } else {
                    const C = f - l.top - l.bottom;
                    _ = u || v ? sl(w, C) : C
                }
                if (v && !u) {
                    const C = Kn(l.left, 0),
                        T = Kn(l.right, 0),
                        O = Kn(l.top, 0),
                        k = Kn(l.bottom, 0);
                    h ? E = d - 2 * (C !== 0 || T !== 0 ? C + T : Kn(l.left, l.right)) : _ = f - 2 * (O !== 0 || k !== 0 ? O + k : Kn(l.top, l.bottom))
                }
                await o({ ...t,
                    availableWidth: E,
                    availableHeight: _
                });
                const P = await i.getDimensions(s.floating);
                return d !== P.width || f !== P.height ? {
                    reset: {
                        rects: !0
                    }
                } : {}
            }
        }
    };

function Dr(e) {
    var t;
    return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window
}

function Rn(e) {
    return Dr(e).getComputedStyle(e)
}

function w3(e) {
    return e instanceof Dr(e).Node
}

function Ts(e) {
    return w3(e) ? (e.nodeName || "").toLowerCase() : ""
}
let Yh;

function b3() {
    if (Yh) return Yh;
    const e = navigator.userAgentData;
    return e && Array.isArray(e.brands) ? (Yh = e.brands.map(t => t.brand + "/" + t.version).join(" "), Yh) : navigator.userAgent
}

function Mn(e) {
    return e instanceof Dr(e).HTMLElement
}

function Nr(e) {
    return e instanceof Dr(e).Element
}

function d2(e) {
    return typeof ShadowRoot > "u" ? !1 : e instanceof Dr(e).ShadowRoot || e instanceof ShadowRoot
}

function au(e) {
    const {
        overflow: t,
        overflowX: r,
        overflowY: n,
        display: i
    } = Rn(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + n + r) && !["inline", "contents"].includes(i)
}

function yQ(e) {
    return ["table", "td", "th"].includes(Ts(e))
}

function P_(e) {
    const t = /firefox/i.test(b3()),
        r = Rn(e),
        n = r.backdropFilter || r.WebkitBackdropFilter;
    return r.transform !== "none" || r.perspective !== "none" || !!n && n !== "none" || t && r.willChange === "filter" || t && !!r.filter && r.filter !== "none" || ["transform", "perspective"].some(i => r.willChange.includes(i)) || ["paint", "layout", "strict", "content"].some(i => {
        const s = r.contain;
        return s != null && s.includes(i)
    })
}

function C_() {
    return /^((?!chrome|android).)*safari/i.test(b3())
}

function mg(e) {
    return ["html", "body", "#document"].includes(Ts(e))
}
const f2 = Math.min,
    Oc = Math.max,
    sp = Math.round;

function x3(e) {
    const t = Rn(e);
    let r = parseFloat(t.width),
        n = parseFloat(t.height);
    const i = Mn(e),
        s = i ? e.offsetWidth : r,
        o = i ? e.offsetHeight : n,
        a = sp(r) !== s || sp(n) !== o;
    return a && (r = s, n = o), {
        width: r,
        height: n,
        fallback: a
    }
}

function E3(e) {
    return Nr(e) ? e : e.contextElement
}
const S3 = {
    x: 1,
    y: 1
};

function Ua(e) {
    const t = E3(e);
    if (!Mn(t)) return S3;
    const r = t.getBoundingClientRect(),
        {
            width: n,
            height: i,
            fallback: s
        } = x3(t);
    let o = (s ? sp(r.width) : r.width) / n,
        a = (s ? sp(r.height) : r.height) / i;
    return o && Number.isFinite(o) || (o = 1), a && Number.isFinite(a) || (a = 1), {
        x: o,
        y: a
    }
}

function wo(e, t, r, n) {
    var i, s;
    t === void 0 && (t = !1), r === void 0 && (r = !1);
    const o = e.getBoundingClientRect(),
        a = E3(e);
    let l = S3;
    t && (n ? Nr(n) && (l = Ua(n)) : l = Ua(e));
    const c = a ? Dr(a) : window,
        u = C_() && r;
    let h = (o.left + (u && ((i = c.visualViewport) == null ? void 0 : i.offsetLeft) || 0)) / l.x,
        d = (o.top + (u && ((s = c.visualViewport) == null ? void 0 : s.offsetTop) || 0)) / l.y,
        f = o.width / l.x,
        p = o.height / l.y;
    if (a) {
        const m = Dr(a),
            w = n && Nr(n) ? Dr(n) : n;
        let y = m.frameElement;
        for (; y && n && w !== m;) {
            const v = Ua(y),
                _ = y.getBoundingClientRect(),
                E = getComputedStyle(y);
            _.x += (y.clientLeft + parseFloat(E.paddingLeft)) * v.x, _.y += (y.clientTop + parseFloat(E.paddingTop)) * v.y, h *= v.x, d *= v.y, f *= v.x, p *= v.y, h += _.x, d += _.y, y = Dr(y).frameElement
        }
    }
    return il({
        width: f,
        height: p,
        x: h,
        y: d
    })
}

function _s(e) {
    return ((w3(e) ? e.ownerDocument : e.document) || window.document).documentElement
}

function gg(e) {
    return Nr(e) ? {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    } : {
        scrollLeft: e.pageXOffset,
        scrollTop: e.pageYOffset
    }
}

function P3(e) {
    return wo(_s(e)).left + gg(e).scrollLeft
}

function ol(e) {
    if (Ts(e) === "html") return e;
    const t = e.assignedSlot || e.parentNode || d2(e) && e.host || _s(e);
    return d2(t) ? t.host : t
}

function C3(e) {
    const t = ol(e);
    return mg(t) ? t.ownerDocument.body : Mn(t) && au(t) ? t : C3(t)
}

function Pi(e, t) {
    var r;
    t === void 0 && (t = []);
    const n = C3(e),
        i = n === ((r = e.ownerDocument) == null ? void 0 : r.body),
        s = Dr(n);
    return i ? t.concat(s, s.visualViewport || [], au(n) ? n : []) : t.concat(n, Pi(n))
}

function p2(e, t, r) {
    let n;
    if (t === "viewport") n = function(o, a) {
        const l = Dr(o),
            c = _s(o),
            u = l.visualViewport;
        let h = c.clientWidth,
            d = c.clientHeight,
            f = 0,
            p = 0;
        if (u) {
            h = u.width, d = u.height;
            const m = C_();
            (!m || m && a === "fixed") && (f = u.offsetLeft, p = u.offsetTop)
        }
        return {
            width: h,
            height: d,
            x: f,
            y: p
        }
    }(e, r);
    else if (t === "document") n = function(o) {
        const a = _s(o),
            l = gg(o),
            c = o.ownerDocument.body,
            u = Oc(a.scrollWidth, a.clientWidth, c.scrollWidth, c.clientWidth),
            h = Oc(a.scrollHeight, a.clientHeight, c.scrollHeight, c.clientHeight);
        let d = -l.scrollLeft + P3(o);
        const f = -l.scrollTop;
        return Rn(c).direction === "rtl" && (d += Oc(a.clientWidth, c.clientWidth) - u), {
            width: u,
            height: h,
            x: d,
            y: f
        }
    }(_s(e));
    else if (Nr(t)) n = function(o, a) {
        const l = wo(o, !0, a === "fixed"),
            c = l.top + o.clientTop,
            u = l.left + o.clientLeft,
            h = Mn(o) ? Ua(o) : {
                x: 1,
                y: 1
            };
        return {
            width: o.clientWidth * h.x,
            height: o.clientHeight * h.y,
            x: u * h.x,
            y: c * h.y
        }
    }(t, r);
    else {
        const o = { ...t
        };
        if (C_()) {
            var i, s;
            const a = Dr(e);
            o.x -= ((i = a.visualViewport) == null ? void 0 : i.offsetLeft) || 0, o.y -= ((s = a.visualViewport) == null ? void 0 : s.offsetTop) || 0
        }
        n = o
    }
    return il(n)
}

function T3(e, t) {
    const r = ol(e);
    return !(r === t || !Nr(r) || mg(r)) && (Rn(r).position === "fixed" || T3(r, t))
}

function m2(e, t) {
    return Mn(e) && Rn(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null
}

function g2(e, t) {
    const r = Dr(e);
    if (!Mn(e)) return r;
    let n = m2(e, t);
    for (; n && yQ(n) && Rn(n).position === "static";) n = m2(n, t);
    return n && (Ts(n) === "html" || Ts(n) === "body" && Rn(n).position === "static" && !P_(n)) ? r : n || function(i) {
        let s = ol(i);
        for (; Mn(s) && !mg(s);) {
            if (P_(s)) return s;
            s = ol(s)
        }
        return null
    }(e) || r
}

function _Q(e, t, r) {
    const n = Mn(t),
        i = _s(t),
        s = wo(e, !0, r === "fixed", t);
    let o = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const a = {
        x: 0,
        y: 0
    };
    if (n || !n && r !== "fixed")
        if ((Ts(t) !== "body" || au(i)) && (o = gg(t)), Mn(t)) {
            const l = wo(t, !0);
            a.x = l.x + t.clientLeft, a.y = l.y + t.clientTop
        } else i && (a.x = P3(i));
    return {
        x: s.left + o.scrollLeft - a.x,
        y: s.top + o.scrollTop - a.y,
        width: s.width,
        height: s.height
    }
}
const wQ = {
    getClippingRect: function(e) {
        let {
            element: t,
            boundary: r,
            rootBoundary: n,
            strategy: i
        } = e;
        const s = r === "clippingAncestors" ? function(c, u) {
                const h = u.get(c);
                if (h) return h;
                let d = Pi(c).filter(w => Nr(w) && Ts(w) !== "body"),
                    f = null;
                const p = Rn(c).position === "fixed";
                let m = p ? ol(c) : c;
                for (; Nr(m) && !mg(m);) {
                    const w = Rn(m),
                        y = P_(m);
                    y || w.position !== "fixed" || (f = null), (p ? !y && !f : !y && w.position === "static" && f && ["absolute", "fixed"].includes(f.position) || au(m) && !y && T3(c, m)) ? d = d.filter(v => v !== m) : f = w, m = ol(m)
                }
                return u.set(c, d), d
            }(t, this._c) : [].concat(r),
            o = [...s, n],
            a = o[0],
            l = o.reduce((c, u) => {
                const h = p2(t, u, i);
                return c.top = Oc(h.top, c.top), c.right = f2(h.right, c.right), c.bottom = f2(h.bottom, c.bottom), c.left = Oc(h.left, c.left), c
            }, p2(t, a, i));
        return {
            width: l.right - l.left,
            height: l.bottom - l.top,
            x: l.left,
            y: l.top
        }
    },
    convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
        let {
            rect: t,
            offsetParent: r,
            strategy: n
        } = e;
        const i = Mn(r),
            s = _s(r);
        if (r === s) return t;
        let o = {
                scrollLeft: 0,
                scrollTop: 0
            },
            a = {
                x: 1,
                y: 1
            };
        const l = {
            x: 0,
            y: 0
        };
        if ((i || !i && n !== "fixed") && ((Ts(r) !== "body" || au(s)) && (o = gg(r)), Mn(r))) {
            const c = wo(r);
            a = Ua(r), l.x = c.x + r.clientLeft, l.y = c.y + r.clientTop
        }
        return {
            width: t.width * a.x,
            height: t.height * a.y,
            x: t.x * a.x - o.scrollLeft * a.x + l.x,
            y: t.y * a.y - o.scrollTop * a.y + l.y
        }
    },
    isElement: Nr,
    getDimensions: function(e) {
        return x3(e)
    },
    getOffsetParent: g2,
    getDocumentElement: _s,
    getScale: Ua,
    async getElementRects(e) {
        let {
            reference: t,
            floating: r,
            strategy: n
        } = e;
        const i = this.getOffsetParent || g2,
            s = this.getDimensions;
        return {
            reference: _Q(t, await i(r), n),
            floating: {
                x: 0,
                y: 0,
                ...await s(r)
            }
        }
    },
    getClientRects: e => Array.from(e.getClientRects()),
    isRTL: e => Rn(e).direction === "rtl"
};

function bQ(e, t, r, n) {
    n === void 0 && (n = {});
    const {
        ancestorScroll: i = !0,
        ancestorResize: s = !0,
        elementResize: o = !0,
        animationFrame: a = !1
    } = n, l = i || s ? [...Nr(e) ? Pi(e) : e.contextElement ? Pi(e.contextElement) : [], ...Pi(t)] : [];
    l.forEach(d => {
        const f = !Nr(d) && d.toString().includes("V");
        !i || a && !f || d.addEventListener("scroll", r, {
            passive: !0
        }), s && d.addEventListener("resize", r)
    });
    let c, u = null;
    o && (u = new ResizeObserver(() => {
        r()
    }), Nr(e) && !a && u.observe(e), Nr(e) || !e.contextElement || a || u.observe(e.contextElement), u.observe(t));
    let h = a ? wo(e) : null;
    return a && function d() {
        const f = wo(e);
        !h || f.x === h.x && f.y === h.y && f.width === h.width && f.height === h.height || r(), h = f, c = requestAnimationFrame(d)
    }(), r(), () => {
        var d;
        l.forEach(f => {
            i && f.removeEventListener("scroll", r), s && f.removeEventListener("resize", r)
        }), (d = u) == null || d.disconnect(), u = null, a && cancelAnimationFrame(c)
    }
}
const xQ = (e, t, r) => {
        const n = new Map,
            i = {
                platform: wQ,
                ...r
            },
            s = { ...i.platform,
                _c: n
            };
        return hQ(e, t, { ...i,
            platform: s
        })
    },
    O3 = e => {
        const {
            element: t,
            padding: r
        } = e;

        function n(i) {
            return Object.prototype.hasOwnProperty.call(i, "current")
        }
        return {
            name: "arrow",
            options: e,
            fn(i) {
                return n(t) ? t.current != null ? u2({
                    element: t.current,
                    padding: r
                }).fn(i) : {} : t ? u2({
                    element: t,
                    padding: r
                }).fn(i) : {}
            }
        }
    };
var Md = typeof document < "u" ? b.useLayoutEffect : b.useEffect;

function op(e, t) {
    if (e === t) return !0;
    if (typeof e != typeof t) return !1;
    if (typeof e == "function" && e.toString() === t.toString()) return !0;
    let r, n, i;
    if (e && t && typeof e == "object") {
        if (Array.isArray(e)) {
            if (r = e.length, r != t.length) return !1;
            for (n = r; n-- !== 0;)
                if (!op(e[n], t[n])) return !1;
            return !0
        }
        if (i = Object.keys(e), r = i.length, r !== Object.keys(t).length) return !1;
        for (n = r; n-- !== 0;)
            if (!Object.prototype.hasOwnProperty.call(t, i[n])) return !1;
        for (n = r; n-- !== 0;) {
            const s = i[n];
            if (!(s === "_owner" && e.$$typeof) && !op(e[s], t[s])) return !1
        }
        return !0
    }
    return e !== e && t !== t
}

function v2(e) {
    const t = b.useRef(e);
    return Md(() => {
        t.current = e
    }), t
}

function EQ(e) {
    e === void 0 && (e = {});
    const {
        placement: t = "bottom",
        strategy: r = "absolute",
        middleware: n = [],
        platform: i,
        whileElementsMounted: s,
        open: o
    } = e, [a, l] = b.useState({
        x: null,
        y: null,
        strategy: r,
        placement: t,
        middlewareData: {},
        isPositioned: !1
    }), [c, u] = b.useState(n);
    op(c, n) || u(n);
    const h = b.useRef(null),
        d = b.useRef(null),
        f = b.useRef(a),
        p = v2(s),
        m = v2(i),
        [w, y] = b.useState(null),
        [v, _] = b.useState(null),
        E = b.useCallback(D => {
            h.current !== D && (h.current = D, y(D))
        }, []),
        P = b.useCallback(D => {
            d.current !== D && (d.current = D, _(D))
        }, []),
        C = b.useCallback(() => {
            if (!h.current || !d.current) return;
            const D = {
                placement: t,
                strategy: r,
                middleware: c
            };
            m.current && (D.platform = m.current), xQ(h.current, d.current, D).then(B => {
                const j = { ...B,
                    isPositioned: !0
                };
                T.current && !op(f.current, j) && (f.current = j, Ci.flushSync(() => {
                    l(j)
                }))
            })
        }, [c, t, r, m]);
    Md(() => {
        o === !1 && f.current.isPositioned && (f.current.isPositioned = !1, l(D => ({ ...D,
            isPositioned: !1
        })))
    }, [o]);
    const T = b.useRef(!1);
    Md(() => (T.current = !0, () => {
        T.current = !1
    }), []), Md(() => {
        if (w && v) {
            if (p.current) return p.current(w, v, C);
            C()
        }
    }, [w, v, C, p]);
    const O = b.useMemo(() => ({
            reference: h,
            floating: d,
            setReference: E,
            setFloating: P
        }), [E, P]),
        k = b.useMemo(() => ({
            reference: w,
            floating: v
        }), [w, v]);
    return b.useMemo(() => ({ ...a,
        update: C,
        refs: O,
        elements: k,
        reference: E,
        floating: P
    }), [a, C, O, k, E, P])
}
var al = typeof document < "u" ? b.useLayoutEffect : b.useEffect;
let d0 = !1,
    SQ = 0;
const y2 = () => "floating-ui-" + SQ++;

function PQ() {
    const [e, t] = b.useState(() => d0 ? y2() : void 0);
    return al(() => {
        e == null && t(y2())
    }, []), b.useEffect(() => {
        d0 || (d0 = !0)
    }, []), e
}
const CQ = Hd["useId".toString()],
    _2 = CQ || PQ;

function TQ() {
    const e = new Map;
    return {
        emit(t, r) {
            var n;
            (n = e.get(t)) == null || n.forEach(i => i(r))
        },
        on(t, r) {
            e.set(t, [...e.get(t) || [], r])
        },
        off(t, r) {
            e.set(t, (e.get(t) || []).filter(n => n !== r))
        }
    }
}
const OQ = b.createContext(null),
    AQ = b.createContext(null),
    A3 = () => {
        var e;
        return ((e = b.useContext(OQ)) == null ? void 0 : e.id) || null
    },
    xw = () => b.useContext(AQ);

function os(e) {
    return (e == null ? void 0 : e.ownerDocument) || document
}

function IQ() {
    const e = navigator.userAgentData;
    return e != null && e.platform ? e.platform : navigator.platform
}

function $Q() {
    const e = navigator.userAgentData;
    return e && Array.isArray(e.brands) ? e.brands.map(t => {
        let {
            brand: r,
            version: n
        } = t;
        return r + "/" + n
    }).join(" ") : navigator.userAgent
}

function Ew(e) {
    return os(e).defaultView || window
}

function Jn(e) {
    return e ? e instanceof Ew(e).Element : !1
}

function I3(e) {
    return e ? e instanceof Ew(e).HTMLElement : !1
}

function RQ(e) {
    if (typeof ShadowRoot > "u") return !1;
    const t = Ew(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot
}

function kQ(e) {
    if (e.mozInputSource === 0 && e.isTrusted) return !0;
    const t = /Android/i;
    return (t.test(IQ()) || t.test($Q())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType
}

function MQ(e) {
    return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0
}

function $3(e, t) {
    const r = ["mouse", "pen"];
    return t || r.push("", void 0), r.includes(e)
}

function w2(e) {
    const t = b.useRef(e);
    return al(() => {
        t.current = e
    }), t
}
const b2 = "data-floating-ui-safe-polygon";

function Dd(e, t, r) {
    return r && !$3(r) ? 0 : typeof e == "number" ? e : e == null ? void 0 : e[t]
}
const DQ = function(e, t) {
        let {
            enabled: r = !0,
            delay: n = 0,
            handleClose: i = null,
            mouseOnly: s = !1,
            restMs: o = 0,
            move: a = !0
        } = t === void 0 ? {} : t;
        const {
            open: l,
            onOpenChange: c,
            dataRef: u,
            events: h,
            elements: {
                domReference: d,
                floating: f
            },
            refs: p
        } = e, m = xw(), w = A3(), y = w2(i), v = w2(n), _ = b.useRef(), E = b.useRef(), P = b.useRef(), C = b.useRef(), T = b.useRef(!0), O = b.useRef(!1), k = b.useRef(() => {}), D = b.useCallback(() => {
            var M;
            const W = (M = u.current.openEvent) == null ? void 0 : M.type;
            return (W == null ? void 0 : W.includes("mouse")) && W !== "mousedown"
        }, [u]);
        b.useEffect(() => {
            if (!r) return;

            function M() {
                clearTimeout(E.current), clearTimeout(C.current), T.current = !0
            }
            return h.on("dismiss", M), () => {
                h.off("dismiss", M)
            }
        }, [r, h]), b.useEffect(() => {
            if (!r || !y.current || !l) return;

            function M() {
                D() && c(!1)
            }
            const W = os(f).documentElement;
            return W.addEventListener("mouseleave", M), () => {
                W.removeEventListener("mouseleave", M)
            }
        }, [f, l, c, r, y, u, D]);
        const B = b.useCallback(function(M) {
                M === void 0 && (M = !0);
                const W = Dd(v.current, "close", _.current);
                W && !P.current ? (clearTimeout(E.current), E.current = setTimeout(() => c(!1), W)) : M && (clearTimeout(E.current), c(!1))
            }, [v, c]),
            j = b.useCallback(() => {
                k.current(), P.current = void 0
            }, []),
            L = b.useCallback(() => {
                if (O.current) {
                    const M = os(p.floating.current).body;
                    M.style.pointerEvents = "", M.removeAttribute(b2), O.current = !1
                }
            }, [p]);
        return b.useEffect(() => {
            if (!r) return;

            function M() {
                return u.current.openEvent ? ["click", "mousedown"].includes(u.current.openEvent.type) : !1
            }

            function W(G) {
                if (clearTimeout(E.current), T.current = !1, s && !$3(_.current) || o > 0 && Dd(v.current, "open") === 0) return;
                u.current.openEvent = G;
                const X = Dd(v.current, "open", _.current);
                X ? E.current = setTimeout(() => {
                    c(!0)
                }, X) : c(!0)
            }

            function Z(G) {
                if (M()) return;
                k.current();
                const X = os(f);
                if (clearTimeout(C.current), y.current) {
                    l || clearTimeout(E.current), P.current = y.current({ ...e,
                        tree: m,
                        x: G.clientX,
                        y: G.clientY,
                        onClose() {
                            L(), j(), B()
                        }
                    });
                    const z = P.current;
                    X.addEventListener("mousemove", z), k.current = () => {
                        X.removeEventListener("mousemove", z)
                    };
                    return
                }
                B()
            }

            function q(G) {
                M() || y.current == null || y.current({ ...e,
                    tree: m,
                    x: G.clientX,
                    y: G.clientY,
                    onClose() {
                        L(), j(), B()
                    }
                })(G)
            }
            if (Jn(d)) {
                const G = d;
                return l && G.addEventListener("mouseleave", q), f == null || f.addEventListener("mouseleave", q), a && G.addEventListener("mousemove", W, {
                    once: !0
                }), G.addEventListener("mouseenter", W), G.addEventListener("mouseleave", Z), () => {
                    l && G.removeEventListener("mouseleave", q), f == null || f.removeEventListener("mouseleave", q), a && G.removeEventListener("mousemove", W), G.removeEventListener("mouseenter", W), G.removeEventListener("mouseleave", Z)
                }
            }
        }, [d, f, r, e, s, o, a, B, j, L, c, l, m, v, y, u]), al(() => {
            var M;
            if (r && l && (M = y.current) != null && M.__options.blockPointerEvents && D()) {
                const q = os(f).body;
                if (q.setAttribute(b2, ""), q.style.pointerEvents = "none", O.current = !0, Jn(d) && f) {
                    var W, Z;
                    const G = d,
                        X = m == null || (W = m.nodesRef.current.find(z => z.id === w)) == null || (Z = W.context) == null ? void 0 : Z.elements.floating;
                    return X && (X.style.pointerEvents = ""), G.style.pointerEvents = "auto", f.style.pointerEvents = "auto", () => {
                        G.style.pointerEvents = "", f.style.pointerEvents = ""
                    }
                }
            }
        }, [r, l, w, f, d, m, y, u, D]), al(() => {
            l || (_.current = void 0, j(), L())
        }, [l, j, L]), b.useEffect(() => () => {
            j(), clearTimeout(E.current), clearTimeout(C.current), L()
        }, [r, j, L]), b.useMemo(() => {
            if (!r) return {};

            function M(W) {
                _.current = W.pointerType
            }
            return {
                reference: {
                    onPointerDown: M,
                    onPointerEnter: M,
                    onMouseMove() {
                        l || o === 0 || (clearTimeout(C.current), C.current = setTimeout(() => {
                            T.current || c(!0)
                        }, o))
                    }
                },
                floating: {
                    onMouseEnter() {
                        clearTimeout(E.current)
                    },
                    onMouseLeave() {
                        h.emit("dismiss", {
                            type: "mouseLeave",
                            data: {
                                returnFocus: !1
                            }
                        }), B(!1)
                    }
                }
            }
        }, [h, r, o, l, c, B])
    },
    R3 = b.createContext({
        delay: 0,
        initialDelay: 0,
        timeoutMs: 0,
        currentId: null,
        setCurrentId: () => {},
        setState: () => {},
        isInstantPhase: !1
    }),
    k3 = () => b.useContext(R3),
    NQ = e => {
        let {
            children: t,
            delay: r,
            timeoutMs: n = 0
        } = e;
        const [i, s] = b.useReducer((l, c) => ({ ...l,
            ...c
        }), {
            delay: r,
            timeoutMs: n,
            initialDelay: r,
            currentId: null,
            isInstantPhase: !1
        }), o = b.useRef(null), a = b.useCallback(l => {
            s({
                currentId: l
            })
        }, []);
        return al(() => {
            i.currentId ? o.current === null ? o.current = i.currentId : s({
                isInstantPhase: !0
            }) : (s({
                isInstantPhase: !1
            }), o.current = null)
        }, [i.currentId]), b.createElement(R3.Provider, {
            value: b.useMemo(() => ({ ...i,
                setState: s,
                setCurrentId: a
            }), [i, s, a])
        }, t)
    },
    LQ = (e, t) => {
        let {
            open: r,
            onOpenChange: n
        } = e, {
            id: i
        } = t;
        const {
            currentId: s,
            setCurrentId: o,
            initialDelay: a,
            setState: l,
            timeoutMs: c
        } = k3();
        b.useEffect(() => {
            s && (l({
                delay: {
                    open: 1,
                    close: Dd(a, "close")
                }
            }), s !== i && n(!1))
        }, [i, n, l, s, a]), b.useEffect(() => {
            function u() {
                n(!1), l({
                    delay: a,
                    currentId: null
                })
            }
            if (!r && s === i)
                if (c) {
                    const h = window.setTimeout(u, c);
                    return () => {
                        clearTimeout(h)
                    }
                } else u()
        }, [r, l, s, i, n, a, c]), b.useEffect(() => {
            r && o(i)
        }, [r, o, i])
    };

function FQ(e) {
    let t = e.activeElement;
    for (;
        ((r = t) == null || (n = r.shadowRoot) == null ? void 0 : n.activeElement) != null;) {
        var r, n;
        t = t.shadowRoot.activeElement
    }
    return t
}

function x2(e, t) {
    if (!e || !t) return !1;
    const r = t.getRootNode && t.getRootNode();
    if (e.contains(t)) return !0;
    if (r && RQ(r)) {
        let n = t;
        do {
            if (n && e === n) return !0;
            n = n.parentNode || n.host
        } while (n)
    }
    return !1
}

function f0(e, t) {
    let r = e.filter(i => {
            var s;
            return i.parentId === t && ((s = i.context) == null ? void 0 : s.open)
        }) || [],
        n = r;
    for (; n.length;) n = e.filter(i => {
        var s;
        return (s = n) == null ? void 0 : s.some(o => {
            var a;
            return i.parentId === o.id && ((a = i.context) == null ? void 0 : a.open)
        })
    }) || [], r = r.concat(n);
    return r
}

function BQ(e) {
    return "composedPath" in e ? e.composedPath()[0] : e.target
}
const zQ = Hd["useInsertionEffect".toString()],
    jQ = zQ || (e => e());

function M3(e) {
    const t = b.useRef(() => {});
    return jQ(() => {
        t.current = e
    }), b.useCallback(function() {
        for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
        return t.current == null ? void 0 : t.current(...n)
    }, [])
}

function Nd(e, t) {
    if (t == null) return !1;
    if ("composedPath" in e) return e.composedPath().includes(t);
    const r = e;
    return r.target != null && t.contains(r.target)
}
const UQ = {
        pointerdown: "onPointerDown",
        mousedown: "onMouseDown",
        click: "onClick"
    },
    HQ = {
        pointerdown: "onPointerDownCapture",
        mousedown: "onMouseDownCapture",
        click: "onClickCapture"
    },
    GQ = function(e) {
        var t, r;
        return e === void 0 && (e = !0), {
            escapeKeyBubbles: typeof e == "boolean" ? e : (t = e.escapeKey) != null ? t : !0,
            outsidePressBubbles: typeof e == "boolean" ? e : (r = e.outsidePress) != null ? r : !0
        }
    },
    VQ = function(e, t) {
        let {
            open: r,
            onOpenChange: n,
            events: i,
            nodeId: s,
            elements: {
                reference: o,
                domReference: a,
                floating: l
            },
            dataRef: c
        } = e, {
            enabled: u = !0,
            escapeKey: h = !0,
            outsidePress: d = !0,
            outsidePressEvent: f = "pointerdown",
            referencePress: p = !1,
            referencePressEvent: m = "pointerdown",
            ancestorScroll: w = !1,
            bubbles: y = !0
        } = t === void 0 ? {} : t;
        const v = xw(),
            _ = A3() != null,
            E = M3(typeof d == "function" ? d : () => !1),
            P = typeof d == "function" ? E : d,
            C = b.useRef(!1),
            {
                escapeKeyBubbles: T,
                outsidePressBubbles: O
            } = GQ(y);
        return b.useEffect(() => {
            if (!r || !u) return;
            c.current.__escapeKeyBubbles = T, c.current.__outsidePressBubbles = O;

            function k(M) {
                if (M.key === "Escape") {
                    const W = v ? f0(v.nodesRef.current, s) : [];
                    if (W.length > 0) {
                        let Z = !0;
                        if (W.forEach(q => {
                                var G;
                                if ((G = q.context) != null && G.open && !q.context.dataRef.current.__escapeKeyBubbles) {
                                    Z = !1;
                                    return
                                }
                            }), !Z) return
                    }
                    i.emit("dismiss", {
                        type: "escapeKey",
                        data: {
                            returnFocus: {
                                preventScroll: !1
                            }
                        }
                    }), n(!1)
                }
            }

            function D(M) {
                const W = C.current;
                if (C.current = !1, W || typeof P == "function" && !P(M)) return;
                const Z = BQ(M);
                if (I3(Z) && l) {
                    const X = l.ownerDocument.defaultView || window,
                        z = Z.scrollWidth > Z.clientWidth,
                        Q = Z.scrollHeight > Z.clientHeight;
                    let ie = Q && M.offsetX > Z.clientWidth;
                    if (Q && X.getComputedStyle(Z).direction === "rtl" && (ie = M.offsetX <= Z.offsetWidth - Z.clientWidth), ie || z && M.offsetY > Z.clientHeight) return
                }
                const q = v && f0(v.nodesRef.current, s).some(X => {
                    var z;
                    return Nd(M, (z = X.context) == null ? void 0 : z.elements.floating)
                });
                if (Nd(M, l) || Nd(M, a) || q) return;
                const G = v ? f0(v.nodesRef.current, s) : [];
                if (G.length > 0) {
                    let X = !0;
                    if (G.forEach(z => {
                            var Q;
                            if ((Q = z.context) != null && Q.open && !z.context.dataRef.current.__outsidePressBubbles) {
                                X = !1;
                                return
                            }
                        }), !X) return
                }
                i.emit("dismiss", {
                    type: "outsidePress",
                    data: {
                        returnFocus: _ ? {
                            preventScroll: !0
                        } : kQ(M) || MQ(M)
                    }
                }), n(!1)
            }

            function B() {
                n(!1)
            }
            const j = os(l);
            h && j.addEventListener("keydown", k), P && j.addEventListener(f, D);
            let L = [];
            return w && (Jn(a) && (L = Pi(a)), Jn(l) && (L = L.concat(Pi(l))), !Jn(o) && o && o.contextElement && (L = L.concat(Pi(o.contextElement)))), L = L.filter(M => {
                var W;
                return M !== ((W = j.defaultView) == null ? void 0 : W.visualViewport)
            }), L.forEach(M => {
                M.addEventListener("scroll", B, {
                    passive: !0
                })
            }), () => {
                h && j.removeEventListener("keydown", k), P && j.removeEventListener(f, D), L.forEach(M => {
                    M.removeEventListener("scroll", B)
                })
            }
        }, [c, l, a, o, h, P, f, i, v, s, r, n, w, u, T, O, _]), b.useEffect(() => {
            C.current = !1
        }, [P, f]), b.useMemo(() => u ? {
            reference: {
                [UQ[m]]: () => {
                    p && (i.emit("dismiss", {
                        type: "referencePress",
                        data: {
                            returnFocus: !1
                        }
                    }), n(!1))
                }
            },
            floating: {
                [HQ[f]]: () => {
                    C.current = !0
                }
            }
        } : {}, [u, i, p, f, m, n])
    },
    WQ = function(e, t) {
        let {
            open: r,
            onOpenChange: n,
            dataRef: i,
            events: s,
            refs: o,
            elements: {
                floating: a,
                domReference: l
            }
        } = e, {
            enabled: c = !0,
            keyboardOnly: u = !0
        } = t === void 0 ? {} : t;
        const h = b.useRef(""),
            d = b.useRef(!1),
            f = b.useRef();
        return b.useEffect(() => {
            if (!c) return;
            const m = os(a).defaultView || window;

            function w() {
                !r && I3(l) && l === FQ(os(l)) && (d.current = !0)
            }
            return m.addEventListener("blur", w), () => {
                m.removeEventListener("blur", w)
            }
        }, [a, l, r, c]), b.useEffect(() => {
            if (!c) return;

            function p(m) {
                (m.type === "referencePress" || m.type === "escapeKey") && (d.current = !0)
            }
            return s.on("dismiss", p), () => {
                s.off("dismiss", p)
            }
        }, [s, c]), b.useEffect(() => () => {
            clearTimeout(f.current)
        }, []), b.useMemo(() => c ? {
            reference: {
                onPointerDown(p) {
                    let {
                        pointerType: m
                    } = p;
                    h.current = m, d.current = !!(m && u)
                },
                onMouseLeave() {
                    d.current = !1
                },
                onFocus(p) {
                    var m;
                    d.current || p.type === "focus" && ((m = i.current.openEvent) == null ? void 0 : m.type) === "mousedown" && i.current.openEvent && Nd(i.current.openEvent, l) || (i.current.openEvent = p.nativeEvent, n(!0))
                },
                onBlur(p) {
                    d.current = !1;
                    const m = p.relatedTarget,
                        w = Jn(m) && m.hasAttribute("data-floating-ui-focus-guard") && m.getAttribute("data-type") === "outside";
                    f.current = setTimeout(() => {
                        x2(o.floating.current, m) || x2(l, m) || w || n(!1)
                    })
                }
            }
        } : {}, [c, u, l, o, i, n])
    },
    XQ = function(e, t) {
        let {
            open: r
        } = e, {
            enabled: n = !0,
            role: i = "dialog"
        } = t === void 0 ? {} : t;
        const s = _2(),
            o = _2();
        return b.useMemo(() => {
            const a = {
                id: s,
                role: i
            };
            return n ? i === "tooltip" ? {
                reference: {
                    "aria-describedby": r ? s : void 0
                },
                floating: a
            } : {
                reference: {
                    "aria-expanded": r ? "true" : "false",
                    "aria-haspopup": i === "alertdialog" ? "dialog" : i,
                    "aria-controls": r ? s : void 0,
                    ...i === "listbox" && {
                        role: "combobox"
                    },
                    ...i === "menu" && {
                        id: o
                    }
                },
                floating: { ...a,
                    ...i === "menu" && {
                        "aria-labelledby": o
                    }
                }
            } : {}
        }, [n, i, r, s, o])
    };

function Sw(e) {
    e === void 0 && (e = {});
    const {
        open: t = !1,
        onOpenChange: r,
        nodeId: n
    } = e, i = EQ(e), s = xw(), o = b.useRef(null), a = b.useRef({}), l = b.useState(() => TQ())[0], [c, u] = b.useState(null), h = b.useCallback(y => {
        const v = Jn(y) ? {
            getBoundingClientRect: () => y.getBoundingClientRect(),
            contextElement: y
        } : y;
        i.refs.setReference(v)
    }, [i.refs]), d = b.useCallback(y => {
        (Jn(y) || y === null) && (o.current = y, u(y)), (Jn(i.refs.reference.current) || i.refs.reference.current === null || y !== null && !Jn(y)) && i.refs.setReference(y)
    }, [i.refs]), f = b.useMemo(() => ({ ...i.refs,
        setReference: d,
        setPositionReference: h,
        domReference: o
    }), [i.refs, d, h]), p = b.useMemo(() => ({ ...i.elements,
        domReference: c
    }), [i.elements, c]), m = M3(r), w = b.useMemo(() => ({ ...i,
        refs: f,
        elements: p,
        dataRef: a,
        nodeId: n,
        events: l,
        open: t,
        onOpenChange: m
    }), [i, n, l, t, m, f, p]);
    return al(() => {
        const y = s == null ? void 0 : s.nodesRef.current.find(v => v.id === n);
        y && (y.context = w)
    }), b.useMemo(() => ({ ...i,
        context: w,
        refs: f,
        reference: d,
        positionReference: h
    }), [i, f, w, d, h])
}

function p0(e, t, r) {
    const n = new Map;
    return { ...r === "floating" && {
            tabIndex: -1
        },
        ...e,
        ...t.map(i => i ? i[r] : null).concat(e).reduce((i, s) => (s && Object.entries(s).forEach(o => {
            let [a, l] = o;
            if (a.indexOf("on") === 0) {
                if (n.has(a) || n.set(a, []), typeof l == "function") {
                    var c;
                    (c = n.get(a)) == null || c.push(l), i[a] = function() {
                        for (var u, h = arguments.length, d = new Array(h), f = 0; f < h; f++) d[f] = arguments[f];
                        (u = n.get(a)) == null || u.forEach(p => p(...d))
                    }
                }
            } else i[a] = l
        }), i), {})
    }
}
const YQ = function(e) {
    e === void 0 && (e = []);
    const t = e,
        r = b.useCallback(s => p0(s, e, "reference"), t),
        n = b.useCallback(s => p0(s, e, "floating"), t),
        i = b.useCallback(s => p0(s, e, "item"), e.map(s => s == null ? void 0 : s.item));
    return b.useMemo(() => ({
        getReferenceProps: r,
        getFloatingProps: n,
        getItemProps: i
    }), [r, n, i])
};

function D3({
    opened: e,
    floating: t,
    position: r,
    positionDependencies: n
}) {
    const [i, s] = b.useState(0);
    b.useEffect(() => {
        if (t.refs.reference.current && t.refs.floating.current) return bQ(t.refs.reference.current, t.refs.floating.current, t.update)
    }, [t.refs.reference.current, t.refs.floating.current, e, i, r]), sn(() => {
        t.update()
    }, n), sn(() => {
        s(o => o + 1)
    }, [e])
}

function KQ(e) {
    const t = [y3(e.offset)];
    return e.middlewares.shift && t.push(bw({
        limiter: gQ()
    })), e.middlewares.flip && t.push(g3()), e.middlewares.inline && t.push(v3()), t.push(O3({
        element: e.arrowRef,
        padding: e.arrowOffset
    })), t
}

function qQ(e) {
    const [t, r] = Au({
        value: e.opened,
        defaultValue: e.defaultOpened,
        finalValue: !1,
        onChange: e.onChange
    }), n = () => {
        var o;
        (o = e.onClose) == null || o.call(e), r(!1)
    }, i = () => {
        var o, a;
        t ? ((o = e.onClose) == null || o.call(e), r(!1)) : ((a = e.onOpen) == null || a.call(e), r(!0))
    }, s = Sw({
        placement: e.position,
        middleware: [...KQ(e), ...e.width === "target" ? [vQ({
            apply({
                rects: o
            }) {
                var a, l;
                Object.assign((l = (a = s.refs.floating.current) == null ? void 0 : a.style) != null ? l : {}, {
                    width: `${o.reference.width}px`
                })
            }
        })] : []]
    });
    return D3({
        opened: e.opened,
        position: e.position,
        positionDependencies: e.positionDependencies,
        floating: s
    }), sn(() => {
        var o;
        (o = e.onPositionChange) == null || o.call(e, s.placement)
    }, [s.placement]), sn(() => {
        var o, a;
        e.opened ? (a = e.onOpen) == null || a.call(e) : (o = e.onClose) == null || o.call(e)
    }, [e.opened]), {
        floating: s,
        controlled: typeof e.opened == "boolean",
        opened: t,
        onClose: n,
        onToggle: i
    }
}
const N3 = {
        context: "Popover component was not found in the tree",
        children: "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    },
    [QQ, L3] = ml(N3.context);
var ZQ = Object.defineProperty,
    JQ = Object.defineProperties,
    eZ = Object.getOwnPropertyDescriptors,
    ap = Object.getOwnPropertySymbols,
    F3 = Object.prototype.hasOwnProperty,
    B3 = Object.prototype.propertyIsEnumerable,
    E2 = (e, t, r) => t in e ? ZQ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Kh = (e, t) => {
        for (var r in t || (t = {})) F3.call(t, r) && E2(e, r, t[r]);
        if (ap)
            for (var r of ap(t)) B3.call(t, r) && E2(e, r, t[r]);
        return e
    },
    tZ = (e, t) => JQ(e, eZ(t)),
    rZ = (e, t) => {
        var r = {};
        for (var n in e) F3.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && ap)
            for (var n of ap(e)) t.indexOf(n) < 0 && B3.call(e, n) && (r[n] = e[n]);
        return r
    };
const nZ = {
        refProp: "ref",
        popupType: "dialog"
    },
    z3 = b.forwardRef((e, t) => {
        const r = ve("PopoverTarget", nZ, e),
            {
                children: n,
                refProp: i,
                popupType: s
            } = r,
            o = rZ(r, ["children", "refProp", "popupType"]);
        if (!Pu(n)) throw new Error(N3.children);
        const a = o,
            l = L3(),
            c = Oo(l.reference, n.ref, t),
            u = l.withRoles ? {
                "aria-haspopup": s,
                "aria-expanded": l.opened,
                "aria-controls": l.getDropdownId(),
                id: l.getTargetId()
            } : {};
        return b.cloneElement(n, Kh(tZ(Kh(Kh(Kh({}, a), u), l.targetProps), {
            className: xR(l.targetProps.className, a.className, n.props.className),
            [i]: c
        }), l.controlled ? null : {
            onClick: l.onToggle
        }))
    });
z3.displayName = "@mantine/core/PopoverTarget";
var iZ = Pe((e, {
    radius: t,
    shadow: r
}) => ({
    dropdown: {
        position: "absolute",
        backgroundColor: e.white,
        background: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
        border: `${R(1)} solid ${e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[2]}`,
        padding: `${e.spacing.sm} ${e.spacing.md}`,
        boxShadow: e.shadows[r] || r || "none",
        borderRadius: e.fn.radius(t),
        "&:focus": {
            outline: 0
        }
    },
    arrow: {
        backgroundColor: "inherit",
        border: `${R(1)} solid ${e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[2]}`,
        zIndex: 1
    }
}));
const sZ = iZ;
var oZ = Object.defineProperty,
    S2 = Object.getOwnPropertySymbols,
    aZ = Object.prototype.hasOwnProperty,
    lZ = Object.prototype.propertyIsEnumerable,
    P2 = (e, t, r) => t in e ? oZ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Jo = (e, t) => {
        for (var r in t || (t = {})) aZ.call(t, r) && P2(e, r, t[r]);
        if (S2)
            for (var r of S2(t)) lZ.call(t, r) && P2(e, r, t[r]);
        return e
    };
const C2 = {
    entering: "in",
    entered: "in",
    exiting: "out",
    exited: "out",
    "pre-exiting": "out",
    "pre-entering": "out"
};

function cZ({
    transition: e,
    state: t,
    duration: r,
    timingFunction: n
}) {
    const i = {
        transitionDuration: `${r}ms`,
        transitionTimingFunction: n
    };
    return typeof e == "string" ? e in Bh ? Jo(Jo(Jo({
        transitionProperty: Bh[e].transitionProperty
    }, i), Bh[e].common), Bh[e][C2[t]]) : null : Jo(Jo(Jo({
        transitionProperty: e.transitionProperty
    }, i), e.common), e[C2[t]])
}

function uZ({
    duration: e,
    exitDuration: t,
    timingFunction: r,
    mounted: n,
    onEnter: i,
    onExit: s,
    onEntered: o,
    onExited: a
}) {
    const l = yr(),
        c = lg(),
        u = l.respectReducedMotion ? c : !1,
        [h, d] = b.useState(u ? 0 : e),
        [f, p] = b.useState(n ? "entered" : "exited"),
        m = b.useRef(-1),
        w = y => {
            const v = y ? i : s,
                _ = y ? o : a;
            p(y ? "pre-entering" : "pre-exiting"), window.clearTimeout(m.current);
            const E = u ? 0 : y ? e : t;
            if (d(E), E === 0) typeof v == "function" && v(), typeof _ == "function" && _(), p(y ? "entered" : "exited");
            else {
                const P = window.setTimeout(() => {
                    typeof v == "function" && v(), p(y ? "entering" : "exiting")
                }, 10);
                m.current = window.setTimeout(() => {
                    window.clearTimeout(P), typeof _ == "function" && _(), p(y ? "entered" : "exited")
                }, E)
            }
        };
    return sn(() => {
        w(n)
    }, [n]), b.useEffect(() => () => window.clearTimeout(m.current), []), {
        transitionDuration: h,
        transitionStatus: f,
        transitionTimingFunction: r || l.transitionTimingFunction
    }
}

function _l({
    keepMounted: e,
    transition: t,
    duration: r = 250,
    exitDuration: n = r,
    mounted: i,
    children: s,
    timingFunction: o,
    onExit: a,
    onEntered: l,
    onEnter: c,
    onExited: u
}) {
    const {
        transitionDuration: h,
        transitionStatus: d,
        transitionTimingFunction: f
    } = uZ({
        mounted: i,
        exitDuration: n,
        duration: r,
        timingFunction: o,
        onExit: a,
        onEntered: l,
        onEnter: c,
        onExited: u
    });
    return h === 0 ? i ? I.createElement(I.Fragment, null, s({})) : e ? s({
        display: "none"
    }) : null : d === "exited" ? e ? s({
        display: "none"
    }) : null : I.createElement(I.Fragment, null, s(cZ({
        transition: t,
        duration: h,
        state: d,
        timingFunction: f
    })))
}
_l.displayName = "@mantine/core/Transition";

function Pw({
    children: e,
    active: t = !0,
    refProp: r = "ref"
}) {
    const n = rX(t),
        i = Oo(n, e == null ? void 0 : e.ref);
    return Pu(e) ? b.cloneElement(e, {
        [r]: i
    }) : e
}
Pw.displayName = "@mantine/core/FocusTrap";
var hZ = Object.defineProperty,
    dZ = Object.defineProperties,
    fZ = Object.getOwnPropertyDescriptors,
    T2 = Object.getOwnPropertySymbols,
    pZ = Object.prototype.hasOwnProperty,
    mZ = Object.prototype.propertyIsEnumerable,
    O2 = (e, t, r) => t in e ? hZ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Wi = (e, t) => {
        for (var r in t || (t = {})) pZ.call(t, r) && O2(e, r, t[r]);
        if (T2)
            for (var r of T2(t)) mZ.call(t, r) && O2(e, r, t[r]);
        return e
    },
    qh = (e, t) => dZ(e, fZ(t));

function A2(e, t, r, n) {
    return e === "center" || n === "center" ? {
        top: t
    } : e === "end" ? {
        bottom: r
    } : e === "start" ? {
        top: r
    } : {}
}

function I2(e, t, r, n, i) {
    return e === "center" || n === "center" ? {
        left: t
    } : e === "end" ? {
        [i === "ltr" ? "right" : "left"]: r
    } : e === "start" ? {
        [i === "ltr" ? "left" : "right"]: r
    } : {}
}
const gZ = {
    bottom: "borderTopLeftRadius",
    left: "borderTopRightRadius",
    right: "borderBottomLeftRadius",
    top: "borderBottomRightRadius"
};

function vZ({
    position: e,
    arrowSize: t,
    arrowOffset: r,
    arrowRadius: n,
    arrowPosition: i,
    arrowX: s,
    arrowY: o,
    dir: a
}) {
    const [l, c = "center"] = e.split("-"), u = {
        width: R(t),
        height: R(t),
        transform: "rotate(45deg)",
        position: "absolute",
        [gZ[l]]: R(n)
    }, h = R(-t / 2);
    return l === "left" ? qh(Wi(Wi({}, u), A2(c, o, r, i)), {
        right: h,
        borderLeftColor: "transparent",
        borderBottomColor: "transparent"
    }) : l === "right" ? qh(Wi(Wi({}, u), A2(c, o, r, i)), {
        left: h,
        borderRightColor: "transparent",
        borderTopColor: "transparent"
    }) : l === "top" ? qh(Wi(Wi({}, u), I2(c, s, r, i, a)), {
        bottom: h,
        borderTopColor: "transparent",
        borderLeftColor: "transparent"
    }) : l === "bottom" ? qh(Wi(Wi({}, u), I2(c, s, r, i, a)), {
        top: h,
        borderBottomColor: "transparent",
        borderRightColor: "transparent"
    }) : {}
}
var yZ = Object.defineProperty,
    _Z = Object.defineProperties,
    wZ = Object.getOwnPropertyDescriptors,
    lp = Object.getOwnPropertySymbols,
    j3 = Object.prototype.hasOwnProperty,
    U3 = Object.prototype.propertyIsEnumerable,
    $2 = (e, t, r) => t in e ? yZ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    bZ = (e, t) => {
        for (var r in t || (t = {})) j3.call(t, r) && $2(e, r, t[r]);
        if (lp)
            for (var r of lp(t)) U3.call(t, r) && $2(e, r, t[r]);
        return e
    },
    xZ = (e, t) => _Z(e, wZ(t)),
    EZ = (e, t) => {
        var r = {};
        for (var n in e) j3.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && lp)
            for (var n of lp(e)) t.indexOf(n) < 0 && U3.call(e, n) && (r[n] = e[n]);
        return r
    };
const Cw = b.forwardRef((e, t) => {
    var r = e,
        {
            position: n,
            arrowSize: i,
            arrowOffset: s,
            arrowRadius: o,
            arrowPosition: a,
            visible: l,
            arrowX: c,
            arrowY: u
        } = r,
        h = EZ(r, ["position", "arrowSize", "arrowOffset", "arrowRadius", "arrowPosition", "visible", "arrowX", "arrowY"]);
    const d = yr();
    return l ? I.createElement("div", xZ(bZ({}, h), {
        ref: t,
        style: vZ({
            position: n,
            arrowSize: i,
            arrowOffset: s,
            arrowRadius: o,
            arrowPosition: a,
            dir: d.dir,
            arrowX: c,
            arrowY: u
        })
    })) : null
});
Cw.displayName = "@mantine/core/FloatingArrow";
var SZ = Object.defineProperty,
    PZ = Object.defineProperties,
    CZ = Object.getOwnPropertyDescriptors,
    cp = Object.getOwnPropertySymbols,
    H3 = Object.prototype.hasOwnProperty,
    G3 = Object.prototype.propertyIsEnumerable,
    R2 = (e, t, r) => t in e ? SZ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    ea = (e, t) => {
        for (var r in t || (t = {})) H3.call(t, r) && R2(e, r, t[r]);
        if (cp)
            for (var r of cp(t)) G3.call(t, r) && R2(e, r, t[r]);
        return e
    },
    Qh = (e, t) => PZ(e, CZ(t)),
    TZ = (e, t) => {
        var r = {};
        for (var n in e) H3.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && cp)
            for (var n of cp(e)) t.indexOf(n) < 0 && G3.call(e, n) && (r[n] = e[n]);
        return r
    };
const OZ = {};

function V3(e) {
    var t;
    const r = ve("PopoverDropdown", OZ, e),
        {
            style: n,
            className: i,
            children: s,
            onKeyDownCapture: o
        } = r,
        a = TZ(r, ["style", "className", "children", "onKeyDownCapture"]),
        l = L3(),
        {
            classes: c,
            cx: u
        } = sZ({
            radius: l.radius,
            shadow: l.shadow
        }, {
            name: l.__staticSelector,
            classNames: l.classNames,
            styles: l.styles,
            unstyled: l.unstyled,
            variant: l.variant
        }),
        h = KR({
            opened: l.opened,
            shouldReturnFocus: l.returnFocus
        }),
        d = l.withRoles ? {
            "aria-labelledby": l.getTargetId(),
            id: l.getDropdownId(),
            role: "dialog"
        } : {};
    return l.disabled ? null : I.createElement(vl, Qh(ea({}, l.portalProps), {
        withinPortal: l.withinPortal
    }), I.createElement(_l, Qh(ea({
        mounted: l.opened
    }, l.transitionProps), {
        transition: l.transitionProps.transition || "fade",
        duration: (t = l.transitionProps.duration) != null ? t : 150,
        keepMounted: l.keepMounted,
        exitDuration: typeof l.transitionProps.exitDuration == "number" ? l.transitionProps.exitDuration : l.transitionProps.duration
    }), f => {
        var p, m;
        return I.createElement(Pw, {
            active: l.trapFocus
        }, I.createElement(Ie, ea(Qh(ea({}, d), {
            tabIndex: -1,
            ref: l.floating,
            style: Qh(ea(ea({}, n), f), {
                zIndex: l.zIndex,
                top: (p = l.y) != null ? p : 0,
                left: (m = l.x) != null ? m : 0,
                width: l.width === "target" ? void 0 : R(l.width)
            }),
            className: u(c.dropdown, i),
            onKeyDownCapture: OG(l.onClose, {
                active: l.closeOnEscape,
                onTrigger: h,
                onKeyDown: o
            }),
            "data-position": l.placement
        }), a), s, I.createElement(Cw, {
            ref: l.arrowRef,
            arrowX: l.arrowX,
            arrowY: l.arrowY,
            visible: l.withArrow,
            position: l.placement,
            arrowSize: l.arrowSize,
            arrowRadius: l.arrowRadius,
            arrowOffset: l.arrowOffset,
            arrowPosition: l.arrowPosition,
            className: c.arrow
        })))
    }))
}
V3.displayName = "@mantine/core/PopoverDropdown";

function W3(e, t) {
    if (e === "rtl" && (t.includes("right") || t.includes("left"))) {
        const [r, n] = t.split("-"), i = r === "right" ? "left" : "right";
        return n === void 0 ? i : `${i}-${n}`
    }
    return t
}
var k2 = Object.getOwnPropertySymbols,
    AZ = Object.prototype.hasOwnProperty,
    IZ = Object.prototype.propertyIsEnumerable,
    $Z = (e, t) => {
        var r = {};
        for (var n in e) AZ.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && k2)
            for (var n of k2(e)) t.indexOf(n) < 0 && IZ.call(e, n) && (r[n] = e[n]);
        return r
    };
const RZ = {
    position: "bottom",
    offset: 8,
    positionDependencies: [],
    transitionProps: {
        transition: "fade",
        duration: 150
    },
    middlewares: {
        flip: !0,
        shift: !0,
        inline: !1
    },
    arrowSize: 7,
    arrowOffset: 5,
    arrowRadius: 0,
    arrowPosition: "side",
    closeOnClickOutside: !0,
    withinPortal: !1,
    closeOnEscape: !0,
    trapFocus: !1,
    withRoles: !0,
    returnFocus: !1,
    clickOutsideEvents: ["mousedown", "touchstart"],
    zIndex: $s("popover"),
    __staticSelector: "Popover",
    width: "max-content"
};

function Ha(e) {
    var t, r, n, i, s, o;
    const a = b.useRef(null),
        l = ve("Popover", RZ, e),
        {
            children: c,
            position: u,
            offset: h,
            onPositionChange: d,
            positionDependencies: f,
            opened: p,
            transitionProps: m,
            width: w,
            middlewares: y,
            withArrow: v,
            arrowSize: _,
            arrowOffset: E,
            arrowRadius: P,
            arrowPosition: C,
            unstyled: T,
            classNames: O,
            styles: k,
            closeOnClickOutside: D,
            withinPortal: B,
            portalProps: j,
            closeOnEscape: L,
            clickOutsideEvents: M,
            trapFocus: W,
            onClose: Z,
            onOpen: q,
            onChange: G,
            zIndex: X,
            radius: z,
            shadow: Q,
            id: ie,
            defaultOpened: _e,
            __staticSelector: we,
            withRoles: De,
            disabled: Te,
            returnFocus: Ne,
            variant: et,
            keepMounted: Le
        } = l,
        tt = $Z(l, ["children", "position", "offset", "onPositionChange", "positionDependencies", "opened", "transitionProps", "width", "middlewares", "withArrow", "arrowSize", "arrowOffset", "arrowRadius", "arrowPosition", "unstyled", "classNames", "styles", "closeOnClickOutside", "withinPortal", "portalProps", "closeOnEscape", "clickOutsideEvents", "trapFocus", "onClose", "onOpen", "onChange", "zIndex", "radius", "shadow", "id", "defaultOpened", "__staticSelector", "withRoles", "disabled", "returnFocus", "variant", "keepMounted"]),
        [Ue, Ve] = b.useState(null),
        [rt, Dt] = b.useState(null),
        zt = Ou(ie),
        Vr = yr(),
        at = qQ({
            middlewares: y,
            width: w,
            position: W3(Vr.dir, u),
            offset: typeof h == "number" ? h + (v ? _ / 2 : 0) : h,
            arrowRef: a,
            arrowOffset: E,
            onPositionChange: d,
            positionDependencies: f,
            opened: p,
            defaultOpened: _e,
            onChange: G,
            onOpen: q,
            onClose: Z
        });
    XR(() => at.opened && D && at.onClose(), M, [Ue, rt]);
    const _r = b.useCallback(Ar => {
            Ve(Ar), at.floating.reference(Ar)
        }, [at.floating.reference]),
        Ni = b.useCallback(Ar => {
            Dt(Ar), at.floating.floating(Ar)
        }, [at.floating.floating]);
    return I.createElement(QQ, {
        value: {
            returnFocus: Ne,
            disabled: Te,
            controlled: at.controlled,
            reference: _r,
            floating: Ni,
            x: at.floating.x,
            y: at.floating.y,
            arrowX: (n = (r = (t = at.floating) == null ? void 0 : t.middlewareData) == null ? void 0 : r.arrow) == null ? void 0 : n.x,
            arrowY: (o = (s = (i = at.floating) == null ? void 0 : i.middlewareData) == null ? void 0 : s.arrow) == null ? void 0 : o.y,
            opened: at.opened,
            arrowRef: a,
            transitionProps: m,
            width: w,
            withArrow: v,
            arrowSize: _,
            arrowOffset: E,
            arrowRadius: P,
            arrowPosition: C,
            placement: at.floating.placement,
            trapFocus: W,
            withinPortal: B,
            portalProps: j,
            zIndex: X,
            radius: z,
            shadow: Q,
            closeOnEscape: L,
            onClose: at.onClose,
            onToggle: at.onToggle,
            getTargetId: () => `${zt}-target`,
            getDropdownId: () => `${zt}-dropdown`,
            withRoles: De,
            targetProps: tt,
            __staticSelector: we,
            classNames: O,
            styles: k,
            unstyled: T,
            variant: et,
            keepMounted: Le
        }
    }, c)
}
Ha.Target = z3;
Ha.Dropdown = V3;
Ha.displayName = "@mantine/core/Popover";
var kZ = Pe((e, t, {
    size: r
}) => ({
    label: {
        display: "inline-block",
        fontSize: he({
            size: r,
            sizes: e.fontSizes
        }),
        fontWeight: 500,
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[9],
        wordBreak: "break-word",
        cursor: "default",
        WebkitTapHighlightColor: "transparent"
    },
    required: {
        color: e.fn.variant({
            variant: "filled",
            color: "red"
        }).background
    }
}));
const MZ = kZ;
var DZ = Object.defineProperty,
    up = Object.getOwnPropertySymbols,
    X3 = Object.prototype.hasOwnProperty,
    Y3 = Object.prototype.propertyIsEnumerable,
    M2 = (e, t, r) => t in e ? DZ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    NZ = (e, t) => {
        for (var r in t || (t = {})) X3.call(t, r) && M2(e, r, t[r]);
        if (up)
            for (var r of up(t)) Y3.call(t, r) && M2(e, r, t[r]);
        return e
    },
    LZ = (e, t) => {
        var r = {};
        for (var n in e) X3.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && up)
            for (var n of up(e)) t.indexOf(n) < 0 && Y3.call(e, n) && (r[n] = e[n]);
        return r
    };
const FZ = {
        labelElement: "label",
        size: "sm"
    },
    Tw = b.forwardRef((e, t) => {
        const r = ve("InputLabel", FZ, e),
            {
                labelElement: n,
                children: i,
                required: s,
                size: o,
                classNames: a,
                styles: l,
                unstyled: c,
                className: u,
                htmlFor: h,
                __staticSelector: d,
                variant: f,
                onMouseDown: p
            } = r,
            m = LZ(r, ["labelElement", "children", "required", "size", "classNames", "styles", "unstyled", "className", "htmlFor", "__staticSelector", "variant", "onMouseDown"]),
            {
                classes: w,
                cx: y
            } = MZ(null, {
                name: ["InputWrapper", d],
                classNames: a,
                styles: l,
                unstyled: c,
                variant: f,
                size: o
            });
        return I.createElement(Ie, NZ({
            component: n,
            ref: t,
            className: y(w.label, u),
            htmlFor: n === "label" ? h : void 0,
            onMouseDown: v => {
                p == null || p(v), !v.defaultPrevented && v.detail > 1 && v.preventDefault()
            }
        }, m), i, s && I.createElement("span", {
            className: w.required,
            "aria-hidden": !0
        }, " *"))
    });
Tw.displayName = "@mantine/core/InputLabel";
var BZ = Pe((e, t, {
    size: r
}) => ({
    error: {
        wordBreak: "break-word",
        color: e.fn.variant({
            variant: "filled",
            color: "red"
        }).background,
        fontSize: `calc(${he({size:r,sizes:e.fontSizes})} - ${R(2)})`,
        lineHeight: 1.2,
        display: "block"
    }
}));
const zZ = BZ;
var jZ = Object.defineProperty,
    hp = Object.getOwnPropertySymbols,
    K3 = Object.prototype.hasOwnProperty,
    q3 = Object.prototype.propertyIsEnumerable,
    D2 = (e, t, r) => t in e ? jZ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    UZ = (e, t) => {
        for (var r in t || (t = {})) K3.call(t, r) && D2(e, r, t[r]);
        if (hp)
            for (var r of hp(t)) q3.call(t, r) && D2(e, r, t[r]);
        return e
    },
    HZ = (e, t) => {
        var r = {};
        for (var n in e) K3.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && hp)
            for (var n of hp(e)) t.indexOf(n) < 0 && q3.call(e, n) && (r[n] = e[n]);
        return r
    };
const GZ = {
        size: "sm"
    },
    Ow = b.forwardRef((e, t) => {
        const r = ve("InputError", GZ, e),
            {
                children: n,
                className: i,
                classNames: s,
                styles: o,
                unstyled: a,
                size: l,
                __staticSelector: c,
                variant: u
            } = r,
            h = HZ(r, ["children", "className", "classNames", "styles", "unstyled", "size", "__staticSelector", "variant"]),
            {
                classes: d,
                cx: f
            } = zZ(null, {
                name: ["InputWrapper", c],
                classNames: s,
                styles: o,
                unstyled: a,
                variant: u,
                size: l
            });
        return I.createElement(ir, UZ({
            className: f(d.error, i),
            ref: t
        }, h), n)
    });
Ow.displayName = "@mantine/core/InputError";
var VZ = Pe((e, t, {
    size: r
}) => ({
    description: {
        wordBreak: "break-word",
        color: e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6],
        fontSize: `calc(${he({size:r,sizes:e.fontSizes})} - ${R(2)})`,
        lineHeight: 1.2,
        display: "block"
    }
}));
const WZ = VZ;
var XZ = Object.defineProperty,
    dp = Object.getOwnPropertySymbols,
    Q3 = Object.prototype.hasOwnProperty,
    Z3 = Object.prototype.propertyIsEnumerable,
    N2 = (e, t, r) => t in e ? XZ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    YZ = (e, t) => {
        for (var r in t || (t = {})) Q3.call(t, r) && N2(e, r, t[r]);
        if (dp)
            for (var r of dp(t)) Z3.call(t, r) && N2(e, r, t[r]);
        return e
    },
    KZ = (e, t) => {
        var r = {};
        for (var n in e) Q3.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && dp)
            for (var n of dp(e)) t.indexOf(n) < 0 && Z3.call(e, n) && (r[n] = e[n]);
        return r
    };
const qZ = {
        size: "sm"
    },
    Aw = b.forwardRef((e, t) => {
        const r = ve("InputDescription", qZ, e),
            {
                children: n,
                className: i,
                classNames: s,
                styles: o,
                unstyled: a,
                size: l,
                __staticSelector: c,
                variant: u
            } = r,
            h = KZ(r, ["children", "className", "classNames", "styles", "unstyled", "size", "__staticSelector", "variant"]),
            {
                classes: d,
                cx: f
            } = WZ(null, {
                name: ["InputWrapper", c],
                classNames: s,
                styles: o,
                unstyled: a,
                variant: u,
                size: l
            });
        return I.createElement(ir, YZ({
            color: "dimmed",
            className: f(d.description, i),
            ref: t,
            unstyled: a
        }, h), n)
    });
Aw.displayName = "@mantine/core/InputDescription";
const J3 = b.createContext({
        offsetBottom: !1,
        offsetTop: !1,
        describedBy: void 0
    }),
    QZ = J3.Provider,
    ZZ = () => b.useContext(J3);

function JZ(e, {
    hasDescription: t,
    hasError: r
}) {
    const n = e.findIndex(l => l === "input"),
        i = e[n - 1],
        s = e[n + 1];
    return {
        offsetBottom: t && s === "description" || r && s === "error",
        offsetTop: t && i === "description" || r && i === "error"
    }
}
var eJ = Object.defineProperty,
    tJ = Object.defineProperties,
    rJ = Object.getOwnPropertyDescriptors,
    L2 = Object.getOwnPropertySymbols,
    nJ = Object.prototype.hasOwnProperty,
    iJ = Object.prototype.propertyIsEnumerable,
    F2 = (e, t, r) => t in e ? eJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    sJ = (e, t) => {
        for (var r in t || (t = {})) nJ.call(t, r) && F2(e, r, t[r]);
        if (L2)
            for (var r of L2(t)) iJ.call(t, r) && F2(e, r, t[r]);
        return e
    },
    oJ = (e, t) => tJ(e, rJ(t)),
    aJ = Pe(e => ({
        root: oJ(sJ({}, e.fn.fontStyles()), {
            lineHeight: e.lineHeight
        })
    }));
const lJ = aJ;
var cJ = Object.defineProperty,
    uJ = Object.defineProperties,
    hJ = Object.getOwnPropertyDescriptors,
    fp = Object.getOwnPropertySymbols,
    eM = Object.prototype.hasOwnProperty,
    tM = Object.prototype.propertyIsEnumerable,
    B2 = (e, t, r) => t in e ? cJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Xi = (e, t) => {
        for (var r in t || (t = {})) eM.call(t, r) && B2(e, r, t[r]);
        if (fp)
            for (var r of fp(t)) tM.call(t, r) && B2(e, r, t[r]);
        return e
    },
    z2 = (e, t) => uJ(e, hJ(t)),
    dJ = (e, t) => {
        var r = {};
        for (var n in e) eM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && fp)
            for (var n of fp(e)) t.indexOf(n) < 0 && tM.call(e, n) && (r[n] = e[n]);
        return r
    };
const fJ = {
        labelElement: "label",
        size: "sm",
        inputContainer: e => e,
        inputWrapperOrder: ["label", "description", "input", "error"]
    },
    rM = b.forwardRef((e, t) => {
        const r = ve("InputWrapper", fJ, e),
            {
                className: n,
                label: i,
                children: s,
                required: o,
                id: a,
                error: l,
                description: c,
                labelElement: u,
                labelProps: h,
                descriptionProps: d,
                errorProps: f,
                classNames: p,
                styles: m,
                size: w,
                inputContainer: y,
                __staticSelector: v,
                unstyled: _,
                inputWrapperOrder: E,
                withAsterisk: P,
                variant: C
            } = r,
            T = dJ(r, ["className", "label", "children", "required", "id", "error", "description", "labelElement", "labelProps", "descriptionProps", "errorProps", "classNames", "styles", "size", "inputContainer", "__staticSelector", "unstyled", "inputWrapperOrder", "withAsterisk", "variant"]),
            {
                classes: O,
                cx: k
            } = lJ(null, {
                classNames: p,
                styles: m,
                name: ["InputWrapper", v],
                unstyled: _,
                variant: C,
                size: w
            }),
            D = {
                classNames: p,
                styles: m,
                unstyled: _,
                size: w,
                variant: C,
                __staticSelector: v
            },
            B = typeof P == "boolean" ? P : o,
            j = a ? `${a}-error` : f == null ? void 0 : f.id,
            L = a ? `${a}-description` : d == null ? void 0 : d.id,
            W = `${!!l&&typeof l!="boolean"?j:""} ${c?L:""}`,
            Z = W.trim().length > 0 ? W.trim() : void 0,
            q = i && I.createElement(Tw, Xi(Xi({
                key: "label",
                labelElement: u,
                id: a ? `${a}-label` : void 0,
                htmlFor: a,
                required: B
            }, D), h), i),
            G = c && I.createElement(Aw, z2(Xi(Xi({
                key: "description"
            }, d), D), {
                size: (d == null ? void 0 : d.size) || D.size,
                id: (d == null ? void 0 : d.id) || L
            }), c),
            X = I.createElement(b.Fragment, {
                key: "input"
            }, y(s)),
            z = typeof l != "boolean" && l && I.createElement(Ow, z2(Xi(Xi({}, f), D), {
                size: (f == null ? void 0 : f.size) || D.size,
                key: "error",
                id: (f == null ? void 0 : f.id) || j
            }), l),
            Q = E.map(ie => {
                switch (ie) {
                    case "label":
                        return q;
                    case "input":
                        return X;
                    case "description":
                        return G;
                    case "error":
                        return z;
                    default:
                        return null
                }
            });
        return I.createElement(QZ, {
            value: Xi({
                describedBy: Z
            }, JZ(E, {
                hasDescription: !!G,
                hasError: !!z
            }))
        }, I.createElement(Ie, Xi({
            className: k(O.root, n),
            ref: t
        }, T), Q))
    });
rM.displayName = "@mantine/core/InputWrapper";
var pJ = Object.defineProperty,
    pp = Object.getOwnPropertySymbols,
    nM = Object.prototype.hasOwnProperty,
    iM = Object.prototype.propertyIsEnumerable,
    j2 = (e, t, r) => t in e ? pJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    mJ = (e, t) => {
        for (var r in t || (t = {})) nM.call(t, r) && j2(e, r, t[r]);
        if (pp)
            for (var r of pp(t)) iM.call(t, r) && j2(e, r, t[r]);
        return e
    },
    gJ = (e, t) => {
        var r = {};
        for (var n in e) nM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && pp)
            for (var n of pp(e)) t.indexOf(n) < 0 && iM.call(e, n) && (r[n] = e[n]);
        return r
    };
const vJ = {},
    sM = b.forwardRef((e, t) => {
        const r = ve("InputPlaceholder", vJ, e),
            {
                sx: n
            } = r,
            i = gJ(r, ["sx"]);
        return I.createElement(Ie, mJ({
            component: "span",
            sx: [s => s.fn.placeholderStyles(), ...Wm(n)],
            ref: t
        }, i))
    });
sM.displayName = "@mantine/core/InputPlaceholder";
var yJ = Object.defineProperty,
    _J = Object.defineProperties,
    wJ = Object.getOwnPropertyDescriptors,
    U2 = Object.getOwnPropertySymbols,
    bJ = Object.prototype.hasOwnProperty,
    xJ = Object.prototype.propertyIsEnumerable,
    H2 = (e, t, r) => t in e ? yJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Zh = (e, t) => {
        for (var r in t || (t = {})) bJ.call(t, r) && H2(e, r, t[r]);
        if (U2)
            for (var r of U2(t)) xJ.call(t, r) && H2(e, r, t[r]);
        return e
    },
    m0 = (e, t) => _J(e, wJ(t));
const fr = {
        xs: R(30),
        sm: R(36),
        md: R(42),
        lg: R(50),
        xl: R(60)
    },
    EJ = ["default", "filled", "unstyled"];

function SJ({
    theme: e,
    variant: t
}) {
    return EJ.includes(t) ? t === "default" ? {
        border: `${R(1)} solid ${e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[4]}`,
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
        transition: "border-color 100ms ease",
        "&:focus, &:focus-within": e.focusRingStyles.inputStyles(e)
    } : t === "filled" ? {
        border: `${R(1)} solid transparent`,
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[1],
        "&:focus, &:focus-within": e.focusRingStyles.inputStyles(e)
    } : {
        borderWidth: 0,
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
        backgroundColor: "transparent",
        minHeight: R(28),
        outline: 0,
        "&:focus, &:focus-within": {
            outline: "none",
            borderColor: "transparent"
        },
        "&:disabled": {
            backgroundColor: "transparent",
            "&:focus, &:focus-within": {
                outline: "none",
                borderColor: "transparent"
            }
        }
    } : null
}
var PJ = Pe((e, {
        multiline: t,
        radius: r,
        invalid: n,
        rightSectionWidth: i,
        withRightSection: s,
        iconWidth: o,
        offsetBottom: a,
        offsetTop: l,
        pointer: c
    }, {
        variant: u,
        size: h
    }) => {
        const d = e.fn.variant({
                variant: "filled",
                color: "red"
            }).background,
            f = u === "default" || u === "filled" ? {
                minHeight: he({
                    size: h,
                    sizes: fr
                }),
                paddingLeft: `calc(${he({size:h,sizes:fr})}  / 3)`,
                paddingRight: s ? i || he({
                    size: h,
                    sizes: fr
                }) : `calc(${he({size:h,sizes:fr})}  / 3)`,
                borderRadius: e.fn.radius(r)
            } : u === "unstyled" && s ? {
                paddingRight: i || he({
                    size: h,
                    sizes: fr
                })
            } : null;
        return {
            wrapper: {
                position: "relative",
                marginTop: l ? `calc(${e.spacing.xs} / 2)` : void 0,
                marginBottom: a ? `calc(${e.spacing.xs} / 2)` : void 0
            },
            input: m0(Zh(Zh(m0(Zh({}, e.fn.fontStyles()), {
                height: t ? u === "unstyled" ? void 0 : "auto" : he({
                    size: h,
                    sizes: fr
                }),
                WebkitTapHighlightColor: "transparent",
                lineHeight: t ? e.lineHeight : `calc(${he({size:h,sizes:fr})} - ${R(2)})`,
                appearance: "none",
                resize: "none",
                boxSizing: "border-box",
                fontSize: he({
                    size: h,
                    sizes: e.fontSizes
                }),
                width: "100%",
                color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
                display: "block",
                textAlign: "left",
                cursor: c ? "pointer" : void 0
            }), SJ({
                theme: e,
                variant: u
            })), f), {
                "&:disabled, &[data-disabled]": {
                    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[1],
                    color: e.colors.dark[2],
                    opacity: .6,
                    cursor: "not-allowed",
                    "&::placeholder": {
                        color: e.colors.dark[2]
                    }
                },
                "&[data-invalid]": {
                    color: d,
                    borderColor: d,
                    "&::placeholder": {
                        opacity: 1,
                        color: d
                    }
                },
                "&[data-with-icon]": {
                    paddingLeft: typeof o == "number" ? R(o) : he({
                        size: h,
                        sizes: fr
                    })
                },
                "&::placeholder": m0(Zh({}, e.fn.placeholderStyles()), {
                    opacity: 1
                }),
                "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button, &::-webkit-search-decoration, &::-webkit-search-cancel-button, &::-webkit-search-results-button, &::-webkit-search-results-decoration": {
                    appearance: "none"
                },
                "&[type=number]": {
                    MozAppearance: "textfield"
                }
            }),
            icon: {
                pointerEvents: "none",
                position: "absolute",
                zIndex: 1,
                left: 0,
                top: 0,
                bottom: 0,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                width: o ? R(o) : he({
                    size: h,
                    sizes: fr
                }),
                color: n ? e.colors.red[e.colorScheme === "dark" ? 6 : 7] : e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[5]
            },
            rightSection: {
                position: "absolute",
                top: 0,
                bottom: 0,
                right: 0,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                width: i || he({
                    size: h,
                    sizes: fr
                })
            }
        }
    }),
    CJ = Object.defineProperty,
    TJ = Object.defineProperties,
    OJ = Object.getOwnPropertyDescriptors,
    mp = Object.getOwnPropertySymbols,
    oM = Object.prototype.hasOwnProperty,
    aM = Object.prototype.propertyIsEnumerable,
    G2 = (e, t, r) => t in e ? CJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Jh = (e, t) => {
        for (var r in t || (t = {})) oM.call(t, r) && G2(e, r, t[r]);
        if (mp)
            for (var r of mp(t)) aM.call(t, r) && G2(e, r, t[r]);
        return e
    },
    V2 = (e, t) => TJ(e, OJ(t)),
    AJ = (e, t) => {
        var r = {};
        for (var n in e) oM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && mp)
            for (var n of mp(e)) t.indexOf(n) < 0 && aM.call(e, n) && (r[n] = e[n]);
        return r
    };
const IJ = {
        size: "sm",
        variant: "default"
    },
    $o = b.forwardRef((e, t) => {
        const r = ve("Input", IJ, e),
            {
                className: n,
                error: i,
                required: s,
                disabled: o,
                variant: a,
                icon: l,
                style: c,
                rightSectionWidth: u,
                iconWidth: h,
                rightSection: d,
                rightSectionProps: f,
                radius: p,
                size: m,
                wrapperProps: w,
                classNames: y,
                styles: v,
                __staticSelector: _,
                multiline: E,
                sx: P,
                unstyled: C,
                pointer: T
            } = r,
            O = AJ(r, ["className", "error", "required", "disabled", "variant", "icon", "style", "rightSectionWidth", "iconWidth", "rightSection", "rightSectionProps", "radius", "size", "wrapperProps", "classNames", "styles", "__staticSelector", "multiline", "sx", "unstyled", "pointer"]),
            {
                offsetBottom: k,
                offsetTop: D,
                describedBy: B
            } = ZZ(),
            {
                classes: j,
                cx: L
            } = PJ({
                radius: p,
                multiline: E,
                invalid: !!i,
                rightSectionWidth: u ? R(u) : void 0,
                iconWidth: h,
                withRightSection: !!d,
                offsetBottom: k,
                offsetTop: D,
                pointer: T
            }, {
                classNames: y,
                styles: v,
                name: ["Input", _],
                unstyled: C,
                variant: a,
                size: m
            }),
            {
                systemStyles: M,
                rest: W
            } = ug(O);
        return I.createElement(Ie, Jh(Jh({
            className: L(j.wrapper, n),
            sx: P,
            style: c
        }, M), w), l && I.createElement("div", {
            className: j.icon
        }, l), I.createElement(Ie, V2(Jh({
            component: "input"
        }, W), {
            ref: t,
            required: s,
            "aria-invalid": !!i,
            "aria-describedby": B,
            disabled: o,
            "data-disabled": o || void 0,
            "data-with-icon": !!l || void 0,
            "data-invalid": !!i || void 0,
            className: j.input
        })), d && I.createElement("div", V2(Jh({}, f), {
            className: j.rightSection
        }), d))
    });
$o.displayName = "@mantine/core/Input";
$o.Wrapper = rM;
$o.Label = Tw;
$o.Description = Aw;
$o.Error = Ow;
$o.Placeholder = sM;
const T_ = $o;
var $J = Pe((e, {
    orientation: t,
    buttonBorderWidth: r
}) => ({
    root: {
        display: "flex",
        flexDirection: t === "vertical" ? "column" : "row",
        "& [data-button]": {
            "&:first-of-type:not(:last-of-type)": {
                borderBottomRightRadius: 0,
                [t === "vertical" ? "borderBottomLeftRadius" : "borderTopRightRadius"]: 0,
                [t === "vertical" ? "borderBottomWidth" : "borderRightWidth"]: `calc(${R(r)} / 2)`
            },
            "&:last-of-type:not(:first-of-type)": {
                borderTopLeftRadius: 0,
                [t === "vertical" ? "borderTopRightRadius" : "borderBottomLeftRadius"]: 0,
                [t === "vertical" ? "borderTopWidth" : "borderLeftWidth"]: `calc(${R(r)} / 2)`
            },
            "&:not(:first-of-type):not(:last-of-type)": {
                borderRadius: 0,
                [t === "vertical" ? "borderTopWidth" : "borderLeftWidth"]: `calc(${R(r)} / 2)`,
                [t === "vertical" ? "borderBottomWidth" : "borderRightWidth"]: `calc(${R(r)} / 2)`
            },
            "& + [data-button]": {
                [t === "vertical" ? "marginTop" : "marginLeft"]: `calc(${r} * -1)`,
                "@media (min-resolution: 192dpi)": {
                    [t === "vertical" ? "marginTop" : "marginLeft"]: 0
                }
            }
        }
    }
}));
const RJ = $J;
var kJ = Object.defineProperty,
    gp = Object.getOwnPropertySymbols,
    lM = Object.prototype.hasOwnProperty,
    cM = Object.prototype.propertyIsEnumerable,
    W2 = (e, t, r) => t in e ? kJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    MJ = (e, t) => {
        for (var r in t || (t = {})) lM.call(t, r) && W2(e, r, t[r]);
        if (gp)
            for (var r of gp(t)) cM.call(t, r) && W2(e, r, t[r]);
        return e
    },
    DJ = (e, t) => {
        var r = {};
        for (var n in e) lM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && gp)
            for (var n of gp(e)) t.indexOf(n) < 0 && cM.call(e, n) && (r[n] = e[n]);
        return r
    };
const NJ = {
        orientation: "horizontal",
        buttonBorderWidth: 1
    },
    uM = b.forwardRef((e, t) => {
        const r = ve("ButtonGroup", NJ, e),
            {
                className: n,
                orientation: i,
                buttonBorderWidth: s,
                unstyled: o
            } = r,
            a = DJ(r, ["className", "orientation", "buttonBorderWidth", "unstyled"]),
            {
                classes: l,
                cx: c
            } = RJ({
                orientation: i,
                buttonBorderWidth: s
            }, {
                name: "ButtonGroup",
                unstyled: o
            });
        return I.createElement(Ie, MJ({
            className: c(l.root, n),
            ref: t
        }, a))
    });
uM.displayName = "@mantine/core/ButtonGroup";
var LJ = Object.defineProperty,
    FJ = Object.defineProperties,
    BJ = Object.getOwnPropertyDescriptors,
    X2 = Object.getOwnPropertySymbols,
    zJ = Object.prototype.hasOwnProperty,
    jJ = Object.prototype.propertyIsEnumerable,
    Y2 = (e, t, r) => t in e ? LJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    yi = (e, t) => {
        for (var r in t || (t = {})) zJ.call(t, r) && Y2(e, r, t[r]);
        if (X2)
            for (var r of X2(t)) jJ.call(t, r) && Y2(e, r, t[r]);
        return e
    },
    Ld = (e, t) => FJ(e, BJ(t));
const UJ = ["filled", "outline", "light", "white", "default", "subtle", "gradient"],
    O_ = {
        xs: {
            height: fr.xs,
            paddingLeft: R(14),
            paddingRight: R(14)
        },
        sm: {
            height: fr.sm,
            paddingLeft: R(18),
            paddingRight: R(18)
        },
        md: {
            height: fr.md,
            paddingLeft: R(22),
            paddingRight: R(22)
        },
        lg: {
            height: fr.lg,
            paddingLeft: R(26),
            paddingRight: R(26)
        },
        xl: {
            height: fr.xl,
            paddingLeft: R(32),
            paddingRight: R(32)
        },
        "compact-xs": {
            height: R(22),
            paddingLeft: R(7),
            paddingRight: R(7)
        },
        "compact-sm": {
            height: R(26),
            paddingLeft: R(8),
            paddingRight: R(8)
        },
        "compact-md": {
            height: R(30),
            paddingLeft: R(10),
            paddingRight: R(10)
        },
        "compact-lg": {
            height: R(34),
            paddingLeft: R(12),
            paddingRight: R(12)
        },
        "compact-xl": {
            height: R(40),
            paddingLeft: R(14),
            paddingRight: R(14)
        }
    };

function HJ({
    compact: e,
    size: t,
    withLeftIcon: r,
    withRightIcon: n
}) {
    if (e) return O_[`compact-${t}`];
    const i = O_[t];
    return i ? Ld(yi({}, i), {
        paddingLeft: r ? `calc(${i.paddingLeft}  / 1.5)` : i.paddingLeft,
        paddingRight: n ? `calc(${i.paddingRight}  / 1.5)` : i.paddingRight
    }) : {}
}
const GJ = e => ({
    display: e ? "block" : "inline-block",
    width: e ? "100%" : "auto"
});

function VJ({
    variant: e,
    theme: t,
    color: r,
    gradient: n
}) {
    if (!UJ.includes(e)) return null;
    const i = t.fn.variant({
        color: r,
        variant: e,
        gradient: n
    });
    return e === "gradient" ? yi({
        border: 0,
        backgroundImage: i.background,
        color: i.color
    }, t.fn.hover({
        backgroundSize: "200%"
    })) : yi({
        border: `${R(1)} solid ${i.border}`,
        backgroundColor: i.background,
        color: i.color
    }, t.fn.hover({
        backgroundColor: i.hover
    }))
}
var WJ = Pe((e, {
    radius: t,
    fullWidth: r,
    compact: n,
    withLeftIcon: i,
    withRightIcon: s,
    color: o,
    gradient: a
}, {
    variant: l,
    size: c
}) => ({
    root: Ld(yi(Ld(yi(yi(yi(yi({}, HJ({
        compact: n,
        size: c,
        withLeftIcon: i,
        withRightIcon: s
    })), e.fn.fontStyles()), e.fn.focusStyles()), GJ(r)), {
        borderRadius: e.fn.radius(t),
        fontWeight: 600,
        position: "relative",
        lineHeight: 1,
        fontSize: he({
            size: c,
            sizes: e.fontSizes
        }),
        userSelect: "none",
        cursor: "pointer"
    }), VJ({
        variant: l,
        theme: e,
        color: o,
        gradient: a
    })), {
        "&:active": e.activeStyles,
        "&:disabled, &[data-disabled]": {
            borderColor: "transparent",
            backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
            color: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[5],
            cursor: "not-allowed",
            backgroundImage: "none",
            pointerEvents: "none",
            "&:active": {
                transform: "none"
            }
        },
        "&[data-loading]": {
            pointerEvents: "none",
            "&::before": Ld(yi({
                content: '""'
            }, e.fn.cover(R(-1))), {
                backgroundColor: e.colorScheme === "dark" ? e.fn.rgba(e.colors.dark[7], .5) : "rgba(255, 255, 255, .5)",
                borderRadius: e.fn.radius(t),
                cursor: "not-allowed"
            })
        }
    }),
    icon: {
        display: "flex",
        alignItems: "center"
    },
    leftIcon: {
        marginRight: e.spacing.xs
    },
    rightIcon: {
        marginLeft: e.spacing.xs
    },
    centerLoader: {
        position: "absolute",
        left: "50%",
        transform: "translateX(-50%)",
        opacity: .5
    },
    inner: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        height: "100%",
        overflow: "visible"
    },
    label: {
        whiteSpace: "nowrap",
        height: "100%",
        overflow: "hidden",
        display: "flex",
        alignItems: "center"
    }
}));
const XJ = WJ;
var YJ = Object.defineProperty,
    vp = Object.getOwnPropertySymbols,
    hM = Object.prototype.hasOwnProperty,
    dM = Object.prototype.propertyIsEnumerable,
    K2 = (e, t, r) => t in e ? YJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    q2 = (e, t) => {
        for (var r in t || (t = {})) hM.call(t, r) && K2(e, r, t[r]);
        if (vp)
            for (var r of vp(t)) dM.call(t, r) && K2(e, r, t[r]);
        return e
    },
    KJ = (e, t) => {
        var r = {};
        for (var n in e) hM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && vp)
            for (var n of vp(e)) t.indexOf(n) < 0 && dM.call(e, n) && (r[n] = e[n]);
        return r
    };
const qJ = {
        size: "sm",
        type: "button",
        variant: "filled",
        loaderPosition: "left"
    },
    Iw = b.forwardRef((e, t) => {
        const r = ve("Button", qJ, e),
            {
                className: n,
                size: i,
                color: s,
                type: o,
                disabled: a,
                children: l,
                leftIcon: c,
                rightIcon: u,
                fullWidth: h,
                variant: d,
                radius: f,
                uppercase: p,
                compact: m,
                loading: w,
                loaderPosition: y,
                loaderProps: v,
                gradient: _,
                classNames: E,
                styles: P,
                unstyled: C
            } = r,
            T = KJ(r, ["className", "size", "color", "type", "disabled", "children", "leftIcon", "rightIcon", "fullWidth", "variant", "radius", "uppercase", "compact", "loading", "loaderPosition", "loaderProps", "gradient", "classNames", "styles", "unstyled"]),
            {
                classes: O,
                cx: k,
                theme: D
            } = XJ({
                radius: f,
                color: s,
                fullWidth: h,
                compact: m,
                gradient: _,
                withLeftIcon: !!c,
                withRightIcon: !!u
            }, {
                name: "Button",
                unstyled: C,
                classNames: E,
                styles: P,
                variant: d,
                size: i
            }),
            B = D.fn.variant({
                color: s,
                variant: d
            }),
            j = I.createElement(Ao, q2({
                color: B.color,
                size: `calc(${he({size:i,sizes:O_}).height} / 2)`
            }, v));
        return I.createElement(hg, q2({
            className: k(O.root, n),
            type: o,
            disabled: a,
            "data-button": !0,
            "data-disabled": a || void 0,
            "data-loading": w || void 0,
            ref: t,
            unstyled: C
        }, T), I.createElement("div", {
            className: O.inner
        }, (c || w && y === "left") && I.createElement("span", {
            className: k(O.icon, O.leftIcon)
        }, w && y === "left" ? j : c), w && y === "center" && I.createElement("span", {
            className: O.centerLoader
        }, j), I.createElement("span", {
            className: O.label,
            style: {
                textTransform: p ? "uppercase" : void 0
            }
        }, l), (u || w && y === "right") && I.createElement("span", {
            className: k(O.icon, O.rightIcon)
        }, w && y === "right" ? j : u)))
    });
Iw.displayName = "@mantine/core/Button";
Iw.Group = uM;
const A_ = Iw;
var QJ = Pe((e, {
    radius: t,
    shadow: r
}) => ({
    root: {
        outline: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        textDecoration: "none",
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
        boxSizing: "border-box",
        borderRadius: e.fn.radius(t),
        boxShadow: e.shadows[r] || r || "none",
        "&[data-with-border]": {
            border: `${R(1)} solid ${e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[3]}`
        }
    }
}));
const ZJ = QJ;
var JJ = Object.defineProperty,
    yp = Object.getOwnPropertySymbols,
    fM = Object.prototype.hasOwnProperty,
    pM = Object.prototype.propertyIsEnumerable,
    Q2 = (e, t, r) => t in e ? JJ(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    eee = (e, t) => {
        for (var r in t || (t = {})) fM.call(t, r) && Q2(e, r, t[r]);
        if (yp)
            for (var r of yp(t)) pM.call(t, r) && Q2(e, r, t[r]);
        return e
    },
    tee = (e, t) => {
        var r = {};
        for (var n in e) fM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && yp)
            for (var n of yp(e)) t.indexOf(n) < 0 && pM.call(e, n) && (r[n] = e[n]);
        return r
    };
const ree = {},
    mM = b.forwardRef((e, t) => {
        const r = ve("Paper", ree, e),
            {
                className: n,
                children: i,
                radius: s,
                withBorder: o,
                shadow: a,
                unstyled: l,
                variant: c
            } = r,
            u = tee(r, ["className", "children", "radius", "withBorder", "shadow", "unstyled", "variant"]),
            {
                classes: h,
                cx: d
            } = ZJ({
                radius: s,
                shadow: a
            }, {
                name: "Paper",
                unstyled: l,
                variant: c
            });
        return I.createElement(Ie, eee({
            className: d(h.root, n),
            "data-with-border": o || void 0,
            ref: t
        }, u), i)
    });
mM.displayName = "@mantine/core/Paper";
const $w = mM,
    gM = b.createContext({
        padding: 0
    }),
    nee = gM.Provider,
    iee = () => b.useContext(gM).padding;
var see = Pe((e, {
    padding: t,
    withBorder: r,
    inheritPadding: n
}) => {
    const i = he({
            size: t,
            sizes: e.spacing
        }),
        s = `calc(-1 * ${i})`,
        o = e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3];
    return {
        cardSection: {
            display: "block",
            marginLeft: s,
            marginRight: s,
            paddingLeft: n ? i : void 0,
            paddingRight: n ? i : void 0,
            borderTop: r ? `${R(1)} solid ${o}` : void 0,
            borderBottom: r ? `${R(1)} solid ${o}` : void 0,
            "& + &": {
                borderTop: 0
            },
            "&[data-first]": {
                marginTop: s,
                borderTop: 0,
                borderBottom: r ? `${R(1)} solid ${o}` : void 0
            },
            "&[data-last]": {
                marginBottom: s,
                borderBottom: 0
            }
        }
    }
});
const oee = see;
var aee = Object.defineProperty,
    _p = Object.getOwnPropertySymbols,
    vM = Object.prototype.hasOwnProperty,
    yM = Object.prototype.propertyIsEnumerable,
    Z2 = (e, t, r) => t in e ? aee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    lee = (e, t) => {
        for (var r in t || (t = {})) vM.call(t, r) && Z2(e, r, t[r]);
        if (_p)
            for (var r of _p(t)) yM.call(t, r) && Z2(e, r, t[r]);
        return e
    },
    cee = (e, t) => {
        var r = {};
        for (var n in e) vM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && _p)
            for (var n of _p(e)) t.indexOf(n) < 0 && yM.call(e, n) && (r[n] = e[n]);
        return r
    };
const uee = {
        withBorder: !1,
        inheritPadding: !1
    },
    _M = b.forwardRef((e, t) => {
        const r = ve("CardSection", uee, e),
            {
                className: n,
                withBorder: i,
                inheritPadding: s,
                unstyled: o,
                variant: a
            } = r,
            l = cee(r, ["className", "withBorder", "inheritPadding", "unstyled", "variant"]),
            {
                classes: c,
                cx: u
            } = oee({
                padding: iee(),
                withBorder: i,
                inheritPadding: s
            }, {
                name: "Card",
                unstyled: o,
                variant: a
            });
        return I.createElement(Ie, lee({
            className: u(c.cardSection, n),
            ref: t
        }, l))
    });
_M.displayName = "@mantine/core/CardSection";
const wM = _M;
var hee = Pe(e => ({
    root: {
        position: "relative",
        overflow: "hidden",
        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white
    }
}));
const dee = hee;
var fee = Object.defineProperty,
    wp = Object.getOwnPropertySymbols,
    bM = Object.prototype.hasOwnProperty,
    xM = Object.prototype.propertyIsEnumerable,
    J2 = (e, t, r) => t in e ? fee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    pee = (e, t) => {
        for (var r in t || (t = {})) bM.call(t, r) && J2(e, r, t[r]);
        if (wp)
            for (var r of wp(t)) xM.call(t, r) && J2(e, r, t[r]);
        return e
    },
    mee = (e, t) => {
        var r = {};
        for (var n in e) bM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && wp)
            for (var n of wp(e)) t.indexOf(n) < 0 && xM.call(e, n) && (r[n] = e[n]);
        return r
    };
const gee = {
        padding: "md"
    },
    Rw = b.forwardRef((e, t) => {
        const r = ve("Card", gee, e),
            {
                className: n,
                padding: i,
                radius: s,
                children: o,
                unstyled: a,
                variant: l
            } = r,
            c = mee(r, ["className", "padding", "radius", "children", "unstyled", "variant"]),
            {
                classes: u,
                cx: h
            } = dee(null, {
                name: "Card",
                unstyled: a,
                variant: l
            }),
            d = b.Children.toArray(o),
            f = d.map((p, m) => typeof p == "object" && p && "type" in p && p.type === wM ? b.cloneElement(p, {
                variant: l,
                padding: i,
                "data-first": m === 0 || void 0,
                "data-last": m === d.length - 1 || void 0
            }) : p);
        return I.createElement(nee, {
            value: {
                padding: i
            }
        }, I.createElement($w, pee({
            className: h(u.root, n),
            radius: s,
            p: i,
            ref: t
        }, c), f))
    });
Rw.Section = wM;
Rw.displayName = "@mantine/core/Card";
const kw = Rw;
var vee = Pe((e, {
    inline: t
}) => ({
    root: {
        display: t ? "inline-flex" : "flex",
        alignItems: "center",
        justifyContent: "center"
    }
}));
const yee = vee;
var _ee = Object.defineProperty,
    bp = Object.getOwnPropertySymbols,
    EM = Object.prototype.hasOwnProperty,
    SM = Object.prototype.propertyIsEnumerable,
    eC = (e, t, r) => t in e ? _ee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    wee = (e, t) => {
        for (var r in t || (t = {})) EM.call(t, r) && eC(e, r, t[r]);
        if (bp)
            for (var r of bp(t)) SM.call(t, r) && eC(e, r, t[r]);
        return e
    },
    bee = (e, t) => {
        var r = {};
        for (var n in e) EM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && bp)
            for (var n of bp(e)) t.indexOf(n) < 0 && SM.call(e, n) && (r[n] = e[n]);
        return r
    };
const PM = b.forwardRef((e, t) => {
    const r = ve("Center", {}, e),
        {
            inline: n,
            className: i,
            unstyled: s,
            variant: o
        } = r,
        a = bee(r, ["inline", "className", "unstyled", "variant"]),
        {
            classes: l,
            cx: c
        } = yee({
            inline: n
        }, {
            name: "Center",
            unstyled: s,
            variant: o
        });
    return I.createElement(Ie, wee({
        ref: t,
        className: c(l.root, i)
    }, a))
});
PM.displayName = "@mantine/core/Center";
const CM = PM;
var xee = Object.defineProperty,
    Eee = Object.defineProperties,
    See = Object.getOwnPropertyDescriptors,
    tC = Object.getOwnPropertySymbols,
    Pee = Object.prototype.hasOwnProperty,
    Cee = Object.prototype.propertyIsEnumerable,
    rC = (e, t, r) => t in e ? xee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Tee = (e, t) => {
        for (var r in t || (t = {})) Pee.call(t, r) && rC(e, r, t[r]);
        if (tC)
            for (var r of tC(t)) Cee.call(t, r) && rC(e, r, t[r]);
        return e
    },
    Oee = (e, t) => Eee(e, See(t));
const g0 = {
    xs: R(16),
    sm: R(20),
    md: R(24),
    lg: R(30),
    xl: R(36)
};
var Aee = Pe((e, {
    labelPosition: t
}, {
    size: r
}) => ({
    root: {},
    body: {
        display: "flex"
    },
    labelWrapper: Oee(Tee({}, e.fn.fontStyles()), {
        display: "inline-flex",
        flexDirection: "column",
        WebkitTapHighlightColor: "transparent",
        fontSize: r in g0 ? he({
            size: r,
            sizes: e.fontSizes
        }) : void 0,
        lineHeight: r in g0 ? he({
            size: r,
            sizes: g0
        }) : void 0,
        color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
        cursor: e.cursorType,
        order: t === "left" ? 1 : 2
    }),
    description: {
        marginTop: `calc(${e.spacing.xs} / 2)`,
        [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm
    },
    error: {
        marginTop: `calc(${e.spacing.xs} / 2)`,
        [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm
    },
    label: {
        cursor: e.cursorType,
        [t === "left" ? "paddingRight" : "paddingLeft"]: e.spacing.sm,
        "&[data-disabled]": {
            color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
        }
    }
}));
const Iee = Aee;
var $ee = Object.defineProperty,
    xp = Object.getOwnPropertySymbols,
    TM = Object.prototype.hasOwnProperty,
    OM = Object.prototype.propertyIsEnumerable,
    nC = (e, t, r) => t in e ? $ee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Ree = (e, t) => {
        for (var r in t || (t = {})) TM.call(t, r) && nC(e, r, t[r]);
        if (xp)
            for (var r of xp(t)) OM.call(t, r) && nC(e, r, t[r]);
        return e
    },
    kee = (e, t) => {
        var r = {};
        for (var n in e) TM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && xp)
            for (var n of xp(e)) t.indexOf(n) < 0 && OM.call(e, n) && (r[n] = e[n]);
        return r
    };
const AM = b.forwardRef((e, t) => {
    var r = e,
        {
            __staticSelector: n,
            className: i,
            classNames: s,
            styles: o,
            unstyled: a,
            children: l,
            label: c,
            description: u,
            id: h,
            disabled: d,
            error: f,
            size: p,
            labelPosition: m,
            variant: w
        } = r,
        y = kee(r, ["__staticSelector", "className", "classNames", "styles", "unstyled", "children", "label", "description", "id", "disabled", "error", "size", "labelPosition", "variant"]);
    const {
        classes: v,
        cx: _
    } = Iee({
        labelPosition: m
    }, {
        name: n,
        styles: o,
        classNames: s,
        unstyled: a,
        variant: w,
        size: p
    });
    return I.createElement(Ie, Ree({
        className: _(v.root, i),
        ref: t
    }, y), I.createElement("div", {
        className: _(v.body)
    }, l, I.createElement("div", {
        className: v.labelWrapper
    }, c && I.createElement("label", {
        className: v.label,
        "data-disabled": d || void 0,
        htmlFor: h
    }, c), u && I.createElement(T_.Description, {
        className: v.description
    }, u), f && f !== "boolean" && I.createElement(T_.Error, {
        className: v.error
    }, f))))
});
AM.displayName = "@mantine/core/InlineInput";
var Mee = Object.defineProperty,
    Dee = Object.defineProperties,
    Nee = Object.getOwnPropertyDescriptors,
    iC = Object.getOwnPropertySymbols,
    Lee = Object.prototype.hasOwnProperty,
    Fee = Object.prototype.propertyIsEnumerable,
    sC = (e, t, r) => t in e ? Mee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    oC = (e, t) => {
        for (var r in t || (t = {})) Lee.call(t, r) && sC(e, r, t[r]);
        if (iC)
            for (var r of iC(t)) Fee.call(t, r) && sC(e, r, t[r]);
        return e
    },
    aC = (e, t) => Dee(e, Nee(t)),
    Bee = Pe((e, {
        radius: t
    }, {
        size: r
    }) => {
        const n = e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[3];
        return {
            root: aC(oC({}, e.fn.focusStyles()), {
                width: R(r),
                height: R(r),
                WebkitTapHighlightColor: "transparent",
                border: 0,
                borderRadius: e.fn.radius(t),
                appearance: "none",
                WebkitAppearance: "none",
                padding: 0,
                position: "relative",
                overflow: "hidden"
            }),
            overlay: aC(oC({}, e.fn.cover()), {
                position: "absolute",
                borderRadius: e.fn.radius(t)
            }),
            children: {
                display: "inline-flex",
                justifyContent: "center",
                alignItems: "center"
            },
            shadowOverlay: {
                boxShadow: `rgba(0, 0, 0, .1) 0 0 0 ${R(1)} inset, rgb(0, 0, 0, .15) 0 0 ${R(4)} inset`,
                zIndex: 1
            },
            alphaOverlay: {
                backgroundImage: `linear-gradient(45deg, ${n} 25%, transparent 25%), linear-gradient(-45deg, ${n} 25%, transparent 25%), linear-gradient(45deg, transparent 75%, ${n} 75%), linear-gradient(-45deg, ${e.colorScheme==="dark"?e.colors.dark[7]:e.white} 75%, ${n} 75%)`,
                backgroundSize: `${R(8)} ${R(8)}`,
                backgroundPosition: `0 0, 0 ${R(4)}, ${R(4)} -${R(4)}, -${R(4)} 0`
            }
        }
    });
const zee = Bee;
var jee = Object.defineProperty,
    Ep = Object.getOwnPropertySymbols,
    IM = Object.prototype.hasOwnProperty,
    $M = Object.prototype.propertyIsEnumerable,
    lC = (e, t, r) => t in e ? jee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Uee = (e, t) => {
        for (var r in t || (t = {})) IM.call(t, r) && lC(e, r, t[r]);
        if (Ep)
            for (var r of Ep(t)) $M.call(t, r) && lC(e, r, t[r]);
        return e
    },
    Hee = (e, t) => {
        var r = {};
        for (var n in e) IM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Ep)
            for (var n of Ep(e)) t.indexOf(n) < 0 && $M.call(e, n) && (r[n] = e[n]);
        return r
    };
const Gee = {
        size: R(25),
        radius: R(25),
        withShadow: !0
    },
    RM = b.forwardRef((e, t) => {
        const r = ve("ColorSwatch", Gee, e),
            {
                color: n,
                size: i,
                radius: s,
                className: o,
                children: a,
                classNames: l,
                styles: c,
                unstyled: u,
                withShadow: h,
                variant: d
            } = r,
            f = Hee(r, ["color", "size", "radius", "className", "children", "classNames", "styles", "unstyled", "withShadow", "variant"]),
            {
                classes: p,
                cx: m
            } = zee({
                radius: s
            }, {
                classNames: l,
                styles: c,
                unstyled: u,
                name: "ColorSwatch",
                size: i,
                variant: d
            });
        return I.createElement(Ie, Uee({
            className: m(p.root, o),
            ref: t
        }, f), I.createElement("div", {
            className: m(p.alphaOverlay, p.overlay)
        }), h && I.createElement("div", {
            className: m(p.shadowOverlay, p.overlay)
        }), I.createElement("div", {
            className: p.overlay,
            style: {
                backgroundColor: n
            }
        }), I.createElement("div", {
            className: m(p.children, p.overlay)
        }, a))
    });
RM.displayName = "@mantine/core/ColorSwatch";
const kM = RM,
    Qn = {
        xs: R(8),
        sm: R(12),
        md: R(16),
        lg: R(20),
        xl: R(22)
    };
var Vee = Pe((e, t, {
    size: r
}) => {
    const n = he({
        size: r,
        sizes: Qn
    });
    return {
        thumb: {
            overflow: "hidden",
            boxSizing: "border-box",
            position: "absolute",
            boxShadow: `0 0 ${R(1)} rgba(0, 0, 0, .6)`,
            border: `${R(2)} solid ${e.white}`,
            backgroundColor: "transparent",
            width: n,
            height: n,
            borderRadius: n
        }
    }
});
const Wee = Vee;
var Xee = Object.defineProperty,
    cC = Object.getOwnPropertySymbols,
    Yee = Object.prototype.hasOwnProperty,
    Kee = Object.prototype.propertyIsEnumerable,
    uC = (e, t, r) => t in e ? Xee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    qee = (e, t) => {
        for (var r in t || (t = {})) Yee.call(t, r) && uC(e, r, t[r]);
        if (cC)
            for (var r of cC(t)) Kee.call(t, r) && uC(e, r, t[r]);
        return e
    };

function Mw({
    position: e,
    className: t,
    styles: r,
    classNames: n,
    style: i,
    size: s,
    __staticSelector: o,
    unstyled: a,
    variant: l
}) {
    const {
        classes: c,
        cx: u
    } = Wee(null, {
        classNames: n,
        styles: r,
        name: o,
        unstyled: a,
        size: s,
        variant: l
    });
    return I.createElement("div", {
        className: u(c.thumb, t),
        style: qee({
            left: `calc(${e.x*100}% - ${Qn[s]} / 2)`,
            top: `calc(${e.y*100}% - ${Qn[s]} / 2)`
        }, i)
    })
}
Mw.displayName = "@mantine/core/Thumb";
var Qee = Object.defineProperty,
    hC = Object.getOwnPropertySymbols,
    Zee = Object.prototype.hasOwnProperty,
    Jee = Object.prototype.propertyIsEnumerable,
    dC = (e, t, r) => t in e ? Qee(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    fC = (e, t) => {
        for (var r in t || (t = {})) Zee.call(t, r) && dC(e, r, t[r]);
        if (hC)
            for (var r of hC(t)) Jee.call(t, r) && dC(e, r, t[r]);
        return e
    },
    ete = Pe((e, t, {
        size: r
    }) => ({
        sliderThumb: {
            ref: ys("sliderThumb")
        },
        slider: {
            position: "relative",
            height: `calc(${he({size:r,sizes:Qn})} + ${R(2)})`,
            boxSizing: "border-box",
            marginLeft: `calc(${he({size:r,sizes:Qn})} / 2)`,
            marginRight: `calc(${he({size:r,sizes:Qn})} / 2)`,
            outline: 0,
            [`&:focus .${ys("sliderThumb")}`]: fC({}, e.focusRing === "always" || e.focusRing === "auto" ? e.focusRingStyles.styles(e) : e.focusRingStyles.resetStyles(e)),
            [`&:focus:not(:focus-visible) .${ys("sliderThumb")}`]: fC({}, e.focusRing === "auto" || e.focusRing === "never" ? e.focusRingStyles.resetStyles(e) : null)
        },
        sliderOverlay: {
            position: "absolute",
            boxSizing: "border-box",
            top: 0,
            bottom: 0,
            left: `calc(${he({size:r,sizes:Qn})} * -1 / 2 - ${R(1)})`,
            right: `calc(${he({size:r,sizes:Qn})} * -1 / 2 - ${R(1)})`,
            borderRadius: 1e3
        }
    }));
const tte = ete;
var rte = Object.defineProperty,
    nte = Object.defineProperties,
    ite = Object.getOwnPropertyDescriptors,
    Sp = Object.getOwnPropertySymbols,
    MM = Object.prototype.hasOwnProperty,
    DM = Object.prototype.propertyIsEnumerable,
    pC = (e, t, r) => t in e ? rte(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    ste = (e, t) => {
        for (var r in t || (t = {})) MM.call(t, r) && pC(e, r, t[r]);
        if (Sp)
            for (var r of Sp(t)) DM.call(t, r) && pC(e, r, t[r]);
        return e
    },
    ote = (e, t) => nte(e, ite(t)),
    ate = (e, t) => {
        var r = {};
        for (var n in e) MM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Sp)
            for (var n of Sp(e)) t.indexOf(n) < 0 && DM.call(e, n) && (r[n] = e[n]);
        return r
    };
const Dw = b.forwardRef((e, t) => {
    var r = e,
        {
            value: n,
            onChange: i,
            onChangeEnd: s,
            maxValue: o,
            round: a,
            size: l = "md",
            thumbColor: c = "transparent",
            __staticSelector: u = "ColorSlider",
            focusable: h = !0,
            overlays: d,
            classNames: f,
            styles: p,
            className: m,
            unstyled: w,
            variant: y
        } = r,
        v = ate(r, ["value", "onChange", "onChangeEnd", "maxValue", "round", "size", "thumbColor", "__staticSelector", "focusable", "overlays", "classNames", "styles", "className", "unstyled", "variant"]);
    const {
        classes: _,
        cx: E
    } = tte(null, {
        classNames: f,
        styles: p,
        name: u,
        unstyled: w,
        variant: y,
        size: l
    }), [P, C] = b.useState({
        y: 0,
        x: n / o
    }), T = b.useRef(P), O = L => a ? Math.round(L * o) : L * o, {
        ref: k
    } = tk(({
        x: L,
        y: M
    }) => {
        T.current = {
            x: L,
            y: M
        }, i(O(L))
    }, {
        onScrubEnd: () => {
            const {
                x: L
            } = T.current;
            s(O(L))
        }
    });
    sn(() => {
        C({
            y: 0,
            x: n / o
        })
    }, [n]);
    const D = (L, M) => {
            L.preventDefault();
            const W = ek(M);
            i(O(W.x)), s(O(W.x))
        },
        B = L => {
            switch (L.key) {
                case "ArrowRight":
                    {
                        D(L, {
                            x: P.x + .05,
                            y: P.y
                        });
                        break
                    }
                case "ArrowLeft":
                    {
                        D(L, {
                            x: P.x - .05,
                            y: P.y
                        });
                        break
                    }
            }
        },
        j = d.map((L, M) => I.createElement("div", {
            className: _.sliderOverlay,
            style: L,
            key: M
        }));
    return I.createElement(Ie, ote(ste({}, v), {
        ref: Oo(k, t),
        className: E(_.slider, m),
        role: "slider",
        "aria-valuenow": n,
        "aria-valuemax": o,
        "aria-valuemin": 0,
        tabIndex: h ? 0 : -1,
        onKeyDown: B
    }), j, I.createElement(Mw, {
        __staticSelector: u,
        classNames: f,
        styles: p,
        position: P,
        style: {
            top: R(1),
            backgroundColor: c
        },
        className: _.sliderThumb,
        size: l
    }))
});
Dw.displayName = "@mantine/core/ColorSlider";
var lte = Object.defineProperty,
    cte = Object.defineProperties,
    ute = Object.getOwnPropertyDescriptors,
    Pp = Object.getOwnPropertySymbols,
    NM = Object.prototype.hasOwnProperty,
    LM = Object.prototype.propertyIsEnumerable,
    mC = (e, t, r) => t in e ? lte(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    hte = (e, t) => {
        for (var r in t || (t = {})) NM.call(t, r) && mC(e, r, t[r]);
        if (Pp)
            for (var r of Pp(t)) LM.call(t, r) && mC(e, r, t[r]);
        return e
    },
    dte = (e, t) => cte(e, ute(t)),
    fte = (e, t) => {
        var r = {};
        for (var n in e) NM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Pp)
            for (var n of Pp(e)) t.indexOf(n) < 0 && LM.call(e, n) && (r[n] = e[n]);
        return r
    };
const pte = {},
    FM = b.forwardRef((e, t) => {
        const r = ve("HueSlider", pte, e),
            {
                value: n,
                onChange: i,
                onChangeEnd: s,
                __staticSelector: o
            } = r,
            a = fte(r, ["value", "onChange", "onChangeEnd", "__staticSelector"]);
        return I.createElement(Dw, dte(hte({}, a), {
            ref: t,
            value: n,
            onChange: i,
            onChangeEnd: s,
            maxValue: 360,
            thumbColor: `hsl(${n}, 100%, 50%)`,
            round: !0,
            __staticSelector: o || "HueSlider",
            overlays: [{
                backgroundImage: "linear-gradient(to right,hsl(0,100%,50%),hsl(60,100%,50%),hsl(120,100%,50%),hsl(170,100%,50%),hsl(240,100%,50%),hsl(300,100%,50%),hsl(360,100%,50%))"
            }, {
                boxShadow: `rgba(0, 0, 0, .1) 0 0 0 ${R(1)} inset, rgb(0, 0, 0, .15) 0 0 ${R(4)} inset`
            }]
        }))
    });
FM.displayName = "@mantine/core/HueSlider";
var mte = Object.defineProperty,
    gte = Object.defineProperties,
    vte = Object.getOwnPropertyDescriptors,
    gC = Object.getOwnPropertySymbols,
    yte = Object.prototype.hasOwnProperty,
    _te = Object.prototype.propertyIsEnumerable,
    vC = (e, t, r) => t in e ? mte(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    yC = (e, t) => {
        for (var r in t || (t = {})) yte.call(t, r) && vC(e, r, t[r]);
        if (gC)
            for (var r of gC(t)) _te.call(t, r) && vC(e, r, t[r]);
        return e
    },
    _C = (e, t) => gte(e, vte(t));

function Sn(e, t = 0, r = 10 ** t) {
    return Math.round(r * e) / r
}

function wte({
    h: e,
    s: t,
    l: r,
    a: n
}) {
    const i = t * ((r < 50 ? r : 100 - r) / 100);
    return {
        h: e,
        s: i > 0 ? 2 * i / (r + i) * 100 : 0,
        v: r + i,
        a: n
    }
}
const bte = {
    grad: 360 / 400,
    turn: 360,
    rad: 360 / (Math.PI * 2)
};

function xte(e, t = "deg") {
    return Number(e) * (bte[t] || 1)
}
const Ete = /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;

function wC(e) {
    const t = Ete.exec(e);
    return t ? wte({
        h: xte(t[1], t[2]),
        s: Number(t[3]),
        l: Number(t[4]),
        a: t[5] === void 0 ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
    }) : {
        h: 0,
        s: 0,
        v: 0,
        a: 1
    }
}

function I_({
    r: e,
    g: t,
    b: r,
    a: n
}) {
    const i = Math.max(e, t, r),
        s = i - Math.min(e, t, r),
        o = s ? i === e ? (t - r) / s : i === t ? 2 + (r - e) / s : 4 + (e - t) / s : 0;
    return {
        h: Sn(60 * (o < 0 ? o + 6 : o)),
        s: Sn(i ? s / i * 100 : 0),
        v: Sn(i / 255 * 100),
        a: n
    }
}

function $_(e) {
    const t = e[0] === "#" ? e.slice(1) : e;
    return t.length === 3 ? I_({
        r: parseInt(t[0] + t[0], 16),
        g: parseInt(t[1] + t[1], 16),
        b: parseInt(t[2] + t[2], 16),
        a: 1
    }) : I_({
        r: parseInt(t.slice(0, 2), 16),
        g: parseInt(t.slice(2, 4), 16),
        b: parseInt(t.slice(4, 6), 16),
        a: 1
    })
}

function Ste(e) {
    const t = e[0] === "#" ? e.slice(1) : e,
        r = o => Math.round(parseInt(o, 16) / 255 * 100) / 100;
    if (t.length === 4) {
        const o = t.slice(0, 3),
            a = r(t[3] + t[3]);
        return _C(yC({}, $_(o)), {
            a
        })
    }
    const n = t.slice(0, 6),
        i = r(t.slice(6, 8));
    return _C(yC({}, $_(n)), {
        a: i
    })
}
const Pte = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;

function bC(e) {
    const t = Pte.exec(e);
    return t ? I_({
        r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
        g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
        b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
        a: t[7] === void 0 ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
    }) : {
        h: 0,
        s: 0,
        v: 0,
        a: 1
    }
}
const BM = {
        hex: /^#?([0-9A-F]{3}){1,2}$/i,
        hexa: /^#?([0-9A-F]{4}){1,2}$/i,
        rgb: /^rgb\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/i,
        rgba: /^rgba\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/i,
        hsl: /hsl\(\s*(\d+)\s*,\s*(\d+(?:\.\d+)?%)\s*,\s*(\d+(?:\.\d+)?%)\)/i,
        hsla: /^hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/i
    },
    Cte = {
        hex: $_,
        hexa: Ste,
        rgb: bC,
        rgba: bC,
        hsl: wC,
        hsla: wC
    };

function Tte(e) {
    for (const [, t] of Object.entries(BM))
        if (t.test(e)) return !0;
    return !1
}

function ed(e) {
    if (typeof e != "string") return {
        h: 0,
        s: 0,
        v: 0,
        a: 1
    };
    if (e === "transparent") return {
        h: 0,
        s: 0,
        v: 0,
        a: 0
    };
    const t = e.trim();
    for (const [r, n] of Object.entries(BM))
        if (n.test(t)) return Cte[r](t);
    return {
        h: 0,
        s: 0,
        v: 0,
        a: 1
    }
}
var Ote = Object.defineProperty,
    Ate = Object.defineProperties,
    Ite = Object.getOwnPropertyDescriptors,
    Cp = Object.getOwnPropertySymbols,
    zM = Object.prototype.hasOwnProperty,
    jM = Object.prototype.propertyIsEnumerable,
    xC = (e, t, r) => t in e ? Ote(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    $te = (e, t) => {
        for (var r in t || (t = {})) zM.call(t, r) && xC(e, r, t[r]);
        if (Cp)
            for (var r of Cp(t)) jM.call(t, r) && xC(e, r, t[r]);
        return e
    },
    Rte = (e, t) => Ate(e, Ite(t)),
    kte = (e, t) => {
        var r = {};
        for (var n in e) zM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Cp)
            for (var n of Cp(e)) t.indexOf(n) < 0 && jM.call(e, n) && (r[n] = e[n]);
        return r
    };
const Mte = {},
    UM = b.forwardRef((e, t) => {
        const r = ve("AlphaSlider", Mte, e),
            {
                value: n,
                onChange: i,
                onChangeEnd: s,
                color: o,
                __staticSelector: a
            } = r,
            l = kte(r, ["value", "onChange", "onChangeEnd", "color", "__staticSelector"]),
            c = yr(),
            u = c.colorScheme === "dark" ? c.colors.dark[4] : c.colors.gray[3];
        return I.createElement(Dw, Rte($te({}, l), {
            ref: t,
            value: n,
            onChange: h => i(Sn(h, 2)),
            onChangeEnd: h => s(Sn(h, 2)),
            maxValue: 1,
            round: !1,
            __staticSelector: a || "AlphaSlider",
            overlays: [{
                backgroundImage: `linear-gradient(45deg, ${u} 25%, transparent 25%), linear-gradient(-45deg, ${u} 25%, transparent 25%), linear-gradient(45deg, transparent 75%, ${u} 75%), linear-gradient(-45deg, ${c.colorScheme==="dark"?c.colors.dark[7]:c.white} 75%, ${u} 75%)`,
                backgroundSize: `${R(8)} ${R(8)}`,
                backgroundPosition: `0 0, 0 ${R(4)}, ${R(4)} -${R(4)}, -${R(4)} 0`
            }, {
                backgroundImage: `linear-gradient(90deg, transparent, ${o})`
            }, {
                boxShadow: `rgba(0, 0, 0, .1) 0 0 0 ${R(1)} inset, rgb(0, 0, 0, .15) 0 0 ${R(4)} inset`
            }]
        }))
    });
UM.displayName = "@mantine/core/AlphaSlider";
var Dte = Object.defineProperty,
    EC = Object.getOwnPropertySymbols,
    Nte = Object.prototype.hasOwnProperty,
    Lte = Object.prototype.propertyIsEnumerable,
    SC = (e, t, r) => t in e ? Dte(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    v0 = (e, t) => {
        for (var r in t || (t = {})) Nte.call(t, r) && SC(e, r, t[r]);
        if (EC)
            for (var r of EC(t)) Lte.call(t, r) && SC(e, r, t[r]);
        return e
    };
const Fte = {
    xs: R(100),
    sm: R(110),
    md: R(120),
    lg: R(140),
    xl: R(160)
};
var Bte = Pe((e, t, {
    size: r
}) => ({
    saturationThumb: {
        ref: ys("saturationThumb")
    },
    saturation: {
        boxSizing: "border-box",
        position: "relative",
        height: he({
            size: r,
            sizes: Fte
        }),
        borderRadius: e.radius.sm,
        margin: `calc(${he({size:r,sizes:Qn})} / 2)`,
        WebkitTapHighlightColor: "transparent",
        [`&:focus .${ys("saturationThumb")}`]: v0({}, e.focusRing === "always" || e.focusRing === "auto" ? e.focusRingStyles.styles(e) : e.focusRingStyles.resetStyles(e)),
        [`&:focus:not(:focus-visible) .${ys("saturationThumb")}`]: v0({}, e.focusRing === "auto" || e.focusRing === "never" ? e.focusRingStyles.resetStyles(e) : null)
    },
    saturationOverlay: v0({
        boxSizing: "border-box",
        borderRadius: e.radius.sm
    }, e.fn.cover(`calc(${he({size:r,sizes:Qn})} * -1 / 2 - ${R(1)})`))
}));
const zte = Bte;

function HM({
    h: e,
    s: t,
    v: r,
    a: n
}) {
    const i = e / 360 * 6,
        s = t / 100,
        o = r / 100,
        a = Math.floor(i),
        l = o * (1 - s),
        c = o * (1 - (i - a) * s),
        u = o * (1 - (1 - i + a) * s),
        h = a % 6;
    return {
        r: Sn([o, c, l, l, u, o][h] * 255),
        g: Sn([u, o, o, c, l, l][h] * 255),
        b: Sn([l, l, u, o, o, c][h] * 255),
        a: Sn(n, 2)
    }
}

function PC(e, t) {
    const {
        r,
        g: n,
        b: i,
        a: s
    } = HM(e);
    return t ? `rgba(${r}, ${n}, ${i}, ${Sn(s,2)})` : `rgb(${r}, ${n}, ${i})`
}

function CC({
    h: e,
    s: t,
    v: r,
    a: n
}, i) {
    const s = (200 - t) * r / 100,
        o = {
            h: Math.round(e),
            s: Math.round(s > 0 && s < 200 ? t * r / 100 / (s <= 100 ? s : 200 - s) * 100 : 0),
            l: Math.round(s / 2)
        };
    return i ? `hsla(${o.h}, ${o.s}%, ${o.l}%, ${Sn(n,2)})` : `hsl(${o.h}, ${o.s}%, ${o.l}%)`
}

function Fd(e) {
    const t = e.toString(16);
    return t.length < 2 ? `0${t}` : t
}

function GM(e) {
    const {
        r: t,
        g: r,
        b: n
    } = HM(e);
    return `#${Fd(t)}${Fd(r)}${Fd(n)}`
}

function jte(e) {
    const t = Math.round(e.a * 255);
    return `${GM(e)}${Fd(t)}`
}
const y0 = {
    hex: GM,
    hexa: e => jte(e),
    rgb: e => PC(e, !1),
    rgba: e => PC(e, !0),
    hsl: e => CC(e, !1),
    hsla: e => CC(e, !0)
};

function Ki(e, t) {
    return t ? e in y0 ? y0[e](t) : y0.hex(t) : "#000000"
}

function VM({
    value: e,
    onChange: t,
    onChangeEnd: r,
    focusable: n = !0,
    __staticSelector: i = "saturation",
    size: s,
    color: o,
    saturationLabel: a,
    classNames: l,
    styles: c,
    unstyled: u,
    variant: h
}) {
    const {
        classes: d
    } = zte(null, {
        classNames: l,
        styles: c,
        name: i,
        unstyled: u,
        variant: h,
        size: s
    }), [f, p] = b.useState({
        x: e.s / 100,
        y: 1 - e.v / 100
    }), m = b.useRef(f), {
        ref: w
    } = tk(({
        x: _,
        y: E
    }) => {
        m.current = {
            x: _,
            y: E
        }, t({
            s: Math.round(_ * 100),
            v: Math.round((1 - E) * 100)
        })
    }, {
        onScrubEnd: () => {
            const {
                x: _,
                y: E
            } = m.current;
            r({
                s: Math.round(_ * 100),
                v: Math.round((1 - E) * 100)
            })
        }
    });
    b.useEffect(() => {
        p({
            x: e.s / 100,
            y: 1 - e.v / 100
        })
    }, [e.s, e.v]);
    const y = (_, E) => {
            _.preventDefault();
            const P = ek(E);
            t({
                s: Math.round(P.x * 100),
                v: Math.round((1 - P.y) * 100)
            }), r({
                s: Math.round(P.x * 100),
                v: Math.round((1 - P.y) * 100)
            })
        },
        v = _ => {
            switch (_.key) {
                case "ArrowUp":
                    {
                        y(_, {
                            y: f.y - .05,
                            x: f.x
                        });
                        break
                    }
                case "ArrowDown":
                    {
                        y(_, {
                            y: f.y + .05,
                            x: f.x
                        });
                        break
                    }
                case "ArrowRight":
                    {
                        y(_, {
                            x: f.x + .05,
                            y: f.y
                        });
                        break
                    }
                case "ArrowLeft":
                    {
                        y(_, {
                            x: f.x - .05,
                            y: f.y
                        });
                        break
                    }
            }
        };
    return I.createElement("div", {
        className: d.saturation,
        ref: w,
        role: "slider",
        "aria-label": a,
        "aria-valuenow": f.x,
        "aria-valuetext": Ki("rgba", e),
        tabIndex: n ? 0 : -1,
        onKeyDown: v
    }, I.createElement("div", {
        className: d.saturationOverlay,
        style: {
            backgroundColor: `hsl(${e.h}, 100%, 50%)`
        }
    }), I.createElement("div", {
        className: d.saturationOverlay,
        style: {
            backgroundImage: "linear-gradient(90deg, #fff, transparent)"
        }
    }), I.createElement("div", {
        className: d.saturationOverlay,
        style: {
            backgroundImage: "linear-gradient(0deg, #000, transparent)"
        }
    }), I.createElement(Mw, {
        __staticSelector: i,
        classNames: l,
        styles: c,
        position: f,
        className: d.saturationThumb,
        style: {
            backgroundColor: o
        },
        size: s
    }))
}
VM.displayName = "@mantine/core/Saturation";
var Ute = Pe((e, {
    swatchesPerRow: t
}) => ({
    swatch: {
        width: `calc(${100/t}% - ${R(4)})`,
        height: 0,
        paddingBottom: `calc(${100/t}% - ${R(4)})`,
        margin: R(2),
        boxSizing: "content-box"
    },
    swatches: {
        boxSizing: "border-box",
        marginLeft: R(-2),
        marginRight: R(-2),
        display: "flex",
        flexWrap: "wrap"
    }
}));
const Hte = Ute;
var Gte = Object.defineProperty,
    Tp = Object.getOwnPropertySymbols,
    WM = Object.prototype.hasOwnProperty,
    XM = Object.prototype.propertyIsEnumerable,
    TC = (e, t, r) => t in e ? Gte(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Vte = (e, t) => {
        for (var r in t || (t = {})) WM.call(t, r) && TC(e, r, t[r]);
        if (Tp)
            for (var r of Tp(t)) XM.call(t, r) && TC(e, r, t[r]);
        return e
    },
    Wte = (e, t) => {
        var r = {};
        for (var n in e) WM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Tp)
            for (var n of Tp(e)) t.indexOf(n) < 0 && XM.call(e, n) && (r[n] = e[n]);
        return r
    };

function YM(e) {
    var t = e,
        {
            data: r,
            swatchesPerRow: n = 10,
            focusable: i = !0,
            classNames: s,
            styles: o,
            __staticSelector: a = "color-picker",
            unstyled: l,
            setValue: c,
            onChangeEnd: u,
            variant: h,
            size: d
        } = t,
        f = Wte(t, ["data", "swatchesPerRow", "focusable", "classNames", "styles", "__staticSelector", "unstyled", "setValue", "onChangeEnd", "variant", "size"]);
    const {
        classes: p
    } = Hte({
        swatchesPerRow: n
    }, {
        classNames: s,
        styles: o,
        name: a,
        unstyled: l,
        variant: h,
        size: d
    }), m = r.map((w, y) => I.createElement(kM, {
        className: p.swatch,
        component: "button",
        type: "button",
        color: w,
        key: y,
        radius: "sm",
        onClick: () => {
            c(w), u == null || u(w)
        },
        style: {
            cursor: "pointer"
        },
        "aria-label": w,
        tabIndex: i ? 0 : -1
    }));
    return I.createElement("div", Vte({
        className: p.swatches
    }, f), m)
}
YM.displayName = "@mantine/core/Swatches";
const Xte = {
    xs: R(180),
    sm: R(200),
    md: R(240),
    lg: R(280),
    xl: R(320)
};
var Yte = Pe((e, {
    fullWidth: t
}, {
    size: r
}) => ({
    preview: {},
    wrapper: {
        boxSizing: "border-box",
        width: t ? "100%" : he({
            size: r,
            sizes: Xte
        }),
        padding: R(1)
    },
    body: {
        display: "flex",
        boxSizing: "border-box",
        paddingTop: `calc(${he({size:r,sizes:e.spacing})} / 2)`
    },
    sliders: {
        flex: 1,
        boxSizing: "border-box",
        "&:not(:only-child)": {
            marginRight: e.spacing.xs
        }
    },
    slider: {
        boxSizing: "border-box",
        "& + &": {
            marginTop: R(5)
        }
    },
    swatch: {
        cursor: "pointer"
    }
}));
const Kte = Yte;
var qte = Object.defineProperty,
    Qte = Object.defineProperties,
    Zte = Object.getOwnPropertyDescriptors,
    Op = Object.getOwnPropertySymbols,
    KM = Object.prototype.hasOwnProperty,
    qM = Object.prototype.propertyIsEnumerable,
    OC = (e, t, r) => t in e ? qte(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    ta = (e, t) => {
        for (var r in t || (t = {})) KM.call(t, r) && OC(e, r, t[r]);
        if (Op)
            for (var r of Op(t)) qM.call(t, r) && OC(e, r, t[r]);
        return e
    },
    _0 = (e, t) => Qte(e, Zte(t)),
    Jte = (e, t) => {
        var r = {};
        for (var n in e) KM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Op)
            for (var n of Op(e)) t.indexOf(n) < 0 && qM.call(e, n) && (r[n] = e[n]);
        return r
    };
const ere = {
        xs: 26,
        sm: 34,
        md: 42,
        lg: 50,
        xl: 54
    },
    tre = {
        swatchesPerRow: 10,
        size: "sm",
        withPicker: !0,
        focusable: !0,
        __staticSelector: "ColorPicker"
    },
    QM = b.forwardRef((e, t) => {
        const r = ve("ColorPicker", tre, e),
            {
                value: n,
                defaultValue: i,
                onChange: s,
                onChangeEnd: o,
                format: a,
                swatches: l,
                swatchesPerRow: c,
                size: u,
                withPicker: h,
                fullWidth: d,
                focusable: f,
                __staticSelector: p,
                saturationLabel: m,
                hueLabel: w,
                alphaLabel: y,
                className: v,
                styles: _,
                classNames: E,
                unstyled: P,
                onColorSwatchClick: C,
                variant: T
            } = r,
            O = Jte(r, ["value", "defaultValue", "onChange", "onChangeEnd", "format", "swatches", "swatchesPerRow", "size", "withPicker", "fullWidth", "focusable", "__staticSelector", "saturationLabel", "hueLabel", "alphaLabel", "className", "styles", "classNames", "unstyled", "onColorSwatchClick", "variant"]),
            {
                classes: k,
                cx: D
            } = Kte({
                fullWidth: d
            }, {
                classNames: E,
                styles: _,
                name: p,
                unstyled: P,
                variant: T,
                size: u
            }),
            B = b.useRef(a),
            j = b.useRef(null),
            L = b.useRef(!0),
            M = a === "hexa" || a === "rgba" || a === "hsla",
            [W, Z, q] = Au({
                value: n,
                defaultValue: i,
                finalValue: "#FFFFFF",
                onChange: s
            }),
            [G, X] = b.useState(ed(W)),
            z = Q => {
                L.current = !1, X(ie => {
                    const _e = ta(ta({}, ie), Q);
                    return j.current = Ki(B.current, _e), _e
                }), Z(j.current), setTimeout(() => {
                    L.current = !0
                }, 0)
            };
        return sn(() => {
            Tte(n) && L.current && (X(ed(n)), L.current = !0)
        }, [n]), sn(() => {
            B.current = a, Z(Ki(a, G))
        }, [a]), I.createElement(Ie, ta({
            className: D(k.wrapper, v),
            ref: t
        }, O), h && I.createElement(I.Fragment, null, I.createElement(VM, {
            value: G,
            onChange: z,
            onChangeEnd: ({
                s: Q,
                v: ie
            }) => o == null ? void 0 : o(Ki(B.current, _0(ta({}, G), {
                s: Q,
                v: ie
            }))),
            color: W,
            styles: _,
            classNames: E,
            size: u,
            focusable: f,
            saturationLabel: m,
            __staticSelector: p
        }), I.createElement("div", {
            className: k.body
        }, I.createElement("div", {
            className: k.sliders
        }, I.createElement(FM, {
            value: G.h,
            onChange: Q => z({
                h: Q
            }),
            onChangeEnd: Q => o == null ? void 0 : o(Ki(B.current, _0(ta({}, G), {
                h: Q
            }))),
            size: u,
            styles: _,
            classNames: E,
            focusable: f,
            "aria-label": w,
            __staticSelector: p
        }), M && I.createElement(UM, {
            value: G.a,
            onChange: Q => z({
                a: Q
            }),
            onChangeEnd: Q => {
                o == null || o(Ki(B.current, _0(ta({}, G), {
                    a: Q
                })))
            },
            size: u,
            color: Ki("hex", G),
            style: {
                marginTop: R(6)
            },
            styles: _,
            classNames: E,
            focusable: f,
            "aria-label": y,
            __staticSelector: p
        })), M && I.createElement(kM, {
            color: W,
            radius: "sm",
            size: he({
                size: u,
                sizes: ere
            }),
            className: k.preview
        }))), Array.isArray(l) && I.createElement(YM, {
            data: l,
            style: {
                marginTop: R(5)
            },
            swatchesPerRow: c,
            focusable: f,
            classNames: E,
            styles: _,
            __staticSelector: p,
            setValue: Z,
            onChangeEnd: Q => {
                const ie = Ki(a, ed(Q));
                C == null || C(ie), o == null || o(ie), q || X(ed(Q))
            }
        }))
    });
QM.displayName = "@mantine/core/ColorPicker";
const [rre, wl] = ml("ModalBase component was not found in tree");
var nre = Pe(() => ({
    close: {
        marginLeft: "auto",
        marginRight: 0
    }
}));
const ire = nre;
var sre = Object.defineProperty,
    Ap = Object.getOwnPropertySymbols,
    ZM = Object.prototype.hasOwnProperty,
    JM = Object.prototype.propertyIsEnumerable,
    AC = (e, t, r) => t in e ? sre(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    ore = (e, t) => {
        for (var r in t || (t = {})) ZM.call(t, r) && AC(e, r, t[r]);
        if (Ap)
            for (var r of Ap(t)) JM.call(t, r) && AC(e, r, t[r]);
        return e
    },
    are = (e, t) => {
        var r = {};
        for (var n in e) ZM.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Ap)
            for (var n of Ap(e)) t.indexOf(n) < 0 && JM.call(e, n) && (r[n] = e[n]);
        return r
    };
const lre = {
        size: "sm"
    },
    cre = b.forwardRef((e, t) => {
        const r = wl(),
            n = ve(`${r.__staticSelector}CloseButton`, lre, e),
            {
                className: i
            } = n,
            s = are(n, ["className"]),
            {
                classes: o,
                cx: a
            } = ire(null, r.stylesApi);
        return I.createElement(Gk, ore({
            className: a(o.close, i),
            ref: t,
            onClick: r.onClose
        }, s))
    });
var ure = Pe(() => ({
    overlay: {}
}));
const hre = ure;
var dre = Object.defineProperty,
    fre = Object.defineProperties,
    pre = Object.getOwnPropertyDescriptors,
    IC = Object.getOwnPropertySymbols,
    mre = Object.prototype.hasOwnProperty,
    gre = Object.prototype.propertyIsEnumerable,
    $C = (e, t, r) => t in e ? dre(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    vre = (e, t) => {
        for (var r in t || (t = {})) mre.call(t, r) && $C(e, r, t[r]);
        if (IC)
            for (var r of IC(t)) gre.call(t, r) && $C(e, r, t[r]);
        return e
    },
    yre = (e, t) => fre(e, pre(t)),
    _re = Pe((e, {
        color: t,
        opacity: r,
        blur: n,
        radius: i,
        gradient: s,
        fixed: o,
        zIndex: a
    }) => ({
        root: yre(vre({}, e.fn.cover(0)), {
            position: o ? "fixed" : "absolute",
            backgroundColor: s ? void 0 : e.fn.rgba(t, r),
            backgroundImage: s,
            backdropFilter: n ? `blur(${R(n)})` : void 0,
            borderRadius: e.fn.radius(i),
            zIndex: a,
            "&[data-center]": {
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
            }
        })
    }));
const wre = _re;
var bre = Object.defineProperty,
    Ip = Object.getOwnPropertySymbols,
    e5 = Object.prototype.hasOwnProperty,
    t5 = Object.prototype.propertyIsEnumerable,
    RC = (e, t, r) => t in e ? bre(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    xre = (e, t) => {
        for (var r in t || (t = {})) e5.call(t, r) && RC(e, r, t[r]);
        if (Ip)
            for (var r of Ip(t)) t5.call(t, r) && RC(e, r, t[r]);
        return e
    },
    Ere = (e, t) => {
        var r = {};
        for (var n in e) e5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Ip)
            for (var n of Ip(e)) t.indexOf(n) < 0 && t5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Sre = {
        opacity: .6,
        color: "#000",
        zIndex: $s("modal"),
        radius: 0
    },
    r5 = b.forwardRef((e, t) => {
        const r = ve("Overlay", Sre, e),
            {
                variant: n,
                opacity: i,
                color: s,
                blur: o,
                gradient: a,
                zIndex: l,
                radius: c,
                children: u,
                className: h,
                classNames: d,
                styles: f,
                unstyled: p,
                center: m,
                fixed: w
            } = r,
            y = Ere(r, ["variant", "opacity", "color", "blur", "gradient", "zIndex", "radius", "children", "className", "classNames", "styles", "unstyled", "center", "fixed"]),
            {
                classes: v,
                cx: _
            } = wre({
                color: s,
                opacity: i,
                blur: o,
                radius: c,
                gradient: a,
                fixed: w,
                zIndex: l
            }, {
                name: "Overlay",
                classNames: d,
                styles: f,
                unstyled: p,
                variant: n
            });
        return I.createElement(Ie, xre({
            ref: t,
            className: _(v.root, h),
            "data-center": m || void 0
        }, y), u)
    });
r5.displayName = "@mantine/core/Overlay";
const n5 = r5;
var Pre = Object.defineProperty,
    Cre = Object.defineProperties,
    Tre = Object.getOwnPropertyDescriptors,
    $p = Object.getOwnPropertySymbols,
    i5 = Object.prototype.hasOwnProperty,
    s5 = Object.prototype.propertyIsEnumerable,
    kC = (e, t, r) => t in e ? Pre(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Zl = (e, t) => {
        for (var r in t || (t = {})) i5.call(t, r) && kC(e, r, t[r]);
        if ($p)
            for (var r of $p(t)) s5.call(t, r) && kC(e, r, t[r]);
        return e
    },
    Ore = (e, t) => Cre(e, Tre(t)),
    Are = (e, t) => {
        var r = {};
        for (var n in e) i5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && $p)
            for (var n of $p(e)) t.indexOf(n) < 0 && s5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Ire = {},
    $re = b.forwardRef((e, t) => {
        const r = wl(),
            n = ve(`${r.__staticSelector}Overlay`, Ire, e),
            {
                onClick: i,
                transitionProps: s,
                style: o,
                className: a
            } = n,
            l = Are(n, ["onClick", "transitionProps", "style", "className"]),
            {
                classes: c,
                cx: u
            } = hre(null, r.stylesApi),
            h = d => {
                i == null || i(d), r.closeOnClickOutside && r.onClose()
            };
        return I.createElement(_l, Ore(Zl(Zl({
            mounted: r.opened
        }, r.transitionProps), s), {
            transition: "fade"
        }), d => I.createElement(n5, Zl({
            ref: t,
            onClick: h,
            fixed: !0,
            style: Zl(Zl({}, o), d),
            className: u(c.overlay, a),
            zIndex: r.zIndex
        }, l)))
    });
var Rre = Pe((e, {
    zIndex: t
}) => ({
    inner: {
        position: "fixed",
        width: "100%",
        top: 0,
        bottom: 0,
        maxHeight: "100%",
        zIndex: t,
        pointerEvents: "none"
    },
    content: {
        pointerEvents: "all"
    }
}));
const kre = Rre;
var Mre = Object.defineProperty,
    Rp = Object.getOwnPropertySymbols,
    o5 = Object.prototype.hasOwnProperty,
    a5 = Object.prototype.propertyIsEnumerable,
    MC = (e, t, r) => t in e ? Mre(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Jl = (e, t) => {
        for (var r in t || (t = {})) o5.call(t, r) && MC(e, r, t[r]);
        if (Rp)
            for (var r of Rp(t)) a5.call(t, r) && MC(e, r, t[r]);
        return e
    },
    Dre = (e, t) => {
        var r = {};
        for (var n in e) o5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Rp)
            for (var n of Rp(e)) t.indexOf(n) < 0 && a5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Nre = {},
    Lre = b.forwardRef((e, t) => {
        const r = wl(),
            n = ve(`${r.__staticSelector}Content`, Nre, e),
            {
                className: i,
                transitionProps: s,
                style: o,
                onKeyDown: a
            } = n,
            l = Dre(n, ["className", "transitionProps", "style", "onKeyDown"]),
            {
                classes: c,
                cx: u
            } = kre({
                zIndex: r.zIndex + 1
            }, r.stylesApi),
            h = d => {
                var f;
                ((f = d.target) == null ? void 0 : f.getAttribute("data-mantine-stop-propagation")) !== "true" && d.key === "Escape" && r.closeOnEscape && r.onClose(), a == null || a(d)
            };
        return I.createElement(_l, Jl(Jl({
            mounted: r.opened,
            transition: "pop"
        }, r.transitionProps), s), d => I.createElement("div", {
            className: u(c.inner)
        }, I.createElement(Pw, {
            active: r.opened && r.trapFocus
        }, I.createElement($w, Jl({
            component: "section",
            role: "dialog",
            tabIndex: -1,
            "aria-modal": !0,
            "aria-describedby": r.bodyMounted ? r.getBodyId() : void 0,
            "aria-labelledby": r.titleMounted ? r.getTitleId() : void 0,
            onKeyDown: h,
            ref: t,
            className: u(c.content, i),
            style: Jl(Jl({}, o), d),
            shadow: r.shadow
        }, l), l.children))))
    });
var Fre = Pe((e, {
    padding: t
}) => {
    const r = he({
        size: t,
        sizes: e.spacing
    });
    return {
        header: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            padding: r,
            paddingRight: `calc(${r} - ${R(5)})`,
            position: "sticky",
            top: 0,
            backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
            zIndex: 1e3
        }
    }
});
const Bre = Fre;
var zre = Object.defineProperty,
    kp = Object.getOwnPropertySymbols,
    l5 = Object.prototype.hasOwnProperty,
    c5 = Object.prototype.propertyIsEnumerable,
    DC = (e, t, r) => t in e ? zre(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    jre = (e, t) => {
        for (var r in t || (t = {})) l5.call(t, r) && DC(e, r, t[r]);
        if (kp)
            for (var r of kp(t)) c5.call(t, r) && DC(e, r, t[r]);
        return e
    },
    Ure = (e, t) => {
        var r = {};
        for (var n in e) l5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && kp)
            for (var n of kp(e)) t.indexOf(n) < 0 && c5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Hre = {},
    Gre = b.forwardRef((e, t) => {
        const r = wl(),
            n = ve(`${r.__staticSelector}Header`, Hre, e),
            {
                className: i
            } = n,
            s = Ure(n, ["className"]),
            {
                classes: o,
                cx: a
            } = Bre({
                padding: r.padding
            }, r.stylesApi);
        return I.createElement(Ie, jre({
            ref: t,
            className: a(o.header, i)
        }, s))
    });
var Vre = Pe(e => ({
    title: {
        lineHeight: 1,
        padding: 0,
        margin: 0,
        fontWeight: 400,
        fontSize: e.fontSizes.md
    }
}));
const Wre = Vre;
var Xre = Object.defineProperty,
    Mp = Object.getOwnPropertySymbols,
    u5 = Object.prototype.hasOwnProperty,
    h5 = Object.prototype.propertyIsEnumerable,
    NC = (e, t, r) => t in e ? Xre(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Yre = (e, t) => {
        for (var r in t || (t = {})) u5.call(t, r) && NC(e, r, t[r]);
        if (Mp)
            for (var r of Mp(t)) h5.call(t, r) && NC(e, r, t[r]);
        return e
    },
    Kre = (e, t) => {
        var r = {};
        for (var n in e) u5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Mp)
            for (var n of Mp(e)) t.indexOf(n) < 0 && h5.call(e, n) && (r[n] = e[n]);
        return r
    };
const qre = {},
    Qre = b.forwardRef((e, t) => {
        const r = wl(),
            n = ve(`${r.__staticSelector}Title`, qre, e),
            {
                className: i
            } = n,
            s = Kre(n, ["className"]),
            {
                classes: o,
                cx: a
            } = Wre(null, r.stylesApi);
        return b.useEffect(() => (r.setTitleMounted(!0), () => r.setTitleMounted(!1)), []), I.createElement(Ie, Yre({
            component: "h2",
            id: r.getTitleId(),
            className: a(o.title, i),
            ref: t
        }, s))
    });
var Zre = Pe((e, {
    padding: t
}) => ({
    body: {
        padding: he({
            size: t,
            sizes: e.spacing
        }),
        "&:not(:only-child)": {
            paddingTop: 0
        }
    }
}));
const Jre = Zre;
var ene = Object.defineProperty,
    Dp = Object.getOwnPropertySymbols,
    d5 = Object.prototype.hasOwnProperty,
    f5 = Object.prototype.propertyIsEnumerable,
    LC = (e, t, r) => t in e ? ene(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    tne = (e, t) => {
        for (var r in t || (t = {})) d5.call(t, r) && LC(e, r, t[r]);
        if (Dp)
            for (var r of Dp(t)) f5.call(t, r) && LC(e, r, t[r]);
        return e
    },
    rne = (e, t) => {
        var r = {};
        for (var n in e) d5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Dp)
            for (var n of Dp(e)) t.indexOf(n) < 0 && f5.call(e, n) && (r[n] = e[n]);
        return r
    };
const nne = {},
    ine = b.forwardRef((e, t) => {
        const r = wl(),
            n = ve(`${r.__staticSelector}Body`, nne, e),
            {
                className: i
            } = n,
            s = rne(n, ["className"]),
            {
                classes: o,
                cx: a
            } = Jre({
                padding: r.padding
            }, r.stylesApi);
        return b.useEffect(() => (r.setBodyMounted(!0), () => r.setBodyMounted(!1)), []), I.createElement(Ie, tne({
            id: r.getBodyId(),
            className: a(o.body, i),
            ref: t
        }, s))
    });

function sne({
    children: e
}) {
    return I.createElement(I.Fragment, null, e)
}

function one({
    opened: e,
    transitionDuration: t
}) {
    const [r, n] = b.useState(e), i = b.useRef(), o = lg() ? 0 : t;
    return b.useEffect(() => (e ? (n(!0), window.clearTimeout(i.current)) : o === 0 ? n(!1) : i.current = window.setTimeout(() => n(!1), o), () => window.clearTimeout(i.current)), [e, o]), r
}
var ane = Pe(() => ({
    root: {}
}));
const lne = ane;
var cne = Object.defineProperty,
    une = Object.defineProperties,
    hne = Object.getOwnPropertyDescriptors,
    Np = Object.getOwnPropertySymbols,
    p5 = Object.prototype.hasOwnProperty,
    m5 = Object.prototype.propertyIsEnumerable,
    FC = (e, t, r) => t in e ? cne(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    w0 = (e, t) => {
        for (var r in t || (t = {})) p5.call(t, r) && FC(e, r, t[r]);
        if (Np)
            for (var r of Np(t)) m5.call(t, r) && FC(e, r, t[r]);
        return e
    },
    BC = (e, t) => une(e, hne(t)),
    dne = (e, t) => {
        var r = {};
        for (var n in e) p5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Np)
            for (var n of Np(e)) t.indexOf(n) < 0 && m5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Nw = {
    closeOnClickOutside: !0,
    withinPortal: !0,
    lockScroll: !0,
    trapFocus: !0,
    returnFocus: !0,
    closeOnEscape: !0,
    keepMounted: !1,
    zIndex: $s("modal"),
    padding: "md",
    size: "md",
    shadow: "xl"
};

function Ot(e) {
    const t = ve("ModalBase", Nw, e),
        {
            opened: r,
            onClose: n,
            children: i,
            closeOnClickOutside: s,
            __staticSelector: o,
            transitionProps: a,
            withinPortal: l,
            portalProps: c,
            keepMounted: u,
            target: h,
            zIndex: d,
            lockScroll: f,
            trapFocus: p,
            closeOnEscape: m,
            returnFocus: w,
            padding: y,
            shadow: v,
            id: _,
            size: E,
            variant: P,
            classNames: C,
            unstyled: T,
            styles: O,
            className: k
        } = t,
        D = dne(t, ["opened", "onClose", "children", "closeOnClickOutside", "__staticSelector", "transitionProps", "withinPortal", "portalProps", "keepMounted", "target", "zIndex", "lockScroll", "trapFocus", "closeOnEscape", "returnFocus", "padding", "shadow", "id", "size", "variant", "classNames", "unstyled", "styles", "className"]),
        {
            classes: B,
            cx: j
        } = lne(null, {
            name: o,
            classNames: C,
            styles: O,
            unstyled: T,
            variant: P,
            size: E
        }),
        L = Ou(_),
        [M, W] = b.useState(!1),
        [Z, q] = b.useState(!1),
        G = typeof(a == null ? void 0 : a.duration) == "number" ? a == null ? void 0 : a.duration : 200,
        X = one({
            opened: r,
            transitionDuration: G
        });
    return ou("keydown", z => {
        !p && z.key === "Escape" && m && n()
    }), KR({
        opened: r,
        shouldReturnFocus: p && w
    }), I.createElement(vl, BC(w0({}, c), {
        withinPortal: l,
        target: h
    }), I.createElement(rre, {
        value: {
            __staticSelector: o,
            opened: r,
            onClose: n,
            closeOnClickOutside: s,
            transitionProps: BC(w0({}, a), {
                duration: G,
                keepMounted: u
            }),
            zIndex: d,
            padding: y,
            id: L,
            getTitleId: () => `${L}-title`,
            getBodyId: () => `${L}-body`,
            titleMounted: M,
            bodyMounted: Z,
            setTitleMounted: W,
            setBodyMounted: q,
            trapFocus: p,
            closeOnEscape: m,
            shadow: v,
            stylesApi: {
                name: o,
                size: E,
                variant: P,
                classNames: C,
                styles: O,
                unstyled: T
            }
        }
    }, I.createElement(xG, {
        enabled: X && f
    }, I.createElement(Ie, w0({
        className: j(B.root, k)
    }, D), i))))
}
Ot.CloseButton = cre;
Ot.Overlay = $re;
Ot.Content = Lre;
Ot.Header = Gre;
Ot.Title = Qre;
Ot.Body = ine;
Ot.NativeScrollArea = sne;
var fne = Object.defineProperty,
    Lp = Object.getOwnPropertySymbols,
    g5 = Object.prototype.hasOwnProperty,
    v5 = Object.prototype.propertyIsEnumerable,
    zC = (e, t, r) => t in e ? fne(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    jC = (e, t) => {
        for (var r in t || (t = {})) g5.call(t, r) && zC(e, r, t[r]);
        if (Lp)
            for (var r of Lp(t)) v5.call(t, r) && zC(e, r, t[r]);
        return e
    },
    pne = (e, t) => {
        var r = {};
        for (var n in e) g5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Lp)
            for (var n of Lp(e)) t.indexOf(n) < 0 && v5.call(e, n) && (r[n] = e[n]);
        return r
    };
const mne = {
        multiple: !1
    },
    y5 = b.forwardRef((e, t) => {
        const r = ve("FileButton", mne, e),
            {
                onChange: n,
                children: i,
                multiple: s,
                accept: o,
                name: a,
                form: l,
                resetRef: c,
                disabled: u,
                capture: h,
                inputProps: d
            } = r,
            f = pne(r, ["onChange", "children", "multiple", "accept", "name", "form", "resetRef", "disabled", "capture", "inputProps"]),
            p = b.useRef(),
            m = () => {
                !u && p.current.click()
            },
            w = v => {
                n(s ? Array.from(v.currentTarget.files) : v.currentTarget.files[0] || null)
            };
        return mw(c, () => {
            p.current.value = ""
        }), I.createElement(I.Fragment, null, i(jC({
            onClick: m
        }, f)), I.createElement("input", jC({
            style: {
                display: "none"
            },
            type: "file",
            accept: o,
            multiple: s,
            onChange: w,
            ref: Oo(t, p),
            name: a,
            form: l,
            capture: h
        }, d)))
    });
y5.displayName = "@mantine/core/FileButton";
const gne = {
    gap: {
        type: "spacing",
        property: "gap"
    },
    rowGap: {
        type: "spacing",
        property: "rowGap"
    },
    columnGap: {
        type: "spacing",
        property: "columnGap"
    },
    align: {
        type: "identity",
        property: "alignItems"
    },
    justify: {
        type: "identity",
        property: "justifyContent"
    },
    wrap: {
        type: "identity",
        property: "flexWrap"
    },
    direction: {
        type: "identity",
        property: "flexDirection"
    }
};
var vne = Object.defineProperty,
    yne = Object.defineProperties,
    _ne = Object.getOwnPropertyDescriptors,
    Fp = Object.getOwnPropertySymbols,
    _5 = Object.prototype.hasOwnProperty,
    w5 = Object.prototype.propertyIsEnumerable,
    UC = (e, t, r) => t in e ? vne(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    wne = (e, t) => {
        for (var r in t || (t = {})) _5.call(t, r) && UC(e, r, t[r]);
        if (Fp)
            for (var r of Fp(t)) w5.call(t, r) && UC(e, r, t[r]);
        return e
    },
    bne = (e, t) => yne(e, _ne(t)),
    xne = (e, t) => {
        var r = {};
        for (var n in e) _5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Fp)
            for (var n of Fp(e)) t.indexOf(n) < 0 && w5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Ene = {},
    R_ = b.forwardRef((e, t) => {
        const r = ve("Flex", Ene, e),
            {
                gap: n,
                rowGap: i,
                columnGap: s,
                align: o,
                justify: a,
                wrap: l,
                direction: c,
                sx: u
            } = r,
            h = xne(r, ["gap", "rowGap", "columnGap", "align", "justify", "wrap", "direction", "sx"]);
        return I.createElement(Ie, bne(wne({}, h), {
            sx: [{
                display: "flex"
            }, d => y_({
                gap: n,
                rowGap: i,
                columnGap: s,
                align: o,
                justify: a,
                wrap: l,
                direction: c
            }, d, gne), ...Wm(u)],
            ref: t
        }))
    });
R_.displayName = "@mantine/core/Flex";

function Sne(e) {
    return b.Children.toArray(e).filter(Boolean)
}
const Pne = {
    left: "flex-start",
    center: "center",
    right: "flex-end",
    apart: "space-between"
};
var Cne = Pe((e, {
    spacing: t,
    position: r,
    noWrap: n,
    grow: i,
    align: s,
    count: o
}) => ({
    root: {
        boxSizing: "border-box",
        display: "flex",
        flexDirection: "row",
        alignItems: s || "center",
        flexWrap: n ? "nowrap" : "wrap",
        justifyContent: Pne[r],
        gap: he({
            size: t,
            sizes: e.spacing
        }),
        "& > *": {
            boxSizing: "border-box",
            maxWidth: i ? `calc(${100/o}% - (${R(he({size:t,sizes:e.spacing}))} - ${he({size:t,sizes:e.spacing})} / ${o}))` : void 0,
            flexGrow: i ? 1 : 0
        }
    }
}));
const Tne = Cne;
var One = Object.defineProperty,
    Bp = Object.getOwnPropertySymbols,
    b5 = Object.prototype.hasOwnProperty,
    x5 = Object.prototype.propertyIsEnumerable,
    HC = (e, t, r) => t in e ? One(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Ane = (e, t) => {
        for (var r in t || (t = {})) b5.call(t, r) && HC(e, r, t[r]);
        if (Bp)
            for (var r of Bp(t)) x5.call(t, r) && HC(e, r, t[r]);
        return e
    },
    Ine = (e, t) => {
        var r = {};
        for (var n in e) b5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Bp)
            for (var n of Bp(e)) t.indexOf(n) < 0 && x5.call(e, n) && (r[n] = e[n]);
        return r
    };
const $ne = {
        position: "left",
        spacing: "md"
    },
    co = b.forwardRef((e, t) => {
        const r = ve("Group", $ne, e),
            {
                className: n,
                position: i,
                align: s,
                children: o,
                noWrap: a,
                grow: l,
                spacing: c,
                unstyled: u,
                variant: h
            } = r,
            d = Ine(r, ["className", "position", "align", "children", "noWrap", "grow", "spacing", "unstyled", "variant"]),
            f = Sne(o),
            {
                classes: p,
                cx: m
            } = Tne({
                align: s,
                grow: l,
                noWrap: a,
                spacing: c,
                position: i,
                count: f.length
            }, {
                unstyled: u,
                name: "Group",
                variant: h
            });
        return I.createElement(Ie, Ane({
            className: m(p.root, n),
            ref: t
        }, d), f)
    });
co.displayName = "@mantine/core/Group";

function E5(e, t) {
    if (e == null) return {};
    var r = {},
        n = Object.keys(e),
        i, s;
    for (s = 0; s < n.length; s++) i = n[s], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
    return r
}
var Rne = Object.defineProperty,
    kne = Object.defineProperties,
    Mne = Object.getOwnPropertyDescriptors,
    GC = Object.getOwnPropertySymbols,
    Dne = Object.prototype.hasOwnProperty,
    Nne = Object.prototype.propertyIsEnumerable,
    VC = (e, t, r) => t in e ? Rne(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Lne = (e, t) => {
        for (var r in t || (t = {})) Dne.call(t, r) && VC(e, r, t[r]);
        if (GC)
            for (var r of GC(t)) Nne.call(t, r) && VC(e, r, t[r]);
        return e
    },
    Fne = (e, t) => kne(e, Mne(t)),
    Bne = Pe(e => ({
        root: Fne(Lne({}, e.fn.cover()), {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            overflow: "hidden"
        })
    }));
const zne = Bne;
var jne = Object.defineProperty,
    Une = Object.defineProperties,
    Hne = Object.getOwnPropertyDescriptors,
    zp = Object.getOwnPropertySymbols,
    S5 = Object.prototype.hasOwnProperty,
    P5 = Object.prototype.propertyIsEnumerable,
    WC = (e, t, r) => t in e ? jne(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    td = (e, t) => {
        for (var r in t || (t = {})) S5.call(t, r) && WC(e, r, t[r]);
        if (zp)
            for (var r of zp(t)) P5.call(t, r) && WC(e, r, t[r]);
        return e
    },
    Gne = (e, t) => Une(e, Hne(t)),
    Vne = (e, t) => {
        var r = {};
        for (var n in e) S5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && zp)
            for (var n of zp(e)) t.indexOf(n) < 0 && P5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Wne = {
        overlayOpacity: .75,
        transitionDuration: 0,
        radius: 0,
        zIndex: $s("overlay")
    },
    C5 = b.forwardRef((e, t) => {
        const r = ve("LoadingOverlay", Wne, e),
            {
                className: n,
                visible: i,
                loaderProps: s,
                overlayOpacity: o,
                overlayColor: a,
                transitionDuration: l,
                exitTransitionDuration: c,
                zIndex: u,
                style: h,
                loader: d,
                radius: f,
                overlayBlur: p,
                unstyled: m,
                variant: w,
                keepMounted: y
            } = r,
            v = Vne(r, ["className", "visible", "loaderProps", "overlayOpacity", "overlayColor", "transitionDuration", "exitTransitionDuration", "zIndex", "style", "loader", "radius", "overlayBlur", "unstyled", "variant", "keepMounted"]),
            {
                classes: _,
                cx: E,
                theme: P
            } = zne(null, {
                name: "LoadingOverlay",
                unstyled: m,
                variant: w
            }),
            C = `calc(${u} + 1)`;
        return I.createElement(_l, {
            keepMounted: y,
            duration: l,
            exitDuration: c,
            mounted: i,
            transition: "fade"
        }, T => I.createElement(Ie, td({
            className: E(_.root, n),
            style: Gne(td(td({}, T), h), {
                zIndex: u
            }),
            ref: t
        }, v), d ? I.createElement("div", {
            style: {
                zIndex: C
            }
        }, d) : I.createElement(Ao, td({
            style: {
                zIndex: C
            }
        }, s)), I.createElement(n5, {
            opacity: o,
            zIndex: u,
            radius: f,
            blur: p,
            unstyled: m,
            color: a || (P.colorScheme === "dark" ? P.colors.dark[5] : P.white)
        })))
    });
C5.displayName = "@mantine/core/LoadingOverlay";
const [Xne, Yne] = ml("Modal component was not found in tree"), Kne = {
    xs: R(320),
    sm: R(380),
    md: R(440),
    lg: R(620),
    xl: R(780)
};
var qne = Pe((e, {
    yOffset: t,
    xOffset: r,
    centered: n,
    fullScreen: i
}, {
    size: s
}) => ({
    content: {
        flex: i ? "0 0 100%" : `0 0 ${he({size:s,sizes:Kne})}`,
        maxWidth: "100%",
        maxHeight: i ? void 0 : `calc(100vh - (${R(t)} * 2))`,
        height: i ? "100vh" : void 0,
        borderRadius: i ? 0 : void 0,
        overflowY: "auto"
    },
    inner: {
        paddingTop: i ? 0 : t,
        paddingBottom: i ? 0 : t,
        paddingLeft: i ? 0 : r,
        paddingRight: i ? 0 : r,
        display: "flex",
        justifyContent: "center",
        alignItems: n ? "center" : "flex-start"
    }
}));
const Qne = qne;
var Zne = Object.defineProperty,
    Jne = Object.defineProperties,
    eie = Object.getOwnPropertyDescriptors,
    jp = Object.getOwnPropertySymbols,
    T5 = Object.prototype.hasOwnProperty,
    O5 = Object.prototype.propertyIsEnumerable,
    XC = (e, t, r) => t in e ? Zne(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    k_ = (e, t) => {
        for (var r in t || (t = {})) T5.call(t, r) && XC(e, r, t[r]);
        if (jp)
            for (var r of jp(t)) O5.call(t, r) && XC(e, r, t[r]);
        return e
    },
    A5 = (e, t) => Jne(e, eie(t)),
    tie = (e, t) => {
        var r = {};
        for (var n in e) T5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && jp)
            for (var n of jp(e)) t.indexOf(n) < 0 && O5.call(e, n) && (r[n] = e[n]);
        return r
    };
const rie = A5(k_({}, Nw), {
    yOffset: "5vh",
    xOffset: "5vw"
});

function I5(e) {
    const t = ve("ModalRoot", rie, e),
        {
            classNames: r,
            variant: n,
            size: i,
            yOffset: s,
            xOffset: o,
            scrollAreaComponent: a,
            radius: l,
            centered: c,
            fullScreen: u
        } = t,
        h = tie(t, ["classNames", "variant", "size", "yOffset", "xOffset", "scrollAreaComponent", "radius", "centered", "fullScreen"]),
        {
            classes: d,
            cx: f
        } = Qne({
            yOffset: s,
            xOffset: o,
            centered: c,
            fullScreen: u
        }, {
            name: "Modal",
            variant: n,
            size: i
        });
    return I.createElement(Xne, {
        value: {
            yOffset: s,
            scrollAreaComponent: a,
            radius: l
        }
    }, I.createElement(Ot, k_({
        __staticSelector: "Modal",
        size: i,
        variant: n,
        classNames: A5(k_({}, r), {
            content: f(d.content, r == null ? void 0 : r.content),
            inner: f(d.inner, r == null ? void 0 : r.inner)
        })
    }, h)))
}
var nie = Object.defineProperty,
    Up = Object.getOwnPropertySymbols,
    $5 = Object.prototype.hasOwnProperty,
    R5 = Object.prototype.propertyIsEnumerable,
    YC = (e, t, r) => t in e ? nie(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    iie = (e, t) => {
        for (var r in t || (t = {})) $5.call(t, r) && YC(e, r, t[r]);
        if (Up)
            for (var r of Up(t)) R5.call(t, r) && YC(e, r, t[r]);
        return e
    },
    sie = (e, t) => {
        var r = {};
        for (var n in e) $5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Up)
            for (var n of Up(e)) t.indexOf(n) < 0 && R5.call(e, n) && (r[n] = e[n]);
        return r
    };
const oie = {
        shadow: "xl"
    },
    k5 = b.forwardRef((e, t) => {
        const r = ve("ModalContent", oie, e),
            {
                children: n,
                scrollAreaComponent: i
            } = r,
            s = sie(r, ["children", "scrollAreaComponent"]),
            o = Yne(),
            a = i || o.scrollAreaComponent || Ot.NativeScrollArea;
        return I.createElement(Ot.Content, iie({
            ref: t,
            radius: o.radius
        }, s), I.createElement(a, {
            style: {
                maxHeight: `calc(100vh - (${R(o.yOffset)} * 2))`
            }
        }, n))
    });
var aie = Object.defineProperty,
    lie = Object.defineProperties,
    cie = Object.getOwnPropertyDescriptors,
    Hp = Object.getOwnPropertySymbols,
    M5 = Object.prototype.hasOwnProperty,
    D5 = Object.prototype.propertyIsEnumerable,
    KC = (e, t, r) => t in e ? aie(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Bd = (e, t) => {
        for (var r in t || (t = {})) M5.call(t, r) && KC(e, r, t[r]);
        if (Hp)
            for (var r of Hp(t)) D5.call(t, r) && KC(e, r, t[r]);
        return e
    },
    uie = (e, t) => lie(e, cie(t)),
    hie = (e, t) => {
        var r = {};
        for (var n in e) M5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Hp)
            for (var n of Hp(e)) t.indexOf(n) < 0 && D5.call(e, n) && (r[n] = e[n]);
        return r
    };
const die = uie(Bd({}, Nw), {
    transitionProps: {
        duration: 200,
        transition: "pop"
    },
    withOverlay: !0,
    withCloseButton: !0
});

function Ln(e) {
    const t = ve("Modal", die, e),
        {
            title: r,
            withOverlay: n,
            overlayProps: i,
            withCloseButton: s,
            closeButtonProps: o,
            children: a
        } = t,
        l = hie(t, ["title", "withOverlay", "overlayProps", "withCloseButton", "closeButtonProps", "children"]),
        c = !!r || s;
    return I.createElement(I5, Bd({}, l), n && I.createElement(Ot.Overlay, Bd({}, i)), I.createElement(k5, null, c && I.createElement(Ot.Header, null, r && I.createElement(Ot.Title, null, r), s && I.createElement(Ot.CloseButton, Bd({}, o))), I.createElement(Ot.Body, null, a)))
}
Ln.Root = I5;
Ln.CloseButton = Ot.CloseButton;
Ln.Overlay = Ot.Overlay;
Ln.Content = k5;
Ln.Header = Ot.Header;
Ln.Title = Ot.Title;
Ln.Body = Ot.Body;
Ln.NativeScrollArea = Ot.NativeScrollArea;
var fie = Pe((e, {
    color: t,
    radius: r,
    withTitle: n
}) => {
    const i = e.fn.radius(r),
        s = e.fn.variant({
            variant: "filled",
            color: t
        });
    return {
        closeButton: e.fn.hover({
            backgroundColor: e.colorScheme === "dark" ? e.colors.dark[8] : e.colors.gray[0]
        }),
        icon: {
            boxSizing: "border-box",
            marginRight: e.spacing.md,
            width: R(28),
            height: R(28),
            borderRadius: R(28),
            display: "flex",
            flex: "none",
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: s.background,
            color: e.white
        },
        root: {
            overflow: "hidden",
            boxSizing: "border-box",
            position: "relative",
            display: "flex",
            alignItems: "center",
            paddingLeft: R(22),
            paddingRight: e.spacing.xs,
            paddingTop: e.spacing.xs,
            paddingBottom: e.spacing.xs,
            borderRadius: i,
            backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
            boxShadow: e.shadows.lg,
            "&::before": {
                content: '""',
                display: "block",
                position: "absolute",
                width: R(6),
                top: i,
                bottom: i,
                left: R(4),
                borderRadius: i,
                backgroundColor: s.background
            },
            "&[data-with-icon]": {
                paddingLeft: e.spacing.xs,
                "&::before": {
                    display: "none"
                }
            },
            "&[data-with-border]": {
                border: `${R(1)} solid ${e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[3]}`
            }
        },
        body: {
            flex: 1,
            overflow: "hidden",
            marginRight: e.spacing.xs
        },
        loader: {
            marginRight: e.spacing.md
        },
        title: {
            lineHeight: 1.4,
            marginBottom: R(2),
            overflow: "hidden",
            textOverflow: "ellipsis",
            color: e.colorScheme === "dark" ? e.white : e.colors.gray[9]
        },
        description: {
            color: n ? e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6] : e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
            lineHeight: 1.4,
            overflow: "hidden",
            textOverflow: "ellipsis"
        }
    }
});
const pie = fie;
var mie = Object.defineProperty,
    gie = Object.defineProperties,
    vie = Object.getOwnPropertyDescriptors,
    Gp = Object.getOwnPropertySymbols,
    N5 = Object.prototype.hasOwnProperty,
    L5 = Object.prototype.propertyIsEnumerable,
    qC = (e, t, r) => t in e ? mie(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    QC = (e, t) => {
        for (var r in t || (t = {})) N5.call(t, r) && qC(e, r, t[r]);
        if (Gp)
            for (var r of Gp(t)) L5.call(t, r) && qC(e, r, t[r]);
        return e
    },
    yie = (e, t) => gie(e, vie(t)),
    _ie = (e, t) => {
        var r = {};
        for (var n in e) N5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Gp)
            for (var n of Gp(e)) t.indexOf(n) < 0 && L5.call(e, n) && (r[n] = e[n]);
        return r
    };
const wie = {
        withCloseButton: !0
    },
    F5 = b.forwardRef((e, t) => {
        const r = ve("Notification", wie, e),
            {
                className: n,
                color: i,
                radius: s,
                loading: o,
                withCloseButton: a,
                withBorder: l,
                title: c,
                icon: u,
                children: h,
                onClose: d,
                closeButtonProps: f,
                classNames: p,
                styles: m,
                unstyled: w,
                variant: y
            } = r,
            v = _ie(r, ["className", "color", "radius", "loading", "withCloseButton", "withBorder", "title", "icon", "children", "onClose", "closeButtonProps", "classNames", "styles", "unstyled", "variant"]),
            {
                classes: _,
                cx: E
            } = pie({
                color: i,
                radius: s,
                withTitle: !!c
            }, {
                name: "Notification",
                classNames: p,
                styles: m,
                unstyled: w,
                variant: y
            });
        return I.createElement(Ie, QC({
            className: E(_.root, n),
            "data-with-icon": !!u || o || void 0,
            "data-with-border": l || void 0,
            role: "alert",
            ref: t
        }, v), u && !o && I.createElement("div", {
            className: _.icon
        }, u), o && I.createElement(Ao, {
            size: 28,
            color: i,
            className: _.loader
        }), I.createElement("div", {
            className: _.body
        }, c && I.createElement(ir, {
            className: _.title,
            size: "sm",
            weight: 500
        }, c), I.createElement(ir, {
            color: "dimmed",
            className: _.description,
            size: "sm"
        }, h)), a && I.createElement(Gk, yie(QC({
            iconSize: 16,
            color: "gray"
        }, f), {
            onClick: d,
            className: _.closeButton
        })))
    });
F5.displayName = "@mantine/core/Notification";
const B5 = b.createContext(!1),
    bie = B5.Provider,
    xie = () => b.useContext(B5);

function z5({
    children: e,
    openDelay: t = 0,
    closeDelay: r = 0
}) {
    return I.createElement(bie, {
        value: !0
    }, I.createElement(NQ, {
        delay: {
            open: t,
            close: r
        }
    }, e))
}
z5.displayName = "@mantine/core/TooltipGroup";
var Eie = Object.defineProperty,
    Sie = Object.defineProperties,
    Pie = Object.getOwnPropertyDescriptors,
    ZC = Object.getOwnPropertySymbols,
    Cie = Object.prototype.hasOwnProperty,
    Tie = Object.prototype.propertyIsEnumerable,
    JC = (e, t, r) => t in e ? Eie(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    eT = (e, t) => {
        for (var r in t || (t = {})) Cie.call(t, r) && JC(e, r, t[r]);
        if (ZC)
            for (var r of ZC(t)) Tie.call(t, r) && JC(e, r, t[r]);
        return e
    },
    Oie = (e, t) => Sie(e, Pie(t));

function Aie(e, t) {
    if (!t) return {
        backgroundColor: e.colorScheme === "dark" ? e.colors.gray[2] : e.colors.gray[9],
        color: e.colorScheme === "dark" ? e.black : e.white
    };
    const r = e.fn.variant({
        variant: "filled",
        color: t,
        primaryFallback: !1
    });
    return {
        backgroundColor: r.background,
        color: r.color
    }
}
var Iie = Pe((e, {
    color: t,
    radius: r,
    width: n,
    multiline: i
}) => ({
    tooltip: Oie(eT(eT({}, e.fn.fontStyles()), Aie(e, t)), {
        lineHeight: e.lineHeight,
        fontSize: e.fontSizes.sm,
        borderRadius: e.fn.radius(r),
        padding: `calc(${e.spacing.xs} / 2) ${e.spacing.xs}`,
        position: "absolute",
        whiteSpace: i ? "unset" : "nowrap",
        pointerEvents: "none",
        width: n
    }),
    arrow: {
        backgroundColor: "inherit",
        border: 0,
        zIndex: 1
    }
}));
const j5 = Iie,
    U5 = {
        children: "Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    };

function $ie({
    offset: e,
    position: t
}) {
    const [r, n] = b.useState(!1), i = b.useRef(), {
        x: s,
        y: o,
        reference: a,
        floating: l,
        refs: c,
        update: u,
        placement: h
    } = Sw({
        placement: t,
        middleware: [bw({
            crossAxis: !0,
            padding: 5,
            rootBoundary: "document"
        })]
    }), d = h.includes("right") ? e : t.includes("left") ? e * -1 : 0, f = h.includes("bottom") ? e : t.includes("top") ? e * -1 : 0, p = b.useCallback(({
        clientX: m,
        clientY: w
    }) => {
        a({
            getBoundingClientRect() {
                return {
                    width: 0,
                    height: 0,
                    x: m,
                    y: w,
                    left: m + d,
                    top: w + f,
                    right: m,
                    bottom: w
                }
            }
        })
    }, [a]);
    return b.useEffect(() => {
        if (c.floating.current) {
            const m = i.current;
            m.addEventListener("mousemove", p);
            const w = Pi(c.floating.current);
            return w.forEach(y => {
                y.addEventListener("scroll", u)
            }), () => {
                m.removeEventListener("mousemove", p), w.forEach(y => {
                    y.removeEventListener("scroll", u)
                })
            }
        }
    }, [a, c.floating.current, u, p, r]), {
        handleMouseMove: p,
        x: s,
        y: o,
        opened: r,
        setOpened: n,
        boundaryRef: i,
        floating: l
    }
}
var Rie = Object.defineProperty,
    kie = Object.defineProperties,
    Mie = Object.getOwnPropertyDescriptors,
    Vp = Object.getOwnPropertySymbols,
    H5 = Object.prototype.hasOwnProperty,
    G5 = Object.prototype.propertyIsEnumerable,
    tT = (e, t, r) => t in e ? Rie(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    rd = (e, t) => {
        for (var r in t || (t = {})) H5.call(t, r) && tT(e, r, t[r]);
        if (Vp)
            for (var r of Vp(t)) G5.call(t, r) && tT(e, r, t[r]);
        return e
    },
    nd = (e, t) => kie(e, Mie(t)),
    Die = (e, t) => {
        var r = {};
        for (var n in e) H5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Vp)
            for (var n of Vp(e)) t.indexOf(n) < 0 && G5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Nie = {
    refProp: "ref",
    withinPortal: !0,
    offset: 10,
    position: "right",
    zIndex: $s("popover")
};

function V5(e) {
    var t;
    const r = ve("TooltipFloating", Nie, e),
        {
            children: n,
            refProp: i,
            withinPortal: s,
            portalProps: o,
            style: a,
            className: l,
            classNames: c,
            styles: u,
            unstyled: h,
            radius: d,
            color: f,
            label: p,
            offset: m,
            position: w,
            multiline: y,
            width: v,
            zIndex: _,
            disabled: E,
            variant: P
        } = r,
        C = Die(r, ["children", "refProp", "withinPortal", "portalProps", "style", "className", "classNames", "styles", "unstyled", "radius", "color", "label", "offset", "position", "multiline", "width", "zIndex", "disabled", "variant"]),
        {
            handleMouseMove: T,
            x: O,
            y: k,
            opened: D,
            boundaryRef: B,
            floating: j,
            setOpened: L
        } = $ie({
            offset: m,
            position: w
        }),
        {
            classes: M,
            cx: W
        } = j5({
            radius: d,
            color: f,
            multiline: y,
            width: v
        }, {
            name: "TooltipFloating",
            classNames: c,
            styles: u,
            unstyled: h,
            variant: P
        });
    if (!Pu(n)) throw new Error(U5.children);
    const Z = Oo(B, n.ref),
        q = X => {
            var z, Q;
            (Q = (z = n.props).onMouseEnter) == null || Q.call(z, X), T(X), L(!0)
        },
        G = X => {
            var z, Q;
            (Q = (z = n.props).onMouseLeave) == null || Q.call(z, X), L(!1)
        };
    return I.createElement(I.Fragment, null, I.createElement(vl, nd(rd({}, o), {
        withinPortal: s
    }), I.createElement(Ie, nd(rd({}, C), {
        ref: j,
        className: W(M.tooltip, l),
        style: nd(rd({}, a), {
            zIndex: _,
            display: !E && D ? "block" : "none",
            top: k??"",
            left: (t = Math.round(O)) != null ? t : ""
        })
    }), p)), b.cloneElement(n, nd(rd({}, n.props), {
        [i]: Z,
        onMouseEnter: q,
        onMouseLeave: G
    })))
}
V5.displayName = "@mantine/core/TooltipFloating";

function Lie(e) {
    const [t, r] = b.useState(!1), i = typeof e.opened == "boolean" ? e.opened : t, s = xie(), o = Ou(), {
        delay: a,
        currentId: l,
        setCurrentId: c
    } = k3(), u = b.useCallback(O => {
        r(O), O && c(o)
    }, [c, o]), {
        x: h,
        y: d,
        reference: f,
        floating: p,
        context: m,
        refs: w,
        update: y,
        placement: v,
        middlewareData: {
            arrow: {
                x: _,
                y: E
            } = {}
        }
    } = Sw({
        placement: e.position,
        open: i,
        onOpenChange: u,
        middleware: [y3(e.offset), bw({
            padding: 8
        }), g3(), O3({
            element: e.arrowRef,
            padding: e.arrowOffset
        }), ...e.inline ? [v3()] : []]
    }), {
        getReferenceProps: P,
        getFloatingProps: C
    } = YQ([DQ(m, {
        enabled: e.events.hover,
        delay: s ? a : {
            open: e.openDelay,
            close: e.closeDelay
        },
        mouseOnly: !e.events.touch
    }), WQ(m, {
        enabled: e.events.focus,
        keyboardOnly: !0
    }), XQ(m, {
        role: "tooltip"
    }), VQ(m, {
        enabled: typeof e.opened === void 0
    }), LQ(m, {
        id: o
    })]);
    return D3({
        opened: i,
        position: e.position,
        positionDependencies: e.positionDependencies,
        floating: {
            refs: w,
            update: y
        }
    }), sn(() => {
        var O;
        (O = e.onPositionChange) == null || O.call(e, v)
    }, [v]), {
        x: h,
        y: d,
        arrowX: _,
        arrowY: E,
        reference: f,
        floating: p,
        getFloatingProps: C,
        getReferenceProps: P,
        isGroupPhase: i && l && l !== o,
        opened: i,
        placement: v
    }
}
var Fie = Object.defineProperty,
    Bie = Object.defineProperties,
    zie = Object.getOwnPropertyDescriptors,
    Wp = Object.getOwnPropertySymbols,
    W5 = Object.prototype.hasOwnProperty,
    X5 = Object.prototype.propertyIsEnumerable,
    rT = (e, t, r) => t in e ? Fie(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    zs = (e, t) => {
        for (var r in t || (t = {})) W5.call(t, r) && rT(e, r, t[r]);
        if (Wp)
            for (var r of Wp(t)) X5.call(t, r) && rT(e, r, t[r]);
        return e
    },
    b0 = (e, t) => Bie(e, zie(t)),
    jie = (e, t) => {
        var r = {};
        for (var n in e) W5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Wp)
            for (var n of Wp(e)) t.indexOf(n) < 0 && X5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Uie = {
        position: "top",
        refProp: "ref",
        withinPortal: !1,
        inline: !1,
        arrowSize: 4,
        arrowOffset: 5,
        arrowRadius: 0,
        arrowPosition: "side",
        offset: 5,
        transitionProps: {
            duration: 100,
            transition: "fade"
        },
        width: "auto",
        events: {
            hover: !0,
            focus: !1,
            touch: !1
        },
        zIndex: $s("popover"),
        positionDependencies: []
    },
    vg = b.forwardRef((e, t) => {
        var r;
        const n = b.useRef(null),
            i = ve("Tooltip", Uie, e),
            {
                children: s,
                position: o,
                refProp: a,
                label: l,
                openDelay: c,
                closeDelay: u,
                onPositionChange: h,
                opened: d,
                withinPortal: f,
                portalProps: p,
                radius: m,
                color: w,
                classNames: y,
                styles: v,
                unstyled: _,
                style: E,
                className: P,
                withArrow: C,
                arrowSize: T,
                arrowOffset: O,
                arrowRadius: k,
                arrowPosition: D,
                offset: B,
                transitionProps: j,
                multiline: L,
                width: M,
                events: W,
                zIndex: Z,
                disabled: q,
                positionDependencies: G,
                onClick: X,
                onMouseEnter: z,
                onMouseLeave: Q,
                inline: ie,
                variant: _e,
                keepMounted: we
            } = i,
            De = jie(i, ["children", "position", "refProp", "label", "openDelay", "closeDelay", "onPositionChange", "opened", "withinPortal", "portalProps", "radius", "color", "classNames", "styles", "unstyled", "style", "className", "withArrow", "arrowSize", "arrowOffset", "arrowRadius", "arrowPosition", "offset", "transitionProps", "multiline", "width", "events", "zIndex", "disabled", "positionDependencies", "onClick", "onMouseEnter", "onMouseLeave", "inline", "variant", "keepMounted"]),
            {
                classes: Te,
                cx: Ne,
                theme: et
            } = j5({
                radius: m,
                color: w,
                width: M,
                multiline: L
            }, {
                name: "Tooltip",
                classNames: y,
                styles: v,
                unstyled: _,
                variant: _e
            }),
            Le = Lie({
                position: W3(et.dir, o),
                closeDelay: u,
                openDelay: c,
                onPositionChange: h,
                opened: d,
                events: W,
                arrowRef: n,
                arrowOffset: O,
                offset: B + (C ? T / 2 : 0),
                positionDependencies: [...G, s],
                inline: ie
            });
        if (!Pu(s)) throw new Error(U5.children);
        const tt = Oo(Le.reference, s.ref, t);
        return I.createElement(I.Fragment, null, I.createElement(vl, b0(zs({}, p), {
            withinPortal: f
        }), I.createElement(_l, b0(zs({
            keepMounted: we,
            mounted: !q && Le.opened
        }, j), {
            transition: j.transition || "fade",
            duration: Le.isGroupPhase ? 10 : (r = j.duration) != null ? r : 100
        }), Ue => {
            var Ve, rt;
            return I.createElement(Ie, zs(zs({}, De), Le.getFloatingProps({
                ref: Le.floating,
                className: Te.tooltip,
                style: b0(zs(zs({}, E), Ue), {
                    zIndex: Z,
                    top: (Ve = Le.y) != null ? Ve : 0,
                    left: (rt = Le.x) != null ? rt : 0
                })
            })), l, I.createElement(Cw, {
                ref: n,
                arrowX: Le.arrowX,
                arrowY: Le.arrowY,
                visible: C,
                position: Le.placement,
                arrowSize: T,
                arrowOffset: O,
                arrowRadius: k,
                arrowPosition: D,
                className: Te.arrow
            }))
        })), b.cloneElement(s, Le.getReferenceProps(zs({
            onClick: X,
            onMouseEnter: z,
            onMouseLeave: Q,
            onMouseMove: e.onMouseMove,
            onPointerDown: e.onPointerDown,
            onPointerEnter: e.onPointerEnter,
            [a]: tt,
            className: Ne(P, s.props.className)
        }, s.props))))
    });
vg.Group = z5;
vg.Floating = V5;
vg.displayName = "@mantine/core/Tooltip";
const Y5 = vg;
var Hie = Pe((e, {
    spacing: t,
    align: r,
    justify: n
}) => ({
    root: {
        display: "flex",
        flexDirection: "column",
        alignItems: r,
        justifyContent: n,
        gap: he({
            size: t,
            sizes: e.spacing
        })
    }
}));
const Gie = Hie;
var Vie = Object.defineProperty,
    Xp = Object.getOwnPropertySymbols,
    K5 = Object.prototype.hasOwnProperty,
    q5 = Object.prototype.propertyIsEnumerable,
    nT = (e, t, r) => t in e ? Vie(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Wie = (e, t) => {
        for (var r in t || (t = {})) K5.call(t, r) && nT(e, r, t[r]);
        if (Xp)
            for (var r of Xp(t)) q5.call(t, r) && nT(e, r, t[r]);
        return e
    },
    Xie = (e, t) => {
        var r = {};
        for (var n in e) K5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Xp)
            for (var n of Xp(e)) t.indexOf(n) < 0 && q5.call(e, n) && (r[n] = e[n]);
        return r
    };
const Yie = {
        spacing: "md",
        align: "stretch",
        justify: "flex-start"
    },
    Q5 = b.forwardRef((e, t) => {
        const r = ve("Stack", Yie, e),
            {
                spacing: n,
                className: i,
                align: s,
                justify: o,
                unstyled: a,
                variant: l
            } = r,
            c = Xie(r, ["spacing", "className", "align", "justify", "unstyled", "variant"]),
            {
                classes: u,
                cx: h
            } = Gie({
                spacing: n,
                align: s,
                justify: o
            }, {
                name: "Stack",
                unstyled: a,
                variant: l
            });
        return I.createElement(Ie, Wie({
            className: h(u.root, i),
            ref: t
        }, c))
    });
Q5.displayName = "@mantine/core/Stack";
const Z5 = b.createContext(null),
    Kie = Z5.Provider,
    qie = () => b.useContext(Z5);
var Qie = Object.defineProperty,
    Yp = Object.getOwnPropertySymbols,
    J5 = Object.prototype.hasOwnProperty,
    eD = Object.prototype.propertyIsEnumerable,
    iT = (e, t, r) => t in e ? Qie(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    sT = (e, t) => {
        for (var r in t || (t = {})) J5.call(t, r) && iT(e, r, t[r]);
        if (Yp)
            for (var r of Yp(t)) eD.call(t, r) && iT(e, r, t[r]);
        return e
    },
    Zie = (e, t) => {
        var r = {};
        for (var n in e) J5.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Yp)
            for (var n of Yp(e)) t.indexOf(n) < 0 && eD.call(e, n) && (r[n] = e[n]);
        return r
    };
const Jie = {
        size: "sm"
    },
    tD = b.forwardRef((e, t) => {
        const r = ve("SwitchGroup", Jie, e),
            {
                children: n,
                value: i,
                defaultValue: s,
                onChange: o,
                size: a,
                wrapperProps: l
            } = r,
            c = Zie(r, ["children", "value", "defaultValue", "onChange", "size", "wrapperProps"]),
            [u, h] = Au({
                value: i,
                defaultValue: s,
                finalValue: [],
                onChange: o
            }),
            d = f => {
                const p = f.currentTarget.value;
                h(u.includes(p) ? u.filter(m => m !== p) : [...u, p])
            };
        return I.createElement(Kie, {
            value: {
                value: u,
                onChange: d,
                size: a
            }
        }, I.createElement(T_.Wrapper, sT(sT({
            labelElement: "div",
            size: a,
            __staticSelector: "SwitchGroup",
            ref: t
        }, l), c), n))
    });
tD.displayName = "@mantine/core/SwitchGroup";
var ese = Object.defineProperty,
    tse = Object.defineProperties,
    rse = Object.getOwnPropertyDescriptors,
    oT = Object.getOwnPropertySymbols,
    nse = Object.prototype.hasOwnProperty,
    ise = Object.prototype.propertyIsEnumerable,
    aT = (e, t, r) => t in e ? ese(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    sse = (e, t) => {
        for (var r in t || (t = {})) nse.call(t, r) && aT(e, r, t[r]);
        if (oT)
            for (var r of oT(t)) ise.call(t, r) && aT(e, r, t[r]);
        return e
    },
    ose = (e, t) => tse(e, rse(t));
const ase = {
        xs: R(16),
        sm: R(20),
        md: R(24),
        lg: R(30),
        xl: R(36)
    },
    lse = {
        xs: R(32),
        sm: R(38),
        md: R(46),
        lg: R(56),
        xl: R(72)
    },
    cse = {
        xs: R(12),
        sm: R(14),
        md: R(18),
        lg: R(22),
        xl: R(28)
    },
    use = {
        xs: R(5),
        sm: R(6),
        md: R(7),
        lg: R(9),
        xl: R(11)
    },
    hse = {
        xs: R(4),
        sm: R(5),
        md: R(6),
        lg: R(8),
        xl: R(10)
    };
var dse = Pe((e, {
    radius: t,
    color: r,
    labelPosition: n,
    error: i
}, {
    size: s
}) => {
    const o = he({
            size: s,
            sizes: cse
        }),
        a = he({
            size: t,
            sizes: e.radius
        }),
        l = e.fn.variant({
            variant: "filled",
            color: r
        }),
        c = he({
            size: s,
            sizes: lse
        }),
        u = R(s === "xs" ? 1 : 2),
        h = e.fn.variant({
            variant: "filled",
            color: "red"
        }).background;
    return {
        root: {
            position: "relative"
        },
        input: {
            height: 0,
            width: 0,
            overflow: "hidden",
            whiteSpace: "nowrap",
            padding: 0,
            WebkitClipPath: "inset(50%)",
            clipPath: "inset(50%)",
            position: "absolute"
        },
        track: ose(sse({}, e.fn.focusStyles("input:focus + &")), {
            cursor: e.cursorType,
            overflow: "hidden",
            WebkitTapHighlightColor: "transparent",
            position: "relative",
            borderRadius: a,
            backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[2],
            border: `${R(1)} solid ${i?h:e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[3]}`,
            height: he({
                size: s,
                sizes: ase
            }),
            minWidth: c,
            margin: 0,
            transitionProperty: "background-color, border-color",
            transitionTimingFunction: e.transitionTimingFunction,
            transitionDuration: "150ms",
            boxSizing: "border-box",
            appearance: "none",
            display: "flex",
            alignItems: "center",
            fontSize: he({
                size: s,
                sizes: use
            }),
            fontWeight: 600,
            order: n === "left" ? 2 : 1,
            userSelect: "none",
            zIndex: 0,
            lineHeight: 0,
            color: e.colorScheme === "dark" ? e.colors.dark[1] : e.colors.gray[6],
            transition: `color 150ms ${e.transitionTimingFunction}`,
            "input:checked + &": {
                backgroundColor: l.background,
                borderColor: l.background,
                color: e.white,
                transition: `color 150ms ${e.transitionTimingFunction}`
            },
            "input:disabled + &": {
                backgroundColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
                borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
                cursor: "not-allowed"
            }
        }),
        thumb: {
            position: "absolute",
            zIndex: 1,
            borderRadius: a,
            boxSizing: "border-box",
            display: "flex",
            backgroundColor: e.white,
            height: o,
            width: o,
            border: `${R(1)} solid ${e.colorScheme==="dark"?e.white:e.colors.gray[3]}`,
            left: u,
            transition: `left 150ms ${e.transitionTimingFunction}`,
            "& > *": {
                margin: "auto"
            },
            "@media (prefers-reduced-motion)": {
                transitionDuration: e.respectReducedMotion ? "0ms" : ""
            },
            "input:checked + * > &": {
                left: `calc(100% - ${o} - ${u})`,
                borderColor: e.white
            },
            "input:disabled + * > &": {
                borderColor: e.colorScheme === "dark" ? e.colors.dark[4] : e.colors.gray[2],
                backgroundColor: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[0]
            }
        },
        trackLabel: {
            height: "100%",
            display: "grid",
            placeContent: "center",
            minWidth: `calc(${c} - ${o})`,
            paddingInline: he({
                size: s,
                sizes: hse
            }),
            margin: `0 0 0 calc(${o} + ${u})`,
            transition: `margin 150ms ${e.transitionTimingFunction}`,
            "input:checked + * > &": {
                margin: `0 calc(${o} + ${u}) 0 0`
            }
        }
    }
});
const fse = dse;
var pse = Object.defineProperty,
    mse = Object.defineProperties,
    gse = Object.getOwnPropertyDescriptors,
    Kp = Object.getOwnPropertySymbols,
    rD = Object.prototype.hasOwnProperty,
    nD = Object.prototype.propertyIsEnumerable,
    lT = (e, t, r) => t in e ? pse(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    x0 = (e, t) => {
        for (var r in t || (t = {})) rD.call(t, r) && lT(e, r, t[r]);
        if (Kp)
            for (var r of Kp(t)) nD.call(t, r) && lT(e, r, t[r]);
        return e
    },
    vse = (e, t) => mse(e, gse(t)),
    yse = (e, t) => {
        var r = {};
        for (var n in e) rD.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Kp)
            for (var n of Kp(e)) t.indexOf(n) < 0 && nD.call(e, n) && (r[n] = e[n]);
        return r
    };
const _se = {
        offLabel: "",
        onLabel: "",
        size: "sm",
        radius: "xl",
        error: !1
    },
    qp = b.forwardRef((e, t) => {
        var r;
        const n = ve("Switch", _se, e),
            {
                className: i,
                color: s,
                label: o,
                offLabel: a,
                onLabel: l,
                id: c,
                style: u,
                size: h,
                radius: d,
                wrapperProps: f,
                children: p,
                unstyled: m,
                styles: w,
                classNames: y,
                thumbIcon: v,
                sx: _,
                checked: E,
                defaultChecked: P,
                onChange: C,
                labelPosition: T,
                description: O,
                error: k,
                disabled: D,
                variant: B
            } = n,
            j = yse(n, ["className", "color", "label", "offLabel", "onLabel", "id", "style", "size", "radius", "wrapperProps", "children", "unstyled", "styles", "classNames", "thumbIcon", "sx", "checked", "defaultChecked", "onChange", "labelPosition", "description", "error", "disabled", "variant"]),
            L = qie(),
            M = (L == null ? void 0 : L.size) || h,
            {
                classes: W,
                cx: Z
            } = fse({
                color: s,
                radius: d,
                labelPosition: T,
                error: !!k
            }, {
                name: "Switch",
                classNames: y,
                styles: w,
                unstyled: m,
                size: M,
                variant: B
            }),
            {
                systemStyles: q,
                rest: G
            } = ug(j),
            X = Ou(c),
            z = L ? {
                checked: L.value.includes(G.value),
                onChange: L.onChange
            } : {},
            [Q, ie] = Au({
                value: (r = z.checked) != null ? r : E,
                defaultValue: P,
                finalValue: !1
            });
        return I.createElement(AM, x0(x0({
            className: Z(i, W.root),
            sx: _,
            style: u,
            id: X,
            size: (L == null ? void 0 : L.size) || h,
            labelPosition: T,
            label: o,
            description: O,
            error: k,
            disabled: D,
            __staticSelector: "Switch",
            classNames: y,
            styles: w,
            unstyled: m,
            "data-checked": z.checked || void 0,
            variant: B
        }, q), f), I.createElement("input", vse(x0({}, G), {
            disabled: D,
            checked: Q,
            onChange: _e => {
                L ? z.onChange(_e) : C == null || C(_e), ie(_e.currentTarget.checked)
            },
            id: X,
            ref: t,
            type: "checkbox",
            className: W.input
        })), I.createElement("label", {
            htmlFor: X,
            className: W.track
        }, I.createElement("div", {
            className: W.thumb
        }, v), I.createElement("div", {
            className: W.trackLabel
        }, Q ? l : a)))
    });
qp.displayName = "@mantine/core/Switch";
qp.Group = tD;
var wse = Object.defineProperty,
    bse = Object.defineProperties,
    xse = Object.getOwnPropertyDescriptors,
    cT = Object.getOwnPropertySymbols,
    Ese = Object.prototype.hasOwnProperty,
    Sse = Object.prototype.propertyIsEnumerable,
    uT = (e, t, r) => t in e ? wse(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Pse = (e, t) => {
        for (var r in t || (t = {})) Ese.call(t, r) && uT(e, r, t[r]);
        if (cT)
            for (var r of cT(t)) Sse.call(t, r) && uT(e, r, t[r]);
        return e
    },
    Cse = (e, t) => bse(e, xse(t)),
    Tse = Pe((e, {
        captionSide: t,
        horizontalSpacing: r,
        verticalSpacing: n,
        fontSize: i,
        withBorder: s,
        withColumnBorders: o
    }) => {
        const a = `${R(1)} solid ${e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[3]}`;
        return {
            root: Cse(Pse({}, e.fn.fontStyles()), {
                width: "100%",
                borderCollapse: "collapse",
                captionSide: t,
                color: e.colorScheme === "dark" ? e.colors.dark[0] : e.black,
                lineHeight: e.lineHeight,
                border: s ? a : void 0,
                "& caption": {
                    marginTop: t === "top" ? 0 : e.spacing.xs,
                    marginBottom: t === "bottom" ? 0 : e.spacing.xs,
                    fontSize: e.fontSizes.sm,
                    color: e.colorScheme === "dark" ? e.colors.dark[2] : e.colors.gray[6]
                },
                "& thead tr th, & tfoot tr th, & tbody tr th": {
                    textAlign: "left",
                    fontWeight: "bold",
                    color: e.colorScheme === "dark" ? e.colors.dark[0] : e.colors.gray[7],
                    fontSize: he({
                        size: i,
                        sizes: e.fontSizes
                    }),
                    padding: `${he({size:n,sizes:e.spacing})} ${he({size:r,sizes:e.spacing})}`
                },
                "& thead tr th": {
                    borderBottom: a
                },
                "& tfoot tr th, & tbody tr th": {
                    borderTop: a
                },
                "& tbody tr td": {
                    padding: `${he({size:n,sizes:e.spacing})} ${he({size:r,sizes:e.spacing})}`,
                    borderTop: a,
                    fontSize: he({
                        size: i,
                        sizes: e.fontSizes
                    })
                },
                "& tbody tr:first-of-type td, & tbody tr:first-of-type th": {
                    borderTop: "none"
                },
                "& thead th, & tbody td": {
                    borderRight: o ? a : "none",
                    "&:last-of-type": {
                        borderRight: "none",
                        borderLeft: o ? a : "none"
                    }
                },
                "& tbody tr th": {
                    borderRight: o ? a : "none"
                },
                "&[data-striped] tbody tr:nth-of-type(odd)": {
                    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.colors.gray[0]
                },
                "&[data-hover] tbody tr": e.fn.hover({
                    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[1]
                })
            })
        }
    });
const Ose = Tse;
var Ase = Object.defineProperty,
    Ise = Object.defineProperties,
    $se = Object.getOwnPropertyDescriptors,
    Qp = Object.getOwnPropertySymbols,
    iD = Object.prototype.hasOwnProperty,
    sD = Object.prototype.propertyIsEnumerable,
    hT = (e, t, r) => t in e ? Ase(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Rse = (e, t) => {
        for (var r in t || (t = {})) iD.call(t, r) && hT(e, r, t[r]);
        if (Qp)
            for (var r of Qp(t)) sD.call(t, r) && hT(e, r, t[r]);
        return e
    },
    kse = (e, t) => Ise(e, $se(t)),
    Mse = (e, t) => {
        var r = {};
        for (var n in e) iD.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Qp)
            for (var n of Qp(e)) t.indexOf(n) < 0 && sD.call(e, n) && (r[n] = e[n]);
        return r
    };
const Dse = {
        striped: !1,
        highlightOnHover: !1,
        captionSide: "top",
        horizontalSpacing: "xs",
        fontSize: "sm",
        verticalSpacing: 7,
        withBorder: !1,
        withColumnBorders: !1
    },
    oD = b.forwardRef((e, t) => {
        const r = ve("Table", Dse, e),
            {
                className: n,
                children: i,
                striped: s,
                highlightOnHover: o,
                captionSide: a,
                horizontalSpacing: l,
                verticalSpacing: c,
                fontSize: u,
                unstyled: h,
                withBorder: d,
                withColumnBorders: f,
                variant: p
            } = r,
            m = Mse(r, ["className", "children", "striped", "highlightOnHover", "captionSide", "horizontalSpacing", "verticalSpacing", "fontSize", "unstyled", "withBorder", "withColumnBorders", "variant"]),
            {
                classes: w,
                cx: y
            } = Ose({
                captionSide: a,
                verticalSpacing: c,
                horizontalSpacing: l,
                fontSize: u,
                withBorder: d,
                withColumnBorders: f
            }, {
                unstyled: h,
                name: "Table",
                variant: p
            });
        return I.createElement(Ie, kse(Rse({}, m), {
            component: "table",
            ref: t,
            className: y(w.root, n),
            "data-striped": s || void 0,
            "data-hover": o || void 0
        }), i)
    });
oD.displayName = "@mantine/core/Table";
var Nse = Object.defineProperty,
    Lse = Object.defineProperties,
    Fse = Object.getOwnPropertyDescriptors,
    dT = Object.getOwnPropertySymbols,
    Bse = Object.prototype.hasOwnProperty,
    zse = Object.prototype.propertyIsEnumerable,
    fT = (e, t, r) => t in e ? Nse(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    jse = (e, t) => {
        for (var r in t || (t = {})) Bse.call(t, r) && fT(e, r, t[r]);
        if (dT)
            for (var r of dT(t)) zse.call(t, r) && fT(e, r, t[r]);
        return e
    },
    Use = (e, t) => Lse(e, Fse(t));

function Hse(e, t, r) {
    return typeof e < "u" ? e in r.headings.sizes ? r.headings.sizes[e].fontSize : R(e) : r.headings.sizes[t].fontSize
}

function Gse(e, t, r) {
    return typeof e < "u" && e in r.headings.sizes ? r.headings.sizes[e].lineHeight : r.headings.sizes[t].lineHeight
}
var Vse = Pe((e, {
    element: t,
    weight: r,
    inline: n
}, {
    size: i
}) => ({
    root: Use(jse({}, e.fn.fontStyles()), {
        fontFamily: e.headings.fontFamily,
        fontWeight: r || e.headings.sizes[t].fontWeight || e.headings.fontWeight,
        fontSize: Hse(i, t, e),
        lineHeight: n ? 1 : Gse(i, t, e),
        margin: 0
    })
}));
const Wse = Vse;
var Xse = Object.defineProperty,
    Zp = Object.getOwnPropertySymbols,
    aD = Object.prototype.hasOwnProperty,
    lD = Object.prototype.propertyIsEnumerable,
    pT = (e, t, r) => t in e ? Xse(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Yse = (e, t) => {
        for (var r in t || (t = {})) aD.call(t, r) && pT(e, r, t[r]);
        if (Zp)
            for (var r of Zp(t)) lD.call(t, r) && pT(e, r, t[r]);
        return e
    },
    Kse = (e, t) => {
        var r = {};
        for (var n in e) aD.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Zp)
            for (var n of Zp(e)) t.indexOf(n) < 0 && lD.call(e, n) && (r[n] = e[n]);
        return r
    };
const qse = {
        order: 1
    },
    cD = b.forwardRef((e, t) => {
        const r = ve("Title", qse, e),
            {
                className: n,
                order: i,
                children: s,
                unstyled: o,
                size: a,
                weight: l,
                inline: c,
                variant: u
            } = r,
            h = Kse(r, ["className", "order", "children", "unstyled", "size", "weight", "inline", "variant"]),
            {
                classes: d,
                cx: f
            } = Wse({
                element: `h${i}`,
                weight: l,
                inline: c
            }, {
                name: "Title",
                unstyled: o,
                variant: u,
                size: a
            });
        return [1, 2, 3, 4, 5, 6].includes(i) ? I.createElement(ir, Yse({
            variant: u,
            component: `h${i}`,
            ref: t,
            className: f(d.root, n)
        }, h), s) : null
    });
cD.displayName = "@mantine/core/Title";
var Be = {},
    Qse = {
        get exports() {
            return Be
        },
        set exports(e) {
            Be = e
        }
    },
    Zse = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
    Jse = Zse,
    eoe = Jse;

function uD() {}

function hD() {}
hD.resetWarningCache = uD;
var toe = function() {
    function e(n, i, s, o, a, l) {
        if (l !== eoe) {
            var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw c.name = "Invariant Violation", c
        }
    }
    e.isRequired = e;

    function t() {
        return e
    }
    var r = {
        array: e,
        bigint: e,
        bool: e,
        func: e,
        number: e,
        object: e,
        string: e,
        symbol: e,
        any: e,
        arrayOf: t,
        element: e,
        elementType: e,
        instanceOf: t,
        node: e,
        objectOf: t,
        oneOf: t,
        oneOfType: t,
        shape: t,
        exact: t,
        checkPropTypes: hD,
        resetWarningCache: uD
    };
    return r.PropTypes = r, r
};
Qse.exports = toe();
var roe = {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
    },
    noe = Object.defineProperty,
    ioe = Object.defineProperties,
    soe = Object.getOwnPropertyDescriptors,
    Jp = Object.getOwnPropertySymbols,
    dD = Object.prototype.hasOwnProperty,
    fD = Object.prototype.propertyIsEnumerable,
    mT = (e, t, r) => t in e ? noe(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    gT = (e, t) => {
        for (var r in t || (t = {})) dD.call(t, r) && mT(e, r, t[r]);
        if (Jp)
            for (var r of Jp(t)) fD.call(t, r) && mT(e, r, t[r]);
        return e
    },
    ooe = (e, t) => ioe(e, soe(t)),
    aoe = (e, t) => {
        var r = {};
        for (var n in e) dD.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && Jp)
            for (var n of Jp(e)) t.indexOf(n) < 0 && fD.call(e, n) && (r[n] = e[n]);
        return r
    },
    Xt = (e, t, r) => {
        const n = b.forwardRef((i, s) => {
            var o = i,
                {
                    color: a = "currentColor",
                    size: l = 24,
                    stroke: c = 2,
                    children: u
                } = o,
                h = aoe(o, ["color", "size", "stroke", "children"]);
            return b.createElement("svg", gT(ooe(gT({
                ref: s
            }, roe), {
                width: l,
                height: l,
                stroke: a,
                strokeWidth: c,
                className: `tabler-icon tabler-icon-${e}`
            }), h), [...r.map(([d, f]) => b.createElement(d, f)), ...u || []])
        });
        return n.propTypes = {
            color: Be.string,
            size: Be.oneOfType([Be.string, Be.number]),
            stroke: Be.oneOfType([Be.string, Be.number])
        }, n.displayName = `${t}`, n
    },
    loe = Xt("adjustments", "IconAdjustments", [
        ["path", {
            d: "M4 10a2 2 0 1 0 4 0a2 2 0 0 0 -4 0",
            key: "svg-0"
        }],
        ["path", {
            d: "M6 4v4",
            key: "svg-1"
        }],
        ["path", {
            d: "M6 12v8",
            key: "svg-2"
        }],
        ["path", {
            d: "M10 16a2 2 0 1 0 4 0a2 2 0 0 0 -4 0",
            key: "svg-3"
        }],
        ["path", {
            d: "M12 4v10",
            key: "svg-4"
        }],
        ["path", {
            d: "M12 18v2",
            key: "svg-5"
        }],
        ["path", {
            d: "M16 7a2 2 0 1 0 4 0a2 2 0 0 0 -4 0",
            key: "svg-6"
        }],
        ["path", {
            d: "M18 4v1",
            key: "svg-7"
        }],
        ["path", {
            d: "M18 9v11",
            key: "svg-8"
        }]
    ]),
    coe = Xt("arrows-move", "IconArrowsMove", [
        ["path", {
            d: "M18 9l3 3l-3 3",
            key: "svg-0"
        }],
        ["path", {
            d: "M15 12h6",
            key: "svg-1"
        }],
        ["path", {
            d: "M6 9l-3 3l3 3",
            key: "svg-2"
        }],
        ["path", {
            d: "M3 12h6",
            key: "svg-3"
        }],
        ["path", {
            d: "M9 18l3 3l3 -3",
            key: "svg-4"
        }],
        ["path", {
            d: "M12 15v6",
            key: "svg-5"
        }],
        ["path", {
            d: "M15 6l-3 -3l-3 3",
            key: "svg-6"
        }],
        ["path", {
            d: "M12 3v6",
            key: "svg-7"
        }]
    ]),
    uoe = Xt("chart-histogram", "IconChartHistogram", [
        ["path", {
            d: "M3 3v18h18",
            key: "svg-0"
        }],
        ["path", {
            d: "M20 18v3",
            key: "svg-1"
        }],
        ["path", {
            d: "M16 16v5",
            key: "svg-2"
        }],
        ["path", {
            d: "M12 13v8",
            key: "svg-3"
        }],
        ["path", {
            d: "M8 16v5",
            key: "svg-4"
        }],
        ["path", {
            d: "M3 11c6 0 5 -5 9 -5s3 5 9 5",
            key: "svg-5"
        }]
    ]),
    hoe = Xt("circle-dotted", "IconCircleDotted", [
        ["path", {
            d: "M7.5 4.21l0 .01",
            key: "svg-0"
        }],
        ["path", {
            d: "M4.21 7.5l0 .01",
            key: "svg-1"
        }],
        ["path", {
            d: "M3 12l0 .01",
            key: "svg-2"
        }],
        ["path", {
            d: "M4.21 16.5l0 .01",
            key: "svg-3"
        }],
        ["path", {
            d: "M7.5 19.79l0 .01",
            key: "svg-4"
        }],
        ["path", {
            d: "M12 21l0 .01",
            key: "svg-5"
        }],
        ["path", {
            d: "M16.5 19.79l0 .01",
            key: "svg-6"
        }],
        ["path", {
            d: "M19.79 16.5l0 .01",
            key: "svg-7"
        }],
        ["path", {
            d: "M21 12l0 .01",
            key: "svg-8"
        }],
        ["path", {
            d: "M19.79 7.5l0 .01",
            key: "svg-9"
        }],
        ["path", {
            d: "M16.5 4.21l0 .01",
            key: "svg-10"
        }],
        ["path", {
            d: "M12 3l0 .01",
            key: "svg-11"
        }]
    ]),
    doe = Xt("circle-filled", "IconCircleFilled", [
        ["path", {
            d: "M7 3.34a10 10 0 1 1 -4.995 8.984l-.005 -.324l.005 -.324a10 10 0 0 1 4.995 -8.336z",
            fill: "currentColor",
            key: "svg-0",
            strokeWidth: "0"
        }]
    ]),
    foe = Xt("color-picker", "IconColorPicker", [
        ["path", {
            d: "M11 7l6 6",
            key: "svg-0"
        }],
        ["path", {
            d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z",
            key: "svg-1"
        }]
    ]),
    poe = Xt("diamond-filled", "IconDiamondFilled", [
        ["path", {
            d: "M18 4a1 1 0 0 1 .783 .378l.074 .108l3 5a1 1 0 0 1 -.032 1.078l-.08 .103l-8.53 9.533a1.7 1.7 0 0 1 -1.215 .51c-.4 0 -.785 -.14 -1.11 -.417l-.135 -.126l-8.5 -9.5a1 1 0 0 1 -.172 -1.067l.06 -.115l3.013 -5.022l.064 -.09a.982 .982 0 0 1 .155 -.154l.089 -.064l.088 -.05l.05 -.023l.06 -.025l.109 -.032l.112 -.02l.117 -.005h12zm-8.886 3.943a1 1 0 0 0 -1.371 .343l-.6 1l-.06 .116a1 1 0 0 0 .177 1.07l2 2.2l.09 .088a1 1 0 0 0 1.323 -.02l.087 -.09a1 1 0 0 0 -.02 -1.323l-1.501 -1.65l.218 -.363l.055 -.103a1 1 0 0 0 -.398 -1.268z",
            fill: "currentColor",
            key: "svg-0",
            strokeWidth: "0"
        }]
    ]),
    moe = Xt("diamond", "IconDiamond", [
        ["path", {
            d: "M6 5h12l3 5l-8.5 9.5a.7 .7 0 0 1 -1 0l-8.5 -9.5l3 -5",
            key: "svg-0"
        }],
        ["path", {
            d: "M10 12l-2 -2.2l.6 -1",
            key: "svg-1"
        }]
    ]),
    goe = Xt("eye-off", "IconEyeOff", [
        ["path", {
            d: "M10.585 10.587a2 2 0 0 0 2.829 2.828",
            key: "svg-0"
        }],
        ["path", {
            d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87",
            key: "svg-1"
        }],
        ["path", {
            d: "M3 3l18 18",
            key: "svg-2"
        }]
    ]),
    voe = Xt("eye", "IconEye", [
        ["path", {
            d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0",
            key: "svg-0"
        }],
        ["path", {
            d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6",
            key: "svg-1"
        }]
    ]),
    vT = Xt("file-vector", "IconFileVector", [
        ["path", {
            d: "M14 3v4a1 1 0 0 0 1 1h4",
            key: "svg-0"
        }],
        ["path", {
            d: "M9.5 16.5m-1.5 0a1.5 1.5 0 1 0 3 0a1.5 1.5 0 1 0 -3 0",
            key: "svg-1"
        }],
        ["path", {
            d: "M14.5 12.5m-1.5 0a1.5 1.5 0 1 0 3 0a1.5 1.5 0 1 0 -3 0",
            key: "svg-2"
        }],
        ["path", {
            d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z",
            key: "svg-3"
        }],
        ["path", {
            d: "M9.5 15a2.5 2.5 0 0 1 2.5 -2.5h1",
            key: "svg-4"
        }]
    ]),
    yoe = Xt("file-x", "IconFileX", [
        ["path", {
            d: "M14 3v4a1 1 0 0 0 1 1h4",
            key: "svg-0"
        }],
        ["path", {
            d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z",
            key: "svg-1"
        }],
        ["path", {
            d: "M10 12l4 4m0 -4l-4 4",
            key: "svg-2"
        }]
    ]),
    _oe = Xt("home", "IconHome", [
        ["path", {
            d: "M5 12l-2 0l9 -9l9 9l-2 0",
            key: "svg-0"
        }],
        ["path", {
            d: "M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7",
            key: "svg-1"
        }],
        ["path", {
            d: "M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6",
            key: "svg-2"
        }]
    ]),
    woe = Xt("ruler-measure", "IconRulerMeasure", [
        ["path", {
            d: "M19.875 12c.621 0 1.125 .512 1.125 1.143v5.714c0 .631 -.504 1.143 -1.125 1.143h-15.875a1 1 0 0 1 -1 -1v-5.857c0 -.631 .504 -1.143 1.125 -1.143h15.75z",
            key: "svg-0"
        }],
        ["path", {
            d: "M9 12v2",
            key: "svg-1"
        }],
        ["path", {
            d: "M6 12v3",
            key: "svg-2"
        }],
        ["path", {
            d: "M12 12v3",
            key: "svg-3"
        }],
        ["path", {
            d: "M18 12v3",
            key: "svg-4"
        }],
        ["path", {
            d: "M15 12v2",
            key: "svg-5"
        }],
        ["path", {
            d: "M3 3v4",
            key: "svg-6"
        }],
        ["path", {
            d: "M3 5h18",
            key: "svg-7"
        }],
        ["path", {
            d: "M21 3v4",
            key: "svg-8"
        }]
    ]),
    yT = Xt("trash-x", "IconTrashX", [
        ["path", {
            d: "M4 7h16",
            key: "svg-0"
        }],
        ["path", {
            d: "M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12",
            key: "svg-1"
        }],
        ["path", {
            d: "M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3",
            key: "svg-2"
        }],
        ["path", {
            d: "M10 12l4 4m0 -4l-4 4",
            key: "svg-3"
        }]
    ]),
    boe = Xt("user-question", "IconUserQuestion", [
        ["path", {
            d: "M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0",
            key: "svg-0"
        }],
        ["path", {
            d: "M6 21v-2a4 4 0 0 1 4 -4h3.5",
            key: "svg-1"
        }],
        ["path", {
            d: "M19 22v.01",
            key: "svg-2"
        }],
        ["path", {
            d: "M19 19a2.003 2.003 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483",
            key: "svg-3"
        }]
    ]),
    xoe = Xt("zoom-in", "IconZoomIn", [
        ["path", {
            d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0",
            key: "svg-0"
        }],
        ["path", {
            d: "M7 10l6 0",
            key: "svg-1"
        }],
        ["path", {
            d: "M10 7l0 6",
            key: "svg-2"
        }],
        ["path", {
            d: "M21 21l-6 -6",
            key: "svg-3"
        }]
    ]),
    Eoe = Xt("zoom-out", "IconZoomOut", [
        ["path", {
            d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0",
            key: "svg-0"
        }],
        ["path", {
            d: "M7 10l6 0",
            key: "svg-1"
        }],
        ["path", {
            d: "M21 21l-6 -6",
            key: "svg-2"
        }]
    ]);

function Soe() {
    const [e, {
        open: t,
        close: r
    }] = cg(!1);
    return V.jsxs(V.Fragment, {
        children: [V.jsx(mi, {
            size: "lg",
            variant: "default",
            onClick: t,
            style: {
                width: 40,
                height: 40,
                position: "absolute",
                bottom: 10,
                right: 10,
                pointerEvents: "all"
            },
            className: "transparency",
            children: V.jsx(boe, {
                size: 18
            })
        }), V.jsxs(Ln, {
            title: "Information",
            opened: e,
            onClose: r,
            children: [V.jsxs(cD, {
                order: 2,
                children: ["Version: ", "2.1.3"]
            }), V.jsx("br", {}), V.jsxs(qt, {
                variant: "contained",
                defaultValue: "customization",
                children: [V.jsxs(qt.Item, {
                    value: "Contributors",
                    children: [V.jsx(qt.Control, {
                        children: "Contributors"
                    }), V.jsxs(qt.Panel, {
                        children: ["GRX is a free and open source software for viewing Gerber files. Built by", " ", V.jsx(Vi, {
                            href: "https://github.com/hpcreery",
                            target: "_blank",
                            children: "Hunter Creery"
                        }), " ", "and", " ", V.jsx(Vi, {
                            href: "https://github.com/phcreery",
                            target: "_blank",
                            children: "Peyton Creery"
                        }), "."]
                    })]
                }, "4"), V.jsxs(qt.Item, {
                    value: "Software Toolchain",
                    children: [V.jsx(qt.Control, {
                        children: "Software Toolchain"
                    }), V.jsxs(qt.Panel, {
                        children: ["GRX is built with", " ", V.jsx(Vi, {
                            href: "https://electronjs.org/",
                            target: "_blank",
                            children: "Electron"
                        }), ",", " ", V.jsx(Vi, {
                            href: "https://reactjs.org/",
                            target: "_blank",
                            children: "React"
                        }), ",", " ", V.jsx(Vi, {
                            href: "https://ui.mantine.dev/",
                            target: "_blank",
                            children: "Maintine UI"
                        }), ", and", " ", V.jsx(Vi, {
                            href: "https://pixijs.com/",
                            target: "_blank",
                            children: "PixiJS"
                        }), "."]
                    })]
                }, "1"), V.jsxs(qt.Item, {
                    value: "License",
                    children: [V.jsx(qt.Control, {
                        children: "License"
                    }), V.jsx(qt.Panel, {
                        children: V.jsxs(ir, {
                            children: ["GRX is licensed under the", " ", V.jsx(Vi, {
                                href: "https://opensource.org/license/mit/",
                                children: "MIT License"
                            }), " and found", " ", V.jsx(Vi, {
                                href: "https://github.com/hpcreery/GRX/blob/master/LICENSE",
                                children: "here"
                            }), "."]
                        })
                    })]
                }, "2"), V.jsxs(qt.Item, {
                    value: "Disclaimer",
                    children: [V.jsx(qt.Control, {
                        children: "Disclaimer"
                    }), V.jsxs(qt.Panel, {
                        children: [V.jsx(ir, {
                            children: 'This software is provided "as is" and without any express or implied warranties, including, without limitation, the implied warranties of merchantability and fitness for a particular purpose. The entire risk arising out of the use or performance of the software remains with you. In no event shall the authors or copyright holders be liable for any damages whatsoever (including, without limitation, damages for loss of business profits, business interruption, loss of business information, or other pecuniary loss) arising out of the use of or inability to use this software. Because some states/jurisdictions do not allow the exclusion or limitation of liability for consequential or incidental damages, the above limitation may not apply to you.'
                        }), V.jsx("br", {}), V.jsx(ir, {
                            c: "red",
                            children: "All data is processed locally on your computer. No data is sent to any servers. Your Data and Intellectual Property is not shared with anyone or any company."
                        })]
                    })]
                }, "3")]
            })]
        })]
    })
}
const pD = I.createContext({
    themeMode: "dark",
    setThemeMode: () => {},
    transparency: !0,
    setTransparency: () => {}
});

function Poe({
    gerberApp: e
}) {
    const [t, r] = I.useState(!1), [n, {
        open: i,
        close: s
    }] = cg(!1), {
        themeMode: o,
        setThemeMode: a,
        transparency: l,
        setTransparency: c
    } = I.useContext(pD), u = h => {
        e.renderer.then(async d => {
            d.setAllOutlineMode(h)
        }), r(h)
    };
    return V.jsxs(V.Fragment, {
        children: [V.jsx(kw, {
            withBorder: !0,
            style: {
                width: "unset",
                height: "unset",
                position: "absolute",
                top: 10,
                right: 10,
                pointerEvents: "all"
            },
            padding: 3,
            className: "transparency",
            children: V.jsxs(co, {
                spacing: 1,
                children: [V.jsx(mi, {
                    size: "lg",
                    onClick: () => u(!t),
                    children: t ? V.jsx(moe, {
                        size: 18
                    }) : V.jsx(poe, {
                        size: 18
                    })
                }), V.jsx(fa, {
                    my: "xs",
                    orientation: "vertical"
                }), V.jsx(mi, {
                    size: "lg",
                    onClick: () => {},
                    children: V.jsx(coe, {
                        size: 18
                    })
                }), V.jsx(mi, {
                    size: "lg",
                    onClick: () => {},
                    children: V.jsx(woe, {
                        size: 18
                    })
                }), V.jsx(fa, {
                    my: "xs",
                    orientation: "vertical"
                }), V.jsx(mi, {
                    size: "lg",
                    onClick: () => {
                        e.zoom(-550 / e.virtualViewport.scale.x)
                    },
                    children: V.jsx(xoe, {
                        size: 18
                    })
                }), V.jsx(mi, {
                    size: "lg",
                    onClick: async () => {
                        e.zoom(1e3 / e.virtualViewport.scale.x)
                    },
                    children: V.jsx(Eoe, {
                        size: 18
                    })
                }), V.jsx(mi, {
                    size: "lg",
                    onClick: () => {
                        e.zoomHome(), e.virtualViewport.decelerate()
                    },
                    children: V.jsx(_oe, {
                        size: 18
                    })
                }), V.jsx(fa, {
                    my: "xs",
                    orientation: "vertical"
                }), V.jsx(mi, {
                    size: "lg",
                    onClick: i,
                    children: V.jsx(loe, {
                        size: 18
                    })
                })]
            })
        }), V.jsxs(Ln, {
            title: "Settings",
            opened: n,
            onClose: s,
            children: [V.jsx(fa, {
                my: "sm"
            }), V.jsxs(R_, {
                align: "center",
                style: {
                    width: "100%"
                },
                justify: "space-between",
                children: [V.jsx(ir, {
                    children: "Dark Mode"
                }), V.jsx(qp, {
                    defaultChecked: o === "dark",
                    onChange: h => {
                        h.currentTarget.checked ? a("dark") : a("light")
                    }
                })]
            }), V.jsx(fa, {
                my: "sm"
            }), V.jsxs(R_, {
                align: "center",
                style: {
                    width: "100%"
                },
                justify: "space-between",
                children: [V.jsx(ir, {
                    children: "Transparency"
                }), V.jsx(qp, {
                    defaultChecked: l,
                    onChange: h => {
                        c(h.currentTarget.checked)
                    }
                })]
            })]
        })]
    })
}

function Coe(e) {
    const {
        gerberApp: t
    } = e, [r, n] = I.useState(0), [i, s] = I.useState(0);
    return I.useEffect(() => {
        const o = a => {
            n(a.detail.x), s(a.detail.y)
        };
        return t.pointer.addEventListener("pointermove", o), t.pointer.addEventListener("pointerdown", o), () => {
            t.pointer.removeEventListener("pointermove", o), t.pointer.removeEventListener("pointerdown", o)
        }
    }, []), V.jsx(Y5, {
        label: "Units: Mils",
        position: "left",
        withArrow: !0,
        children: V.jsx(kw, {
            withBorder: !0,
            style: {
                position: "absolute",
                bottom: 10,
                right: 60,
                pointerEvents: "all",
                width: 275,
                height: 40
            },
            className: "transparency",
            padding: 6.5,
            children: V.jsxs(co, {
                position: "center",
                grow: !0,
                ml: "xs",
                mr: "xs",
                children: [V.jsxs(co, {
                    children: [V.jsx(ir, {
                        c: "dimmed",
                        children: "X: "
                    }), r.toFixed(2)]
                }), V.jsxs(co, {
                    children: [V.jsx(ir, {
                        c: "dimmed",
                        children: "Y: "
                    }), i.toFixed(2)]
                })]
            })
        })
    })
}

function bl(e, t, r, n) {
    function i(s) {
        return s instanceof r ? s : new r(function(o) {
            o(s)
        })
    }
    return new(r || (r = Promise))(function(s, o) {
        function a(u) {
            try {
                c(n.next(u))
            } catch (h) {
                o(h)
            }
        }

        function l(u) {
            try {
                c(n.throw(u))
            } catch (h) {
                o(h)
            }
        }

        function c(u) {
            u.done ? s(u.value) : i(u.value).then(a, l)
        }
        c((n = n.apply(e, t || [])).next())
    })
}

function xl(e, t) {
    var r = {
            label: 0,
            sent: function() {
                if (s[0] & 1) throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        },
        n, i, s, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }), o;

    function a(c) {
        return function(u) {
            return l([c, u])
        }
    }

    function l(c) {
        if (n) throw new TypeError("Generator is already executing.");
        for (; o && (o = 0, c[0] && (r = 0)), r;) try {
            if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
            switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                case 0:
                case 1:
                    s = c;
                    break;
                case 4:
                    return r.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    r.label++, i = c[1], c = [0];
                    continue;
                case 7:
                    c = r.ops.pop(), r.trys.pop();
                    continue;
                default:
                    if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        r = 0;
                        continue
                    }
                    if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                        r.label = c[1];
                        break
                    }
                    if (c[0] === 6 && r.label < s[1]) {
                        r.label = s[1], s = c;
                        break
                    }
                    if (s && r.label < s[2]) {
                        r.label = s[2], r.ops.push(c);
                        break
                    }
                    s[2] && r.ops.pop(), r.trys.pop();
                    continue
            }
            c = t.call(e, r)
        } catch (u) {
            c = [6, u], i = 0
        } finally {
            n = s = 0
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}

function _T(e, t) {
    var r = typeof Symbol == "function" && e[Symbol.iterator];
    if (!r) return e;
    var n = r.call(e),
        i, s = [],
        o;
    try {
        for (;
            (t === void 0 || t-- > 0) && !(i = n.next()).done;) s.push(i.value)
    } catch (a) {
        o = {
            error: a
        }
    } finally {
        try {
            i && !i.done && (r = n.return) && r.call(n)
        } finally {
            if (o) throw o.error
        }
    }
    return s
}

function wT(e, t, r) {
    if (r || arguments.length === 2)
        for (var n = 0, i = t.length, s; n < i; n++)(s || !(n in t)) && (s || (s = Array.prototype.slice.call(t, 0, n)), s[n] = t[n]);
    return e.concat(s || Array.prototype.slice.call(t))
}
var Toe = new Map([
    ["aac", "audio/aac"],
    ["abw", "application/x-abiword"],
    ["arc", "application/x-freearc"],
    ["avif", "image/avif"],
    ["avi", "video/x-msvideo"],
    ["azw", "application/vnd.amazon.ebook"],
    ["bin", "application/octet-stream"],
    ["bmp", "image/bmp"],
    ["bz", "application/x-bzip"],
    ["bz2", "application/x-bzip2"],
    ["cda", "application/x-cdf"],
    ["csh", "application/x-csh"],
    ["css", "text/css"],
    ["csv", "text/csv"],
    ["doc", "application/msword"],
    ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    ["eot", "application/vnd.ms-fontobject"],
    ["epub", "application/epub+zip"],
    ["gz", "application/gzip"],
    ["gif", "image/gif"],
    ["heic", "image/heic"],
    ["heif", "image/heif"],
    ["htm", "text/html"],
    ["html", "text/html"],
    ["ico", "image/vnd.microsoft.icon"],
    ["ics", "text/calendar"],
    ["jar", "application/java-archive"],
    ["jpeg", "image/jpeg"],
    ["jpg", "image/jpeg"],
    ["js", "text/javascript"],
    ["json", "application/json"],
    ["jsonld", "application/ld+json"],
    ["mid", "audio/midi"],
    ["midi", "audio/midi"],
    ["mjs", "text/javascript"],
    ["mp3", "audio/mpeg"],
    ["mp4", "video/mp4"],
    ["mpeg", "video/mpeg"],
    ["mpkg", "application/vnd.apple.installer+xml"],
    ["odp", "application/vnd.oasis.opendocument.presentation"],
    ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
    ["odt", "application/vnd.oasis.opendocument.text"],
    ["oga", "audio/ogg"],
    ["ogv", "video/ogg"],
    ["ogx", "application/ogg"],
    ["opus", "audio/opus"],
    ["otf", "font/otf"],
    ["png", "image/png"],
    ["pdf", "application/pdf"],
    ["php", "application/x-httpd-php"],
    ["ppt", "application/vnd.ms-powerpoint"],
    ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
    ["rar", "application/vnd.rar"],
    ["rtf", "application/rtf"],
    ["sh", "application/x-sh"],
    ["svg", "image/svg+xml"],
    ["swf", "application/x-shockwave-flash"],
    ["tar", "application/x-tar"],
    ["tif", "image/tiff"],
    ["tiff", "image/tiff"],
    ["ts", "video/mp2t"],
    ["ttf", "font/ttf"],
    ["txt", "text/plain"],
    ["vsd", "application/vnd.visio"],
    ["wav", "audio/wav"],
    ["weba", "audio/webm"],
    ["webm", "video/webm"],
    ["webp", "image/webp"],
    ["woff", "font/woff"],
    ["woff2", "font/woff2"],
    ["xhtml", "application/xhtml+xml"],
    ["xls", "application/vnd.ms-excel"],
    ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
    ["xml", "application/xml"],
    ["xul", "application/vnd.mozilla.xul+xml"],
    ["zip", "application/zip"],
    ["7z", "application/x-7z-compressed"],
    ["mkv", "video/x-matroska"],
    ["mov", "video/quicktime"],
    ["msg", "application/vnd.ms-outlook"]
]);

function Ru(e, t) {
    var r = Ooe(e);
    if (typeof r.path != "string") {
        var n = e.webkitRelativePath;
        Object.defineProperty(r, "path", {
            value: typeof t == "string" ? t : typeof n == "string" && n.length > 0 ? n : e.name,
            writable: !1,
            configurable: !1,
            enumerable: !0
        })
    }
    return r
}

function Ooe(e) {
    var t = e.name,
        r = t && t.lastIndexOf(".") !== -1;
    if (r && !e.type) {
        var n = t.split(".").pop().toLowerCase(),
            i = Toe.get(n);
        i && Object.defineProperty(e, "type", {
            value: i,
            writable: !1,
            configurable: !1,
            enumerable: !0
        })
    }
    return e
}
var Aoe = [".DS_Store", "Thumbs.db"];

function Ioe(e) {
    return bl(this, void 0, void 0, function() {
        return xl(this, function(t) {
            return em(e) && $oe(e.dataTransfer) ? [2, Doe(e.dataTransfer, e.type)] : Roe(e) ? [2, koe(e)] : Array.isArray(e) && e.every(function(r) {
                return "getFile" in r && typeof r.getFile == "function"
            }) ? [2, Moe(e)] : [2, []]
        })
    })
}

function $oe(e) {
    return em(e)
}

function Roe(e) {
    return em(e) && em(e.target)
}

function em(e) {
    return typeof e == "object" && e !== null
}

function koe(e) {
    return M_(e.target.files).map(function(t) {
        return Ru(t)
    })
}

function Moe(e) {
    return bl(this, void 0, void 0, function() {
        var t;
        return xl(this, function(r) {
            switch (r.label) {
                case 0:
                    return [4, Promise.all(e.map(function(n) {
                        return n.getFile()
                    }))];
                case 1:
                    return t = r.sent(), [2, t.map(function(n) {
                        return Ru(n)
                    })]
            }
        })
    })
}

function Doe(e, t) {
    return bl(this, void 0, void 0, function() {
        var r, n;
        return xl(this, function(i) {
            switch (i.label) {
                case 0:
                    return e.items ? (r = M_(e.items).filter(function(s) {
                        return s.kind === "file"
                    }), t !== "drop" ? [2, r] : [4, Promise.all(r.map(Noe))]) : [3, 2];
                case 1:
                    return n = i.sent(), [2, bT(mD(n))];
                case 2:
                    return [2, bT(M_(e.files).map(function(s) {
                        return Ru(s)
                    }))]
            }
        })
    })
}

function bT(e) {
    return e.filter(function(t) {
        return Aoe.indexOf(t.name) === -1
    })
}

function M_(e) {
    if (e === null) return [];
    for (var t = [], r = 0; r < e.length; r++) {
        var n = e[r];
        t.push(n)
    }
    return t
}

function Noe(e) {
    if (typeof e.webkitGetAsEntry != "function") return xT(e);
    var t = e.webkitGetAsEntry();
    return t && t.isDirectory ? gD(t) : xT(e)
}

function mD(e) {
    return e.reduce(function(t, r) {
        return wT(wT([], _T(t), !1), _T(Array.isArray(r) ? mD(r) : [r]), !1)
    }, [])
}

function xT(e) {
    var t = e.getAsFile();
    if (!t) return Promise.reject("".concat(e, " is not a File"));
    var r = Ru(t);
    return Promise.resolve(r)
}

function Loe(e) {
    return bl(this, void 0, void 0, function() {
        return xl(this, function(t) {
            return [2, e.isDirectory ? gD(e) : Foe(e)]
        })
    })
}

function gD(e) {
    var t = e.createReader();
    return new Promise(function(r, n) {
        var i = [];

        function s() {
            var o = this;
            t.readEntries(function(a) {
                return bl(o, void 0, void 0, function() {
                    var l, c, u;
                    return xl(this, function(h) {
                        switch (h.label) {
                            case 0:
                                if (a.length) return [3, 5];
                                h.label = 1;
                            case 1:
                                return h.trys.push([1, 3, , 4]), [4, Promise.all(i)];
                            case 2:
                                return l = h.sent(), r(l), [3, 4];
                            case 3:
                                return c = h.sent(), n(c), [3, 4];
                            case 4:
                                return [3, 6];
                            case 5:
                                u = Promise.all(a.map(Loe)), i.push(u), s(), h.label = 6;
                            case 6:
                                return [2]
                        }
                    })
                })
            }, function(a) {
                n(a)
            })
        }
        s()
    })
}

function Foe(e) {
    return bl(this, void 0, void 0, function() {
        return xl(this, function(t) {
            return [2, new Promise(function(r, n) {
                e.file(function(i) {
                    var s = Ru(i, e.fullPath);
                    r(s)
                }, function(i) {
                    n(i)
                })
            })]
        })
    })
}
var Boe = function(e, t) {
    if (e && t) {
        var r = Array.isArray(t) ? t : t.split(","),
            n = e.name || "",
            i = (e.type || "").toLowerCase(),
            s = i.replace(/\/.*$/, "");
        return r.some(function(o) {
            var a = o.trim().toLowerCase();
            return a.charAt(0) === "." ? n.toLowerCase().endsWith(a) : a.endsWith("/*") ? s === a.replace(/\/.*$/, "") : i === a
        })
    }
    return !0
};

function ET(e) {
    return Uoe(e) || joe(e) || yD(e) || zoe()
}

function zoe() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function joe(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function Uoe(e) {
    if (Array.isArray(e)) return D_(e)
}

function ST(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function PT(e) {
    for (var t = 1; t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? ST(Object(r), !0).forEach(function(n) {
            vD(e, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ST(Object(r)).forEach(function(n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return e
}

function vD(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = r, e
}

function lu(e, t) {
    return Voe(e) || Goe(e, t) || yD(e, t) || Hoe()
}

function Hoe() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function yD(e, t) {
    if (e) {
        if (typeof e == "string") return D_(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return D_(e, t)
    }
}

function D_(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
    return n
}

function Goe(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
        var n = [],
            i = !0,
            s = !1,
            o, a;
        try {
            for (r = r.call(e); !(i = (o = r.next()).done) && (n.push(o.value), !(t && n.length === t)); i = !0);
        } catch (l) {
            s = !0, a = l
        } finally {
            try {
                !i && r.return != null && r.return()
            } finally {
                if (s) throw a
            }
        }
        return n
    }
}

function Voe(e) {
    if (Array.isArray(e)) return e
}
var Woe = "file-invalid-type",
    Xoe = "file-too-large",
    Yoe = "file-too-small",
    Koe = "too-many-files",
    qoe = function(t) {
        t = Array.isArray(t) && t.length === 1 ? t[0] : t;
        var r = Array.isArray(t) ? "one of ".concat(t.join(", ")) : t;
        return {
            code: Woe,
            message: "File type must be ".concat(r)
        }
    },
    CT = function(t) {
        return {
            code: Xoe,
            message: "File is larger than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
        }
    },
    TT = function(t) {
        return {
            code: Yoe,
            message: "File is smaller than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
        }
    },
    Qoe = {
        code: Koe,
        message: "Too many files"
    };

function _D(e, t) {
    var r = e.type === "application/x-moz-file" || Boe(e, t);
    return [r, r ? null : qoe(t)]
}

function wD(e, t, r) {
    if (Qs(e.size))
        if (Qs(t) && Qs(r)) {
            if (e.size > r) return [!1, CT(r)];
            if (e.size < t) return [!1, TT(t)]
        } else {
            if (Qs(t) && e.size < t) return [!1, TT(t)];
            if (Qs(r) && e.size > r) return [!1, CT(r)]
        }
    return [!0, null]
}

function Qs(e) {
    return e != null
}

function Zoe(e) {
    var t = e.files,
        r = e.accept,
        n = e.minSize,
        i = e.maxSize,
        s = e.multiple,
        o = e.maxFiles,
        a = e.validator;
    return !s && t.length > 1 || s && o >= 1 && t.length > o ? !1 : t.every(function(l) {
        var c = _D(l, r),
            u = lu(c, 1),
            h = u[0],
            d = wD(l, n, i),
            f = lu(d, 1),
            p = f[0],
            m = a ? a(l) : null;
        return h && p && !m
    })
}

function tm(e) {
    return typeof e.isPropagationStopped == "function" ? e.isPropagationStopped() : typeof e.cancelBubble < "u" ? e.cancelBubble : !1
}

function id(e) {
    return e.dataTransfer ? Array.prototype.some.call(e.dataTransfer.types, function(t) {
        return t === "Files" || t === "application/x-moz-file"
    }) : !!e.target && !!e.target.files
}

function OT(e) {
    e.preventDefault()
}

function Joe(e) {
    return e.indexOf("MSIE") !== -1 || e.indexOf("Trident/") !== -1
}

function eae(e) {
    return e.indexOf("Edge/") !== -1
}

function tae() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
    return Joe(e) || eae(e)
}

function zn() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    return function(n) {
        for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) s[o - 1] = arguments[o];
        return t.some(function(a) {
            return !tm(n) && a && a.apply(void 0, [n].concat(s)), tm(n)
        })
    }
}

function rae() {
    return "showOpenFilePicker" in window
}

function nae(e) {
    if (Qs(e)) {
        var t = Object.entries(e).filter(function(r) {
            var n = lu(r, 2),
                i = n[0],
                s = n[1],
                o = !0;
            return bD(i) || (console.warn('Skipped "'.concat(i, '" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')), o = !1), (!Array.isArray(s) || !s.every(xD)) && (console.warn('Skipped "'.concat(i, '" because an invalid file extension was provided.')), o = !1), o
        }).reduce(function(r, n) {
            var i = lu(n, 2),
                s = i[0],
                o = i[1];
            return PT(PT({}, r), {}, vD({}, s, o))
        }, {});
        return [{
            description: "Files",
            accept: t
        }]
    }
    return e
}

function iae(e) {
    if (Qs(e)) return Object.entries(e).reduce(function(t, r) {
        var n = lu(r, 2),
            i = n[0],
            s = n[1];
        return [].concat(ET(t), [i], ET(s))
    }, []).filter(function(t) {
        return bD(t) || xD(t)
    }).join(",")
}

function sae(e) {
    return e instanceof DOMException && (e.name === "AbortError" || e.code === e.ABORT_ERR)
}

function oae(e) {
    return e instanceof DOMException && (e.name === "SecurityError" || e.code === e.SECURITY_ERR)
}

function bD(e) {
    return e === "audio/*" || e === "video/*" || e === "image/*" || e === "text/*" || /\w+\/[-+.\w]+/g.test(e)
}

function xD(e) {
    return /^.*\.[\w]+$/.test(e)
}
var aae = ["children"],
    lae = ["open"],
    cae = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"],
    uae = ["refKey", "onChange", "onClick"];

function hae(e) {
    return pae(e) || fae(e) || ED(e) || dae()
}

function dae() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function fae(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
}

function pae(e) {
    if (Array.isArray(e)) return N_(e)
}

function E0(e, t) {
    return vae(e) || gae(e, t) || ED(e, t) || mae()
}

function mae() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function ED(e, t) {
    if (e) {
        if (typeof e == "string") return N_(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return N_(e, t)
    }
}

function N_(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
    return n
}

function gae(e, t) {
    var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (r != null) {
        var n = [],
            i = !0,
            s = !1,
            o, a;
        try {
            for (r = r.call(e); !(i = (o = r.next()).done) && (n.push(o.value), !(t && n.length === t)); i = !0);
        } catch (l) {
            s = !0, a = l
        } finally {
            try {
                !i && r.return != null && r.return()
            } finally {
                if (s) throw a
            }
        }
        return n
    }
}

function vae(e) {
    if (Array.isArray(e)) return e
}

function AT(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function yt(e) {
    for (var t = 1; t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? AT(Object(r), !0).forEach(function(n) {
            L_(e, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : AT(Object(r)).forEach(function(n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return e
}

function L_(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = r, e
}

function rm(e, t) {
    if (e == null) return {};
    var r = yae(e, t),
        n, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for (i = 0; i < s.length; i++) n = s[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n])
    }
    return r
}

function yae(e, t) {
    if (e == null) return {};
    var r = {},
        n = Object.keys(e),
        i, s;
    for (s = 0; s < n.length; s++) i = n[s], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
    return r
}
var Lw = b.forwardRef(function(e, t) {
    var r = e.children,
        n = rm(e, aae),
        i = PD(n),
        s = i.open,
        o = rm(i, lae);
    return b.useImperativeHandle(t, function() {
        return {
            open: s
        }
    }, [s]), I.createElement(b.Fragment, null, r(yt(yt({}, o), {}, {
        open: s
    })))
});
Lw.displayName = "Dropzone";
var SD = {
    disabled: !1,
    getFilesFromEvent: Ioe,
    maxSize: 1 / 0,
    minSize: 0,
    multiple: !0,
    maxFiles: 0,
    preventDropOnDocument: !0,
    noClick: !1,
    noKeyboard: !1,
    noDrag: !1,
    noDragEventsBubbling: !1,
    validator: null,
    useFsAccessApi: !0,
    autoFocus: !1
};
Lw.defaultProps = SD;
Lw.propTypes = {
    children: Be.func,
    accept: Be.objectOf(Be.arrayOf(Be.string)),
    multiple: Be.bool,
    preventDropOnDocument: Be.bool,
    noClick: Be.bool,
    noKeyboard: Be.bool,
    noDrag: Be.bool,
    noDragEventsBubbling: Be.bool,
    minSize: Be.number,
    maxSize: Be.number,
    maxFiles: Be.number,
    disabled: Be.bool,
    getFilesFromEvent: Be.func,
    onFileDialogCancel: Be.func,
    onFileDialogOpen: Be.func,
    useFsAccessApi: Be.bool,
    autoFocus: Be.bool,
    onDragEnter: Be.func,
    onDragLeave: Be.func,
    onDragOver: Be.func,
    onDrop: Be.func,
    onDropAccepted: Be.func,
    onDropRejected: Be.func,
    onError: Be.func,
    validator: Be.func
};
var F_ = {
    isFocused: !1,
    isFileDialogActive: !1,
    isDragActive: !1,
    isDragAccept: !1,
    isDragReject: !1,
    acceptedFiles: [],
    fileRejections: []
};

function PD() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
        t = yt(yt({}, SD), e),
        r = t.accept,
        n = t.disabled,
        i = t.getFilesFromEvent,
        s = t.maxSize,
        o = t.minSize,
        a = t.multiple,
        l = t.maxFiles,
        c = t.onDragEnter,
        u = t.onDragLeave,
        h = t.onDragOver,
        d = t.onDrop,
        f = t.onDropAccepted,
        p = t.onDropRejected,
        m = t.onFileDialogCancel,
        w = t.onFileDialogOpen,
        y = t.useFsAccessApi,
        v = t.autoFocus,
        _ = t.preventDropOnDocument,
        E = t.noClick,
        P = t.noKeyboard,
        C = t.noDrag,
        T = t.noDragEventsBubbling,
        O = t.onError,
        k = t.validator,
        D = b.useMemo(function() {
            return iae(r)
        }, [r]),
        B = b.useMemo(function() {
            return nae(r)
        }, [r]),
        j = b.useMemo(function() {
            return typeof w == "function" ? w : IT
        }, [w]),
        L = b.useMemo(function() {
            return typeof m == "function" ? m : IT
        }, [m]),
        M = b.useRef(null),
        W = b.useRef(null),
        Z = b.useReducer(_ae, F_),
        q = E0(Z, 2),
        G = q[0],
        X = q[1],
        z = G.isFocused,
        Q = G.isFileDialogActive,
        ie = b.useRef(typeof window < "u" && window.isSecureContext && y && rae()),
        _e = function() {
            !ie.current && Q && setTimeout(function() {
                if (W.current) {
                    var xe = W.current.files;
                    xe.length || (X({
                        type: "closeDialog"
                    }), L())
                }
            }, 300)
        };
    b.useEffect(function() {
        return window.addEventListener("focus", _e, !1),
            function() {
                window.removeEventListener("focus", _e, !1)
            }
    }, [W, Q, L, ie]);
    var we = b.useRef([]),
        De = function(xe) {
            M.current && M.current.contains(xe.target) || (xe.preventDefault(), we.current = [])
        };
    b.useEffect(function() {
        return _ && (document.addEventListener("dragover", OT, !1), document.addEventListener("drop", De, !1)),
            function() {
                _ && (document.removeEventListener("dragover", OT), document.removeEventListener("drop", De))
            }
    }, [M, _]), b.useEffect(function() {
        return !n && v && M.current && M.current.focus(),
            function() {}
    }, [M, v, n]);
    var Te = b.useCallback(function(ae) {
            O ? O(ae) : console.error(ae)
        }, [O]),
        Ne = b.useCallback(function(ae) {
            ae.preventDefault(), ae.persist(), Ar(ae), we.current = [].concat(hae(we.current), [ae.target]), id(ae) && Promise.resolve(i(ae)).then(function(xe) {
                if (!(tm(ae) && !T)) {
                    var gt = xe.length,
                        At = gt > 0 && Zoe({
                            files: xe,
                            accept: D,
                            minSize: o,
                            maxSize: s,
                            multiple: a,
                            maxFiles: l,
                            validator: k
                        }),
                        or = gt > 0 && !At;
                    X({
                        isDragAccept: At,
                        isDragReject: or,
                        isDragActive: !0,
                        type: "setDraggedFiles"
                    }), c && c(ae)
                }
            }).catch(function(xe) {
                return Te(xe)
            })
        }, [i, c, Te, T, D, o, s, a, l, k]),
        et = b.useCallback(function(ae) {
            ae.preventDefault(), ae.persist(), Ar(ae);
            var xe = id(ae);
            if (xe && ae.dataTransfer) try {
                ae.dataTransfer.dropEffect = "copy"
            } catch {}
            return xe && h && h(ae), !1
        }, [h, T]),
        Le = b.useCallback(function(ae) {
            ae.preventDefault(), ae.persist(), Ar(ae);
            var xe = we.current.filter(function(At) {
                    return M.current && M.current.contains(At)
                }),
                gt = xe.indexOf(ae.target);
            gt !== -1 && xe.splice(gt, 1), we.current = xe, !(xe.length > 0) && (X({
                type: "setDraggedFiles",
                isDragActive: !1,
                isDragAccept: !1,
                isDragReject: !1
            }), id(ae) && u && u(ae))
        }, [M, u, T]),
        tt = b.useCallback(function(ae, xe) {
            var gt = [],
                At = [];
            ae.forEach(function(or) {
                var Li = _D(or, D),
                    li = E0(Li, 2),
                    Pl = li[0],
                    Cl = li[1],
                    Mo = wD(or, o, s),
                    ks = E0(Mo, 2),
                    Tl = ks[0],
                    Ol = ks[1],
                    Do = k ? k(or) : null;
                if (Pl && Tl && !Do) gt.push(or);
                else {
                    var No = [Cl, Ol];
                    Do && (No = No.concat(Do)), At.push({
                        file: or,
                        errors: No.filter(function(Tg) {
                            return Tg
                        })
                    })
                }
            }), (!a && gt.length > 1 || a && l >= 1 && gt.length > l) && (gt.forEach(function(or) {
                At.push({
                    file: or,
                    errors: [Qoe]
                })
            }), gt.splice(0)), X({
                acceptedFiles: gt,
                fileRejections: At,
                type: "setFiles"
            }), d && d(gt, At, xe), At.length > 0 && p && p(At, xe), gt.length > 0 && f && f(gt, xe)
        }, [X, a, D, o, s, l, d, f, p, k]),
        Ue = b.useCallback(function(ae) {
            ae.preventDefault(), ae.persist(), Ar(ae), we.current = [], id(ae) && Promise.resolve(i(ae)).then(function(xe) {
                tm(ae) && !T || tt(xe, ae)
            }).catch(function(xe) {
                return Te(xe)
            }), X({
                type: "reset"
            })
        }, [i, tt, Te, T]),
        Ve = b.useCallback(function() {
            if (ie.current) {
                X({
                    type: "openDialog"
                }), j();
                var ae = {
                    multiple: a,
                    types: B
                };
                window.showOpenFilePicker(ae).then(function(xe) {
                    return i(xe)
                }).then(function(xe) {
                    tt(xe, null), X({
                        type: "closeDialog"
                    })
                }).catch(function(xe) {
                    sae(xe) ? (L(xe), X({
                        type: "closeDialog"
                    })) : oae(xe) ? (ie.current = !1, W.current ? (W.current.value = null, W.current.click()) : Te(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))) : Te(xe)
                });
                return
            }
            W.current && (X({
                type: "openDialog"
            }), j(), W.current.value = null, W.current.click())
        }, [X, j, L, y, tt, Te, B, a]),
        rt = b.useCallback(function(ae) {
            !M.current || !M.current.isEqualNode(ae.target) || (ae.key === " " || ae.key === "Enter" || ae.keyCode === 32 || ae.keyCode === 13) && (ae.preventDefault(), Ve())
        }, [M, Ve]),
        Dt = b.useCallback(function() {
            X({
                type: "focus"
            })
        }, []),
        zt = b.useCallback(function() {
            X({
                type: "blur"
            })
        }, []),
        Vr = b.useCallback(function() {
            E || (tae() ? setTimeout(Ve, 0) : Ve())
        }, [E, Ve]),
        at = function(xe) {
            return n ? null : xe
        },
        _r = function(xe) {
            return P ? null : at(xe)
        },
        Ni = function(xe) {
            return C ? null : at(xe)
        },
        Ar = function(xe) {
            T && xe.stopPropagation()
        },
        Bu = b.useMemo(function() {
            return function() {
                var ae = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                    xe = ae.refKey,
                    gt = xe === void 0 ? "ref" : xe,
                    At = ae.role,
                    or = ae.onKeyDown,
                    Li = ae.onFocus,
                    li = ae.onBlur,
                    Pl = ae.onClick,
                    Cl = ae.onDragEnter,
                    Mo = ae.onDragOver,
                    ks = ae.onDragLeave,
                    Tl = ae.onDrop,
                    Ol = rm(ae, cae);
                return yt(yt(L_({
                    onKeyDown: _r(zn(or, rt)),
                    onFocus: _r(zn(Li, Dt)),
                    onBlur: _r(zn(li, zt)),
                    onClick: at(zn(Pl, Vr)),
                    onDragEnter: Ni(zn(Cl, Ne)),
                    onDragOver: Ni(zn(Mo, et)),
                    onDragLeave: Ni(zn(ks, Le)),
                    onDrop: Ni(zn(Tl, Ue)),
                    role: typeof At == "string" && At !== "" ? At : "presentation"
                }, gt, M), !n && !P ? {
                    tabIndex: 0
                } : {}), Ol)
            }
        }, [M, rt, Dt, zt, Vr, Ne, et, Le, Ue, P, C, n]),
        zu = b.useCallback(function(ae) {
            ae.stopPropagation()
        }, []),
        ju = b.useMemo(function() {
            return function() {
                var ae = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                    xe = ae.refKey,
                    gt = xe === void 0 ? "ref" : xe,
                    At = ae.onChange,
                    or = ae.onClick,
                    Li = rm(ae, uae),
                    li = L_({
                        accept: D,
                        multiple: a,
                        type: "file",
                        style: {
                            display: "none"
                        },
                        onChange: at(zn(At, Ue)),
                        onClick: at(zn(or, zu)),
                        tabIndex: -1
                    }, gt, W);
                return yt(yt({}, li), Li)
            }
        }, [W, r, a, Ue, n]);
    return yt(yt({}, G), {}, {
        isFocused: z && !n,
        getRootProps: Bu,
        getInputProps: ju,
        rootRef: M,
        inputRef: W,
        open: at(Ve)
    })
}

function _ae(e, t) {
    switch (t.type) {
        case "focus":
            return yt(yt({}, e), {}, {
                isFocused: !0
            });
        case "blur":
            return yt(yt({}, e), {}, {
                isFocused: !1
            });
        case "openDialog":
            return yt(yt({}, F_), {}, {
                isFileDialogActive: !0
            });
        case "closeDialog":
            return yt(yt({}, e), {}, {
                isFileDialogActive: !1
            });
        case "setDraggedFiles":
            return yt(yt({}, e), {}, {
                isDragActive: t.isDragActive,
                isDragAccept: t.isDragAccept,
                isDragReject: t.isDragReject
            });
        case "setFiles":
            return yt(yt({}, e), {}, {
                acceptedFiles: t.acceptedFiles,
                fileRejections: t.fileRejections
            });
        case "reset":
            return yt({}, F_);
        default:
            return e
    }
}

function IT() {}
const [wae, bae] = ml("Dropzone component was not found in tree");
var $T = Object.getOwnPropertySymbols,
    xae = Object.prototype.hasOwnProperty,
    Eae = Object.prototype.propertyIsEnumerable,
    Sae = (e, t) => {
        var r = {};
        for (var n in e) xae.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && $T)
            for (var n of $T(e)) t.indexOf(n) < 0 && Eae.call(e, n) && (r[n] = e[n]);
        return r
    };

function Fw(e) {
    const t = r => {
        const n = ve(`Dropzone${fP(e)}`, {}, r),
            {
                children: i
            } = n,
            s = Sae(n, ["children"]),
            o = bae(),
            a = Pu(i) ? i : I.createElement("span", null, i);
        return o[e] ? b.cloneElement(a, s) : null
    };
    return t.displayName = `@mantine/dropzone/${fP(e)}`, t
}
const Pae = Fw("accept"),
    Cae = Fw("reject"),
    Tae = Fw("idle");
var Oae = Object.defineProperty,
    Aae = Object.defineProperties,
    Iae = Object.getOwnPropertyDescriptors,
    RT = Object.getOwnPropertySymbols,
    $ae = Object.prototype.hasOwnProperty,
    Rae = Object.prototype.propertyIsEnumerable,
    kT = (e, t, r) => t in e ? Oae(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    MT = (e, t) => {
        for (var r in t || (t = {})) $ae.call(t, r) && kT(e, r, t[r]);
        if (RT)
            for (var r of RT(t)) Rae.call(t, r) && kT(e, r, t[r]);
        return e
    },
    kae = (e, t) => Aae(e, Iae(t)),
    Mae = Pe((e, {
        padding: t,
        radius: r
    }) => {
        const n = e.fn.variant({
                color: "red",
                variant: "light"
            }),
            i = e.fn.variant({
                color: e.primaryColor,
                variant: "light"
            });
        return {
            root: kae(MT(MT({}, e.fn.fontStyles()), e.fn.focusStyles()), {
                boxSizing: "border-box",
                backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white,
                border: `${R(2)} dashed ${e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[4]}`,
                padding: he({
                    size: t,
                    sizes: e.spacing
                }),
                borderRadius: e.fn.radius(r),
                cursor: "pointer",
                userSelect: "none",
                transition: "background-color 150ms ease",
                position: "relative",
                "&:hover": {
                    backgroundColor: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[0]
                },
                "&[data-loading]": {
                    cursor: "default",
                    "&:hover": {
                        backgroundColor: e.colorScheme === "dark" ? e.colors.dark[6] : e.white
                    }
                },
                "&[data-accept]": {
                    backgroundColor: e.colorScheme === "dark" ? i.background : e.colors[e.primaryColor][0],
                    borderColor: e.colorScheme === "dark" ? i.border : e.colors[e.primaryColor][4],
                    "&:hover": {
                        backgroundColor: e.colorScheme === "dark" ? i.background : e.colors[e.primaryColor][0]
                    }
                },
                "&[data-reject]": {
                    backgroundColor: e.colorScheme === "dark" ? n.background : e.colors.red[0],
                    borderColor: e.colorScheme === "dark" ? n.border : e.colors.red[4],
                    "&:hover": {
                        backgroundColor: e.colorScheme === "dark" ? n.background : e.colors.red[0]
                    }
                }
            }),
            inner: {
                pointerEvents: "none",
                userSelect: "none"
            }
        }
    });
const Dae = Mae;
var Nae = Object.defineProperty,
    Lae = Object.defineProperties,
    Fae = Object.getOwnPropertyDescriptors,
    nm = Object.getOwnPropertySymbols,
    CD = Object.prototype.hasOwnProperty,
    TD = Object.prototype.propertyIsEnumerable,
    DT = (e, t, r) => t in e ? Nae(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    ec = (e, t) => {
        for (var r in t || (t = {})) CD.call(t, r) && DT(e, r, t[r]);
        if (nm)
            for (var r of nm(t)) TD.call(t, r) && DT(e, r, t[r]);
        return e
    },
    S0 = (e, t) => Lae(e, Fae(t)),
    Bae = (e, t) => {
        var r = {};
        for (var n in e) CD.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && nm)
            for (var n of nm(e)) t.indexOf(n) < 0 && TD.call(e, n) && (r[n] = e[n]);
        return r
    };
const zae = {
    padding: "md",
    loading: !1,
    multiple: !0,
    maxSize: 1 / 0,
    autoFocus: !1,
    activateOnClick: !0,
    activateOnDrag: !0,
    dragEventsBubbling: !0,
    activateOnKeyboard: !0,
    useFsAccessApi: !0
};

function El(e) {
    const t = ve("Dropzone", zae, e),
        {
            className: r,
            padding: n,
            radius: i,
            disabled: s,
            classNames: o,
            styles: a,
            loading: l,
            multiple: c,
            maxSize: u,
            accept: h,
            children: d,
            onDropAny: f,
            onDrop: p,
            onReject: m,
            openRef: w,
            name: y,
            unstyled: v,
            maxFiles: _,
            autoFocus: E,
            activateOnClick: P,
            activateOnDrag: C,
            dragEventsBubbling: T,
            activateOnKeyboard: O,
            onDragEnter: k,
            onDragLeave: D,
            onDragOver: B,
            onFileDialogCancel: j,
            onFileDialogOpen: L,
            preventDropOnDocument: M,
            useFsAccessApi: W,
            getFilesFromEvent: Z,
            validator: q,
            variant: G
        } = t,
        X = Bae(t, ["className", "padding", "radius", "disabled", "classNames", "styles", "loading", "multiple", "maxSize", "accept", "children", "onDropAny", "onDrop", "onReject", "openRef", "name", "unstyled", "maxFiles", "autoFocus", "activateOnClick", "activateOnDrag", "dragEventsBubbling", "activateOnKeyboard", "onDragEnter", "onDragLeave", "onDragOver", "onFileDialogCancel", "onFileDialogOpen", "preventDropOnDocument", "useFsAccessApi", "getFilesFromEvent", "validator", "variant"]),
        {
            classes: z,
            cx: Q
        } = Dae({
            radius: i,
            padding: n
        }, {
            name: "Dropzone",
            classNames: o,
            styles: a,
            unstyled: v,
            variant: G
        }),
        {
            getRootProps: ie,
            getInputProps: _e,
            isDragAccept: we,
            isDragReject: De,
            open: Te
        } = PD(ec({
            onDrop: f,
            onDropAccepted: p,
            onDropRejected: m,
            disabled: s || l,
            accept: Array.isArray(h) ? h.reduce((et, Le) => S0(ec({}, et), {
                [Le]: []
            }), {}) : h,
            multiple: c,
            maxSize: u,
            maxFiles: _,
            autoFocus: E,
            noClick: !P,
            noDrag: !C,
            noDragEventsBubbling: !T,
            noKeyboard: !O,
            onDragEnter: k,
            onDragLeave: D,
            onDragOver: B,
            onFileDialogCancel: j,
            onFileDialogOpen: L,
            preventDropOnDocument: M,
            useFsAccessApi: W,
            validator: q
        }, Z ? {
            getFilesFromEvent: Z
        } : null));
    mw(w, Te);
    const Ne = !we && !De;
    return I.createElement(wae, {
        value: {
            accept: we,
            reject: De,
            idle: Ne
        }
    }, I.createElement(Ie, S0(ec(ec({}, X), ie()), {
        "data-accept": we || void 0,
        "data-reject": De || void 0,
        "data-idle": Ne || void 0,
        "data-loading": l || void 0,
        className: Q(z.root, r)
    }), I.createElement(C5, {
        visible: l,
        radius: i,
        unstyled: v
    }), I.createElement("input", S0(ec({}, _e()), {
        name: y
    })), I.createElement("div", {
        className: z.inner
    }, d)))
}
El.displayName = "@mantine/dropzone/Dropzone";
El.Accept = Pae;
El.Reject = Cae;
El.Idle = Tae;
const OD = El;
var jae = Object.defineProperty,
    Uae = Object.defineProperties,
    Hae = Object.getOwnPropertyDescriptors,
    NT = Object.getOwnPropertySymbols,
    Gae = Object.prototype.hasOwnProperty,
    Vae = Object.prototype.propertyIsEnumerable,
    LT = (e, t, r) => t in e ? jae(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    Wae = (e, t) => {
        for (var r in t || (t = {})) Gae.call(t, r) && LT(e, r, t[r]);
        if (NT)
            for (var r of NT(t)) Vae.call(t, r) && LT(e, r, t[r]);
        return e
    },
    Xae = (e, t) => Uae(e, Hae(t)),
    Yae = Pe(e => ({
        wrapper: Xae(Wae({}, e.fn.cover(0)), {
            position: "fixed",
            backgroundColor: e.colorScheme === "dark" ? e.colors.dark[7] : e.white,
            display: "flex",
            padding: e.spacing.xs,
            transition: "opacity 100ms ease"
        }),
        dropzone: {
            flex: 1
        }
    }));
const Kae = Yae;
var qae = Object.defineProperty,
    Qae = Object.defineProperties,
    Zae = Object.getOwnPropertyDescriptors,
    im = Object.getOwnPropertySymbols,
    AD = Object.prototype.hasOwnProperty,
    ID = Object.prototype.propertyIsEnumerable,
    FT = (e, t, r) => t in e ? qae(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    P0 = (e, t) => {
        for (var r in t || (t = {})) AD.call(t, r) && FT(e, r, t[r]);
        if (im)
            for (var r of im(t)) ID.call(t, r) && FT(e, r, t[r]);
        return e
    },
    C0 = (e, t) => Qae(e, Zae(t)),
    Jae = (e, t) => {
        var r = {};
        for (var n in e) AD.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && im)
            for (var n of im(e)) t.indexOf(n) < 0 && ID.call(e, n) && (r[n] = e[n]);
        return r
    };
const ele = {
    padding: "md",
    loading: !1,
    multiple: !0,
    maxSize: 1 / 0,
    autoFocus: !1,
    activateOnClick: !0,
    activateOnDrag: !0,
    dragEventsBubbling: !0,
    activateOnKeyboard: !0,
    active: !0,
    zIndex: $s("max"),
    withinPortal: !0
};

function $D(e) {
    const t = ve("DropzoneFullScreen", ele, e),
        {
            classNames: r,
            styles: n,
            sx: i,
            className: s,
            style: o,
            unstyled: a,
            active: l,
            onDrop: c,
            onReject: u,
            zIndex: h,
            withinPortal: d,
            portalProps: f
        } = t,
        p = Jae(t, ["classNames", "styles", "sx", "className", "style", "unstyled", "active", "onDrop", "onReject", "zIndex", "withinPortal", "portalProps"]),
        [m, w] = I.useState(0),
        [y, {
            open: v,
            close: _
        }] = cg(!1),
        {
            classes: E,
            cx: P
        } = Kae(null, {
            name: "DropzoneFullScreen",
            classNames: r,
            styles: n,
            unstyled: a
        }),
        C = O => {
            O.dataTransfer.types.includes("Files") && (w(k => k + 1), v())
        },
        T = () => {
            w(O => O - 1)
        };
    return b.useEffect(() => {
        m === 0 && _()
    }, [m]), b.useEffect(() => {
        if (l) return document.addEventListener("dragenter", C, !1), document.addEventListener("dragleave", T, !1), () => {
            document.removeEventListener("dragenter", C, !1), document.removeEventListener("dragleave", T, !1)
        }
    }, [l]), I.createElement(vl, C0(P0({}, f), {
        withinPortal: d
    }), I.createElement(Ie, {
        className: P(E.wrapper, s),
        sx: i,
        style: C0(P0({}, o), {
            opacity: y ? 1 : 0,
            pointerEvents: y ? "all" : "none",
            zIndex: h
        })
    }, I.createElement(El, C0(P0({}, p), {
        classNames: r,
        styles: n,
        unstyled: a,
        className: E.dropzone,
        onDrop: O => {
            c == null || c(O), _()
        },
        onReject: O => {
            u == null || u(O), _()
        }
    }))))
}
$D.displayName = "@mantine/dropzone/DropzoneFullScreen";
OD.FullScreen = $D;
const sd = OD;

function B_(e, t) {
    return B_ = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
        return n.__proto__ = i, n
    }, B_(e, t)
}

function RD(e, t) {
    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, B_(e, t)
}
const BT = {
        disabled: !1
    },
    sm = I.createContext(null);
var fc = "unmounted",
    Xs = "exited",
    Ys = "entering",
    pa = "entered",
    z_ = "exiting",
    Di = function(e) {
        RD(t, e);

        function t(n, i) {
            var s;
            s = e.call(this, n, i) || this;
            var o = i,
                a = o && !o.isMounting ? n.enter : n.appear,
                l;
            return s.appearStatus = null, n.in ? a ? (l = Xs, s.appearStatus = Ys) : l = pa : n.unmountOnExit || n.mountOnEnter ? l = fc : l = Xs, s.state = {
                status: l
            }, s.nextCallback = null, s
        }
        t.getDerivedStateFromProps = function(i, s) {
            var o = i.in;
            return o && s.status === fc ? {
                status: Xs
            } : null
        };
        var r = t.prototype;
        return r.componentDidMount = function() {
            this.updateStatus(!0, this.appearStatus)
        }, r.componentDidUpdate = function(i) {
            var s = null;
            if (i !== this.props) {
                var o = this.state.status;
                this.props.in ? o !== Ys && o !== pa && (s = Ys) : (o === Ys || o === pa) && (s = z_)
            }
            this.updateStatus(!1, s)
        }, r.componentWillUnmount = function() {
            this.cancelNextCallback()
        }, r.getTimeouts = function() {
            var i = this.props.timeout,
                s, o, a;
            return s = o = a = i, i != null && typeof i != "number" && (s = i.exit, o = i.enter, a = i.appear !== void 0 ? i.appear : o), {
                exit: s,
                enter: o,
                appear: a
            }
        }, r.updateStatus = function(i, s) {
            i === void 0 && (i = !1), s !== null ? (this.cancelNextCallback(), s === Ys ? this.performEnter(i) : this.performExit()) : this.props.unmountOnExit && this.state.status === Xs && this.setState({
                status: fc
            })
        }, r.performEnter = function(i) {
            var s = this,
                o = this.props.enter,
                a = this.context ? this.context.isMounting : i,
                l = this.props.nodeRef ? [a] : [Tv.findDOMNode(this), a],
                c = l[0],
                u = l[1],
                h = this.getTimeouts(),
                d = a ? h.appear : h.enter;
            if (!i && !o || BT.disabled) {
                this.safeSetState({
                    status: pa
                }, function() {
                    s.props.onEntered(c)
                });
                return
            }
            this.props.onEnter(c, u), this.safeSetState({
                status: Ys
            }, function() {
                s.props.onEntering(c, u), s.onTransitionEnd(d, function() {
                    s.safeSetState({
                        status: pa
                    }, function() {
                        s.props.onEntered(c, u)
                    })
                })
            })
        }, r.performExit = function() {
            var i = this,
                s = this.props.exit,
                o = this.getTimeouts(),
                a = this.props.nodeRef ? void 0 : Tv.findDOMNode(this);
            if (!s || BT.disabled) {
                this.safeSetState({
                    status: Xs
                }, function() {
                    i.props.onExited(a)
                });
                return
            }
            this.props.onExit(a), this.safeSetState({
                status: z_
            }, function() {
                i.props.onExiting(a), i.onTransitionEnd(o.exit, function() {
                    i.safeSetState({
                        status: Xs
                    }, function() {
                        i.props.onExited(a)
                    })
                })
            })
        }, r.cancelNextCallback = function() {
            this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null)
        }, r.safeSetState = function(i, s) {
            s = this.setNextCallback(s), this.setState(i, s)
        }, r.setNextCallback = function(i) {
            var s = this,
                o = !0;
            return this.nextCallback = function(a) {
                o && (o = !1, s.nextCallback = null, i(a))
            }, this.nextCallback.cancel = function() {
                o = !1
            }, this.nextCallback
        }, r.onTransitionEnd = function(i, s) {
            this.setNextCallback(s);
            var o = this.props.nodeRef ? this.props.nodeRef.current : Tv.findDOMNode(this),
                a = i == null && !this.props.addEndListener;
            if (!o || a) {
                setTimeout(this.nextCallback, 0);
                return
            }
            if (this.props.addEndListener) {
                var l = this.props.nodeRef ? [this.nextCallback] : [o, this.nextCallback],
                    c = l[0],
                    u = l[1];
                this.props.addEndListener(c, u)
            }
            i != null && setTimeout(this.nextCallback, i)
        }, r.render = function() {
            var i = this.state.status;
            if (i === fc) return null;
            var s = this.props,
                o = s.children;
            s.in, s.mountOnEnter, s.unmountOnExit, s.appear, s.enter, s.exit, s.timeout, s.addEndListener, s.onEnter, s.onEntering, s.onEntered, s.onExit, s.onExiting, s.onExited, s.nodeRef;
            var a = E5(s, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
            return I.createElement(sm.Provider, {
                value: null
            }, typeof o == "function" ? o(i, a) : I.cloneElement(I.Children.only(o), a))
        }, t
    }(I.Component);
Di.contextType = sm;
Di.propTypes = {};

function ra() {}
Di.defaultProps = { in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: ra,
    onEntering: ra,
    onEntered: ra,
    onExit: ra,
    onExiting: ra,
    onExited: ra
};
Di.UNMOUNTED = fc;
Di.EXITED = Xs;
Di.ENTERING = Ys;
Di.ENTERED = pa;
Di.EXITING = z_;
const tle = Di;

function rle(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function Bw(e, t) {
    var r = function(s) {
            return t && b.isValidElement(s) ? t(s) : s
        },
        n = Object.create(null);
    return e && b.Children.map(e, function(i) {
        return i
    }).forEach(function(i) {
        n[i.key] = r(i)
    }), n
}

function nle(e, t) {
    e = e || {}, t = t || {};

    function r(u) {
        return u in t ? t[u] : e[u]
    }
    var n = Object.create(null),
        i = [];
    for (var s in e) s in t ? i.length && (n[s] = i, i = []) : i.push(s);
    var o, a = {};
    for (var l in t) {
        if (n[l])
            for (o = 0; o < n[l].length; o++) {
                var c = n[l][o];
                a[n[l][o]] = r(c)
            }
        a[l] = r(l)
    }
    for (o = 0; o < i.length; o++) a[i[o]] = r(i[o]);
    return a
}

function no(e, t, r) {
    return r[t] != null ? r[t] : e.props[t]
}

function ile(e, t) {
    return Bw(e.children, function(r) {
        return b.cloneElement(r, {
            onExited: t.bind(null, r),
            in: !0,
            appear: no(r, "appear", e),
            enter: no(r, "enter", e),
            exit: no(r, "exit", e)
        })
    })
}

function sle(e, t, r) {
    var n = Bw(e.children),
        i = nle(t, n);
    return Object.keys(i).forEach(function(s) {
        var o = i[s];
        if (b.isValidElement(o)) {
            var a = s in t,
                l = s in n,
                c = t[s],
                u = b.isValidElement(c) && !c.props.in;
            l && (!a || u) ? i[s] = b.cloneElement(o, {
                onExited: r.bind(null, o),
                in: !0,
                exit: no(o, "exit", e),
                enter: no(o, "enter", e)
            }) : !l && a && !u ? i[s] = b.cloneElement(o, { in: !1
            }) : l && a && b.isValidElement(c) && (i[s] = b.cloneElement(o, {
                onExited: r.bind(null, o),
                in: c.props.in,
                exit: no(o, "exit", e),
                enter: no(o, "enter", e)
            }))
        }
    }), i
}
var ole = Object.values || function(e) {
        return Object.keys(e).map(function(t) {
            return e[t]
        })
    },
    ale = {
        component: "div",
        childFactory: function(t) {
            return t
        }
    },
    zw = function(e) {
        RD(t, e);

        function t(n, i) {
            var s;
            s = e.call(this, n, i) || this;
            var o = s.handleExited.bind(rle(s));
            return s.state = {
                contextValue: {
                    isMounting: !0
                },
                handleExited: o,
                firstRender: !0
            }, s
        }
        var r = t.prototype;
        return r.componentDidMount = function() {
            this.mounted = !0, this.setState({
                contextValue: {
                    isMounting: !1
                }
            })
        }, r.componentWillUnmount = function() {
            this.mounted = !1
        }, t.getDerivedStateFromProps = function(i, s) {
            var o = s.children,
                a = s.handleExited,
                l = s.firstRender;
            return {
                children: l ? ile(i, a) : sle(i, o, a),
                firstRender: !1
            }
        }, r.handleExited = function(i, s) {
            var o = Bw(this.props.children);
            i.key in o || (i.props.onExited && i.props.onExited(s), this.mounted && this.setState(function(a) {
                var l = dt({}, a.children);
                return delete l[i.key], {
                    children: l
                }
            }))
        }, r.render = function() {
            var i = this.props,
                s = i.component,
                o = i.childFactory,
                a = E5(i, ["component", "childFactory"]),
                l = this.state.contextValue,
                c = ole(this.state.children).map(o);
            return delete a.appear, delete a.enter, delete a.exit, s === null ? I.createElement(sm.Provider, {
                value: l
            }, c) : I.createElement(sm.Provider, {
                value: l
            }, I.createElement(s, a, c))
        }, t
    }(I.Component);
zw.propTypes = {};
zw.defaultProps = ale;
const lle = zw,
    [cle, ku] = $G("mantine-notifications"),
    ule = ku("show"),
    hle = ku("hide"),
    dle = ku("clean"),
    fle = ku("cleanQueue"),
    ple = ku("update"),
    ws = {
        show: ule,
        hide: hle,
        clean: dle,
        cleanQueue: fle,
        update: ple
    };

function mle([e, t], r) {
    const n = {};
    return e === "top" && (n.top = r), e === "bottom" && (n.bottom = r), t === "left" && (n.left = r), t === "right" && (n.right = r), t === "center" && (n.left = "50%", n.transform = "translateX(-50%)"), n
}
var gle = Object.defineProperty,
    zT = Object.getOwnPropertySymbols,
    vle = Object.prototype.hasOwnProperty,
    yle = Object.prototype.propertyIsEnumerable,
    jT = (e, t, r) => t in e ? gle(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    UT = (e, t) => {
        for (var r in t || (t = {})) vle.call(t, r) && jT(e, r, t[r]);
        if (zT)
            for (var r of zT(t)) yle.call(t, r) && jT(e, r, t[r]);
        return e
    };
const HT = {
        left: "translateX(-100%)",
        right: "translateX(100%)",
        "top-center": "translateY(-100%)",
        "bottom-center": "translateY(100%)"
    },
    _le = {
        left: "translateX(0)",
        right: "translateX(0)",
        "top-center": "translateY(0)",
        "bottom-center": "translateY(0)"
    };

function wle({
    state: e,
    maxHeight: t,
    positioning: r,
    transitionDuration: n
}) {
    const [i, s] = r, o = s === "center" ? `${i}-center` : s, a = {
        opacity: 0,
        maxHeight: t,
        transform: HT[o],
        transitionDuration: `${n}ms, ${n}ms, ${n}ms`,
        transitionTimingFunction: "cubic-bezier(.51,.3,0,1.21), cubic-bezier(.51,.3,0,1.21), linear",
        transitionProperty: "opacity, transform, max-height"
    }, l = {
        opacity: 1,
        transform: _le[o]
    }, c = {
        opacity: 0,
        maxHeight: 0,
        transform: HT[o]
    }, u = {
        entering: l,
        entered: l,
        exiting: c,
        exited: c
    };
    return UT(UT({}, a), u[e])
}

function ble(e, t) {
    return typeof t == "number" ? t : t === !1 || e === !1 ? !1 : e
}
var xle = Object.defineProperty,
    Ele = Object.defineProperties,
    Sle = Object.getOwnPropertyDescriptors,
    om = Object.getOwnPropertySymbols,
    kD = Object.prototype.hasOwnProperty,
    MD = Object.prototype.propertyIsEnumerable,
    GT = (e, t, r) => t in e ? xle(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    VT = (e, t) => {
        for (var r in t || (t = {})) kD.call(t, r) && GT(e, r, t[r]);
        if (om)
            for (var r of om(t)) MD.call(t, r) && GT(e, r, t[r]);
        return e
    },
    Ple = (e, t) => Ele(e, Sle(t)),
    WT = (e, t) => {
        var r = {};
        for (var n in e) kD.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && om)
            for (var n of om(e)) t.indexOf(n) < 0 && MD.call(e, n) && (r[n] = e[n]);
        return r
    };

function DD(e) {
    var t = e,
        {
            notification: r,
            autoClose: n,
            onHide: i,
            innerRef: s
        } = t,
        o = WT(t, ["notification", "autoClose", "onHide", "innerRef"]);
    const a = r,
        {
            autoClose: l,
            message: c
        } = a,
        u = WT(a, ["autoClose", "message"]),
        h = ble(n, l),
        d = b.useRef(),
        f = () => {
            i(r.id), window.clearTimeout(d.current)
        },
        p = () => {
            clearTimeout(d.current)
        },
        m = () => {
            typeof h == "number" && (d.current = window.setTimeout(f, h))
        };
    return b.useEffect(() => {
        typeof r.onOpen == "function" && r.onOpen(r)
    }, []), b.useEffect(() => (m(), p), [n, r.autoClose]), I.createElement(F5, Ple(VT(VT({}, u), o), {
        onClose: f,
        onMouseEnter: p,
        onMouseLeave: m,
        ref: s
    }), c)
}
DD.displayName = "@mantine/notifications/NotificationContainer";
var Cle = Pe((e, {
    zIndex: t
}) => ({
    notifications: {
        width: `calc(100% - ${e.spacing.md} * 2)`,
        boxSizing: "border-box",
        position: "fixed",
        zIndex: t
    },
    notification: {
        "&:not(:first-of-type)": {
            marginTop: e.spacing.sm
        }
    }
}));
const Tle = Cle;
var Ole = Object.defineProperty,
    Ale = Object.defineProperties,
    Ile = Object.getOwnPropertyDescriptors,
    XT = Object.getOwnPropertySymbols,
    $le = Object.prototype.hasOwnProperty,
    Rle = Object.prototype.propertyIsEnumerable,
    YT = (e, t, r) => t in e ? Ole(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    kle = (e, t) => {
        for (var r in t || (t = {})) $le.call(t, r) && YT(e, r, t[r]);
        if (XT)
            for (var r of XT(t)) Rle.call(t, r) && YT(e, r, t[r]);
        return e
    },
    Mle = (e, t) => Ale(e, Ile(t));

function Dle({
    limit: e
}) {
    const {
        state: t,
        queue: r,
        update: n,
        cleanQueue: i
    } = uX({
        initialValues: [],
        limit: e
    });
    return {
        notifications: t,
        queue: r,
        showNotification: c => {
            const u = c.id || pw();
            return n(h => c.id && h.some(d => d.id === c.id) ? h : [...h, Mle(kle({}, c), {
                id: u
            })]), u
        },
        updateNotification: c => n(u => {
            const h = u.findIndex(f => f.id === c.id);
            if (h === -1) return u;
            const d = [...u];
            return d[h] = c, d
        }),
        hideNotification: c => n(u => u.filter(h => h.id === c ? (typeof h.onClose == "function" && h.onClose(h), !1) : !0)),
        cleanQueue: i,
        clean: () => n(() => [])
    }
}
var Nle = Object.defineProperty,
    am = Object.getOwnPropertySymbols,
    ND = Object.prototype.hasOwnProperty,
    LD = Object.prototype.propertyIsEnumerable,
    KT = (e, t, r) => t in e ? Nle(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : e[t] = r,
    T0 = (e, t) => {
        for (var r in t || (t = {})) ND.call(t, r) && KT(e, r, t[r]);
        if (am)
            for (var r of am(t)) LD.call(t, r) && KT(e, r, t[r]);
        return e
    },
    Lle = (e, t) => {
        var r = {};
        for (var n in e) ND.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
        if (e != null && am)
            for (var n of am(e)) t.indexOf(n) < 0 && LD.call(e, n) && (r[n] = e[n]);
        return r
    };
const Fle = ["top-left", "top-right", "top-center", "bottom-left", "bottom-right", "bottom-center"],
    Ro = e => {
        var t = e,
            {
                className: r,
                position: n = "bottom-right",
                autoClose: i = 4e3,
                transitionDuration: s = 250,
                containerWidth: o = R(440),
                notificationMaxHeight: a = R(200),
                limit: l = 5,
                zIndex: c = $s("overlay"),
                style: u,
                children: h,
                target: d
            } = t,
            f = Lle(t, ["className", "position", "autoClose", "transitionDuration", "containerWidth", "notificationMaxHeight", "limit", "zIndex", "style", "children", "target"]);
        const p = iX(),
            m = b.useRef({}),
            w = b.useRef(0),
            {
                notifications: y,
                showNotification: v,
                updateNotification: _,
                hideNotification: E,
                clean: P,
                cleanQueue: C
            } = Dle({
                limit: l
            }),
            {
                classes: T,
                cx: O,
                theme: k
            } = Tle({
                zIndex: c
            }),
            D = lg(),
            j = (k.respectReducedMotion ? D : !1) ? 1 : s,
            L = (Fle.includes(n) ? n : "bottom-right").split("-");
        sn(() => {
            y.length > w.current && setTimeout(() => p(), 0), w.current = y.length
        }, [y]), cle({
            show: v,
            hide: E,
            update: _,
            clean: P,
            cleanQueue: C
        });
        const M = y.map(W => I.createElement(tle, {
            key: W.id,
            timeout: j,
            onEnter: () => m.current[W.id].offsetHeight,
            nodeRef: {
                current: m.current[W.id]
            }
        }, Z => I.createElement(DD, {
            innerRef: q => {
                m.current[W.id] = q
            },
            notification: W,
            onHide: E,
            className: T.notification,
            autoClose: i,
            sx: [T0({}, wle({
                state: Z,
                positioning: L,
                transitionDuration: j,
                maxHeight: a
            })), ...Array.isArray(W.sx) ? W.sx : [W.sx]]
        })));
        return I.createElement(gw, {
            target: d
        }, I.createElement(Ie, T0({
            className: O(T.notifications, r),
            style: u,
            sx: T0({
                maxWidth: o
            }, mle(L, k.spacing.md))
        }, f), I.createElement(lle, null, M)))
    };
Ro.displayName = "@mantine/notifications/Notifications";
Ro.show = ws.show;
Ro.hide = ws.hide;
Ro.update = ws.update;
Ro.clean = ws.clean;
Ro.cleanQueue = ws.cleanQueue;

function Ble(e, t, r) {
    return Math.max(t, Math.min(e, r))
}
const ft = {
    toVector(e, t) {
        return e === void 0 && (e = t), Array.isArray(e) ? e : [e, e]
    },
    add(e, t) {
        return [e[0] + t[0], e[1] + t[1]]
    },
    sub(e, t) {
        return [e[0] - t[0], e[1] - t[1]]
    },
    addTo(e, t) {
        e[0] += t[0], e[1] += t[1]
    },
    subTo(e, t) {
        e[0] -= t[0], e[1] -= t[1]
    }
};

function qT(e, t, r) {
    return t === 0 || Math.abs(t) === 1 / 0 ? Math.pow(e, r * 5) : e * t * r / (t + r * e)
}

function QT(e, t, r, n = .15) {
    return n === 0 ? Ble(e, t, r) : e < t ? -qT(t - e, r - t, n) + t : e > r ? +qT(e - r, r - t, n) + r : e
}

function zle(e, [t, r], [n, i]) {
    const [
        [s, o],
        [a, l]
    ] = e;
    return [QT(t, s, o, n), QT(r, a, l, i)]
}

function jle(e, t) {
    if (typeof e != "object" || e === null) return e;
    var r = e[Symbol.toPrimitive];
    if (r !== void 0) {
        var n = r.call(e, t || "default");
        if (typeof n != "object") return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function Ule(e) {
    var t = jle(e, "string");
    return typeof t == "symbol" ? t : String(t)
}

function $t(e, t, r) {
    return t = Ule(t), t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = r, e
}

function ZT(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
            return Object.getOwnPropertyDescriptor(e, i).enumerable
        })), r.push.apply(r, n)
    }
    return r
}

function bt(e) {
    for (var t = 1; t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? ZT(Object(r), !0).forEach(function(n) {
            $t(e, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ZT(Object(r)).forEach(function(n) {
            Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return e
}
const FD = {
    pointer: {
        start: "down",
        change: "move",
        end: "up"
    },
    mouse: {
        start: "down",
        change: "move",
        end: "up"
    },
    touch: {
        start: "start",
        change: "move",
        end: "end"
    },
    gesture: {
        start: "start",
        change: "change",
        end: "end"
    }
};

function JT(e) {
    return e ? e[0].toUpperCase() + e.slice(1) : ""
}
const Hle = ["enter", "leave"];

function Gle(e = !1, t) {
    return e && !Hle.includes(t)
}

function Vle(e, t = "", r = !1) {
    const n = FD[e],
        i = n && n[t] || t;
    return "on" + JT(e) + JT(i) + (Gle(r, i) ? "Capture" : "")
}
const Wle = ["gotpointercapture", "lostpointercapture"];

function Xle(e) {
    let t = e.substring(2).toLowerCase();
    const r = !!~t.indexOf("passive");
    r && (t = t.replace("passive", ""));
    const n = Wle.includes(t) ? "capturecapture" : "capture",
        i = !!~t.indexOf(n);
    return i && (t = t.replace("capture", "")), {
        device: t,
        capture: i,
        passive: r
    }
}

function Yle(e, t = "") {
    const r = FD[e],
        n = r && r[t] || t;
    return e + n
}

function yg(e) {
    return "touches" in e
}

function BD(e) {
    return yg(e) ? "touch" : "pointerType" in e ? e.pointerType : "mouse"
}

function Kle(e) {
    return Array.from(e.touches).filter(t => {
        var r, n;
        return t.target === e.currentTarget || ((r = e.currentTarget) === null || r === void 0 || (n = r.contains) === null || n === void 0 ? void 0 : n.call(r, t.target))
    })
}

function qle(e) {
    return e.type === "touchend" || e.type === "touchcancel" ? e.changedTouches : e.targetTouches
}

function zD(e) {
    return yg(e) ? qle(e)[0] : e
}

function j_(e, t) {
    try {
        const r = t.clientX - e.clientX,
            n = t.clientY - e.clientY,
            i = (t.clientX + e.clientX) / 2,
            s = (t.clientY + e.clientY) / 2,
            o = Math.hypot(r, n);
        return {
            angle: -(Math.atan2(r, n) * 180) / Math.PI,
            distance: o,
            origin: [i, s]
        }
    } catch {}
    return null
}

function Qle(e) {
    return Kle(e).map(t => t.identifier)
}

function eO(e, t) {
    const [r, n] = Array.from(e.touches).filter(i => t.includes(i.identifier));
    return j_(r, n)
}

function O0(e) {
    const t = zD(e);
    return yg(e) ? t.identifier : t.pointerId
}

function ll(e) {
    const t = zD(e);
    return [t.clientX, t.clientY]
}
const tO = 40,
    rO = 800;

function jD(e) {
    let {
        deltaX: t,
        deltaY: r,
        deltaMode: n
    } = e;
    return n === 1 ? (t *= tO, r *= tO) : n === 2 && (t *= rO, r *= rO), [t, r]
}

function Zle(e) {
    var t, r;
    const {
        scrollX: n,
        scrollY: i,
        scrollLeft: s,
        scrollTop: o
    } = e.currentTarget;
    return [(t = n??s) !== null && t !== void 0 ? t : 0, (r = i??o) !== null && r !== void 0 ? r : 0]
}

function Jle(e) {
    const t = {};
    if ("buttons" in e && (t.buttons = e.buttons), "shiftKey" in e) {
        const {
            shiftKey: r,
            altKey: n,
            metaKey: i,
            ctrlKey: s
        } = e;
        Object.assign(t, {
            shiftKey: r,
            altKey: n,
            metaKey: i,
            ctrlKey: s
        })
    }
    return t
}

function lm(e, ...t) {
    return typeof e == "function" ? e(...t) : e
}

function ece() {}

function tce(...e) {
    return e.length === 0 ? ece : e.length === 1 ? e[0] : function() {
        let t;
        for (const r of e) t = r.apply(this, arguments) || t;
        return t
    }
}

function nO(e, t) {
    return Object.assign({}, t, e || {})
}
const rce = 32;
class UD {
    constructor(t, r, n) {
        this.ctrl = t, this.args = r, this.key = n, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset())
    }
    get state() {
        return this.ctrl.state[this.key]
    }
    set state(t) {
        this.ctrl.state[this.key] = t
    }
    get shared() {
        return this.ctrl.state.shared
    }
    get eventStore() {
        return this.ctrl.gestureEventStores[this.key]
    }
    get timeoutStore() {
        return this.ctrl.gestureTimeoutStores[this.key]
    }
    get config() {
        return this.ctrl.config[this.key]
    }
    get sharedConfig() {
        return this.ctrl.config.shared
    }
    get handler() {
        return this.ctrl.handlers[this.key]
    }
    reset() {
        const {
            state: t,
            shared: r,
            ingKey: n,
            args: i
        } = this;
        r[n] = t._active = t.active = t._blocked = t._force = !1, t._step = [!1, !1], t.intentional = !1, t._movement = [0, 0], t._distance = [0, 0], t._direction = [0, 0], t._delta = [0, 0], t._bounds = [
            [-1 / 0, 1 / 0],
            [-1 / 0, 1 / 0]
        ], t.args = i, t.axis = void 0, t.memo = void 0, t.elapsedTime = t.timeDelta = 0, t.direction = [0, 0], t.distance = [0, 0], t.overflow = [0, 0], t._movementBound = [!1, !1], t.velocity = [0, 0], t.movement = [0, 0], t.delta = [0, 0], t.timeStamp = 0
    }
    start(t) {
        const r = this.state,
            n = this.config;
        r._active || (this.reset(), this.computeInitial(), r._active = !0, r.target = t.target, r.currentTarget = t.currentTarget, r.lastOffset = n.from ? lm(n.from, r) : r.offset, r.offset = r.lastOffset, r.startTime = r.timeStamp = t.timeStamp)
    }
    computeValues(t) {
        const r = this.state;
        r._values = t, r.values = this.config.transform(t)
    }
    computeInitial() {
        const t = this.state;
        t._initial = t._values, t.initial = t.values
    }
    compute(t) {
        const {
            state: r,
            config: n,
            shared: i
        } = this;
        r.args = this.args;
        let s = 0;
        if (t && (r.event = t, n.preventDefault && t.cancelable && r.event.preventDefault(), r.type = t.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, Jle(t)), i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0, s = t.timeStamp - r.timeStamp, r.timeStamp = t.timeStamp, r.elapsedTime = r.timeStamp - r.startTime), r._active) {
            const C = r._delta.map(Math.abs);
            ft.addTo(r._distance, C)
        }
        this.axisIntent && this.axisIntent(t);
        const [o, a] = r._movement, [l, c] = n.threshold, {
            _step: u,
            values: h
        } = r;
        if (n.hasCustomTransform ? (u[0] === !1 && (u[0] = Math.abs(o) >= l && h[0]), u[1] === !1 && (u[1] = Math.abs(a) >= c && h[1])) : (u[0] === !1 && (u[0] = Math.abs(o) >= l && Math.sign(o) * l), u[1] === !1 && (u[1] = Math.abs(a) >= c && Math.sign(a) * c)), r.intentional = u[0] !== !1 || u[1] !== !1, !r.intentional) return;
        const d = [0, 0];
        if (n.hasCustomTransform) {
            const [C, T] = h;
            d[0] = u[0] !== !1 ? C - u[0] : 0, d[1] = u[1] !== !1 ? T - u[1] : 0
        } else d[0] = u[0] !== !1 ? o - u[0] : 0, d[1] = u[1] !== !1 ? a - u[1] : 0;
        this.restrictToAxis && !r._blocked && this.restrictToAxis(d);
        const f = r.offset,
            p = r._active && !r._blocked || r.active;
        p && (r.first = r._active && !r.active, r.last = !r._active && r.active, r.active = i[this.ingKey] = r._active, t && (r.first && ("bounds" in n && (r._bounds = lm(n.bounds, r)), this.setup && this.setup()), r.movement = d, this.computeOffset()));
        const [m, w] = r.offset, [
            [y, v],
            [_, E]
        ] = r._bounds;
        r.overflow = [m < y ? -1 : m > v ? 1 : 0, w < _ ? -1 : w > E ? 1 : 0], r._movementBound[0] = r.overflow[0] ? r._movementBound[0] === !1 ? r._movement[0] : r._movementBound[0] : !1, r._movementBound[1] = r.overflow[1] ? r._movementBound[1] === !1 ? r._movement[1] : r._movementBound[1] : !1;
        const P = r._active ? n.rubberband || [0, 0] : [0, 0];
        if (r.offset = zle(r._bounds, r.offset, P), r.delta = ft.sub(r.offset, f), this.computeMovement(), p && (!r.last || s > rce)) {
            r.delta = ft.sub(r.offset, f);
            const C = r.delta.map(Math.abs);
            ft.addTo(r.distance, C), r.direction = r.delta.map(Math.sign), r._direction = r._delta.map(Math.sign), !r.first && s > 0 && (r.velocity = [C[0] / s, C[1] / s], r.timeDelta = s)
        }
    }
    emit() {
        const t = this.state,
            r = this.shared,
            n = this.config;
        if (t._active || this.clean(), (t._blocked || !t.intentional) && !t._force && !n.triggerAllEvents) return;
        const i = this.handler(bt(bt(bt({}, r), t), {}, {
            [this.aliasKey]: t.values
        }));
        i !== void 0 && (t.memo = i)
    }
    clean() {
        this.eventStore.clean(), this.timeoutStore.clean()
    }
}

function nce([e, t], r) {
    const n = Math.abs(e),
        i = Math.abs(t);
    if (n > i && n > r) return "x";
    if (i > n && i > r) return "y"
}
class Mu extends UD {
    constructor(...t) {
        super(...t), $t(this, "aliasKey", "xy")
    }
    reset() {
        super.reset(), this.state.axis = void 0
    }
    init() {
        this.state.offset = [0, 0], this.state.lastOffset = [0, 0]
    }
    computeOffset() {
        this.state.offset = ft.add(this.state.lastOffset, this.state.movement)
    }
    computeMovement() {
        this.state.movement = ft.sub(this.state.offset, this.state.lastOffset)
    }
    axisIntent(t) {
        const r = this.state,
            n = this.config;
        if (!r.axis && t) {
            const i = typeof n.axisThreshold == "object" ? n.axisThreshold[BD(t)] : n.axisThreshold;
            r.axis = nce(r._movement, i)
        }
        r._blocked = (n.lockDirection || !!n.axis) && !r.axis || !!n.axis && n.axis !== r.axis
    }
    restrictToAxis(t) {
        if (this.config.axis || this.config.lockDirection) switch (this.state.axis) {
            case "x":
                t[1] = 0;
                break;
            case "y":
                t[0] = 0;
                break
        }
    }
}
const ice = e => e,
    iO = .15,
    HD = {
        enabled(e = !0) {
            return e
        },
        eventOptions(e, t, r) {
            return bt(bt({}, r.shared.eventOptions), e)
        },
        preventDefault(e = !1) {
            return e
        },
        triggerAllEvents(e = !1) {
            return e
        },
        rubberband(e = 0) {
            switch (e) {
                case !0:
                    return [iO, iO];
                case !1:
                    return [0, 0];
                default:
                    return ft.toVector(e)
            }
        },
        from(e) {
            if (typeof e == "function") return e;
            if (e != null) return ft.toVector(e)
        },
        transform(e, t, r) {
            const n = e || r.shared.transform;
            return this.hasCustomTransform = !!n, n || ice
        },
        threshold(e) {
            return ft.toVector(e, 0)
        }
    },
    sce = 0,
    ko = bt(bt({}, HD), {}, {
        axis(e, t, {
            axis: r
        }) {
            if (this.lockDirection = r === "lock", !this.lockDirection) return r
        },
        axisThreshold(e = sce) {
            return e
        },
        bounds(e = {}) {
            if (typeof e == "function") return s => ko.bounds(e(s));
            if ("current" in e) return () => e.current;
            if (typeof HTMLElement == "function" && e instanceof HTMLElement) return e;
            const {
                left: t = -1 / 0,
                right: r = 1 / 0,
                top: n = -1 / 0,
                bottom: i = 1 / 0
            } = e;
            return [
                [t, r],
                [n, i]
            ]
        }
    }),
    sO = {
        ArrowRight: (e, t = 1) => [e * t, 0],
        ArrowLeft: (e, t = 1) => [-1 * e * t, 0],
        ArrowUp: (e, t = 1) => [0, -1 * e * t],
        ArrowDown: (e, t = 1) => [0, e * t]
    };
class oce extends Mu {
    constructor(...t) {
        super(...t), $t(this, "ingKey", "dragging")
    }
    reset() {
        super.reset();
        const t = this.state;
        t._pointerId = void 0, t._pointerActive = !1, t._keyboardActive = !1, t._preventScroll = !1, t._delayed = !1, t.swipe = [0, 0], t.tap = !1, t.canceled = !1, t.cancel = this.cancel.bind(this)
    }
    setup() {
        const t = this.state;
        if (t._bounds instanceof HTMLElement) {
            const r = t._bounds.getBoundingClientRect(),
                n = t.currentTarget.getBoundingClientRect(),
                i = {
                    left: r.left - n.left + t.offset[0],
                    right: r.right - n.right + t.offset[0],
                    top: r.top - n.top + t.offset[1],
                    bottom: r.bottom - n.bottom + t.offset[1]
                };
            t._bounds = ko.bounds(i)
        }
    }
    cancel() {
        const t = this.state;
        t.canceled || (t.canceled = !0, t._active = !1, setTimeout(() => {
            this.compute(), this.emit()
        }, 0))
    }
    setActive() {
        this.state._active = this.state._pointerActive || this.state._keyboardActive
    }
    clean() {
        this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean()
    }
    pointerDown(t) {
        const r = this.config,
            n = this.state;
        if (t.buttons != null && (Array.isArray(r.pointerButtons) ? !r.pointerButtons.includes(t.buttons) : r.pointerButtons !== -1 && r.pointerButtons !== t.buttons)) return;
        const i = this.ctrl.setEventIds(t);
        r.pointerCapture && t.target.setPointerCapture(t.pointerId), !(i && i.size > 1 && n._pointerActive) && (this.start(t), this.setupPointer(t), n._pointerId = O0(t), n._pointerActive = !0, this.computeValues(ll(t)), this.computeInitial(), r.preventScrollAxis && BD(t) !== "mouse" ? (n._active = !1, this.setupScrollPrevention(t)) : r.delay > 0 ? (this.setupDelayTrigger(t), r.triggerAllEvents && (this.compute(t), this.emit())) : this.startPointerDrag(t))
    }
    startPointerDrag(t) {
        const r = this.state;
        r._active = !0, r._preventScroll = !0, r._delayed = !1, this.compute(t), this.emit()
    }
    pointerMove(t) {
        const r = this.state,
            n = this.config;
        if (!r._pointerActive || r.type === t.type && t.timeStamp === r.timeStamp) return;
        const i = O0(t);
        if (r._pointerId !== void 0 && i !== r._pointerId) return;
        const s = ll(t);
        if (document.pointerLockElement === t.target ? r._delta = [t.movementX, t.movementY] : (r._delta = ft.sub(s, r._values), this.computeValues(s)), ft.addTo(r._movement, r._delta), this.compute(t), r._delayed && r.intentional) {
            this.timeoutStore.remove("dragDelay"), r.active = !1, this.startPointerDrag(t);
            return
        }
        if (n.preventScrollAxis && !r._preventScroll)
            if (r.axis)
                if (r.axis === n.preventScrollAxis || n.preventScrollAxis === "xy") {
                    r._active = !1, this.clean();
                    return
                } else {
                    this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(t);
                    return
                }
        else return;
        this.emit()
    }
    pointerUp(t) {
        this.ctrl.setEventIds(t);
        try {
            this.config.pointerCapture && t.target.hasPointerCapture(t.pointerId) && t.target.releasePointerCapture(t.pointerId)
        } catch {}
        const r = this.state,
            n = this.config;
        if (!r._active || !r._pointerActive) return;
        const i = O0(t);
        if (r._pointerId !== void 0 && i !== r._pointerId) return;
        this.state._pointerActive = !1, this.setActive(), this.compute(t);
        const [s, o] = r._distance;
        if (r.tap = s <= n.tapsThreshold && o <= n.tapsThreshold, r.tap && n.filterTaps) r._force = !0;
        else {
            const [a, l] = r._delta, [c, u] = r._movement, [h, d] = n.swipe.velocity, [f, p] = n.swipe.distance, m = n.swipe.duration;
            if (r.elapsedTime < m) {
                const w = Math.abs(a / r.timeDelta),
                    y = Math.abs(l / r.timeDelta);
                w > h && Math.abs(c) > f && (r.swipe[0] = Math.sign(a)), y > d && Math.abs(u) > p && (r.swipe[1] = Math.sign(l))
            }
        }
        this.emit()
    }
    pointerClick(t) {
        !this.state.tap && t.detail > 0 && (t.preventDefault(), t.stopPropagation())
    }
    setupPointer(t) {
        const r = this.config,
            n = r.device;
        r.pointerLock && t.currentTarget.requestPointerLock(), r.pointerCapture || (this.eventStore.add(this.sharedConfig.window, n, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, n, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, n, "cancel", this.pointerUp.bind(this)))
    }
    pointerClean() {
        this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock()
    }
    preventScroll(t) {
        this.state._preventScroll && t.cancelable && t.preventDefault()
    }
    setupScrollPrevention(t) {
        this.state._preventScroll = !1, ace(t);
        const r = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
            passive: !1
        });
        this.eventStore.add(this.sharedConfig.window, "touch", "end", r), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", r), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, t)
    }
    setupDelayTrigger(t) {
        this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
            this.state._step = [0, 0], this.startPointerDrag(t)
        }, this.config.delay)
    }
    keyDown(t) {
        const r = sO[t.key];
        if (r) {
            const n = this.state,
                i = t.shiftKey ? 10 : t.altKey ? .1 : 1;
            this.start(t), n._delta = r(this.config.keyboardDisplacement, i), n._keyboardActive = !0, ft.addTo(n._movement, n._delta), this.compute(t), this.emit()
        }
    }
    keyUp(t) {
        t.key in sO && (this.state._keyboardActive = !1, this.setActive(), this.compute(t), this.emit())
    }
    bind(t) {
        const r = this.config.device;
        t(r, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (t(r, "change", this.pointerMove.bind(this)), t(r, "end", this.pointerUp.bind(this)), t(r, "cancel", this.pointerUp.bind(this)), t("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (t("key", "down", this.keyDown.bind(this)), t("key", "up", this.keyUp.bind(this))), this.config.filterTaps && t("click", "", this.pointerClick.bind(this), {
            capture: !0,
            passive: !1
        })
    }
}

function ace(e) {
    "persist" in e && typeof e.persist == "function" && e.persist()
}
const Du = typeof window < "u" && window.document && window.document.createElement;

function lce() {
    return Du && "ontouchstart" in window
}

function oO() {
    return lce() || Du && window.navigator.maxTouchPoints > 1
}

function cce() {
    return Du && "onpointerdown" in window
}

function uce() {
    return Du && "exitPointerLock" in window.document
}

function hce() {
    try {
        return "constructor" in GestureEvent
    } catch {
        return !1
    }
}
const Kr = {
        isBrowser: Du,
        gesture: hce(),
        touch: oO(),
        touchscreen: oO(),
        pointer: cce(),
        pointerLock: uce()
    },
    dce = 250,
    fce = 180,
    pce = .5,
    mce = 50,
    gce = 250,
    vce = 10,
    aO = {
        mouse: 0,
        touch: 0,
        pen: 8
    },
    yce = bt(bt({}, ko), {}, {
        device(e, t, {
            pointer: {
                touch: r = !1,
                lock: n = !1,
                mouse: i = !1
            } = {}
        }) {
            return this.pointerLock = n && Kr.pointerLock, Kr.touch && r ? "touch" : this.pointerLock ? "mouse" : Kr.pointer && !i ? "pointer" : Kr.touch ? "touch" : "mouse"
        },
        preventScrollAxis(e, t, {
            preventScroll: r
        }) {
            if (this.preventScrollDelay = typeof r == "number" ? r : r || r === void 0 && e ? dce : void 0, !(!Kr.touchscreen || r === !1)) return e || (r !== void 0 ? "y" : void 0)
        },
        pointerCapture(e, t, {
            pointer: {
                capture: r = !0,
                buttons: n = 1,
                keys: i = !0
            } = {}
        }) {
            return this.pointerButtons = n, this.keys = i, !this.pointerLock && this.device === "pointer" && r
        },
        threshold(e, t, {
            filterTaps: r = !1,
            tapsThreshold: n = 3,
            axis: i = void 0
        }) {
            const s = ft.toVector(e, r ? n : i ? 1 : 0);
            return this.filterTaps = r, this.tapsThreshold = n, s
        },
        swipe({
            velocity: e = pce,
            distance: t = mce,
            duration: r = gce
        } = {}) {
            return {
                velocity: this.transform(ft.toVector(e)),
                distance: this.transform(ft.toVector(t)),
                duration: r
            }
        },
        delay(e = 0) {
            switch (e) {
                case !0:
                    return fce;
                case !1:
                    return 0;
                default:
                    return e
            }
        },
        axisThreshold(e) {
            return e ? bt(bt({}, aO), e) : aO
        },
        keyboardDisplacement(e = vce) {
            return e
        }
    });

function GD(e) {
    const [t, r] = e.overflow, [n, i] = e._delta, [s, o] = e._direction;
    (t < 0 && n > 0 && s < 0 || t > 0 && n < 0 && s > 0) && (e._movement[0] = e._movementBound[0]), (r < 0 && i > 0 && o < 0 || r > 0 && i < 0 && o > 0) && (e._movement[1] = e._movementBound[1])
}
const _ce = 30,
    wce = 100;
class bce extends UD {
    constructor(...t) {
        super(...t), $t(this, "ingKey", "pinching"), $t(this, "aliasKey", "da")
    }
    init() {
        this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = new Map
    }
    reset() {
        super.reset();
        const t = this.state;
        t._touchIds = [], t.canceled = !1, t.cancel = this.cancel.bind(this), t.turns = 0
    }
    computeOffset() {
        const {
            type: t,
            movement: r,
            lastOffset: n
        } = this.state;
        t === "wheel" ? this.state.offset = ft.add(r, n) : this.state.offset = [(1 + r[0]) * n[0], r[1] + n[1]]
    }
    computeMovement() {
        const {
            offset: t,
            lastOffset: r
        } = this.state;
        this.state.movement = [t[0] / r[0], t[1] - r[1]]
    }
    axisIntent() {
        const t = this.state,
            [r, n] = t._movement;
        if (!t.axis) {
            const i = Math.abs(r) * _ce - Math.abs(n);
            i < 0 ? t.axis = "angle" : i > 0 && (t.axis = "scale")
        }
    }
    restrictToAxis(t) {
        this.config.lockDirection && (this.state.axis === "scale" ? t[1] = 0 : this.state.axis === "angle" && (t[0] = 0))
    }
    cancel() {
        const t = this.state;
        t.canceled || setTimeout(() => {
            t.canceled = !0, t._active = !1, this.compute(), this.emit()
        }, 0)
    }
    touchStart(t) {
        this.ctrl.setEventIds(t);
        const r = this.state,
            n = this.ctrl.touchIds;
        if (r._active && r._touchIds.every(s => n.has(s)) || n.size < 2) return;
        this.start(t), r._touchIds = Array.from(n).slice(0, 2);
        const i = eO(t, r._touchIds);
        i && this.pinchStart(t, i)
    }
    pointerStart(t) {
        if (t.buttons != null && t.buttons % 2 !== 1) return;
        this.ctrl.setEventIds(t), t.target.setPointerCapture(t.pointerId);
        const r = this.state,
            n = r._pointerEvents,
            i = this.ctrl.pointerIds;
        if (r._active && Array.from(n.keys()).every(o => i.has(o)) || (n.size < 2 && n.set(t.pointerId, t), r._pointerEvents.size < 2)) return;
        this.start(t);
        const s = j_(...Array.from(n.values()));
        s && this.pinchStart(t, s)
    }
    pinchStart(t, r) {
        const n = this.state;
        n.origin = r.origin, this.computeValues([r.distance, r.angle]), this.computeInitial(), this.compute(t), this.emit()
    }
    touchMove(t) {
        if (!this.state._active) return;
        const r = eO(t, this.state._touchIds);
        r && this.pinchMove(t, r)
    }
    pointerMove(t) {
        const r = this.state._pointerEvents;
        if (r.has(t.pointerId) && r.set(t.pointerId, t), !this.state._active) return;
        const n = j_(...Array.from(r.values()));
        n && this.pinchMove(t, n)
    }
    pinchMove(t, r) {
        const n = this.state,
            i = n._values[1],
            s = r.angle - i;
        let o = 0;
        Math.abs(s) > 270 && (o += Math.sign(s)), this.computeValues([r.distance, r.angle - 360 * o]), n.origin = r.origin, n.turns = o, n._movement = [n._values[0] / n._initial[0] - 1, n._values[1] - n._initial[1]], this.compute(t), this.emit()
    }
    touchEnd(t) {
        this.ctrl.setEventIds(t), this.state._active && this.state._touchIds.some(r => !this.ctrl.touchIds.has(r)) && (this.state._active = !1, this.compute(t), this.emit())
    }
    pointerEnd(t) {
        const r = this.state;
        this.ctrl.setEventIds(t);
        try {
            t.target.releasePointerCapture(t.pointerId)
        } catch {}
        r._pointerEvents.has(t.pointerId) && r._pointerEvents.delete(t.pointerId), r._active && r._pointerEvents.size < 2 && (r._active = !1, this.compute(t), this.emit())
    }
    gestureStart(t) {
        t.cancelable && t.preventDefault();
        const r = this.state;
        r._active || (this.start(t), this.computeValues([t.scale, t.rotation]), r.origin = [t.clientX, t.clientY], this.compute(t), this.emit())
    }
    gestureMove(t) {
        if (t.cancelable && t.preventDefault(), !this.state._active) return;
        const r = this.state;
        this.computeValues([t.scale, t.rotation]), r.origin = [t.clientX, t.clientY];
        const n = r._movement;
        r._movement = [t.scale - 1, t.rotation], r._delta = ft.sub(r._movement, n), this.compute(t), this.emit()
    }
    gestureEnd(t) {
        this.state._active && (this.state._active = !1, this.compute(t), this.emit())
    }
    wheel(t) {
        const r = this.config.modifierKey;
        r && !t[r] || (this.state._active ? this.wheelChange(t) : this.wheelStart(t), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)))
    }
    wheelStart(t) {
        this.start(t), this.wheelChange(t)
    }
    wheelChange(t) {
        "uv" in t || t.cancelable && t.preventDefault();
        const n = this.state;
        n._delta = [-jD(t)[1] / wce * n.offset[0], 0], ft.addTo(n._movement, n._delta), GD(n), this.state.origin = [t.clientX, t.clientY], this.compute(t), this.emit()
    }
    wheelEnd() {
        this.state._active && (this.state._active = !1, this.compute(), this.emit())
    }
    bind(t) {
        const r = this.config.device;
        r && (t(r, "start", this[r + "Start"].bind(this)), t(r, "change", this[r + "Move"].bind(this)), t(r, "end", this[r + "End"].bind(this)), t(r, "cancel", this[r + "End"].bind(this))), this.config.pinchOnWheel && t("wheel", "", this.wheel.bind(this), {
            passive: !1
        })
    }
}
const xce = bt(bt({}, HD), {}, {
    device(e, t, {
        shared: r,
        pointer: {
            touch: n = !1
        } = {}
    }) {
        if (r.target && !Kr.touch && Kr.gesture) return "gesture";
        if (Kr.touch && n) return "touch";
        if (Kr.touchscreen) {
            if (Kr.pointer) return "pointer";
            if (Kr.touch) return "touch"
        }
    },
    bounds(e, t, {
        scaleBounds: r = {},
        angleBounds: n = {}
    }) {
        const i = o => {
                const a = nO(lm(r, o), {
                    min: -1 / 0,
                    max: 1 / 0
                });
                return [a.min, a.max]
            },
            s = o => {
                const a = nO(lm(n, o), {
                    min: -1 / 0,
                    max: 1 / 0
                });
                return [a.min, a.max]
            };
        return typeof r != "function" && typeof n != "function" ? [i(), s()] : o => [i(o), s(o)]
    },
    threshold(e, t, r) {
        return this.lockDirection = r.axis === "lock", ft.toVector(e, this.lockDirection ? [.1, 3] : 0)
    },
    modifierKey(e) {
        return e === void 0 ? "ctrlKey" : e
    },
    pinchOnWheel(e = !0) {
        return e
    }
});
class Ece extends Mu {
    constructor(...t) {
        super(...t), $t(this, "ingKey", "moving")
    }
    move(t) {
        this.config.mouseOnly && t.pointerType !== "mouse" || (this.state._active ? this.moveChange(t) : this.moveStart(t), this.timeoutStore.add("moveEnd", this.moveEnd.bind(this)))
    }
    moveStart(t) {
        this.start(t), this.computeValues(ll(t)), this.compute(t), this.computeInitial(), this.emit()
    }
    moveChange(t) {
        if (!this.state._active) return;
        const r = ll(t),
            n = this.state;
        n._delta = ft.sub(r, n._values), ft.addTo(n._movement, n._delta), this.computeValues(r), this.compute(t), this.emit()
    }
    moveEnd(t) {
        this.state._active && (this.state._active = !1, this.compute(t), this.emit())
    }
    bind(t) {
        t("pointer", "change", this.move.bind(this)), t("pointer", "leave", this.moveEnd.bind(this))
    }
}
const Sce = bt(bt({}, ko), {}, {
    mouseOnly: (e = !0) => e
});
class Pce extends Mu {
    constructor(...t) {
        super(...t), $t(this, "ingKey", "scrolling")
    }
    scroll(t) {
        this.state._active || this.start(t), this.scrollChange(t), this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this))
    }
    scrollChange(t) {
        t.cancelable && t.preventDefault();
        const r = this.state,
            n = Zle(t);
        r._delta = ft.sub(n, r._values), ft.addTo(r._movement, r._delta), this.computeValues(n), this.compute(t), this.emit()
    }
    scrollEnd() {
        this.state._active && (this.state._active = !1, this.compute(), this.emit())
    }
    bind(t) {
        t("scroll", "", this.scroll.bind(this))
    }
}
const Cce = ko;
class Tce extends Mu {
    constructor(...t) {
        super(...t), $t(this, "ingKey", "wheeling")
    }
    wheel(t) {
        this.state._active || this.start(t), this.wheelChange(t), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this))
    }
    wheelChange(t) {
        const r = this.state;
        r._delta = jD(t), ft.addTo(r._movement, r._delta), GD(r), this.compute(t), this.emit()
    }
    wheelEnd() {
        this.state._active && (this.state._active = !1, this.compute(), this.emit())
    }
    bind(t) {
        t("wheel", "", this.wheel.bind(this))
    }
}
const Oce = ko;
class Ace extends Mu {
    constructor(...t) {
        super(...t), $t(this, "ingKey", "hovering")
    }
    enter(t) {
        this.config.mouseOnly && t.pointerType !== "mouse" || (this.start(t), this.computeValues(ll(t)), this.compute(t), this.emit())
    }
    leave(t) {
        if (this.config.mouseOnly && t.pointerType !== "mouse") return;
        const r = this.state;
        if (!r._active) return;
        r._active = !1;
        const n = ll(t);
        r._movement = r._delta = ft.sub(n, r._values), this.computeValues(n), this.compute(t), r.delta = r.movement, this.emit()
    }
    bind(t) {
        t("pointer", "enter", this.enter.bind(this)), t("pointer", "leave", this.leave.bind(this))
    }
}
const Ice = bt(bt({}, ko), {}, {
        mouseOnly: (e = !0) => e
    }),
    jw = new Map,
    U_ = new Map;

function $ce(e) {
    jw.set(e.key, e.engine), U_.set(e.key, e.resolver)
}
const Rce = {
        key: "drag",
        engine: oce,
        resolver: yce
    },
    kce = {
        key: "hover",
        engine: Ace,
        resolver: Ice
    },
    Mce = {
        key: "move",
        engine: Ece,
        resolver: Sce
    },
    Dce = {
        key: "pinch",
        engine: bce,
        resolver: xce
    },
    Nce = {
        key: "scroll",
        engine: Pce,
        resolver: Cce
    },
    Lce = {
        key: "wheel",
        engine: Tce,
        resolver: Oce
    };

function Fce(e, t) {
    if (e == null) return {};
    var r = {},
        n = Object.keys(e),
        i, s;
    for (s = 0; s < n.length; s++) i = n[s], !(t.indexOf(i) >= 0) && (r[i] = e[i]);
    return r
}

function Bce(e, t) {
    if (e == null) return {};
    var r = Fce(e, t),
        n, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for (i = 0; i < s.length; i++) n = s[i], !(t.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n])
    }
    return r
}
const zce = {
        target(e) {
            if (e) return () => "current" in e ? e.current : e
        },
        enabled(e = !0) {
            return e
        },
        window(e = Kr.isBrowser ? window : void 0) {
            return e
        },
        eventOptions({
            passive: e = !0,
            capture: t = !1
        } = {}) {
            return {
                passive: e,
                capture: t
            }
        },
        transform(e) {
            return e
        }
    },
    jce = ["target", "eventOptions", "window", "enabled", "transform"];

function zd(e = {}, t) {
    const r = {};
    for (const [n, i] of Object.entries(t)) switch (typeof i) {
        case "function":
            r[n] = i.call(r, e[n], n, e);
            break;
        case "object":
            r[n] = zd(e[n], i);
            break;
        case "boolean":
            i && (r[n] = e[n]);
            break
    }
    return r
}

function Uce(e, t, r = {}) {
    const n = e,
        {
            target: i,
            eventOptions: s,
            window: o,
            enabled: a,
            transform: l
        } = n,
        c = Bce(n, jce);
    if (r.shared = zd({
            target: i,
            eventOptions: s,
            window: o,
            enabled: a,
            transform: l
        }, zce), t) {
        const u = U_.get(t);
        r[t] = zd(bt({
            shared: r.shared
        }, c), u)
    } else
        for (const u in c) {
            const h = U_.get(u);
            h && (r[u] = zd(bt({
                shared: r.shared
            }, c[u]), h))
        }
    return r
}
class VD {
    constructor(t, r) {
        $t(this, "_listeners", new Set), this._ctrl = t, this._gestureKey = r
    }
    add(t, r, n, i, s) {
        const o = this._listeners,
            a = Yle(r, n),
            l = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {},
            c = bt(bt({}, l), s);
        t.addEventListener(a, i, c);
        const u = () => {
            t.removeEventListener(a, i, c), o.delete(u)
        };
        return o.add(u), u
    }
    clean() {
        this._listeners.forEach(t => t()), this._listeners.clear()
    }
}
class Hce {
    constructor() {
        $t(this, "_timeouts", new Map)
    }
    add(t, r, n = 140, ...i) {
        this.remove(t), this._timeouts.set(t, window.setTimeout(r, n, ...i))
    }
    remove(t) {
        const r = this._timeouts.get(t);
        r && window.clearTimeout(r)
    }
    clean() {
        this._timeouts.forEach(t => void window.clearTimeout(t)), this._timeouts.clear()
    }
}
class Gce {
    constructor(t) {
        $t(this, "gestures", new Set), $t(this, "_targetEventStore", new VD(this)), $t(this, "gestureEventStores", {}), $t(this, "gestureTimeoutStores", {}), $t(this, "handlers", {}), $t(this, "config", {}), $t(this, "pointerIds", new Set), $t(this, "touchIds", new Set), $t(this, "state", {
            shared: {
                shiftKey: !1,
                metaKey: !1,
                ctrlKey: !1,
                altKey: !1
            }
        }), Vce(this, t)
    }
    setEventIds(t) {
        if (yg(t)) return this.touchIds = new Set(Qle(t)), this.touchIds;
        if ("pointerId" in t) return t.type === "pointerup" || t.type === "pointercancel" ? this.pointerIds.delete(t.pointerId) : t.type === "pointerdown" && this.pointerIds.add(t.pointerId), this.pointerIds
    }
    applyHandlers(t, r) {
        this.handlers = t, this.nativeHandlers = r
    }
    applyConfig(t, r) {
        this.config = Uce(t, r, this.config)
    }
    clean() {
        this._targetEventStore.clean();
        for (const t of this.gestures) this.gestureEventStores[t].clean(), this.gestureTimeoutStores[t].clean()
    }
    effect() {
        return this.config.shared.target && this.bind(), () => this._targetEventStore.clean()
    }
    bind(...t) {
        const r = this.config.shared,
            n = {};
        let i;
        if (!(r.target && (i = r.target(), !i))) {
            if (r.enabled) {
                for (const o of this.gestures) {
                    const a = this.config[o],
                        l = lO(n, a.eventOptions, !!i);
                    if (a.enabled) {
                        const c = jw.get(o);
                        new c(this, t, o).bind(l)
                    }
                }
                const s = lO(n, r.eventOptions, !!i);
                for (const o in this.nativeHandlers) s(o, "", a => this.nativeHandlers[o](bt(bt({}, this.state.shared), {}, {
                    event: a,
                    args: t
                })), void 0, !0)
            }
            for (const s in n) n[s] = tce(...n[s]);
            if (!i) return n;
            for (const s in n) {
                const {
                    device: o,
                    capture: a,
                    passive: l
                } = Xle(s);
                this._targetEventStore.add(i, o, "", n[s], {
                    capture: a,
                    passive: l
                })
            }
        }
    }
}

function na(e, t) {
    e.gestures.add(t), e.gestureEventStores[t] = new VD(e, t), e.gestureTimeoutStores[t] = new Hce
}

function Vce(e, t) {
    t.drag && na(e, "drag"), t.wheel && na(e, "wheel"), t.scroll && na(e, "scroll"), t.move && na(e, "move"), t.pinch && na(e, "pinch"), t.hover && na(e, "hover")
}
const lO = (e, t, r) => (n, i, s, o = {}, a = !1) => {
        var l, c;
        const u = (l = o.capture) !== null && l !== void 0 ? l : t.capture,
            h = (c = o.passive) !== null && c !== void 0 ? c : t.passive;
        let d = a ? n : Vle(n, i, u);
        r && h && (d += "Passive"), e[d] = e[d] || [], e[d].push(s)
    },
    Wce = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;

function Xce(e) {
    const t = {},
        r = {},
        n = new Set;
    for (let i in e) Wce.test(i) ? (n.add(RegExp.lastMatch), r[i] = e[i]) : t[i] = e[i];
    return [r, t, n]
}

function ia(e, t, r, n, i, s) {
    if (!e.has(r) || !jw.has(n)) return;
    const o = r + "Start",
        a = r + "End",
        l = c => {
            let u;
            return c.first && o in t && t[o](c), r in t && (u = t[r](c)), c.last && a in t && t[a](c), u
        };
    i[n] = l, s[n] = s[n] || {}
}

function Yce(e, t) {
    const [r, n, i] = Xce(e), s = {};
    return ia(i, r, "onDrag", "drag", s, t), ia(i, r, "onWheel", "wheel", s, t), ia(i, r, "onScroll", "scroll", s, t), ia(i, r, "onPinch", "pinch", s, t), ia(i, r, "onMove", "move", s, t), ia(i, r, "onHover", "hover", s, t), {
        handlers: s,
        config: t,
        nativeHandlers: n
    }
}

function Kce(e, t = {}, r, n) {
    const i = I.useMemo(() => new Gce(e), []);
    if (i.applyHandlers(e, n), i.applyConfig(t, r), I.useEffect(i.effect.bind(i)), I.useEffect(() => i.clean.bind(i), []), t.target === void 0) return i.bind.bind(i)
}

function qce(e) {
    return e.forEach($ce),
        function(r, n) {
            const {
                handlers: i,
                nativeHandlers: s,
                config: o
            } = Yce(r, n || {});
            return Kce(i, o, void 0, s)
        }
}

function Qce(e, t) {
    return qce([Rce, Dce, Nce, Lce, Mce, kce])(e, t || {})
}
var Uw = Lu(),
    Ae = e => Nu(e, Uw),
    Hw = Lu();
Ae.write = e => Nu(e, Hw);
var _g = Lu();
Ae.onStart = e => Nu(e, _g);
var Gw = Lu();
Ae.onFrame = e => Nu(e, Gw);
var Vw = Lu();
Ae.onFinish = e => Nu(e, Vw);
var Ga = [];
Ae.setTimeout = (e, t) => {
    let r = Ae.now() + t,
        n = () => {
            let s = Ga.findIndex(o => o.cancel == n);
            ~s && Ga.splice(s, 1), ls -= ~s ? 1 : 0
        },
        i = {
            time: r,
            handler: e,
            cancel: n
        };
    return Ga.splice(WD(r), 0, i), ls += 1, XD(), i
};
var WD = e => ~(~Ga.findIndex(t => t.time > e) || ~Ga.length);
Ae.cancel = e => {
    _g.delete(e), Gw.delete(e), Vw.delete(e), Uw.delete(e), Hw.delete(e)
};
Ae.sync = e => {
    H_ = !0, Ae.batchedUpdates(e), H_ = !1
};
Ae.throttle = e => {
    let t;

    function r() {
        try {
            e(...t)
        } finally {
            t = null
        }
    }

    function n(...i) {
        t = i, Ae.onStart(r)
    }
    return n.handler = e, n.cancel = () => {
        _g.delete(r), t = null
    }, n
};
var Ww = typeof window < "u" ? window.requestAnimationFrame : () => {};
Ae.use = e => Ww = e;
Ae.now = typeof performance < "u" ? () => performance.now() : Date.now;
Ae.batchedUpdates = e => e();
Ae.catch = console.error;
Ae.frameLoop = "always";
Ae.advance = () => {
    Ae.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : KD()
};
var as = -1,
    ls = 0,
    H_ = !1;

function Nu(e, t) {
    H_ ? (t.delete(e), e(0)) : (t.add(e), XD())
}

function XD() {
    as < 0 && (as = 0, Ae.frameLoop !== "demand" && Ww(YD))
}

function Zce() {
    as = -1
}

function YD() {
    ~as && (Ww(YD), Ae.batchedUpdates(KD))
}

function KD() {
    let e = as;
    as = Ae.now();
    let t = WD(as);
    if (t && (qD(Ga.splice(0, t), r => r.handler()), ls -= t), !ls) {
        Zce();
        return
    }
    _g.flush(), Uw.flush(e ? Math.min(64, as - e) : 16.667), Gw.flush(), Hw.flush(), Vw.flush()
}

function Lu() {
    let e = new Set,
        t = e;
    return {
        add(r) {
            ls += t == e && !e.has(r) ? 1 : 0, e.add(r)
        },
        delete(r) {
            return ls -= t == e && e.has(r) ? 1 : 0, e.delete(r)
        },
        flush(r) {
            t.size && (e = new Set, ls -= t.size, qD(t, n => n(r) && e.add(n)), ls += e.size, t = e)
        }
    }
}

function qD(e, t) {
    e.forEach(r => {
        try {
            t(r)
        } catch (n) {
            Ae.catch(n)
        }
    })
}
var Jce = Object.defineProperty,
    eue = (e, t) => {
        for (var r in t) Jce(e, r, {
            get: t[r],
            enumerable: !0
        })
    },
    Dn = {};
eue(Dn, {
    assign: () => rue,
    colors: () => bs,
    createStringInterpolator: () => Yw,
    skipAnimation: () => ZD,
    to: () => QD,
    willAdvance: () => Kw
});

function G_() {}
var tue = (e, t, r) => Object.defineProperty(e, t, {
        value: r,
        writable: !0,
        configurable: !0
    }),
    ne = {
        arr: Array.isArray,
        obj: e => !!e && e.constructor.name === "Object",
        fun: e => typeof e == "function",
        str: e => typeof e == "string",
        num: e => typeof e == "number",
        und: e => e === void 0
    };

function gi(e, t) {
    if (ne.arr(e)) {
        if (!ne.arr(t) || e.length !== t.length) return !1;
        for (let r = 0; r < e.length; r++)
            if (e[r] !== t[r]) return !1;
        return !0
    }
    return e === t
}
var Ge = (e, t) => e.forEach(t);

function oi(e, t, r) {
    if (ne.arr(e)) {
        for (let n = 0; n < e.length; n++) t.call(r, e[n], `${n}`);
        return
    }
    for (let n in e) e.hasOwnProperty(n) && t.call(r, e[n], n)
}
var Lr = e => ne.und(e) ? [] : ne.arr(e) ? e : [e];

function Ac(e, t) {
    if (e.size) {
        let r = Array.from(e);
        e.clear(), Ge(r, t)
    }
}
var pc = (e, ...t) => Ac(e, r => r(...t)),
    Xw = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
    Yw, QD, bs = null,
    ZD = !1,
    Kw = G_,
    rue = e => {
        e.to && (QD = e.to), e.now && (Ae.now = e.now), e.colors !== void 0 && (bs = e.colors), e.skipAnimation != null && (ZD = e.skipAnimation), e.createStringInterpolator && (Yw = e.createStringInterpolator), e.requestAnimationFrame && Ae.use(e.requestAnimationFrame), e.batchedUpdates && (Ae.batchedUpdates = e.batchedUpdates), e.willAdvance && (Kw = e.willAdvance), e.frameLoop && (Ae.frameLoop = e.frameLoop)
    },
    Ic = new Set,
    Qr = [],
    A0 = [],
    cm = 0,
    wg = {
        get idle() {
            return !Ic.size && !Qr.length
        },
        start(e) {
            cm > e.priority ? (Ic.add(e), Ae.onStart(nue)) : (JD(e), Ae(V_))
        },
        advance: V_,
        sort(e) {
            if (cm) Ae.onFrame(() => wg.sort(e));
            else {
                let t = Qr.indexOf(e);
                ~t && (Qr.splice(t, 1), eN(e))
            }
        },
        clear() {
            Qr = [], Ic.clear()
        }
    };

function nue() {
    Ic.forEach(JD), Ic.clear(), Ae(V_)
}

function JD(e) {
    Qr.includes(e) || eN(e)
}

function eN(e) {
    Qr.splice(iue(Qr, t => t.priority > e.priority), 0, e)
}

function V_(e) {
    let t = A0;
    for (let r = 0; r < Qr.length; r++) {
        let n = Qr[r];
        cm = n.priority, n.idle || (Kw(n), n.advance(e), n.idle || t.push(n))
    }
    return cm = 0, A0 = Qr, A0.length = 0, Qr = t, Qr.length > 0
}

function iue(e, t) {
    let r = e.findIndex(t);
    return r < 0 ? e.length : r
}
var sue = (e, t, r) => Math.min(Math.max(r, e), t),
    oue = {
        transparent: 0,
        aliceblue: 4042850303,
        antiquewhite: 4209760255,
        aqua: 16777215,
        aquamarine: 2147472639,
        azure: 4043309055,
        beige: 4126530815,
        bisque: 4293182719,
        black: 255,
        blanchedalmond: 4293643775,
        blue: 65535,
        blueviolet: 2318131967,
        brown: 2771004159,
        burlywood: 3736635391,
        burntsienna: 3934150143,
        cadetblue: 1604231423,
        chartreuse: 2147418367,
        chocolate: 3530104575,
        coral: 4286533887,
        cornflowerblue: 1687547391,
        cornsilk: 4294499583,
        crimson: 3692313855,
        cyan: 16777215,
        darkblue: 35839,
        darkcyan: 9145343,
        darkgoldenrod: 3095792639,
        darkgray: 2846468607,
        darkgreen: 6553855,
        darkgrey: 2846468607,
        darkkhaki: 3182914559,
        darkmagenta: 2332068863,
        darkolivegreen: 1433087999,
        darkorange: 4287365375,
        darkorchid: 2570243327,
        darkred: 2332033279,
        darksalmon: 3918953215,
        darkseagreen: 2411499519,
        darkslateblue: 1211993087,
        darkslategray: 793726975,
        darkslategrey: 793726975,
        darkturquoise: 13554175,
        darkviolet: 2483082239,
        deeppink: 4279538687,
        deepskyblue: 12582911,
        dimgray: 1768516095,
        dimgrey: 1768516095,
        dodgerblue: 512819199,
        firebrick: 2988581631,
        floralwhite: 4294635775,
        forestgreen: 579543807,
        fuchsia: 4278255615,
        gainsboro: 3705462015,
        ghostwhite: 4177068031,
        gold: 4292280575,
        goldenrod: 3668254975,
        gray: 2155905279,
        green: 8388863,
        greenyellow: 2919182335,
        grey: 2155905279,
        honeydew: 4043305215,
        hotpink: 4285117695,
        indianred: 3445382399,
        indigo: 1258324735,
        ivory: 4294963455,
        khaki: 4041641215,
        lavender: 3873897215,
        lavenderblush: 4293981695,
        lawngreen: 2096890111,
        lemonchiffon: 4294626815,
        lightblue: 2916673279,
        lightcoral: 4034953471,
        lightcyan: 3774873599,
        lightgoldenrodyellow: 4210742015,
        lightgray: 3553874943,
        lightgreen: 2431553791,
        lightgrey: 3553874943,
        lightpink: 4290167295,
        lightsalmon: 4288707327,
        lightseagreen: 548580095,
        lightskyblue: 2278488831,
        lightslategray: 2005441023,
        lightslategrey: 2005441023,
        lightsteelblue: 2965692159,
        lightyellow: 4294959359,
        lime: 16711935,
        limegreen: 852308735,
        linen: 4210091775,
        magenta: 4278255615,
        maroon: 2147483903,
        mediumaquamarine: 1724754687,
        mediumblue: 52735,
        mediumorchid: 3126187007,
        mediumpurple: 2473647103,
        mediumseagreen: 1018393087,
        mediumslateblue: 2070474495,
        mediumspringgreen: 16423679,
        mediumturquoise: 1221709055,
        mediumvioletred: 3340076543,
        midnightblue: 421097727,
        mintcream: 4127193855,
        mistyrose: 4293190143,
        moccasin: 4293178879,
        navajowhite: 4292783615,
        navy: 33023,
        oldlace: 4260751103,
        olive: 2155872511,
        olivedrab: 1804477439,
        orange: 4289003775,
        orangered: 4282712319,
        orchid: 3664828159,
        palegoldenrod: 4008225535,
        palegreen: 2566625535,
        paleturquoise: 2951671551,
        palevioletred: 3681588223,
        papayawhip: 4293907967,
        peachpuff: 4292524543,
        peru: 3448061951,
        pink: 4290825215,
        plum: 3718307327,
        powderblue: 2967529215,
        purple: 2147516671,
        rebeccapurple: 1714657791,
        red: 4278190335,
        rosybrown: 3163525119,
        royalblue: 1097458175,
        saddlebrown: 2336560127,
        salmon: 4202722047,
        sandybrown: 4104413439,
        seagreen: 780883967,
        seashell: 4294307583,
        sienna: 2689740287,
        silver: 3233857791,
        skyblue: 2278484991,
        slateblue: 1784335871,
        slategray: 1887473919,
        slategrey: 1887473919,
        snow: 4294638335,
        springgreen: 16744447,
        steelblue: 1182971135,
        tan: 3535047935,
        teal: 8421631,
        thistle: 3636451583,
        tomato: 4284696575,
        turquoise: 1088475391,
        violet: 4001558271,
        wheat: 4125012991,
        white: 4294967295,
        whitesmoke: 4126537215,
        yellow: 4294902015,
        yellowgreen: 2597139199
    },
    Pn = "[-+]?\\d*\\.?\\d+",
    um = Pn + "%";

function bg(...e) {
    return "\\(\\s*(" + e.join(")\\s*,\\s*(") + ")\\s*\\)"
}
var aue = new RegExp("rgb" + bg(Pn, Pn, Pn)),
    lue = new RegExp("rgba" + bg(Pn, Pn, Pn, Pn)),
    cue = new RegExp("hsl" + bg(Pn, um, um)),
    uue = new RegExp("hsla" + bg(Pn, um, um, Pn)),
    hue = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    due = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    fue = /^#([0-9a-fA-F]{6})$/,
    pue = /^#([0-9a-fA-F]{8})$/;

function mue(e) {
    let t;
    return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = fue.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : bs && bs[e] !== void 0 ? bs[e] : (t = aue.exec(e)) ? (sa(t[1]) << 24 | sa(t[2]) << 16 | sa(t[3]) << 8 | 255) >>> 0 : (t = lue.exec(e)) ? (sa(t[1]) << 24 | sa(t[2]) << 16 | sa(t[3]) << 8 | hO(t[4])) >>> 0 : (t = hue.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + "ff", 16) >>> 0 : (t = pue.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = due.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + t[4] + t[4], 16) >>> 0 : (t = cue.exec(e)) ? (cO(uO(t[1]), od(t[2]), od(t[3])) | 255) >>> 0 : (t = uue.exec(e)) ? (cO(uO(t[1]), od(t[2]), od(t[3])) | hO(t[4])) >>> 0 : null
}

function I0(e, t, r) {
    return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e
}

function cO(e, t, r) {
    let n = r < .5 ? r * (1 + t) : r + t - r * t,
        i = 2 * r - n,
        s = I0(i, n, e + 1 / 3),
        o = I0(i, n, e),
        a = I0(i, n, e - 1 / 3);
    return Math.round(s * 255) << 24 | Math.round(o * 255) << 16 | Math.round(a * 255) << 8
}

function sa(e) {
    let t = parseInt(e, 10);
    return t < 0 ? 0 : t > 255 ? 255 : t
}

function uO(e) {
    return (parseFloat(e) % 360 + 360) % 360 / 360
}

function hO(e) {
    let t = parseFloat(e);
    return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255)
}

function od(e) {
    let t = parseFloat(e);
    return t < 0 ? 0 : t > 100 ? 1 : t / 100
}

function dO(e) {
    let t = mue(e);
    if (t === null) return e;
    t = t || 0;
    let r = (t & 4278190080) >>> 24,
        n = (t & 16711680) >>> 16,
        i = (t & 65280) >>> 8,
        s = (t & 255) / 255;
    return `rgba(${r}, ${n}, ${i}, ${s})`
}
var cu = (e, t, r) => {
    if (ne.fun(e)) return e;
    if (ne.arr(e)) return cu({
        range: e,
        output: t,
        extrapolate: r
    });
    if (ne.str(e.output[0])) return Yw(e);
    let n = e,
        i = n.output,
        s = n.range || [0, 1],
        o = n.extrapolateLeft || n.extrapolate || "extend",
        a = n.extrapolateRight || n.extrapolate || "extend",
        l = n.easing || (c => c);
    return c => {
        let u = vue(c, s);
        return gue(c, s[u], s[u + 1], i[u], i[u + 1], l, o, a, n.map)
    }
};

function gue(e, t, r, n, i, s, o, a, l) {
    let c = l ? l(e) : e;
    if (c < t) {
        if (o === "identity") return c;
        o === "clamp" && (c = t)
    }
    if (c > r) {
        if (a === "identity") return c;
        a === "clamp" && (c = r)
    }
    return n === i ? n : t === r ? e <= t ? n : i : (t === -1 / 0 ? c = -c : r === 1 / 0 ? c = c - t : c = (c - t) / (r - t), c = s(c), n === -1 / 0 ? c = -c : i === 1 / 0 ? c = c + n : c = c * (i - n) + n, c)
}

function vue(e, t) {
    for (var r = 1; r < t.length - 1 && !(t[r] >= e); ++r);
    return r - 1
}
var yue = (e, t = "end") => r => {
        r = t === "end" ? Math.min(r, .999) : Math.max(r, .001);
        let n = r * e,
            i = t === "end" ? Math.floor(n) : Math.ceil(n);
        return sue(0, 1, i / e)
    },
    hm = 1.70158,
    ad = hm * 1.525,
    fO = hm + 1,
    pO = 2 * Math.PI / 3,
    mO = 2 * Math.PI / 4.5,
    ld = e => e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375,
    _ue = {
        linear: e => e,
        easeInQuad: e => e * e,
        easeOutQuad: e => 1 - (1 - e) * (1 - e),
        easeInOutQuad: e => e < .5 ? 2 * e * e : 1 - Math.pow(-2 * e + 2, 2) / 2,
        easeInCubic: e => e * e * e,
        easeOutCubic: e => 1 - Math.pow(1 - e, 3),
        easeInOutCubic: e => e < .5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2,
        easeInQuart: e => e * e * e * e,
        easeOutQuart: e => 1 - Math.pow(1 - e, 4),
        easeInOutQuart: e => e < .5 ? 8 * e * e * e * e : 1 - Math.pow(-2 * e + 2, 4) / 2,
        easeInQuint: e => e * e * e * e * e,
        easeOutQuint: e => 1 - Math.pow(1 - e, 5),
        easeInOutQuint: e => e < .5 ? 16 * e * e * e * e * e : 1 - Math.pow(-2 * e + 2, 5) / 2,
        easeInSine: e => 1 - Math.cos(e * Math.PI / 2),
        easeOutSine: e => Math.sin(e * Math.PI / 2),
        easeInOutSine: e => -(Math.cos(Math.PI * e) - 1) / 2,
        easeInExpo: e => e === 0 ? 0 : Math.pow(2, 10 * e - 10),
        easeOutExpo: e => e === 1 ? 1 : 1 - Math.pow(2, -10 * e),
        easeInOutExpo: e => e === 0 ? 0 : e === 1 ? 1 : e < .5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2,
        easeInCirc: e => 1 - Math.sqrt(1 - Math.pow(e, 2)),
        easeOutCirc: e => Math.sqrt(1 - Math.pow(e - 1, 2)),
        easeInOutCirc: e => e < .5 ? (1 - Math.sqrt(1 - Math.pow(2 * e, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2,
        easeInBack: e => fO * e * e * e - hm * e * e,
        easeOutBack: e => 1 + fO * Math.pow(e - 1, 3) + hm * Math.pow(e - 1, 2),
        easeInOutBack: e => e < .5 ? Math.pow(2 * e, 2) * ((ad + 1) * 2 * e - ad) / 2 : (Math.pow(2 * e - 2, 2) * ((ad + 1) * (e * 2 - 2) + ad) + 2) / 2,
        easeInElastic: e => e === 0 ? 0 : e === 1 ? 1 : -Math.pow(2, 10 * e - 10) * Math.sin((e * 10 - 10.75) * pO),
        easeOutElastic: e => e === 0 ? 0 : e === 1 ? 1 : Math.pow(2, -10 * e) * Math.sin((e * 10 - .75) * pO) + 1,
        easeInOutElastic: e => e === 0 ? 0 : e === 1 ? 1 : e < .5 ? -(Math.pow(2, 20 * e - 10) * Math.sin((20 * e - 11.125) * mO)) / 2 : Math.pow(2, -20 * e + 10) * Math.sin((20 * e - 11.125) * mO) / 2 + 1,
        easeInBounce: e => 1 - ld(1 - e),
        easeOutBounce: ld,
        easeInOutBounce: e => e < .5 ? (1 - ld(1 - 2 * e)) / 2 : (1 + ld(2 * e - 1)) / 2,
        steps: yue
    },
    cl = Symbol.for("FluidValue.get"),
    bo = Symbol.for("FluidValue.observers"),
    qr = e => !!(e && e[cl]),
    xr = e => e && e[cl] ? e[cl]() : e,
    gO = e => e[bo] || null;

function wue(e, t) {
    e.eventObserved ? e.eventObserved(t) : e(t)
}

function uu(e, t) {
    let r = e[bo];
    r && r.forEach(n => {
        wue(n, t)
    })
}
var Lhe, Fhe, DO, tN = (DO = class {
        constructor(e) {
            oe(this, Lhe);
            oe(this, Fhe);
            if (!e && !(e = this.get)) throw Error("Unknown getter");
            bue(this, e)
        }
    }, Lhe = cl, Fhe = bo, DO),
    bue = (e, t) => rN(e, cl, t);

function Sl(e, t) {
    if (e[cl]) {
        let r = e[bo];
        r || rN(e, bo, r = new Set), r.has(t) || (r.add(t), e.observerAdded && e.observerAdded(r.size, t))
    }
    return t
}

function hu(e, t) {
    let r = e[bo];
    if (r && r.has(t)) {
        let n = r.size - 1;
        n ? r.delete(t) : e[bo] = null, e.observerRemoved && e.observerRemoved(n, t)
    }
}
var rN = (e, t, r) => Object.defineProperty(e, t, {
        value: r,
        writable: !0,
        configurable: !0
    }),
    jd = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
    xue = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi,
    vO = new RegExp(`(${jd.source})(%|[a-z]+)`, "i"),
    Eue = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi,
    xg = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/,
    nN = e => {
        let [t, r] = Sue(e);
        if (!t || Xw()) return e;
        let n = window.getComputedStyle(document.documentElement).getPropertyValue(t);
        return n ? n.trim() : r && r.startsWith("--") ? window.getComputedStyle(document.documentElement).getPropertyValue(r) || e : r && xg.test(r) ? nN(r) : r || e
    },
    Sue = e => {
        let t = xg.exec(e);
        if (!t) return [, ];
        let [, r, n] = t;
        return [r, n]
    },
    $0, Pue = (e, t, r, n, i) => `rgba(${Math.round(t)}, ${Math.round(r)}, ${Math.round(n)}, ${i})`,
    iN = e => {
        $0 || ($0 = bs ? new RegExp(`(${Object.keys(bs).join("|")})(?!\\w)`, "g") : /^\b$/);
        let t = e.output.map(i => xr(i).replace(xg, nN).replace(xue, dO).replace($0, dO)),
            r = t.map(i => i.match(jd).map(Number)),
            n = r[0].map((i, s) => r.map(o => {
                if (!(s in o)) throw Error('The arity of each "output" value must be equal');
                return o[s]
            })).map(i => cu({ ...e,
                output: i
            }));
        return i => {
            var a;
            let s = !vO.test(t[0]) && ((a = t.find(l => vO.test(l))) == null ? void 0 : a.replace(jd, "")),
                o = 0;
            return t[0].replace(jd, () => `${n[o++](i)}${s||""}`).replace(Eue, Pue)
        }
    },
    qw = "react-spring: ",
    sN = e => {
        let t = e,
            r = !1;
        if (typeof t != "function") throw new TypeError(`${qw}once requires a function parameter`);
        return (...n) => {
            r || (t(...n), r = !0)
        }
    },
    Cue = sN(console.warn);

function Tue() {
    Cue(`${qw}The "interpolate" function is deprecated in v9 (use "to" instead)`)
}
var Oue = sN(console.warn);

function Aue() {
    Oue(`${qw}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`)
}

function Eg(e) {
    return ne.str(e) && (e[0] == "#" || /\d/.test(e) || !Xw() && xg.test(e) || e in (bs || {}))
}
var Qw = Xw() ? b.useEffect : b.useLayoutEffect,
    Iue = () => {
        let e = b.useRef(!1);
        return Qw(() => (e.current = !0, () => {
            e.current = !1
        }), []), e
    };

function oN() {
    let e = b.useState()[1],
        t = Iue();
    return () => {
        t.current && e(Math.random())
    }
}

function $ue(e, t) {
    let [r] = b.useState(() => ({
        inputs: t,
        result: e()
    })), n = b.useRef(), i = n.current, s = i;
    return s ? t && s.inputs && Rue(t, s.inputs) || (s = {
        inputs: t,
        result: e()
    }) : s = r, b.useEffect(() => {
        n.current = s, i == r && (r.inputs = r.result = void 0)
    }, [s]), s.result
}

function Rue(e, t) {
    if (e.length !== t.length) return !1;
    for (let r = 0; r < e.length; r++)
        if (e[r] !== t[r]) return !1;
    return !0
}
var aN = e => b.useEffect(e, kue),
    kue = [];

function yO(e) {
    let t = b.useRef();
    return b.useEffect(() => {
        t.current = e
    }), t.current
}
var du = Symbol.for("Animated:node"),
    Mue = e => !!e && e[du] === e,
    Gn = e => e && e[du],
    Zw = (e, t) => tue(e, du, t),
    Sg = e => e && e[du] && e[du].getPayload(),
    lN = class {
        constructor() {
            oe(this, "payload");
            Zw(this, this)
        }
        getPayload() {
            return this.payload || []
        }
    },
    Fu = class extends lN {
        constructor(t) {
            super();
            oe(this, "done", !0);
            oe(this, "elapsedTime");
            oe(this, "lastPosition");
            oe(this, "lastVelocity");
            oe(this, "v0");
            oe(this, "durationProgress", 0);
            this._value = t, ne.num(this._value) && (this.lastPosition = this._value)
        }
        static create(t) {
            return new Fu(t)
        }
        getPayload() {
            return [this]
        }
        getValue() {
            return this._value
        }
        setValue(t, r) {
            return ne.num(t) && (this.lastPosition = t, r && (t = Math.round(t / r) * r, this.done && (this.lastPosition = t))), this._value === t ? !1 : (this._value = t, !0)
        }
        reset() {
            let {
                done: t
            } = this;
            this.done = !1, ne.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, t && (this.lastVelocity = null), this.v0 = null)
        }
    },
    fu = class extends Fu {
        constructor(t) {
            super(0);
            oe(this, "_string", null);
            oe(this, "_toString");
            this._toString = cu({
                output: [t, t]
            })
        }
        static create(t) {
            return new fu(t)
        }
        getValue() {
            return this._string??(this._string = this._toString(this._value))
        }
        setValue(t) {
            if (ne.str(t)) {
                if (t == this._string) return !1;
                this._string = t, this._value = 1
            } else if (super.setValue(t)) this._string = null;
            else return !1;
            return !0
        }
        reset(t) {
            t && (this._toString = cu({
                output: [this.getValue(), t]
            })), this._value = 0, super.reset()
        }
    },
    dm = {
        dependencies: null
    },
    Pg = class extends lN {
        constructor(e) {
            super(), this.source = e, this.setValue(e)
        }
        getValue(e) {
            let t = {};
            return oi(this.source, (r, n) => {
                Mue(r) ? t[n] = r.getValue(e) : qr(r) ? t[n] = xr(r) : e || (t[n] = r)
            }), t
        }
        setValue(e) {
            this.source = e, this.payload = this._makePayload(e)
        }
        reset() {
            this.payload && Ge(this.payload, e => e.reset())
        }
        _makePayload(e) {
            if (e) {
                let t = new Set;
                return oi(e, this._addToPayload, t), Array.from(t)
            }
        }
        _addToPayload(e) {
            dm.dependencies && qr(e) && dm.dependencies.add(e);
            let t = Sg(e);
            t && Ge(t, r => this.add(r))
        }
    },
    cN = class extends Pg {
        constructor(t) {
            super(t)
        }
        static create(t) {
            return new cN(t)
        }
        getValue() {
            return this.source.map(t => t.getValue())
        }
        setValue(t) {
            let r = this.getPayload();
            return t.length == r.length ? r.map((n, i) => n.setValue(t[i])).some(Boolean) : (super.setValue(t.map(Due)), !0)
        }
    };

function Due(e) {
    return (Eg(e) ? fu : Fu).create(e)
}

function W_(e) {
    let t = Gn(e);
    return t ? t.constructor : ne.arr(e) ? cN : Eg(e) ? fu : Fu
}
var _O = (e, t) => {
        let r = !ne.fun(e) || e.prototype && e.prototype.isReactComponent;
        return b.forwardRef((n, i) => {
            let s = b.useRef(null),
                o = r && b.useCallback(p => {
                    s.current = Fue(i, p)
                }, [i]),
                [a, l] = Lue(n, t),
                c = oN(),
                u = () => {
                    let p = s.current;
                    r && !p || (p ? t.applyAnimatedValues(p, a.getValue(!0)) : !1) === !1 && c()
                },
                h = new Nue(u, l),
                d = b.useRef();
            Qw(() => (d.current = h, Ge(l, p => Sl(p, h)), () => {
                d.current && (Ge(d.current.deps, p => hu(p, d.current)), Ae.cancel(d.current.update))
            })), b.useEffect(u, []), aN(() => () => {
                let p = d.current;
                Ge(p.deps, m => hu(m, p))
            });
            let f = t.getComponentProps(a.getValue());
            return b.createElement(e, { ...f,
                ref: o
            })
        })
    },
    Nue = class {
        constructor(e, t) {
            this.update = e, this.deps = t
        }
        eventObserved(e) {
            e.type == "change" && Ae.write(this.update)
        }
    };

function Lue(e, t) {
    let r = new Set;
    return dm.dependencies = r, e.style && (e = { ...e,
        style: t.createAnimatedStyle(e.style)
    }), e = new Pg(e), dm.dependencies = null, [e, r]
}

function Fue(e, t) {
    return e && (ne.fun(e) ? e(t) : e.current = t), t
}
var wO = Symbol.for("AnimatedComponent"),
    Bue = (e, {
        applyAnimatedValues: t = () => !1,
        createAnimatedStyle: r = i => new Pg(i),
        getComponentProps: n = i => i
    } = {}) => {
        let i = {
                applyAnimatedValues: t,
                createAnimatedStyle: r,
                getComponentProps: n
            },
            s = o => {
                let a = bO(o) || "Anonymous";
                return ne.str(o) ? o = s[o] || (s[o] = _O(o, i)) : o = o[wO] || (o[wO] = _O(o, i)), o.displayName = `Animated(${a})`, o
            };
        return oi(e, (o, a) => {
            ne.arr(e) && (a = bO(o)), s[a] = s(o)
        }), {
            animated: s
        }
    },
    bO = e => ne.str(e) ? e : e && ne.str(e.displayName) ? e.displayName : ne.fun(e) && e.name || null;

function Zs(e, ...t) {
    return ne.fun(e) ? e(...t) : e
}
var $c = (e, t) => e === !0 || !!(t && e && (ne.fun(e) ? e(t) : Lr(e).includes(t))),
    uN = (e, t) => ne.obj(e) ? t && e[t] : e,
    hN = (e, t) => e.default === !0 ? e[t] : e.default ? e.default[t] : void 0,
    zue = e => e,
    Jw = (e, t = zue) => {
        let r = jue;
        e.default && e.default !== !0 && (e = e.default, r = Object.keys(e));
        let n = {};
        for (let i of r) {
            let s = t(e[i], i);
            ne.und(s) || (n[i] = s)
        }
        return n
    },
    jue = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"],
    Uue = {
        config: 1,
        from: 1,
        to: 1,
        ref: 1,
        loop: 1,
        reset: 1,
        pause: 1,
        cancel: 1,
        reverse: 1,
        immediate: 1,
        default: 1,
        delay: 1,
        onProps: 1,
        onStart: 1,
        onChange: 1,
        onPause: 1,
        onResume: 1,
        onRest: 1,
        onResolve: 1,
        items: 1,
        trail: 1,
        sort: 1,
        expires: 1,
        initial: 1,
        enter: 1,
        update: 1,
        leave: 1,
        children: 1,
        onDestroyed: 1,
        keys: 1,
        callId: 1,
        parentId: 1
    };

function Hue(e) {
    let t = {},
        r = 0;
    if (oi(e, (n, i) => {
            Uue[i] || (t[i] = n, r++)
        }), r) return t
}

function dN(e) {
    let t = Hue(e);
    if (t) {
        let r = {
            to: t
        };
        return oi(e, (n, i) => i in t || (r[i] = n)), r
    }
    return { ...e
    }
}

function pu(e) {
    return e = xr(e), ne.arr(e) ? e.map(pu) : Eg(e) ? Dn.createStringInterpolator({
        range: [0, 1],
        output: [e, e]
    })(1) : e
}

function Gue(e) {
    for (let t in e) return !0;
    return !1
}

function X_(e) {
    return ne.fun(e) || ne.arr(e) && ne.obj(e[0])
}

function Vue(e, t) {
    var r;
    (r = e.ref) == null || r.delete(e), t == null || t.delete(e)
}

function Wue(e, t) {
    var r;
    t && e.ref !== t && ((r = e.ref) == null || r.delete(e), t.add(e), e.ref = t)
}
var Xue = {
        default: {
            tension: 170,
            friction: 26
        },
        gentle: {
            tension: 120,
            friction: 14
        },
        wobbly: {
            tension: 180,
            friction: 12
        },
        stiff: {
            tension: 210,
            friction: 20
        },
        slow: {
            tension: 280,
            friction: 60
        },
        molasses: {
            tension: 280,
            friction: 120
        }
    },
    Y_ = { ...Xue.default,
        mass: 1,
        damping: 1,
        easing: _ue.linear,
        clamp: !1
    },
    Yue = class {
        constructor() {
            oe(this, "tension");
            oe(this, "friction");
            oe(this, "frequency");
            oe(this, "damping");
            oe(this, "mass");
            oe(this, "velocity", 0);
            oe(this, "restVelocity");
            oe(this, "precision");
            oe(this, "progress");
            oe(this, "duration");
            oe(this, "easing");
            oe(this, "clamp");
            oe(this, "bounce");
            oe(this, "decay");
            oe(this, "round");
            Object.assign(this, Y_)
        }
    };

function Kue(e, t, r) {
    r && (r = { ...r
    }, xO(r, t), t = { ...r,
        ...t
    }), xO(e, t), Object.assign(e, t);
    for (let o in Y_) e[o] == null && (e[o] = Y_[o]);
    let {
        frequency: n,
        damping: i
    } = e, {
        mass: s
    } = e;
    return ne.und(n) || (n < .01 && (n = .01), i < 0 && (i = 0), e.tension = Math.pow(2 * Math.PI / n, 2) * s, e.friction = 4 * Math.PI * i * s / n), e
}

function xO(e, t) {
    if (!ne.und(t.decay)) e.duration = void 0;
    else {
        let r = !ne.und(t.tension) || !ne.und(t.friction);
        (r || !ne.und(t.frequency) || !ne.und(t.damping) || !ne.und(t.mass)) && (e.duration = void 0, e.decay = void 0), r && (e.frequency = void 0)
    }
}
var EO = [],
    que = class {
        constructor() {
            oe(this, "changed", !1);
            oe(this, "values", EO);
            oe(this, "toValues", null);
            oe(this, "fromValues", EO);
            oe(this, "to");
            oe(this, "from");
            oe(this, "config", new Yue);
            oe(this, "immediate", !1)
        }
    };

function fN(e, {
    key: t,
    props: r,
    defaultProps: n,
    state: i,
    actions: s
}) {
    return new Promise((o, a) => {
        let l, c, u = $c(r.cancel??(n == null ? void 0 : n.cancel), t);
        if (u) f();
        else {
            ne.und(r.pause) || (i.paused = $c(r.pause, t));
            let p = n == null ? void 0 : n.pause;
            p !== !0 && (p = i.paused || $c(p, t)), l = Zs(r.delay || 0, t), p ? (i.resumeQueue.add(d), s.pause()) : (s.resume(), d())
        }

        function h() {
            i.resumeQueue.add(d), i.timeouts.delete(c), c.cancel(), l = c.time - Ae.now()
        }

        function d() {
            l > 0 && !Dn.skipAnimation ? (i.delayed = !0, c = Ae.setTimeout(f, l), i.pauseQueue.add(h), i.timeouts.add(c)) : f()
        }

        function f() {
            i.delayed && (i.delayed = !1), i.pauseQueue.delete(h), i.timeouts.delete(c), e <= (i.cancelId || 0) && (u = !0);
            try {
                s.start({ ...r,
                    callId: e,
                    cancel: u
                }, o)
            } catch (p) {
                a(p)
            }
        }
    })
}
var eb = (e, t) => t.length == 1 ? t[0] : t.some(r => r.cancelled) ? Va(e.get()) : t.every(r => r.noop) ? pN(e.get()) : xn(e.get(), t.every(r => r.finished)),
    pN = e => ({
        value: e,
        noop: !0,
        finished: !0,
        cancelled: !1
    }),
    xn = (e, t, r = !1) => ({
        value: e,
        finished: t,
        cancelled: r
    }),
    Va = e => ({
        value: e,
        cancelled: !0,
        finished: !1
    });

function mN(e, t, r, n) {
    let {
        callId: i,
        parentId: s,
        onRest: o
    } = t, {
        asyncTo: a,
        promise: l
    } = r;
    return !s && e === a && !t.reset ? l : r.promise = (async () => {
        r.asyncId = i, r.asyncTo = e;
        let c = Jw(t, (w, y) => y === "onRest" ? void 0 : w),
            u, h, d = new Promise((w, y) => (u = w, h = y)),
            f = w => {
                let y = i <= (r.cancelId || 0) && Va(n) || i !== r.asyncId && xn(n, !1);
                if (y) throw w.result = y, h(w), w
            },
            p = (w, y) => {
                let v = new SO,
                    _ = new PO;
                return (async () => {
                    if (Dn.skipAnimation) throw mu(r), _.result = xn(n, !1), h(_), _;
                    f(v);
                    let E = ne.obj(w) ? { ...w
                    } : { ...y,
                        to: w
                    };
                    E.parentId = i, oi(c, (C, T) => {
                        ne.und(E[T]) && (E[T] = C)
                    });
                    let P = await n.start(E);
                    return f(v), r.paused && await new Promise(C => {
                        r.resumeQueue.add(C)
                    }), P
                })()
            },
            m;
        if (Dn.skipAnimation) return mu(r), xn(n, !1);
        try {
            let w;
            ne.arr(e) ? w = (async y => {
                for (let v of y) await p(v)
            })(e) : w = Promise.resolve(e(p, n.stop.bind(n))), await Promise.all([w.then(u), d]), m = xn(n.get(), !0, !1)
        } catch (w) {
            if (w instanceof SO) m = w.result;
            else if (w instanceof PO) m = w.result;
            else throw w
        } finally {
            i == r.asyncId && (r.asyncId = s, r.asyncTo = s ? a : void 0, r.promise = s ? l : void 0)
        }
        return ne.fun(o) && Ae.batchedUpdates(() => {
            o(m, n, n.item)
        }), m
    })()
}

function mu(e, t) {
    Ac(e.timeouts, r => r.cancel()), e.pauseQueue.clear(), e.resumeQueue.clear(), e.asyncId = e.asyncTo = e.promise = void 0, t && (e.cancelId = t)
}
var SO = class extends Error {
        constructor() {
            super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
            oe(this, "result")
        }
    },
    PO = class extends Error {
        constructor() {
            super("SkipAnimationSignal");
            oe(this, "result")
        }
    },
    K_ = e => e instanceof tb,
    Que = 1,
    tb = class extends tN {
        constructor() {
            super(...arguments);
            oe(this, "id", Que++);
            oe(this, "_priority", 0)
        }
        get priority() {
            return this._priority
        }
        set priority(t) {
            this._priority != t && (this._priority = t, this._onPriorityChange(t))
        }
        get() {
            let t = Gn(this);
            return t && t.getValue()
        }
        to(...t) {
            return Dn.to(this, t)
        }
        interpolate(...t) {
            return Tue(), Dn.to(this, t)
        }
        toJSON() {
            return this.get()
        }
        observerAdded(t) {
            t == 1 && this._attach()
        }
        observerRemoved(t) {
            t == 0 && this._detach()
        }
        _attach() {}
        _detach() {}
        _onChange(t, r = !1) {
            uu(this, {
                type: "change",
                parent: this,
                value: t,
                idle: r
            })
        }
        _onPriorityChange(t) {
            this.idle || wg.sort(this), uu(this, {
                type: "priority",
                parent: this,
                priority: t
            })
        }
    },
    xo = Symbol.for("SpringPhase"),
    gN = 1,
    q_ = 2,
    Q_ = 4,
    R0 = e => (e[xo] & gN) > 0,
    Yi = e => (e[xo] & q_) > 0,
    tc = e => (e[xo] & Q_) > 0,
    CO = (e, t) => t ? e[xo] |= q_ | gN : e[xo] &= ~q_,
    TO = (e, t) => t ? e[xo] |= Q_ : e[xo] &= ~Q_,
    Zue = class extends tb {
        constructor(t, r) {
            super();
            oe(this, "key");
            oe(this, "animation", new que);
            oe(this, "queue");
            oe(this, "defaultProps", {});
            oe(this, "_state", {
                paused: !1,
                delayed: !1,
                pauseQueue: new Set,
                resumeQueue: new Set,
                timeouts: new Set
            });
            oe(this, "_pendingCalls", new Set);
            oe(this, "_lastCallId", 0);
            oe(this, "_lastToId", 0);
            oe(this, "_memoizedDuration", 0);
            if (!ne.und(t) || !ne.und(r)) {
                let n = ne.obj(t) ? { ...t
                } : { ...r,
                    from: t
                };
                ne.und(n.default) && (n.default = !0), this.start(n)
            }
        }
        get idle() {
            return !(Yi(this) || this._state.asyncTo) || tc(this)
        }
        get goal() {
            return xr(this.animation.to)
        }
        get velocity() {
            let t = Gn(this);
            return t instanceof Fu ? t.lastVelocity || 0 : t.getPayload().map(r => r.lastVelocity || 0)
        }
        get hasAnimated() {
            return R0(this)
        }
        get isAnimating() {
            return Yi(this)
        }
        get isPaused() {
            return tc(this)
        }
        get isDelayed() {
            return this._state.delayed
        }
        advance(t) {
            let r = !0,
                n = !1,
                i = this.animation,
                {
                    toValues: s
                } = i,
                {
                    config: o
                } = i,
                a = Sg(i.to);
            !a && qr(i.to) && (s = Lr(xr(i.to))), i.values.forEach((u, h) => {
                if (u.done) return;
                let d = u.constructor == fu ? 1 : a ? a[h].lastPosition : s[h],
                    f = i.immediate,
                    p = d;
                if (!f) {
                    if (p = u.lastPosition, o.tension <= 0) {
                        u.done = !0;
                        return
                    }
                    let m = u.elapsedTime += t,
                        w = i.fromValues[h],
                        y = u.v0 != null ? u.v0 : u.v0 = ne.arr(o.velocity) ? o.velocity[h] : o.velocity,
                        v, _ = o.precision || (w == d ? .005 : Math.min(1, Math.abs(d - w) * .001));
                    if (ne.und(o.duration))
                        if (o.decay) {
                            let E = o.decay === !0 ? .998 : o.decay,
                                P = Math.exp(-(1 - E) * m);
                            p = w + y / (1 - E) * (1 - P), f = Math.abs(u.lastPosition - p) <= _, v = y * P
                        } else {
                            v = u.lastVelocity == null ? y : u.lastVelocity;
                            let E = o.restVelocity || _ / 10,
                                P = o.clamp ? 0 : o.bounce,
                                C = !ne.und(P),
                                T = w == d ? u.v0 > 0 : w < d,
                                O, k = !1,
                                D = 1,
                                B = Math.ceil(t / D);
                            for (let j = 0; j < B && (O = Math.abs(v) > E, !(!O && (f = Math.abs(d - p) <= _, f))); ++j) {
                                C && (k = p == d || p > d == T, k && (v = -v * P, p = d));
                                let L = -o.tension * 1e-6 * (p - d),
                                    M = -o.friction * .001 * v,
                                    W = (L + M) / o.mass;
                                v = v + W * D, p = p + v * D
                            }
                        }
                    else {
                        let E = 1;
                        o.duration > 0 && (this._memoizedDuration !== o.duration && (this._memoizedDuration = o.duration, u.durationProgress > 0 && (u.elapsedTime = o.duration * u.durationProgress, m = u.elapsedTime += t)), E = (o.progress || 0) + m / this._memoizedDuration, E = E > 1 ? 1 : E < 0 ? 0 : E, u.durationProgress = E), p = w + o.easing(E) * (d - w), v = (p - u.lastPosition) / t, f = E == 1
                    }
                    u.lastVelocity = v, Number.isNaN(p) && (console.warn("Got NaN while animating:", this), f = !0)
                }
                a && !a[h].done && (f = !1), f ? u.done = !0 : r = !1, u.setValue(p, o.round) && (n = !0)
            });
            let l = Gn(this),
                c = l.getValue();
            if (r) {
                let u = xr(i.to);
                (c !== u || n) && !o.decay ? (l.setValue(u), this._onChange(u)) : n && o.decay && this._onChange(c), this._stop()
            } else n && this._onChange(c)
        }
        set(t) {
            return Ae.batchedUpdates(() => {
                this._stop(), this._focus(t), this._set(t)
            }), this
        }
        pause() {
            this._update({
                pause: !0
            })
        }
        resume() {
            this._update({
                pause: !1
            })
        }
        finish() {
            if (Yi(this)) {
                let {
                    to: t,
                    config: r
                } = this.animation;
                Ae.batchedUpdates(() => {
                    this._onStart(), r.decay || this._set(t, !1), this._stop()
                })
            }
            return this
        }
        update(t) {
            return (this.queue || (this.queue = [])).push(t), this
        }
        start(t, r) {
            let n;
            return ne.und(t) ? (n = this.queue || [], this.queue = []) : n = [ne.obj(t) ? t : { ...r,
                to: t
            }], Promise.all(n.map(i => this._update(i))).then(i => eb(this, i))
        }
        stop(t) {
            let {
                to: r
            } = this.animation;
            return this._focus(this.get()), mu(this._state, t && this._lastCallId), Ae.batchedUpdates(() => this._stop(r, t)), this
        }
        reset() {
            this._update({
                reset: !0
            })
        }
        eventObserved(t) {
            t.type == "change" ? this._start() : t.type == "priority" && (this.priority = t.priority + 1)
        }
        _prepareNode(t) {
            let r = this.key || "",
                {
                    to: n,
                    from: i
                } = t;
            n = ne.obj(n) ? n[r] : n, (n == null || X_(n)) && (n = void 0), i = ne.obj(i) ? i[r] : i, i == null && (i = void 0);
            let s = {
                to: n,
                from: i
            };
            return R0(this) || (t.reverse && ([n, i] = [i, n]), i = xr(i), ne.und(i) ? Gn(this) || this._set(n) : this._set(i)), s
        }
        _update({ ...t
        }, r) {
            let {
                key: n,
                defaultProps: i
            } = this;
            t.default && Object.assign(i, Jw(t, (a, l) => /^on/.test(l) ? uN(a, n) : a)), AO(this, t, "onProps"), nc(this, "onProps", t, this);
            let s = this._prepareNode(t);
            if (Object.isFrozen(this)) throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
            let o = this._state;
            return fN(++this._lastCallId, {
                key: n,
                props: t,
                defaultProps: i,
                state: o,
                actions: {
                    pause: () => {
                        tc(this) || (TO(this, !0), pc(o.pauseQueue), nc(this, "onPause", xn(this, rc(this, this.animation.to)), this))
                    },
                    resume: () => {
                        tc(this) && (TO(this, !1), Yi(this) && this._resume(), pc(o.resumeQueue), nc(this, "onResume", xn(this, rc(this, this.animation.to)), this))
                    },
                    start: this._merge.bind(this, s)
                }
            }).then(a => {
                if (t.loop && a.finished && !(r && a.noop)) {
                    let l = vN(t);
                    if (l) return this._update(l, !0)
                }
                return a
            })
        }
        _merge(t, r, n) {
            if (r.cancel) return this.stop(!0), n(Va(this));
            let i = !ne.und(t.to),
                s = !ne.und(t.from);
            if (i || s)
                if (r.callId > this._lastToId) this._lastToId = r.callId;
                else return n(Va(this));
            let {
                key: o,
                defaultProps: a,
                animation: l
            } = this, {
                to: c,
                from: u
            } = l, {
                to: h = c,
                from: d = u
            } = t;
            s && !i && (!r.default || ne.und(h)) && (h = d), r.reverse && ([h, d] = [d, h]);
            let f = !gi(d, u);
            f && (l.from = d), d = xr(d);
            let p = !gi(h, c);
            p && this._focus(h);
            let m = X_(r.to),
                {
                    config: w
                } = l,
                {
                    decay: y,
                    velocity: v
                } = w;
            (i || s) && (w.velocity = 0), r.config && !m && Kue(w, Zs(r.config, o), r.config !== a.config ? Zs(a.config, o) : void 0);
            let _ = Gn(this);
            if (!_ || ne.und(h)) return n(xn(this, !0));
            let E = ne.und(r.reset) ? s && !r.default : !ne.und(d) && $c(r.reset, o),
                P = E ? d : this.get(),
                C = pu(h),
                T = ne.num(C) || ne.arr(C) || Eg(C),
                O = !m && (!T || $c(a.immediate || r.immediate, o));
            if (p) {
                let j = W_(h);
                if (j !== _.constructor)
                    if (O) _ = this._set(C);
                    else throw Error(`Cannot animate between ${_.constructor.name} and ${j.name}, as the "to" prop suggests`)
            }
            let k = _.constructor,
                D = qr(h),
                B = !1;
            if (!D) {
                let j = E || !R0(this) && f;
                (p || j) && (B = gi(pu(P), C), D = !B), (!gi(l.immediate, O) && !O || !gi(w.decay, y) || !gi(w.velocity, v)) && (D = !0)
            }
            if (B && Yi(this) && (l.changed && !E ? D = !0 : D || this._stop(c)), !m && ((D || qr(c)) && (l.values = _.getPayload(), l.toValues = qr(h) ? null : k == fu ? [1] : Lr(C)), l.immediate != O && (l.immediate = O, !O && !E && this._set(c)), D)) {
                let {
                    onRest: j
                } = l;
                Ge(ehe, M => AO(this, r, M));
                let L = xn(this, rc(this, c));
                pc(this._pendingCalls, L), this._pendingCalls.add(n), l.changed && Ae.batchedUpdates(() => {
                    var M;
                    l.changed = !E, j == null || j(L, this), E ? Zs(a.onRest, L) : (M = l.onStart) == null || M.call(l, L, this)
                })
            }
            E && this._set(P), m ? n(mN(r.to, r, this._state, this)) : D ? this._start() : Yi(this) && !p ? this._pendingCalls.add(n) : n(pN(P))
        }
        _focus(t) {
            let r = this.animation;
            t !== r.to && (gO(this) && this._detach(), r.to = t, gO(this) && this._attach())
        }
        _attach() {
            let t = 0,
                {
                    to: r
                } = this.animation;
            qr(r) && (Sl(r, this), K_(r) && (t = r.priority + 1)), this.priority = t
        }
        _detach() {
            let {
                to: t
            } = this.animation;
            qr(t) && hu(t, this)
        }
        _set(t, r = !0) {
            let n = xr(t);
            if (!ne.und(n)) {
                let i = Gn(this);
                if (!i || !gi(n, i.getValue())) {
                    let s = W_(n);
                    !i || i.constructor != s ? Zw(this, s.create(n)) : i.setValue(n), i && Ae.batchedUpdates(() => {
                        this._onChange(n, r)
                    })
                }
            }
            return Gn(this)
        }
        _onStart() {
            let t = this.animation;
            t.changed || (t.changed = !0, nc(this, "onStart", xn(this, rc(this, t.to)), this))
        }
        _onChange(t, r) {
            r || (this._onStart(), Zs(this.animation.onChange, t, this)), Zs(this.defaultProps.onChange, t, this), super._onChange(t, r)
        }
        _start() {
            let t = this.animation;
            Gn(this).reset(xr(t.to)), t.immediate || (t.fromValues = t.values.map(r => r.lastPosition)), Yi(this) || (CO(this, !0), tc(this) || this._resume())
        }
        _resume() {
            Dn.skipAnimation ? this.finish() : wg.start(this)
        }
        _stop(t, r) {
            if (Yi(this)) {
                CO(this, !1);
                let n = this.animation;
                Ge(n.values, s => {
                    s.done = !0
                }), n.toValues && (n.onChange = n.onPause = n.onResume = void 0), uu(this, {
                    type: "idle",
                    parent: this
                });
                let i = r ? Va(this.get()) : xn(this.get(), rc(this, t??n.to));
                pc(this._pendingCalls, i), n.changed && (n.changed = !1, nc(this, "onRest", i, this))
            }
        }
    };

function rc(e, t) {
    let r = pu(t),
        n = pu(e.get());
    return gi(n, r)
}

function vN(e, t = e.loop, r = e.to) {
    let n = Zs(t);
    if (n) {
        let i = n !== !0 && dN(n),
            s = (i || e).reverse,
            o = !i || i.reset;
        return gu({ ...e,
            loop: t,
            default: !1,
            pause: void 0,
            to: !s || X_(r) ? r : void 0,
            from: o ? e.from : void 0,
            reset: o,
            ...i
        })
    }
}

function gu(e) {
    let {
        to: t,
        from: r
    } = e = dN(e), n = new Set;
    return ne.obj(t) && OO(t, n), ne.obj(r) && OO(r, n), e.keys = n.size ? Array.from(n) : null, e
}

function Jue(e) {
    let t = gu(e);
    return ne.und(t.default) && (t.default = Jw(t)), t
}

function OO(e, t) {
    oi(e, (r, n) => r != null && t.add(n))
}
var ehe = ["onStart", "onRest", "onChange", "onPause", "onResume"];

function AO(e, t, r) {
    e.animation[r] = t[r] !== hN(t, r) ? uN(t[r], e.key) : void 0
}

function nc(e, t, ...r) {
    var n, i, s, o;
    (i = (n = e.animation)[t]) == null || i.call(n, ...r), (o = (s = e.defaultProps)[t]) == null || o.call(s, ...r)
}
var the = ["onStart", "onChange", "onRest"],
    rhe = 1,
    nhe = class {
        constructor(e, t) {
            oe(this, "id", rhe++);
            oe(this, "springs", {});
            oe(this, "queue", []);
            oe(this, "ref");
            oe(this, "_flush");
            oe(this, "_initialProps");
            oe(this, "_lastAsyncId", 0);
            oe(this, "_active", new Set);
            oe(this, "_changed", new Set);
            oe(this, "_started", !1);
            oe(this, "_item");
            oe(this, "_state", {
                paused: !1,
                pauseQueue: new Set,
                resumeQueue: new Set,
                timeouts: new Set
            });
            oe(this, "_events", {
                onStart: new Map,
                onChange: new Map,
                onRest: new Map
            });
            this._onFrame = this._onFrame.bind(this), t && (this._flush = t), e && this.start({
                default: !0,
                ...e
            })
        }
        get idle() {
            return !this._state.asyncTo && Object.values(this.springs).every(e => e.idle && !e.isDelayed && !e.isPaused)
        }
        get item() {
            return this._item
        }
        set item(e) {
            this._item = e
        }
        get() {
            let e = {};
            return this.each((t, r) => e[r] = t.get()), e
        }
        set(e) {
            for (let t in e) {
                let r = e[t];
                ne.und(r) || this.springs[t].set(r)
            }
        }
        update(e) {
            return e && this.queue.push(gu(e)), this
        }
        start(e) {
            let {
                queue: t
            } = this;
            return e ? t = Lr(e).map(gu) : this.queue = [], this._flush ? this._flush(this, t) : (xN(this, t), Z_(this, t))
        }
        stop(e, t) {
            if (e !== !!e && (t = e), t) {
                let r = this.springs;
                Ge(Lr(t), n => r[n].stop(!!e))
            } else mu(this._state, this._lastAsyncId), this.each(r => r.stop(!!e));
            return this
        }
        pause(e) {
            if (ne.und(e)) this.start({
                pause: !0
            });
            else {
                let t = this.springs;
                Ge(Lr(e), r => t[r].pause())
            }
            return this
        }
        resume(e) {
            if (ne.und(e)) this.start({
                pause: !1
            });
            else {
                let t = this.springs;
                Ge(Lr(e), r => t[r].resume())
            }
            return this
        }
        each(e) {
            oi(this.springs, e)
        }
        _onFrame() {
            let {
                onStart: e,
                onChange: t,
                onRest: r
            } = this._events, n = this._active.size > 0, i = this._changed.size > 0;
            (n && !this._started || i && !this._started) && (this._started = !0, Ac(e, ([a, l]) => {
                l.value = this.get(), a(l, this, this._item)
            }));
            let s = !n && this._started,
                o = i || s && r.size ? this.get() : null;
            i && t.size && Ac(t, ([a, l]) => {
                l.value = o, a(l, this, this._item)
            }), s && (this._started = !1, Ac(r, ([a, l]) => {
                l.value = o, a(l, this, this._item)
            }))
        }
        eventObserved(e) {
            if (e.type == "change") this._changed.add(e.parent), e.idle || this._active.add(e.parent);
            else if (e.type == "idle") this._active.delete(e.parent);
            else return;
            Ae.onFrame(this._onFrame)
        }
    };

function Z_(e, t) {
    return Promise.all(t.map(r => yN(e, r))).then(r => eb(e, r))
}
async function yN(e, t, r) {
    let {
        keys: n,
        to: i,
        from: s,
        loop: o,
        onRest: a,
        onResolve: l
    } = t, c = ne.obj(t.default) && t.default;
    o && (t.loop = !1), i === !1 && (t.to = null), s === !1 && (t.from = null);
    let u = ne.arr(i) || ne.fun(i) ? i : void 0;
    u ? (t.to = void 0, t.onRest = void 0, c && (c.onRest = void 0)) : Ge(the, m => {
        let w = t[m];
        if (ne.fun(w)) {
            let y = e._events[m];
            t[m] = ({
                finished: v,
                cancelled: _
            }) => {
                let E = y.get(w);
                E ? (v || (E.finished = !1), _ && (E.cancelled = !0)) : y.set(w, {
                    value: null,
                    finished: v || !1,
                    cancelled: _ || !1
                })
            }, c && (c[m] = t[m])
        }
    });
    let h = e._state;
    t.pause === !h.paused ? (h.paused = t.pause, pc(t.pause ? h.pauseQueue : h.resumeQueue)) : h.paused && (t.pause = !0);
    let d = (n || Object.keys(e.springs)).map(m => e.springs[m].start(t)),
        f = t.cancel === !0 || hN(t, "cancel") === !0;
    (u || f && h.asyncId) && d.push(fN(++e._lastAsyncId, {
        props: t,
        state: h,
        actions: {
            pause: G_,
            resume: G_,
            start(m, w) {
                f ? (mu(h, e._lastAsyncId), w(Va(e))) : (m.onRest = a, w(mN(u, m, h, e)))
            }
        }
    })), h.paused && await new Promise(m => {
        h.resumeQueue.add(m)
    });
    let p = eb(e, await Promise.all(d));
    if (o && p.finished && !(r && p.noop)) {
        let m = vN(t, o, i);
        if (m) return xN(e, [m]), yN(e, m, !0)
    }
    return l && Ae.batchedUpdates(() => l(p, e, e.item)), p
}

function IO(e, t) {
    let r = { ...e.springs
    };
    return t && Ge(Lr(t), n => {
        ne.und(n.keys) && (n = gu(n)), ne.obj(n.to) || (n = { ...n,
            to: void 0
        }), bN(r, n, i => wN(i))
    }), _N(e, r), r
}

function _N(e, t) {
    oi(t, (r, n) => {
        e.springs[n] || (e.springs[n] = r, Sl(r, e))
    })
}

function wN(e, t) {
    let r = new Zue;
    return r.key = e, t && Sl(r, t), r
}

function bN(e, t, r) {
    t.keys && Ge(t.keys, n => {
        (e[n] || (e[n] = r(n)))._prepareNode(t)
    })
}

function xN(e, t) {
    Ge(t, r => {
        bN(e.springs, r, n => wN(n, e))
    })
}
var Cg = ({
        children: e,
        ...t
    }) => {
        let r = b.useContext(fm),
            n = t.pause || !!r.pause,
            i = t.immediate || !!r.immediate;
        t = $ue(() => ({
            pause: n,
            immediate: i
        }), [n, i]);
        let {
            Provider: s
        } = fm;
        return b.createElement(s, {
            value: t
        }, e)
    },
    fm = ihe(Cg, {});
Cg.Provider = fm.Provider;
Cg.Consumer = fm.Consumer;

function ihe(e, t) {
    return Object.assign(e, b.createContext(t)), e.Provider._context = e, e.Consumer._context = e, e
}
var she = () => {
    let e = [],
        t = function(n) {
            Aue();
            let i = [];
            return Ge(e, (s, o) => {
                if (ne.und(n)) i.push(s.start());
                else {
                    let a = r(n, s, o);
                    a && i.push(s.start(a))
                }
            }), i
        };
    t.current = e, t.add = function(n) {
        e.includes(n) || e.push(n)
    }, t.delete = function(n) {
        let i = e.indexOf(n);
        ~i && e.splice(i, 1)
    }, t.pause = function() {
        return Ge(e, n => n.pause(...arguments)), this
    }, t.resume = function() {
        return Ge(e, n => n.resume(...arguments)), this
    }, t.set = function(n) {
        Ge(e, (i, s) => {
            let o = ne.fun(n) ? n(s, i) : n;
            o && i.set(o)
        })
    }, t.start = function(n) {
        let i = [];
        return Ge(e, (s, o) => {
            if (ne.und(n)) i.push(s.start());
            else {
                let a = this._getProps(n, s, o);
                a && i.push(s.start(a))
            }
        }), i
    }, t.stop = function() {
        return Ge(e, n => n.stop(...arguments)), this
    }, t.update = function(n) {
        return Ge(e, (i, s) => i.update(this._getProps(n, i, s))), this
    };
    let r = function(n, i, s) {
        return ne.fun(n) ? n(s, i) : n
    };
    return t._getProps = r, t
};

function ohe(e, t, r) {
    let n = ne.fun(t) && t;
    n && !r && (r = []);
    let i = b.useMemo(() => n || arguments.length == 3 ? she() : void 0, []),
        s = b.useRef(0),
        o = oN(),
        a = b.useMemo(() => ({
            ctrls: [],
            queue: [],
            flush(y, v) {
                let _ = IO(y, v);
                return s.current > 0 && !a.queue.length && !Object.keys(_).some(E => !y.springs[E]) ? Z_(y, v) : new Promise(E => {
                    _N(y, _), a.queue.push(() => {
                        E(Z_(y, v))
                    }), o()
                })
            }
        }), []),
        l = b.useRef([...a.ctrls]),
        c = [],
        u = yO(e) || 0;
    b.useMemo(() => {
        Ge(l.current.slice(e, u), y => {
            Vue(y, i), y.stop(!0)
        }), l.current.length = e, h(u, e)
    }, [e]), b.useMemo(() => {
        h(0, Math.min(u, e))
    }, r);

    function h(y, v) {
        for (let _ = y; _ < v; _++) {
            let E = l.current[_] || (l.current[_] = new nhe(null, a.flush)),
                P = n ? n(_, E) : t[_];
            P && (c[_] = Jue(P))
        }
    }
    let d = l.current.map((y, v) => IO(y, c[v])),
        f = b.useContext(Cg),
        p = yO(f),
        m = f !== p && Gue(f);
    Qw(() => {
        s.current++, a.ctrls = l.current;
        let {
            queue: y
        } = a;
        y.length && (a.queue = [], Ge(y, v => v())), Ge(l.current, (v, _) => {
            i == null || i.add(v), m && v.start({
                default: f
            });
            let E = c[_];
            E && (Wue(v, E.ref), v.ref ? v.queue.push(E) : v.start(E))
        })
    }), aN(() => () => {
        Ge(a.ctrls, y => y.stop(!0))
    });
    let w = d.map(y => ({ ...y
    }));
    return i ? [w, i] : w
}

function ahe(e, t) {
    let r = ne.fun(e),
        [
            [n], i
        ] = ohe(1, r ? e : [e], r ? t || [] : t);
    return r || arguments.length == 2 ? [n, i] : n
}
var lhe = class extends tb {
    constructor(t, r) {
        super();
        oe(this, "key");
        oe(this, "idle", !0);
        oe(this, "calc");
        oe(this, "_active", new Set);
        this.source = t, this.calc = cu(...r);
        let n = this._get(),
            i = W_(n);
        Zw(this, i.create(n))
    }
    advance(t) {
        let r = this._get(),
            n = this.get();
        gi(r, n) || (Gn(this).setValue(r), this._onChange(r, this.idle)), !this.idle && $O(this._active) && k0(this)
    }
    _get() {
        let t = ne.arr(this.source) ? this.source.map(xr) : Lr(xr(this.source));
        return this.calc(...t)
    }
    _start() {
        this.idle && !$O(this._active) && (this.idle = !1, Ge(Sg(this), t => {
            t.done = !1
        }), Dn.skipAnimation ? (Ae.batchedUpdates(() => this.advance()), k0(this)) : wg.start(this))
    }
    _attach() {
        let t = 1;
        Ge(Lr(this.source), r => {
            qr(r) && Sl(r, this), K_(r) && (r.idle || this._active.add(r), t = Math.max(t, r.priority + 1))
        }), this.priority = t, this._start()
    }
    _detach() {
        Ge(Lr(this.source), t => {
            qr(t) && hu(t, this)
        }), this._active.clear(), k0(this)
    }
    eventObserved(t) {
        t.type == "change" ? t.idle ? this.advance() : (this._active.add(t.parent), this._start()) : t.type == "idle" ? this._active.delete(t.parent) : t.type == "priority" && (this.priority = Lr(this.source).reduce((r, n) => Math.max(r, (K_(n) ? n.priority : 0) + 1), 0))
    }
};

function che(e) {
    return e.idle !== !1
}

function $O(e) {
    return !e.size || Array.from(e).every(che)
}

function k0(e) {
    e.idle || (e.idle = !0, Ge(Sg(e), t => {
        t.done = !0
    }), uu(e, {
        type: "idle",
        parent: e
    }))
}
Dn.assign({
    createStringInterpolator: iN,
    to: (e, t) => new lhe(e, t)
});
var EN = /^--/;

function uhe(e, t) {
    return t == null || typeof t == "boolean" || t === "" ? "" : typeof t == "number" && t !== 0 && !EN.test(e) && !(Rc.hasOwnProperty(e) && Rc[e]) ? t + "px" : ("" + t).trim()
}
var RO = {};

function hhe(e, t) {
    if (!e.nodeType || !e.setAttribute) return !1;
    let r = e.nodeName === "filter" || e.parentNode && e.parentNode.nodeName === "filter",
        {
            style: n,
            children: i,
            scrollTop: s,
            scrollLeft: o,
            viewBox: a,
            ...l
        } = t,
        c = Object.values(l),
        u = Object.keys(l).map(h => r || e.hasAttribute(h) ? h : RO[h] || (RO[h] = h.replace(/([A-Z])/g, d => "-" + d.toLowerCase())));
    i !== void 0 && (e.textContent = i);
    for (let h in n)
        if (n.hasOwnProperty(h)) {
            let d = uhe(h, n[h]);
            EN.test(h) ? e.style.setProperty(h, d) : e.style[h] = d
        }
    u.forEach((h, d) => {
        e.setAttribute(h, c[d])
    }), s !== void 0 && (e.scrollTop = s), o !== void 0 && (e.scrollLeft = o), a !== void 0 && e.setAttribute("viewBox", a)
}
var Rc = {
        animationIterationCount: !0,
        borderImageOutset: !0,
        borderImageSlice: !0,
        borderImageWidth: !0,
        boxFlex: !0,
        boxFlexGroup: !0,
        boxOrdinalGroup: !0,
        columnCount: !0,
        columns: !0,
        flex: !0,
        flexGrow: !0,
        flexPositive: !0,
        flexShrink: !0,
        flexNegative: !0,
        flexOrder: !0,
        gridRow: !0,
        gridRowEnd: !0,
        gridRowSpan: !0,
        gridRowStart: !0,
        gridColumn: !0,
        gridColumnEnd: !0,
        gridColumnSpan: !0,
        gridColumnStart: !0,
        fontWeight: !0,
        lineClamp: !0,
        lineHeight: !0,
        opacity: !0,
        order: !0,
        orphans: !0,
        tabSize: !0,
        widows: !0,
        zIndex: !0,
        zoom: !0,
        fillOpacity: !0,
        floodOpacity: !0,
        stopOpacity: !0,
        strokeDasharray: !0,
        strokeDashoffset: !0,
        strokeMiterlimit: !0,
        strokeOpacity: !0,
        strokeWidth: !0
    },
    dhe = (e, t) => e + t.charAt(0).toUpperCase() + t.substring(1),
    fhe = ["Webkit", "Ms", "Moz", "O"];
Rc = Object.keys(Rc).reduce((e, t) => (fhe.forEach(r => e[dhe(r, t)] = e[t]), e), Rc);
var phe = /^(matrix|translate|scale|rotate|skew)/,
    mhe = /^(translate)/,
    ghe = /^(rotate|skew)/,
    M0 = (e, t) => ne.num(e) && e !== 0 ? e + t : e,
    Ud = (e, t) => ne.arr(e) ? e.every(r => Ud(r, t)) : ne.num(e) ? e === t : parseFloat(e) === t,
    vhe = class extends Pg {
        constructor({
            x: e,
            y: t,
            z: r,
            ...n
        }) {
            let i = [],
                s = [];
            (e || t || r) && (i.push([e || 0, t || 0, r || 0]), s.push(o => [`translate3d(${o.map(a=>M0(a,"px")).join(",")})`, Ud(o, 0)])), oi(n, (o, a) => {
                if (a === "transform") i.push([o || ""]), s.push(l => [l, l === ""]);
                else if (phe.test(a)) {
                    if (delete n[a], ne.und(o)) return;
                    let l = mhe.test(a) ? "px" : ghe.test(a) ? "deg" : "";
                    i.push(Lr(o)), s.push(a === "rotate3d" ? ([c, u, h, d]) => [`rotate3d(${c},${u},${h},${M0(d,l)})`, Ud(d, 0)] : c => [`${a}(${c.map(u=>M0(u,l)).join(",")})`, Ud(c, a.startsWith("scale") ? 1 : 0)])
                }
            }), i.length && (n.transform = new yhe(i, s)), super(n)
        }
    },
    yhe = class extends tN {
        constructor(t, r) {
            super();
            oe(this, "_value", null);
            this.inputs = t, this.transforms = r
        }
        get() {
            return this._value || (this._value = this._get())
        }
        _get() {
            let t = "",
                r = !0;
            return Ge(this.inputs, (n, i) => {
                let s = xr(n[0]),
                    [o, a] = this.transforms[i](ne.arr(s) ? s : n.map(xr));
                t += " " + o, r = r && a
            }), r ? "none" : t
        }
        observerAdded(t) {
            t == 1 && Ge(this.inputs, r => Ge(r, n => qr(n) && Sl(n, this)))
        }
        observerRemoved(t) {
            t == 0 && Ge(this.inputs, r => Ge(r, n => qr(n) && hu(n, this)))
        }
        eventObserved(t) {
            t.type == "change" && (this._value = null), uu(this, t)
        }
    },
    _he = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
Dn.assign({
    batchedUpdates: Ci.unstable_batchedUpdates,
    createStringInterpolator: iN,
    colors: oue
});
var whe = Bue(_he, {
        applyAnimatedValues: hhe,
        createAnimatedStyle: e => new vhe(e),
        getComponentProps: ({
            scrollTop: e,
            scrollLeft: t,
            ...r
        }) => r
    }),
    kO = whe.animated;
const bhe = b.forwardRef(function(t, r) {
    const [n, {
        open: i,
        close: s
    }] = cg(!1), {
        gerberApp: o,
        uid: a
    } = t, [l, c] = b.useState(!0), [u, h] = b.useState(!1), [d, f] = b.useState(void 0);
    return b.useEffect(() => {
        n && !u && (o.renderer.then(async p => {
            const m = await p.computeLayerFeaturesHistogram(a);
            f(m), console.log(m)
        }), h(!0), c(!1))
    }, [n]), b.useImperativeHandle(r, () => ({
        open: i,
        close: s
    }), []), V.jsx(V.Fragment, {
        children: V.jsx(Ln, {
            title: "Feature Histogram",
            opened: n,
            onClose: s,
            children: l || d == null ? V.jsx(CM, {
                w: "100%",
                h: "100%",
                mx: "auto",
                children: V.jsx(Ao, {})
            }) : V.jsxs(oD, {
                highlightOnHover: !0,
                withBorder: !0,
                children: [V.jsx("thead", {
                    children: V.jsxs("tr", {
                        children: [V.jsx("th", {
                            children: "dcode"
                        }), V.jsx("th", {
                            children: "qty"
                        }), V.jsx("th", {
                            children: "polarity"
                        })]
                    })
                }), V.jsx("tbody", {
                    children: d.map(p => V.jsxs("tr", {
                        children: [V.jsx("td", {
                            children: p.dcode??"contour"
                        }), V.jsx("td", {
                            children: p.indexes.length
                        }), V.jsx("td", {
                            children: p.polarity
                        })]
                    }, p.dcode))
                })]
            })
        })
    })
});
var xhe = Pe(e => ({
    root: {
        height: 1,
        background: e.colorScheme === "dark" ? e.colors.dark[5] : e.colors.gray[1]
    }
}));

function Ehe({
    className: e,
    sx: t,
    style: r
}) {
    let {
        cx: n,
        classes: i
    } = xhe();
    return V.jsx(Ie, {
        className: n(i.root, e),
        sx: t,
        style: r
    })
}
var She = Pe((e, {
    color: t
}) => {
    let r = VR(e.spacing.sm) / 2;
    return {
        root: {
            width: "100%",
            display: "flex",
            alignItems: "center",
            paddingTop: r,
            paddingBottom: r,
            paddingLeft: e.spacing.sm,
            paddingRight: e.spacing.sm,
            color: t && e.colors[t][6],
            transition: "background .15s ease",
            "&[disabled]": {
                cursor: "not-allowed",
                color: e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[5]
            },
            "&:hover:not([disabled])": {
                background: e.fn.rgba(t ? e.colors[t][6] : e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[4], t ? e.colorScheme === "dark" ? .15 : .08 : .25)
            },
            "&:active:not([disabled])": {
                background: e.fn.rgba(t ? e.colors[t][6] : e.colorScheme === "dark" ? e.colors.dark[3] : e.colors.gray[4], t ? e.colorScheme === "dark" ? .3 : .2 : .5)
            }
        },
        icon: {
            fontSize: 0,
            marginRight: e.spacing.xs
        },
        title: {
            whiteSpace: "nowrap"
        }
    }
});

function Phe({
    className: e,
    style: t,
    icon: r,
    title: n,
    color: i,
    disabled: s,
    onClick: o
}) {
    let {
        cx: a,
        classes: l
    } = She({
        color: i
    });
    return V.jsxs(hg, {
        className: a(l.root, e),
        style: t,
        disabled: s,
        onClick: o,
        children: [r && V.jsx(Ie, {
            className: l.icon,
            children: r
        }), V.jsx(ir, {
            className: l.title,
            size: "sm",
            children: n
        })]
    })
}

function Che(e) {
    let t = e.replace(/([a-z\d])([A-Z]+)/g, "$1 $2").replace(/\W|_/g, " ").trim().toLowerCase();
    return `${t.charAt(0).toUpperCase()}${t.slice(1)}`
}
var MO = {},
    The = Pe(e => ({
        root: {
            position: "fixed",
            border: `1px solid ${e.colorScheme==="dark"?e.colors.dark[4]:e.colors.gray[3]}`,
            overflow: "hidden",
            transition: "all .15s ease"
        }
    }));

function Ohe({
    x: e,
    y: t,
    content: r,
    zIndex: n,
    shadow: i,
    borderRadius: s,
    onHide: o,
    className: a,
    style: l,
    sx: c,
    classNames: u,
    styles: h
}) {
    ou("resize", o), ou("scroll", o);
    let d = XR(o),
        {
            ref: f,
            width: p,
            height: m
        } = fX(),
        w = Oo(d, f),
        y = 0,
        v = 0;
    typeof window < "u" && ({
        innerWidth: y,
        innerHeight: v
    } = window);
    let _ = B => j => {
            o(), B(j)
        },
        {
            cx: E,
            classes: P,
            theme: C
        } = The(),
        {
            dir: T,
            spacing: O
        } = C,
        k = typeof h == "function" ? h(C, MO, MO) : h,
        D = VR(O.md);
    return V.jsx($w, {
        ref: w,
        shadow: i,
        radius: s,
        className: E(P.root, a, u == null ? void 0 : u.root),
        style: { ...k == null ? void 0 : k.root,
            ...l
        },
        sx: [{
            zIndex: n,
            top: t + m + D > v ? v - m - D : t,
            left: T === "ltr" ? e + p + D > y ? y - p - D : e : y - D - (e - p - D < 0 ? p + D : e)
        }, ...Wm(c)],
        children: Array.isArray(r) ? r.map(({
            key: B,
            className: j,
            sx: L,
            style: M,
            onClick: W,
            title: Z,
            ...q
        }) => W ? V.jsx(Phe, {
            className: E(u == null ? void 0 : u.item, j),
            sx: L,
            style: { ...k == null ? void 0 : k.item,
                ...M
            },
            title: Z??Che(B),
            onClick: _(W),
            ...q
        }, B) : V.jsx(Ehe, {
            className: E(u == null ? void 0 : u.divider, j),
            sx: L,
            style: { ...k == null ? void 0 : k.divider,
                ...M
            }
        }, B)) : r(o)
    })
}
var SN = b.createContext(() => () => {});

function Ahe({
    zIndex: e = 9999,
    shadow: t = "sm",
    borderRadius: r = "xs",
    children: n
}) {
    let [i, s] = b.useState(null), o = () => {
        s(null)
    }, a = (l, c) => u => {
        u.preventDefault(), u.stopPropagation(), s({
            x: u.clientX,
            y: u.clientY,
            content: l,
            zIndex: (c == null ? void 0 : c.zIndex) || e,
            shadow: (c == null ? void 0 : c.shadow) || t,
            borderRadius: (c == null ? void 0 : c.borderRadius) || r,
            className: c == null ? void 0 : c.className,
            style: c == null ? void 0 : c.style,
            sx: c == null ? void 0 : c.sx,
            classNames: c == null ? void 0 : c.classNames,
            styles: c == null ? void 0 : c.styles
        })
    };
    return V.jsxs(SN.Provider, {
        value: a,
        children: [n, i && V.jsx(Ohe, {
            onHide: o,
            ...i
        })]
    })
}

function Ihe() {
    return b.useContext(SN)
}

function $he(e) {
    const t = Ihe(),
        r = yr(),
        {
            gerberApp: n,
            file: i,
            actions: s
        } = e,
        o = {
            name: i.name,
            uid: i.uid
        },
        [{
            width: a
        }, l] = ahe(() => ({
            x: 0,
            y: 0,
            width: 0
        })),
        [c, u] = b.useState(0),
        [h, d] = b.useState(!1),
        [f, p] = b.useState(!0),
        [m, w] = b.useState(!1),
        y = b.useRef(null);

    function v(k) {
        const D = k.find(B => B.uid === o.uid);
        D && (u(D.color), d(D.visible), p(!1))
    }
    b.useEffect(() => (n.renderer.then(async k => {
        const D = await k.layers;
        if (v(D), k.addViewportListener("childAdded", fR(async () => {
                v(await k.layers), n.zoomHome()
            })), D.find(j => j.uid === o.uid)) {
            console.log("layer already exists"), p(!1);
            return
        }
        const B = new FileReader;
        B.onerror = j => {
            console.log(j, `${i.name} Error reading file.`), ws.show({
                title: "Error reading file",
                message: `${i.name} Error reading file.`,
                color: "red",
                autoClose: 5e3
            })
        }, B.onabort = j => {
            console.log(j, `${i.name} File read aborted.`), ws.show({
                title: "File read aborted",
                message: `${i.name} File read aborted.`,
                color: "red",
                autoClose: 5e3
            })
        }, B.onprogress = j => {
            const L = Math.round(j.loaded / j.total * 100);
            console.log(`${i.name} ${L}% read`)
        }, B.onload = async j => {
            var L, M, W;
            ((L = j.target) == null ? void 0 : L.result) !== null && ((M = j.target) == null ? void 0 : M.result) !== void 0 && (await k.addGerber(i.name, (W = j.target) == null ? void 0 : W.result, i.uid), ws.show({
                title: "File read",
                message: `${i.name} file read.`,
                color: "green",
                autoClose: 5e3
            }))
        }, B.readAsText(i)
    }), () => {}), []);

    function _() {
        s.remove(i)
    }
    async function E(k) {
        const D = await n.renderer;
        D && (await D.tintLayer(o.uid, k), u(k))
    }
    async function P() {
        const k = await n.renderer;
        k && (h ? (k.hideLayer(o.uid), d(!1)) : (k.showLayer(o.uid), d(!0)))
    }
    let C = 0;
    const T = Qce({
            onDrag: ({
                down: k,
                offset: [D, B],
                event: j
            }) => {
                j.stopPropagation(), k ? (l.start({
                    x: D,
                    y: B,
                    width: -D
                }), C = D) : l.start({
                    x: C < -20 ? -40 : 0,
                    y: 0,
                    width: C < -20 ? 40 : 0
                })
            },
            onWheel: ({
                offset: [k, D]
            }) => {
                l.start({
                    x: -k,
                    y: D,
                    width: k
                })
            }
        }, {
            drag: {
                axis: "x",
                bounds: {
                    left: -40,
                    right: 1,
                    top: 0,
                    bottom: 0
                },
                filterTaps: !0
            },
            wheel: {
                axis: "x",
                bounds: {
                    left: 0,
                    right: 40,
                    top: 0,
                    bottom: 0
                }
            }
        }),
        O = [{
            title: "Change Color",
            key: "1",
            icon: V.jsx(foe, {
                stroke: 1.5,
                size: 18
            }),
            onClick: () => {
                setTimeout(() => {
                    w(!0)
                }, 100)
            }
        }, {
            title: h ? "Hide Layer" : "Show Layer",
            key: "3",
            icon: h ? V.jsx(goe, {
                stroke: 1.5,
                size: 18
            }) : V.jsx(voe, {
                stroke: 1.5,
                size: 18
            }),
            onClick: P
        }, {
            title: "Features Histogram",
            key: "4",
            icon: V.jsx(uoe, {
                stroke: 1.5,
                size: 18
            }),
            onClick: () => {
                var k;
                (k = y.current) == null || k.open()
            },
            disabled: !0
        }, {
            key: "divider"
        }, {
            title: "Delete Layer",
            key: "0",
            icon: V.jsx(yT, {
                stroke: 1.5,
                size: 18,
                style: {
                    color: r.colors.red[7]
                }
            }),
            onClick: _
        }];
    return V.jsxs(Ha, {
        width: "target",
        position: "bottom",
        withArrow: !0,
        trapFocus: !0,
        shadow: "md",
        opened: m,
        onChange: w,
        children: [V.jsx(Ha.Target, {
            children: V.jsxs("div", {
                onContextMenu: t(O, {
                    className: "transparency"
                }),
                style: {
                    display: "flex"
                },
                children: [V.jsx(kO.div, { ...T(),
                    style: {
                        width: "100%",
                        overflow: "hidden"
                    },
                    children: V.jsx(Y5, {
                        label: i.name,
                        withArrow: !0,
                        openDelay: 1e3,
                        transitionProps: {
                            transition: "slide-up",
                            duration: 300
                        },
                        children: V.jsx(A_, {
                            style: {
                                textAlign: "left",
                                width: "100%",
                                overflow: "hidden",
                                padding: 0
                            },
                            variant: "subtle",
                            color: "gray",
                            styles: k => ({
                                root: {
                                    color: k.colorScheme == "dark" ? k.colors.gray[4] : k.colors.gray[9]
                                },
                                inner: {
                                    justifyContent: "flex-start",
                                    paddingLeft: 10
                                }
                            }),
                            leftIcon: h ? V.jsx(doe, {
                                size: 18,
                                style: {
                                    color: ao(c).hex()
                                },
                                onClick: k => {
                                    k.stopPropagation(), w(!m)
                                }
                            }) : V.jsx(hoe, {
                                size: 18,
                                style: {
                                    color: ao(c).hex()
                                },
                                onClick: k => {
                                    k.stopPropagation(), w(!m)
                                }
                            }),
                            onClick: () => {
                                P()
                            },
                            loading: f,
                            children: i.name
                        })
                    })
                }), V.jsx(kO.div, { ...T(),
                    style: {
                        width: a
                    },
                    children: V.jsx(A_, {
                        style: {
                            padding: 0,
                            width: "100%",
                            overflow: "hidden"
                        },
                        leftIcon: V.jsx(yT, {
                            style: {
                                color: r.colors.red[7]
                            },
                            stroke: 1.5,
                            size: 18
                        }),
                        onClick: _,
                        variant: "subtle",
                        color: "gray",
                        styles: () => ({
                            icon: {
                                margin: 0,
                                marginRight: 0
                            },
                            leftIcon: {
                                margin: 0,
                                marginRight: 0
                            }
                        })
                    })
                }), V.jsx(bhe, {
                    ref: y,
                    uid: o.uid,
                    gerberApp: n
                })]
            })
        }), V.jsx(Ha.Dropdown, {
            style: {
                padding: "0.5rem"
            },
            children: V.jsx(QM, {
                style: {
                    width: "100%"
                },
                value: ao(c).hex(),
                onChangeEnd: k => {
                    E(k), w(!1)
                },
                swatchesPerRow: 7,
                format: "hex",
                swatches: ["#25262b", "#868e96", "#fa5252", "#e64980", "#be4bdb", "#7950f2", "#4c6ef5", "#228be6", "#15aabf", "#12b886", "#40c057", "#82c91e", "#fab005", "#fd7e14"]
            })
        })]
    })
}
const Rhe = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);

function khe({
    gerberApp: e
}) {
    const t = yr(),
        [r, n] = b.useState([]);

    function i(a) {
        const l = [];
        a.forEach(async c => {
            const u = new File([], c.name),
                h = Object.assign(u, {
                    uid: c.uid
                });
            l.push(h)
        }), n(l)
    }
    async function s(a) {
        console.log("uploadFiles");
        const l = [...r];
        a.forEach(async c => {
            const u = Rhe(),
                h = Object.assign(c, {
                    uid: u
                });
            l.push(h)
        }), n(l)
    }
    b.useEffect(() => (e.renderer.then(async a => {
        i(await a.layers)
    }), () => {}), []);
    const o = {
        download: () => {},
        preview: () => {},
        remove: async a => {
            const l = await e.renderer;
            l && (await l.removeLayer(a.uid), n(r.filter(c => c.uid !== a.uid)))
        }
    };
    return V.jsxs("div", {
        style: {
            width: "100vw",
            height: "100vh",
            position: "fixed",
            pointerEvents: "none",
            zIndex: 10
        },
        children: [V.jsx(sd.FullScreen, {
            active: !0,
            multiple: !0,
            onDrop: s,
            children: V.jsxs(co, {
                position: "center",
                spacing: "xl",
                mih: 220,
                sx: {
                    pointerEvents: "none"
                },
                style: {
                    zIndex: 40
                },
                children: [V.jsx(sd.Accept, {
                    children: V.jsx(vT, {
                        size: "3.2rem",
                        stroke: 1.5,
                        color: t.colors[t.primaryColor][t.colorScheme === "dark" ? 4 : 6]
                    })
                }), V.jsx(sd.Reject, {
                    children: V.jsx(yoe, {
                        size: "3.2rem",
                        stroke: 1.5,
                        color: t.colors.red[t.colorScheme === "dark" ? 4 : 6]
                    })
                }), V.jsx(sd.Idle, {
                    children: V.jsx(vT, {
                        size: "3.2rem",
                        stroke: 1.5
                    })
                }), V.jsxs("div", {
                    children: [V.jsx(ir, {
                        size: "xl",
                        inline: !0,
                        children: "Drag gerbers here or click to select files"
                    }), V.jsx(ir, {
                        size: "sm",
                        color: "dimmed",
                        inline: !0,
                        mt: 7,
                        children: "Attach as many files as you like"
                    })]
                })]
            })
        }), V.jsx(kw, {
            radius: "12px",
            withBorder: !0,
            style: {
                width: 220,
                height: "-webkit-fill-available",
                margin: 10,
                pointerEvents: "all",
                overflowY: "auto",
                overflowX: "hidden"
            },
            className: "transparency",
            padding: 5,
            children: V.jsxs(uQ, {
                type: "scroll",
                h: "100%",
                viewportProps: {
                    style: {
                        overflowX: "hidden"
                    }
                },
                styles: {
                    viewport: {
                        "&& > div": {
                            display: "block !important"
                        }
                    }
                },
                children: [V.jsx(co, {
                    position: "center",
                    grow: !0,
                    pb: 5,
                    children: V.jsx(y5, {
                        onChange: s,
                        accept: "*",
                        multiple: !0,
                        children: a => V.jsx(A_, {
                            variant: "default",
                            ...a,
                            children: "Upload Gerbers"
                        })
                    })
                }), V.jsx(Q5, {
                    justify: "flex-start",
                    spacing: "0px",
                    children: r.map(a => V.jsx($he, {
                        file: a,
                        gerberApp: e,
                        actions: o
                    }, a.uid))
                })]
            })
        })]
    })
}

function Mhe() {
    const e = yr(),
        t = b.useRef(document.createElement("div")),
        [r, n] = b.useState();
    return b.useEffect(() => (n(new FH({
        element: t.current,
        antialias: !1,
        backgroundColor: ao(e.colorScheme == "dark" ? e.colors.dark[8] : e.colors.gray[2]).num()
    })), () => {
        r && r.destroy()
    }), []), b.useEffect(() => {
        r && r.renderer.then(async i => {
            i.changeBackgroundColor(ao(e.colorScheme == "dark" ? e.colors.dark[8] : e.colors.gray[2]).num())
        })
    }, [e.colorScheme]), V.jsxs(V.Fragment, {
        children: [r != null ? V.jsxs("div", {
            style: {
                width: "100vw",
                height: "100vh",
                position: "fixed",
                pointerEvents: "none",
                zIndex: 10
            },
            children: [V.jsx(khe, {
                gerberApp: r
            }), V.jsx(Poe, {
                gerberApp: r
            }), V.jsx(Soe, {}), V.jsx(Coe, {
                gerberApp: r
            })]
        }) : V.jsx(V.Fragment, {
            children: V.jsx(CM, {
                w: "100%",
                h: "100%",
                mx: "auto",
                children: V.jsx(Ao, {})
            })
        }), V.jsx("div", {
            id: "GRX",
            style: {
                width: "100%",
                height: "100%",
                cursor: "crosshair",
                WebkitUserSelect: "none",
                MozUserSelect: "none",
                userSelect: "none",
                touchAction: "none",
                backgroundColor: e.colorScheme == "dark" ? e.colors.dark[8] : e.colors.gray[1]
            },
            ref: t
        })]
    })
}

function Dhe() {
    const [e, t] = dP({
        key: "color-scheme",
        defaultValue: "dark"
    }), [r, n] = dP({
        key: "transparency",
        defaultValue: !1
    }), i = 30;
    return V.jsx(pD.Provider, {
        value: {
            themeMode: e,
            setThemeMode: t,
            transparency: r,
            setTransparency: n
        },
        children: V.jsx(GR, {
            withGlobalStyles: !0,
            withNormalizeCSS: !0,
            theme: {
                colorScheme: e,
                primaryColor: "teal",
                defaultRadius: "md",
                loader: "bars",
                colors: {
                    dark: ["#C2C2C2", "#A7A7A7", "#919191", "#5E5E5E", "#393939", "#2D2D2D", "#262626", "#1B1B1B", "#141414", "#101010"]
                },
                other: {},
                components: {
                    Button: {
                        styles: {
                            root: {
                                fontWeight: 50
                            }
                        }
                    }
                },
                globalStyles: s => ({
                    ".transparency": {
                        backdropFilter: r ? `blur(${i}px)` : "",
                        backgroundColor: r ? ao(s.colorScheme == "dark" ? s.colors.dark[7] : s.colors.gray[1]).alpha(.7).css() : ao(s.colorScheme == "dark" ? s.colors.dark[7] : s.colors.gray[1]).css()
                    },
                    ".tabler-icon": {
                        strokeWidth: 1.5,
                        color: s.colorScheme == "dark" ? s.colors.dark[0] : s.colors.gray[9]
                    }
                })
            },
            children: V.jsxs(Ahe, {
                zIndex: 1e3,
                shadow: "md",
                borderRadius: "md",
                children: [V.jsx(Ro, {}), V.jsx(Mhe, {})]
            })
        })
    })
}
const Nhe = D0.createRoot(document.getElementById("root"));
Nhe.render(V.jsx(Dhe, {}));